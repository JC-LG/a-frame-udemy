(function () {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const c of document.querySelectorAll('link[rel="modulepreload"]')) o(c);
    new MutationObserver(c => {
        for (const f of c) if (f.type === "childList") for (const T of f.addedNodes) T.tagName === "LINK" && T.rel === "modulepreload" && o(T)
    }).observe(document, {childList: !0, subtree: !0});

    function i(c) {
        const f = {};
        return c.integrity && (f.integrity = c.integrity), c.referrerPolicy && (f.referrerPolicy = c.referrerPolicy), c.crossOrigin === "use-credentials" ? f.credentials = "include" : c.crossOrigin === "anonymous" ? f.credentials = "omit" : f.credentials = "same-origin", f
    }

    function o(c) {
        if (c.ep) return;
        c.ep = !0;
        const f = i(c);
        fetch(c.href, f)
    }
})();

function dw(A) {
    return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A
}

function v3(A) {
    if (A.__esModule) return A;
    var t = A.default;
    if (typeof t == "function") {
        var i = function o() {
            return this instanceof o ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        i.prototype = t.prototype
    } else i = {};
    return Object.defineProperty(i, "__esModule", {value: !0}), Object.keys(A).forEach(function (o) {
        var c = Object.getOwnPropertyDescriptor(A, o);
        Object.defineProperty(i, o, c.get ? c : {
            enumerable: !0, get: function () {
                return A[o]
            }
        })
    }), i
}

var sy = {exports: {}}, Zx;

function y3() {
    return Zx || (Zx = 1, function (A, t) {
        var i = {};
        (function (c, f) {
            A.exports = f()
        })(self, () => (() => {
            var o = {
                "./node_modules/an-array/index.js": m => {
                    var x = Object.prototype.toString;
                    m.exports = h;

                    function h(g) {
                        return g.BYTES_PER_ELEMENT && x.call(g.buffer) === "[object ArrayBuffer]" || Array.isArray(g)
                    }
                },
                "./node_modules/as-number/index.js": m => {
                    m.exports = function (h, g) {
                        return typeof h == "number" ? h : typeof g == "number" ? g : 0
                    }
                },
                "./node_modules/base64-js/index.js": (m, x) => {
                    x.byteLength = M, x.toByteArray = B, x.fromByteArray = L;
                    for (var h = [], g = [], w = typeof Uint8Array < "u" ? Uint8Array : Array, v = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", E = 0, p = v.length; E < p; ++E) h[E] = v[E], g[v.charCodeAt(E)] = E;
                    g[45] = 62, g[95] = 63;

                    function C(O) {
                        var N = O.length;
                        if (N % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                        var F = O.indexOf("=");
                        F === -1 && (F = N);
                        var V = F === N ? 0 : 4 - F % 4;
                        return [F, V]
                    }

                    function M(O) {
                        var N = C(O), F = N[0], V = N[1];
                        return (F + V) * 3 / 4 - V
                    }

                    function b(O, N, F) {
                        return (N + F) * 3 / 4 - F
                    }

                    function B(O) {
                        var N, F = C(O), V = F[0], U = F[1], j = new w(b(O, V, U)), Y = 0, fe = U > 0 ? V - 4 : V, se;
                        for (se = 0; se < fe; se += 4) N = g[O.charCodeAt(se)] << 18 | g[O.charCodeAt(se + 1)] << 12 | g[O.charCodeAt(se + 2)] << 6 | g[O.charCodeAt(se + 3)], j[Y++] = N >> 16 & 255, j[Y++] = N >> 8 & 255, j[Y++] = N & 255;
                        return U === 2 && (N = g[O.charCodeAt(se)] << 2 | g[O.charCodeAt(se + 1)] >> 4, j[Y++] = N & 255), U === 1 && (N = g[O.charCodeAt(se)] << 10 | g[O.charCodeAt(se + 1)] << 4 | g[O.charCodeAt(se + 2)] >> 2, j[Y++] = N >> 8 & 255, j[Y++] = N & 255), j
                    }

                    function R(O) {
                        return h[O >> 18 & 63] + h[O >> 12 & 63] + h[O >> 6 & 63] + h[O & 63]
                    }

                    function I(O, N, F) {
                        for (var V, U = [], j = N; j < F; j += 3) V = (O[j] << 16 & 16711680) + (O[j + 1] << 8 & 65280) + (O[j + 2] & 255), U.push(R(V));
                        return U.join("")
                    }

                    function L(O) {
                        for (var N, F = O.length, V = F % 3, U = [], j = 16383, Y = 0, fe = F - V; Y < fe; Y += j) U.push(I(O, Y, Y + j > fe ? fe : Y + j));
                        return V === 1 ? (N = O[F - 1], U.push(h[N >> 2] + h[N << 4 & 63] + "==")) : V === 2 && (N = (O[F - 2] << 8) + O[F - 1], U.push(h[N >> 10] + h[N >> 4 & 63] + h[N << 2 & 63] + "=")), U.join("")
                    }
                },
                "./node_modules/buffer-equal/index.js": (m, x, h) => {
                    var g = h("./node_modules/buffer/index.js").Buffer;
                    m.exports = function (w, v) {
                        if (g.isBuffer(w) && g.isBuffer(v)) {
                            if (typeof w.equals == "function") return w.equals(v);
                            if (w.length !== v.length) return !1;
                            for (var E = 0; E < w.length; E++) if (w[E] !== v[E]) return !1;
                            return !0
                        }
                    }
                },
                "./node_modules/buffer/index.js": (m, x, h) => {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
                    const g = h("./node_modules/base64-js/index.js"), w = h("./node_modules/ieee754/index.js"),
                        v = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
                    x.Buffer = M, x.SlowBuffer = j, x.INSPECT_MAX_BYTES = 50;
                    const E = 2147483647;
                    x.kMaxLength = E, M.TYPED_ARRAY_SUPPORT = p(), !M.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

                    function p() {
                        try {
                            const oe = new Uint8Array(1), G = {
                                foo: function () {
                                    return 42
                                }
                            };
                            return Object.setPrototypeOf(G, Uint8Array.prototype), Object.setPrototypeOf(oe, G), oe.foo() === 42
                        } catch {
                            return !1
                        }
                    }

                    Object.defineProperty(M.prototype, "parent", {
                        enumerable: !0, get: function () {
                            if (M.isBuffer(this)) return this.buffer
                        }
                    }), Object.defineProperty(M.prototype, "offset", {
                        enumerable: !0, get: function () {
                            if (M.isBuffer(this)) return this.byteOffset
                        }
                    });

                    function C(oe) {
                        if (oe > E) throw new RangeError('The value "' + oe + '" is invalid for option "size"');
                        const G = new Uint8Array(oe);
                        return Object.setPrototypeOf(G, M.prototype), G
                    }

                    function M(oe, G, X) {
                        if (typeof oe == "number") {
                            if (typeof G == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
                            return I(oe)
                        }
                        return b(oe, G, X)
                    }

                    M.poolSize = 8192;

                    function b(oe, G, X) {
                        if (typeof oe == "string") return L(oe, G);
                        if (ArrayBuffer.isView(oe)) return N(oe);
                        if (oe == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof oe);
                        if (_e(oe, ArrayBuffer) || oe && _e(oe.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (_e(oe, SharedArrayBuffer) || oe && _e(oe.buffer, SharedArrayBuffer))) return F(oe, G, X);
                        if (typeof oe == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
                        const ve = oe.valueOf && oe.valueOf();
                        if (ve != null && ve !== oe) return M.from(ve, G, X);
                        const Be = V(oe);
                        if (Be) return Be;
                        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof oe[Symbol.toPrimitive] == "function") return M.from(oe[Symbol.toPrimitive]("string"), G, X);
                        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof oe)
                    }

                    M.from = function (oe, G, X) {
                        return b(oe, G, X)
                    }, Object.setPrototypeOf(M.prototype, Uint8Array.prototype), Object.setPrototypeOf(M, Uint8Array);

                    function B(oe) {
                        if (typeof oe != "number") throw new TypeError('"size" argument must be of type number');
                        if (oe < 0) throw new RangeError('The value "' + oe + '" is invalid for option "size"')
                    }

                    function R(oe, G, X) {
                        return B(oe), oe <= 0 ? C(oe) : G !== void 0 ? typeof X == "string" ? C(oe).fill(G, X) : C(oe).fill(G) : C(oe)
                    }

                    M.alloc = function (oe, G, X) {
                        return R(oe, G, X)
                    };

                    function I(oe) {
                        return B(oe), C(oe < 0 ? 0 : U(oe) | 0)
                    }

                    M.allocUnsafe = function (oe) {
                        return I(oe)
                    }, M.allocUnsafeSlow = function (oe) {
                        return I(oe)
                    };

                    function L(oe, G) {
                        if ((typeof G != "string" || G === "") && (G = "utf8"), !M.isEncoding(G)) throw new TypeError("Unknown encoding: " + G);
                        const X = Y(oe, G) | 0;
                        let ve = C(X);
                        const Be = ve.write(oe, G);
                        return Be !== X && (ve = ve.slice(0, Be)), ve
                    }

                    function O(oe) {
                        const G = oe.length < 0 ? 0 : U(oe.length) | 0, X = C(G);
                        for (let ve = 0; ve < G; ve += 1) X[ve] = oe[ve] & 255;
                        return X
                    }

                    function N(oe) {
                        if (_e(oe, Uint8Array)) {
                            const G = new Uint8Array(oe);
                            return F(G.buffer, G.byteOffset, G.byteLength)
                        }
                        return O(oe)
                    }

                    function F(oe, G, X) {
                        if (G < 0 || oe.byteLength < G) throw new RangeError('"offset" is outside of buffer bounds');
                        if (oe.byteLength < G + (X || 0)) throw new RangeError('"length" is outside of buffer bounds');
                        let ve;
                        return G === void 0 && X === void 0 ? ve = new Uint8Array(oe) : X === void 0 ? ve = new Uint8Array(oe, G) : ve = new Uint8Array(oe, G, X), Object.setPrototypeOf(ve, M.prototype), ve
                    }

                    function V(oe) {
                        if (M.isBuffer(oe)) {
                            const G = U(oe.length) | 0, X = C(G);
                            return X.length === 0 || oe.copy(X, 0, 0, G), X
                        }
                        if (oe.length !== void 0) return typeof oe.length != "number" || Ge(oe.length) ? C(0) : O(oe);
                        if (oe.type === "Buffer" && Array.isArray(oe.data)) return O(oe.data)
                    }

                    function U(oe) {
                        if (oe >= E) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + E.toString(16) + " bytes");
                        return oe | 0
                    }

                    function j(oe) {
                        return +oe != oe && (oe = 0), M.alloc(+oe)
                    }

                    M.isBuffer = function (G) {
                        return G != null && G._isBuffer === !0 && G !== M.prototype
                    }, M.compare = function (G, X) {
                        if (_e(G, Uint8Array) && (G = M.from(G, G.offset, G.byteLength)), _e(X, Uint8Array) && (X = M.from(X, X.offset, X.byteLength)), !M.isBuffer(G) || !M.isBuffer(X)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                        if (G === X) return 0;
                        let ve = G.length, Be = X.length;
                        for (let je = 0, tt = Math.min(ve, Be); je < tt; ++je) if (G[je] !== X[je]) {
                            ve = G[je], Be = X[je];
                            break
                        }
                        return ve < Be ? -1 : Be < ve ? 1 : 0
                    }, M.isEncoding = function (G) {
                        switch (String(G).toLowerCase()) {
                            case"hex":
                            case"utf8":
                            case"utf-8":
                            case"ascii":
                            case"latin1":
                            case"binary":
                            case"base64":
                            case"ucs2":
                            case"ucs-2":
                            case"utf16le":
                            case"utf-16le":
                                return !0;
                            default:
                                return !1
                        }
                    }, M.concat = function (G, X) {
                        if (!Array.isArray(G)) throw new TypeError('"list" argument must be an Array of Buffers');
                        if (G.length === 0) return M.alloc(0);
                        let ve;
                        if (X === void 0) for (X = 0, ve = 0; ve < G.length; ++ve) X += G[ve].length;
                        const Be = M.allocUnsafe(X);
                        let je = 0;
                        for (ve = 0; ve < G.length; ++ve) {
                            let tt = G[ve];
                            if (_e(tt, Uint8Array)) je + tt.length > Be.length ? (M.isBuffer(tt) || (tt = M.from(tt)), tt.copy(Be, je)) : Uint8Array.prototype.set.call(Be, tt, je); else if (M.isBuffer(tt)) tt.copy(Be, je); else throw new TypeError('"list" argument must be an Array of Buffers');
                            je += tt.length
                        }
                        return Be
                    };

                    function Y(oe, G) {
                        if (M.isBuffer(oe)) return oe.length;
                        if (ArrayBuffer.isView(oe) || _e(oe, ArrayBuffer)) return oe.byteLength;
                        if (typeof oe != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof oe);
                        const X = oe.length, ve = arguments.length > 2 && arguments[2] === !0;
                        if (!ve && X === 0) return 0;
                        let Be = !1;
                        for (; ;) switch (G) {
                            case"ascii":
                            case"latin1":
                            case"binary":
                                return X;
                            case"utf8":
                            case"utf-8":
                                return ss(oe).length;
                            case"ucs2":
                            case"ucs-2":
                            case"utf16le":
                            case"utf-16le":
                                return X * 2;
                            case"hex":
                                return X >>> 1;
                            case"base64":
                                return jt(oe).length;
                            default:
                                if (Be) return ve ? -1 : ss(oe).length;
                                G = ("" + G).toLowerCase(), Be = !0
                        }
                    }

                    M.byteLength = Y;

                    function fe(oe, G, X) {
                        let ve = !1;
                        if ((G === void 0 || G < 0) && (G = 0), G > this.length || ((X === void 0 || X > this.length) && (X = this.length), X <= 0) || (X >>>= 0, G >>>= 0, X <= G)) return "";
                        for (oe || (oe = "utf8"); ;) switch (oe) {
                            case"hex":
                                return gt(this, G, X);
                            case"utf8":
                            case"utf-8":
                                return Re(this, G, X);
                            case"ascii":
                                return He(this, G, X);
                            case"latin1":
                            case"binary":
                                return ot(this, G, X);
                            case"base64":
                                return me(this, G, X);
                            case"ucs2":
                            case"ucs-2":
                            case"utf16le":
                            case"utf-16le":
                                return Bt(this, G, X);
                            default:
                                if (ve) throw new TypeError("Unknown encoding: " + oe);
                                oe = (oe + "").toLowerCase(), ve = !0
                        }
                    }

                    M.prototype._isBuffer = !0;

                    function se(oe, G, X) {
                        const ve = oe[G];
                        oe[G] = oe[X], oe[X] = ve
                    }

                    M.prototype.swap16 = function () {
                        const G = this.length;
                        if (G % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                        for (let X = 0; X < G; X += 2) se(this, X, X + 1);
                        return this
                    }, M.prototype.swap32 = function () {
                        const G = this.length;
                        if (G % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                        for (let X = 0; X < G; X += 4) se(this, X, X + 3), se(this, X + 1, X + 2);
                        return this
                    }, M.prototype.swap64 = function () {
                        const G = this.length;
                        if (G % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                        for (let X = 0; X < G; X += 8) se(this, X, X + 7), se(this, X + 1, X + 6), se(this, X + 2, X + 5), se(this, X + 3, X + 4);
                        return this
                    }, M.prototype.toString = function () {
                        const G = this.length;
                        return G === 0 ? "" : arguments.length === 0 ? Re(this, 0, G) : fe.apply(this, arguments)
                    }, M.prototype.toLocaleString = M.prototype.toString, M.prototype.equals = function (G) {
                        if (!M.isBuffer(G)) throw new TypeError("Argument must be a Buffer");
                        return this === G ? !0 : M.compare(this, G) === 0
                    }, M.prototype.inspect = function () {
                        let G = "";
                        const X = x.INSPECT_MAX_BYTES;
                        return G = this.toString("hex", 0, X).replace(/(.{2})/g, "$1 ").trim(), this.length > X && (G += " ... "), "<Buffer " + G + ">"
                    }, v && (M.prototype[v] = M.prototype.inspect), M.prototype.compare = function (G, X, ve, Be, je) {
                        if (_e(G, Uint8Array) && (G = M.from(G, G.offset, G.byteLength)), !M.isBuffer(G)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof G);
                        if (X === void 0 && (X = 0), ve === void 0 && (ve = G ? G.length : 0), Be === void 0 && (Be = 0), je === void 0 && (je = this.length), X < 0 || ve > G.length || Be < 0 || je > this.length) throw new RangeError("out of range index");
                        if (Be >= je && X >= ve) return 0;
                        if (Be >= je) return -1;
                        if (X >= ve) return 1;
                        if (X >>>= 0, ve >>>= 0, Be >>>= 0, je >>>= 0, this === G) return 0;
                        let tt = je - Be, Yt = ve - X;
                        const cn = Math.min(tt, Yt), $t = this.slice(Be, je), en = G.slice(X, ve);
                        for (let Sn = 0; Sn < cn; ++Sn) if ($t[Sn] !== en[Sn]) {
                            tt = $t[Sn], Yt = en[Sn];
                            break
                        }
                        return tt < Yt ? -1 : Yt < tt ? 1 : 0
                    };

                    function pe(oe, G, X, ve, Be) {
                        if (oe.length === 0) return -1;
                        if (typeof X == "string" ? (ve = X, X = 0) : X > 2147483647 ? X = 2147483647 : X < -2147483648 && (X = -2147483648), X = +X, Ge(X) && (X = Be ? 0 : oe.length - 1), X < 0 && (X = oe.length + X), X >= oe.length) {
                            if (Be) return -1;
                            X = oe.length - 1
                        } else if (X < 0) if (Be) X = 0; else return -1;
                        if (typeof G == "string" && (G = M.from(G, ve)), M.isBuffer(G)) return G.length === 0 ? -1 : ue(oe, G, X, ve, Be);
                        if (typeof G == "number") return G = G & 255, typeof Uint8Array.prototype.indexOf == "function" ? Be ? Uint8Array.prototype.indexOf.call(oe, G, X) : Uint8Array.prototype.lastIndexOf.call(oe, G, X) : ue(oe, [G], X, ve, Be);
                        throw new TypeError("val must be string, number or Buffer")
                    }

                    function ue(oe, G, X, ve, Be) {
                        let je = 1, tt = oe.length, Yt = G.length;
                        if (ve !== void 0 && (ve = String(ve).toLowerCase(), ve === "ucs2" || ve === "ucs-2" || ve === "utf16le" || ve === "utf-16le")) {
                            if (oe.length < 2 || G.length < 2) return -1;
                            je = 2, tt /= 2, Yt /= 2, X /= 2
                        }

                        function cn(en, Sn) {
                            return je === 1 ? en[Sn] : en.readUInt16BE(Sn * je)
                        }

                        let $t;
                        if (Be) {
                            let en = -1;
                            for ($t = X; $t < tt; $t++) if (cn(oe, $t) === cn(G, en === -1 ? 0 : $t - en)) {
                                if (en === -1 && (en = $t), $t - en + 1 === Yt) return en * je
                            } else en !== -1 && ($t -= $t - en), en = -1
                        } else for (X + Yt > tt && (X = tt - Yt), $t = X; $t >= 0; $t--) {
                            let en = !0;
                            for (let Sn = 0; Sn < Yt; Sn++) if (cn(oe, $t + Sn) !== cn(G, Sn)) {
                                en = !1;
                                break
                            }
                            if (en) return $t
                        }
                        return -1
                    }

                    M.prototype.includes = function (G, X, ve) {
                        return this.indexOf(G, X, ve) !== -1
                    }, M.prototype.indexOf = function (G, X, ve) {
                        return pe(this, G, X, ve, !0)
                    }, M.prototype.lastIndexOf = function (G, X, ve) {
                        return pe(this, G, X, ve, !1)
                    };

                    function he(oe, G, X, ve) {
                        X = Number(X) || 0;
                        const Be = oe.length - X;
                        ve ? (ve = Number(ve), ve > Be && (ve = Be)) : ve = Be;
                        const je = G.length;
                        ve > je / 2 && (ve = je / 2);
                        let tt;
                        for (tt = 0; tt < ve; ++tt) {
                            const Yt = parseInt(G.substr(tt * 2, 2), 16);
                            if (Ge(Yt)) return tt;
                            oe[X + tt] = Yt
                        }
                        return tt
                    }

                    function Z(oe, G, X, ve) {
                        return Se(ss(G, oe.length - X), oe, X, ve)
                    }

                    function H(oe, G, X, ve) {
                        return Se(Nr(G), oe, X, ve)
                    }

                    function ae(oe, G, X, ve) {
                        return Se(jt(G), oe, X, ve)
                    }

                    function ee(oe, G, X, ve) {
                        return Se(ir(G, oe.length - X), oe, X, ve)
                    }

                    M.prototype.write = function (G, X, ve, Be) {
                        if (X === void 0) Be = "utf8", ve = this.length, X = 0; else if (ve === void 0 && typeof X == "string") Be = X, ve = this.length, X = 0; else if (isFinite(X)) X = X >>> 0, isFinite(ve) ? (ve = ve >>> 0, Be === void 0 && (Be = "utf8")) : (Be = ve, ve = void 0); else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        const je = this.length - X;
                        if ((ve === void 0 || ve > je) && (ve = je), G.length > 0 && (ve < 0 || X < 0) || X > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                        Be || (Be = "utf8");
                        let tt = !1;
                        for (; ;) switch (Be) {
                            case"hex":
                                return he(this, G, X, ve);
                            case"utf8":
                            case"utf-8":
                                return Z(this, G, X, ve);
                            case"ascii":
                            case"latin1":
                            case"binary":
                                return H(this, G, X, ve);
                            case"base64":
                                return ae(this, G, X, ve);
                            case"ucs2":
                            case"ucs-2":
                            case"utf16le":
                            case"utf-16le":
                                return ee(this, G, X, ve);
                            default:
                                if (tt) throw new TypeError("Unknown encoding: " + Be);
                                Be = ("" + Be).toLowerCase(), tt = !0
                        }
                    }, M.prototype.toJSON = function () {
                        return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)}
                    };

                    function me(oe, G, X) {
                        return G === 0 && X === oe.length ? g.fromByteArray(oe) : g.fromByteArray(oe.slice(G, X))
                    }

                    function Re(oe, G, X) {
                        X = Math.min(oe.length, X);
                        const ve = [];
                        let Be = G;
                        for (; Be < X;) {
                            const je = oe[Be];
                            let tt = null, Yt = je > 239 ? 4 : je > 223 ? 3 : je > 191 ? 2 : 1;
                            if (Be + Yt <= X) {
                                let cn, $t, en, Sn;
                                switch (Yt) {
                                    case 1:
                                        je < 128 && (tt = je);
                                        break;
                                    case 2:
                                        cn = oe[Be + 1], (cn & 192) === 128 && (Sn = (je & 31) << 6 | cn & 63, Sn > 127 && (tt = Sn));
                                        break;
                                    case 3:
                                        cn = oe[Be + 1], $t = oe[Be + 2], (cn & 192) === 128 && ($t & 192) === 128 && (Sn = (je & 15) << 12 | (cn & 63) << 6 | $t & 63, Sn > 2047 && (Sn < 55296 || Sn > 57343) && (tt = Sn));
                                        break;
                                    case 4:
                                        cn = oe[Be + 1], $t = oe[Be + 2], en = oe[Be + 3], (cn & 192) === 128 && ($t & 192) === 128 && (en & 192) === 128 && (Sn = (je & 15) << 18 | (cn & 63) << 12 | ($t & 63) << 6 | en & 63, Sn > 65535 && Sn < 1114112 && (tt = Sn))
                                }
                            }
                            tt === null ? (tt = 65533, Yt = 1) : tt > 65535 && (tt -= 65536, ve.push(tt >>> 10 & 1023 | 55296), tt = 56320 | tt & 1023), ve.push(tt), Be += Yt
                        }
                        return Ve(ve)
                    }

                    const ke = 4096;

                    function Ve(oe) {
                        const G = oe.length;
                        if (G <= ke) return String.fromCharCode.apply(String, oe);
                        let X = "", ve = 0;
                        for (; ve < G;) X += String.fromCharCode.apply(String, oe.slice(ve, ve += ke));
                        return X
                    }

                    function He(oe, G, X) {
                        let ve = "";
                        X = Math.min(oe.length, X);
                        for (let Be = G; Be < X; ++Be) ve += String.fromCharCode(oe[Be] & 127);
                        return ve
                    }

                    function ot(oe, G, X) {
                        let ve = "";
                        X = Math.min(oe.length, X);
                        for (let Be = G; Be < X; ++Be) ve += String.fromCharCode(oe[Be]);
                        return ve
                    }

                    function gt(oe, G, X) {
                        const ve = oe.length;
                        (!G || G < 0) && (G = 0), (!X || X < 0 || X > ve) && (X = ve);
                        let Be = "";
                        for (let je = G; je < X; ++je) Be += Le[oe[je]];
                        return Be
                    }

                    function Bt(oe, G, X) {
                        const ve = oe.slice(G, X);
                        let Be = "";
                        for (let je = 0; je < ve.length - 1; je += 2) Be += String.fromCharCode(ve[je] + ve[je + 1] * 256);
                        return Be
                    }

                    M.prototype.slice = function (G, X) {
                        const ve = this.length;
                        G = ~~G, X = X === void 0 ? ve : ~~X, G < 0 ? (G += ve, G < 0 && (G = 0)) : G > ve && (G = ve), X < 0 ? (X += ve, X < 0 && (X = 0)) : X > ve && (X = ve), X < G && (X = G);
                        const Be = this.subarray(G, X);
                        return Object.setPrototypeOf(Be, M.prototype), Be
                    };

                    function Rt(oe, G, X) {
                        if (oe % 1 !== 0 || oe < 0) throw new RangeError("offset is not uint");
                        if (oe + G > X) throw new RangeError("Trying to access beyond buffer length")
                    }

                    M.prototype.readUintLE = M.prototype.readUIntLE = function (G, X, ve) {
                        G = G >>> 0, X = X >>> 0, ve || Rt(G, X, this.length);
                        let Be = this[G], je = 1, tt = 0;
                        for (; ++tt < X && (je *= 256);) Be += this[G + tt] * je;
                        return Be
                    }, M.prototype.readUintBE = M.prototype.readUIntBE = function (G, X, ve) {
                        G = G >>> 0, X = X >>> 0, ve || Rt(G, X, this.length);
                        let Be = this[G + --X], je = 1;
                        for (; X > 0 && (je *= 256);) Be += this[G + --X] * je;
                        return Be
                    }, M.prototype.readUint8 = M.prototype.readUInt8 = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 1, this.length), this[G]
                    }, M.prototype.readUint16LE = M.prototype.readUInt16LE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 2, this.length), this[G] | this[G + 1] << 8
                    }, M.prototype.readUint16BE = M.prototype.readUInt16BE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 2, this.length), this[G] << 8 | this[G + 1]
                    }, M.prototype.readUint32LE = M.prototype.readUInt32LE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 4, this.length), (this[G] | this[G + 1] << 8 | this[G + 2] << 16) + this[G + 3] * 16777216
                    }, M.prototype.readUint32BE = M.prototype.readUInt32BE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 4, this.length), this[G] * 16777216 + (this[G + 1] << 16 | this[G + 2] << 8 | this[G + 3])
                    }, M.prototype.readBigUInt64LE = Ue(function (G) {
                        G = G >>> 0, Ji(G, "offset");
                        const X = this[G], ve = this[G + 7];
                        (X === void 0 || ve === void 0) && Pi(G, this.length - 8);
                        const Be = X + this[++G] * 2 ** 8 + this[++G] * 2 ** 16 + this[++G] * 2 ** 24,
                            je = this[++G] + this[++G] * 2 ** 8 + this[++G] * 2 ** 16 + ve * 2 ** 24;
                        return BigInt(Be) + (BigInt(je) << BigInt(32))
                    }), M.prototype.readBigUInt64BE = Ue(function (G) {
                        G = G >>> 0, Ji(G, "offset");
                        const X = this[G], ve = this[G + 7];
                        (X === void 0 || ve === void 0) && Pi(G, this.length - 8);
                        const Be = X * 2 ** 24 + this[++G] * 2 ** 16 + this[++G] * 2 ** 8 + this[++G],
                            je = this[++G] * 2 ** 24 + this[++G] * 2 ** 16 + this[++G] * 2 ** 8 + ve;
                        return (BigInt(Be) << BigInt(32)) + BigInt(je)
                    }), M.prototype.readIntLE = function (G, X, ve) {
                        G = G >>> 0, X = X >>> 0, ve || Rt(G, X, this.length);
                        let Be = this[G], je = 1, tt = 0;
                        for (; ++tt < X && (je *= 256);) Be += this[G + tt] * je;
                        return je *= 128, Be >= je && (Be -= Math.pow(2, 8 * X)), Be
                    }, M.prototype.readIntBE = function (G, X, ve) {
                        G = G >>> 0, X = X >>> 0, ve || Rt(G, X, this.length);
                        let Be = X, je = 1, tt = this[G + --Be];
                        for (; Be > 0 && (je *= 256);) tt += this[G + --Be] * je;
                        return je *= 128, tt >= je && (tt -= Math.pow(2, 8 * X)), tt
                    }, M.prototype.readInt8 = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 1, this.length), this[G] & 128 ? (255 - this[G] + 1) * -1 : this[G]
                    }, M.prototype.readInt16LE = function (G, X) {
                        G = G >>> 0, X || Rt(G, 2, this.length);
                        const ve = this[G] | this[G + 1] << 8;
                        return ve & 32768 ? ve | 4294901760 : ve
                    }, M.prototype.readInt16BE = function (G, X) {
                        G = G >>> 0, X || Rt(G, 2, this.length);
                        const ve = this[G + 1] | this[G] << 8;
                        return ve & 32768 ? ve | 4294901760 : ve
                    }, M.prototype.readInt32LE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 4, this.length), this[G] | this[G + 1] << 8 | this[G + 2] << 16 | this[G + 3] << 24
                    }, M.prototype.readInt32BE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 4, this.length), this[G] << 24 | this[G + 1] << 16 | this[G + 2] << 8 | this[G + 3]
                    }, M.prototype.readBigInt64LE = Ue(function (G) {
                        G = G >>> 0, Ji(G, "offset");
                        const X = this[G], ve = this[G + 7];
                        (X === void 0 || ve === void 0) && Pi(G, this.length - 8);
                        const Be = this[G + 4] + this[G + 5] * 2 ** 8 + this[G + 6] * 2 ** 16 + (ve << 24);
                        return (BigInt(Be) << BigInt(32)) + BigInt(X + this[++G] * 256 + this[++G] * 65536 + this[++G] * 16777216)
                    }), M.prototype.readBigInt64BE = Ue(function (G) {
                        G = G >>> 0, Ji(G, "offset");
                        const X = this[G], ve = this[G + 7];
                        (X === void 0 || ve === void 0) && Pi(G, this.length - 8);
                        const Be = (X << 24) + this[++G] * 2 ** 16 + this[++G] * 2 ** 8 + this[++G];
                        return (BigInt(Be) << BigInt(32)) + BigInt(this[++G] * 16777216 + this[++G] * 65536 + this[++G] * 256 + ve)
                    }), M.prototype.readFloatLE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 4, this.length), w.read(this, G, !0, 23, 4)
                    }, M.prototype.readFloatBE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 4, this.length), w.read(this, G, !1, 23, 4)
                    }, M.prototype.readDoubleLE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 8, this.length), w.read(this, G, !0, 52, 8)
                    }, M.prototype.readDoubleBE = function (G, X) {
                        return G = G >>> 0, X || Rt(G, 8, this.length), w.read(this, G, !1, 52, 8)
                    };

                    function an(oe, G, X, ve, Be, je) {
                        if (!M.isBuffer(oe)) throw new TypeError('"buffer" argument must be a Buffer instance');
                        if (G > Be || G < je) throw new RangeError('"value" argument is out of bounds');
                        if (X + ve > oe.length) throw new RangeError("Index out of range")
                    }

                    M.prototype.writeUintLE = M.prototype.writeUIntLE = function (G, X, ve, Be) {
                        if (G = +G, X = X >>> 0, ve = ve >>> 0, !Be) {
                            const Yt = Math.pow(2, 8 * ve) - 1;
                            an(this, G, X, ve, Yt, 0)
                        }
                        let je = 1, tt = 0;
                        for (this[X] = G & 255; ++tt < ve && (je *= 256);) this[X + tt] = G / je & 255;
                        return X + ve
                    }, M.prototype.writeUintBE = M.prototype.writeUIntBE = function (G, X, ve, Be) {
                        if (G = +G, X = X >>> 0, ve = ve >>> 0, !Be) {
                            const Yt = Math.pow(2, 8 * ve) - 1;
                            an(this, G, X, ve, Yt, 0)
                        }
                        let je = ve - 1, tt = 1;
                        for (this[X + je] = G & 255; --je >= 0 && (tt *= 256);) this[X + je] = G / tt & 255;
                        return X + ve
                    }, M.prototype.writeUint8 = M.prototype.writeUInt8 = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 1, 255, 0), this[X] = G & 255, X + 1
                    }, M.prototype.writeUint16LE = M.prototype.writeUInt16LE = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 2, 65535, 0), this[X] = G & 255, this[X + 1] = G >>> 8, X + 2
                    }, M.prototype.writeUint16BE = M.prototype.writeUInt16BE = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 2, 65535, 0), this[X] = G >>> 8, this[X + 1] = G & 255, X + 2
                    }, M.prototype.writeUint32LE = M.prototype.writeUInt32LE = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 4, 4294967295, 0), this[X + 3] = G >>> 24, this[X + 2] = G >>> 16, this[X + 1] = G >>> 8, this[X] = G & 255, X + 4
                    }, M.prototype.writeUint32BE = M.prototype.writeUInt32BE = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 4, 4294967295, 0), this[X] = G >>> 24, this[X + 1] = G >>> 16, this[X + 2] = G >>> 8, this[X + 3] = G & 255, X + 4
                    };

                    function En(oe, G, X, ve, Be) {
                        Rr(G, ve, Be, oe, X, 7);
                        let je = Number(G & BigInt(4294967295));
                        oe[X++] = je, je = je >> 8, oe[X++] = je, je = je >> 8, oe[X++] = je, je = je >> 8, oe[X++] = je;
                        let tt = Number(G >> BigInt(32) & BigInt(4294967295));
                        return oe[X++] = tt, tt = tt >> 8, oe[X++] = tt, tt = tt >> 8, oe[X++] = tt, tt = tt >> 8, oe[X++] = tt, X
                    }

                    function Nn(oe, G, X, ve, Be) {
                        Rr(G, ve, Be, oe, X, 7);
                        let je = Number(G & BigInt(4294967295));
                        oe[X + 7] = je, je = je >> 8, oe[X + 6] = je, je = je >> 8, oe[X + 5] = je, je = je >> 8, oe[X + 4] = je;
                        let tt = Number(G >> BigInt(32) & BigInt(4294967295));
                        return oe[X + 3] = tt, tt = tt >> 8, oe[X + 2] = tt, tt = tt >> 8, oe[X + 1] = tt, tt = tt >> 8, oe[X] = tt, X + 8
                    }

                    M.prototype.writeBigUInt64LE = Ue(function (G, X = 0) {
                        return En(this, G, X, BigInt(0), BigInt("0xffffffffffffffff"))
                    }), M.prototype.writeBigUInt64BE = Ue(function (G, X = 0) {
                        return Nn(this, G, X, BigInt(0), BigInt("0xffffffffffffffff"))
                    }), M.prototype.writeIntLE = function (G, X, ve, Be) {
                        if (G = +G, X = X >>> 0, !Be) {
                            const cn = Math.pow(2, 8 * ve - 1);
                            an(this, G, X, ve, cn - 1, -cn)
                        }
                        let je = 0, tt = 1, Yt = 0;
                        for (this[X] = G & 255; ++je < ve && (tt *= 256);) G < 0 && Yt === 0 && this[X + je - 1] !== 0 && (Yt = 1), this[X + je] = (G / tt >> 0) - Yt & 255;
                        return X + ve
                    }, M.prototype.writeIntBE = function (G, X, ve, Be) {
                        if (G = +G, X = X >>> 0, !Be) {
                            const cn = Math.pow(2, 8 * ve - 1);
                            an(this, G, X, ve, cn - 1, -cn)
                        }
                        let je = ve - 1, tt = 1, Yt = 0;
                        for (this[X + je] = G & 255; --je >= 0 && (tt *= 256);) G < 0 && Yt === 0 && this[X + je + 1] !== 0 && (Yt = 1), this[X + je] = (G / tt >> 0) - Yt & 255;
                        return X + ve
                    }, M.prototype.writeInt8 = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 1, 127, -128), G < 0 && (G = 255 + G + 1), this[X] = G & 255, X + 1
                    }, M.prototype.writeInt16LE = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 2, 32767, -32768), this[X] = G & 255, this[X + 1] = G >>> 8, X + 2
                    }, M.prototype.writeInt16BE = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 2, 32767, -32768), this[X] = G >>> 8, this[X + 1] = G & 255, X + 2
                    }, M.prototype.writeInt32LE = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 4, 2147483647, -2147483648), this[X] = G & 255, this[X + 1] = G >>> 8, this[X + 2] = G >>> 16, this[X + 3] = G >>> 24, X + 4
                    }, M.prototype.writeInt32BE = function (G, X, ve) {
                        return G = +G, X = X >>> 0, ve || an(this, G, X, 4, 2147483647, -2147483648), G < 0 && (G = 4294967295 + G + 1), this[X] = G >>> 24, this[X + 1] = G >>> 16, this[X + 2] = G >>> 8, this[X + 3] = G & 255, X + 4
                    }, M.prototype.writeBigInt64LE = Ue(function (G, X = 0) {
                        return En(this, G, X, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                    }), M.prototype.writeBigInt64BE = Ue(function (G, X = 0) {
                        return Nn(this, G, X, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                    });

                    function oi(oe, G, X, ve, Be, je) {
                        if (X + ve > oe.length) throw new RangeError("Index out of range");
                        if (X < 0) throw new RangeError("Index out of range")
                    }

                    function pi(oe, G, X, ve, Be) {
                        return G = +G, X = X >>> 0, Be || oi(oe, G, X, 4), w.write(oe, G, X, ve, 23, 4), X + 4
                    }

                    M.prototype.writeFloatLE = function (G, X, ve) {
                        return pi(this, G, X, !0, ve)
                    }, M.prototype.writeFloatBE = function (G, X, ve) {
                        return pi(this, G, X, !1, ve)
                    };

                    function hi(oe, G, X, ve, Be) {
                        return G = +G, X = X >>> 0, Be || oi(oe, G, X, 8), w.write(oe, G, X, ve, 52, 8), X + 8
                    }

                    M.prototype.writeDoubleLE = function (G, X, ve) {
                        return hi(this, G, X, !0, ve)
                    }, M.prototype.writeDoubleBE = function (G, X, ve) {
                        return hi(this, G, X, !1, ve)
                    }, M.prototype.copy = function (G, X, ve, Be) {
                        if (!M.isBuffer(G)) throw new TypeError("argument should be a Buffer");
                        if (ve || (ve = 0), !Be && Be !== 0 && (Be = this.length), X >= G.length && (X = G.length), X || (X = 0), Be > 0 && Be < ve && (Be = ve), Be === ve || G.length === 0 || this.length === 0) return 0;
                        if (X < 0) throw new RangeError("targetStart out of bounds");
                        if (ve < 0 || ve >= this.length) throw new RangeError("Index out of range");
                        if (Be < 0) throw new RangeError("sourceEnd out of bounds");
                        Be > this.length && (Be = this.length), G.length - X < Be - ve && (Be = G.length - X + ve);
                        const je = Be - ve;
                        return this === G && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(X, ve, Be) : Uint8Array.prototype.set.call(G, this.subarray(ve, Be), X), je
                    }, M.prototype.fill = function (G, X, ve, Be) {
                        if (typeof G == "string") {
                            if (typeof X == "string" ? (Be = X, X = 0, ve = this.length) : typeof ve == "string" && (Be = ve, ve = this.length), Be !== void 0 && typeof Be != "string") throw new TypeError("encoding must be a string");
                            if (typeof Be == "string" && !M.isEncoding(Be)) throw new TypeError("Unknown encoding: " + Be);
                            if (G.length === 1) {
                                const tt = G.charCodeAt(0);
                                (Be === "utf8" && tt < 128 || Be === "latin1") && (G = tt)
                            }
                        } else typeof G == "number" ? G = G & 255 : typeof G == "boolean" && (G = Number(G));
                        if (X < 0 || this.length < X || this.length < ve) throw new RangeError("Out of range index");
                        if (ve <= X) return this;
                        X = X >>> 0, ve = ve === void 0 ? this.length : ve >>> 0, G || (G = 0);
                        let je;
                        if (typeof G == "number") for (je = X; je < ve; ++je) this[je] = G; else {
                            const tt = M.isBuffer(G) ? G : M.from(G, Be), Yt = tt.length;
                            if (Yt === 0) throw new TypeError('The value "' + G + '" is invalid for argument "value"');
                            for (je = 0; je < ve - X; ++je) this[je + X] = tt[je % Yt]
                        }
                        return this
                    };
                    const Vn = {};

                    function yi(oe, G, X) {
                        Vn[oe] = class extends X {
                            constructor() {
                                super(), Object.defineProperty(this, "message", {
                                    value: G.apply(this, arguments),
                                    writable: !0,
                                    configurable: !0
                                }), this.name = `${this.name} [${oe}]`, this.stack, delete this.name
                            }

                            get code() {
                                return oe
                            }

                            set code(Be) {
                                Object.defineProperty(this, "code", {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: Be,
                                    writable: !0
                                })
                            }

                            toString() {
                                return `${this.name} [${oe}]: ${this.message}`
                            }
                        }
                    }

                    yi("ERR_BUFFER_OUT_OF_BOUNDS", function (oe) {
                        return oe ? `${oe} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
                    }, RangeError), yi("ERR_INVALID_ARG_TYPE", function (oe, G) {
                        return `The "${oe}" argument must be of type number. Received type ${typeof G}`
                    }, TypeError), yi("ERR_OUT_OF_RANGE", function (oe, G, X) {
                        let ve = `The value of "${oe}" is out of range.`, Be = X;
                        return Number.isInteger(X) && Math.abs(X) > 4294967296 ? Be = nr(String(X)) : typeof X == "bigint" && (Be = String(X), (X > BigInt(2) ** BigInt(32) || X < -(BigInt(2) ** BigInt(32))) && (Be = nr(Be)), Be += "n"), ve += ` It must be ${G}. Received ${Be}`, ve
                    }, RangeError);

                    function nr(oe) {
                        let G = "", X = oe.length;
                        const ve = oe[0] === "-" ? 1 : 0;
                        for (; X >= ve + 4; X -= 3) G = `_${oe.slice(X - 3, X)}${G}`;
                        return `${oe.slice(0, X)}${G}`
                    }

                    function Oi(oe, G, X) {
                        Ji(G, "offset"), (oe[G] === void 0 || oe[G + X] === void 0) && Pi(G, oe.length - (X + 1))
                    }

                    function Rr(oe, G, X, ve, Be, je) {
                        if (oe > X || oe < G) {
                            const tt = typeof G == "bigint" ? "n" : "";
                            let Yt;
                            throw G === 0 || G === BigInt(0) ? Yt = `>= 0${tt} and < 2${tt} ** ${(je + 1) * 8}${tt}` : Yt = `>= -(2${tt} ** ${(je + 1) * 8 - 1}${tt}) and < 2 ** ${(je + 1) * 8 - 1}${tt}`, new Vn.ERR_OUT_OF_RANGE("value", Yt, oe)
                        }
                        Oi(ve, Be, je)
                    }

                    function Ji(oe, G) {
                        if (typeof oe != "number") throw new Vn.ERR_INVALID_ARG_TYPE(G, "number", oe)
                    }

                    function Pi(oe, G, X) {
                        throw Math.floor(oe) !== oe ? (Ji(oe, X), new Vn.ERR_OUT_OF_RANGE("offset", "an integer", oe)) : G < 0 ? new Vn.ERR_BUFFER_OUT_OF_BOUNDS : new Vn.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${G}`, oe)
                    }

                    const Br = /[^+/0-9A-Za-z-_]/g;

                    function cr(oe) {
                        if (oe = oe.split("=")[0], oe = oe.trim().replace(Br, ""), oe.length < 2) return "";
                        for (; oe.length % 4 !== 0;) oe = oe + "=";
                        return oe
                    }

                    function ss(oe, G) {
                        G = G || 1 / 0;
                        let X;
                        const ve = oe.length;
                        let Be = null;
                        const je = [];
                        for (let tt = 0; tt < ve; ++tt) {
                            if (X = oe.charCodeAt(tt), X > 55295 && X < 57344) {
                                if (!Be) {
                                    if (X > 56319) {
                                        (G -= 3) > -1 && je.push(239, 191, 189);
                                        continue
                                    } else if (tt + 1 === ve) {
                                        (G -= 3) > -1 && je.push(239, 191, 189);
                                        continue
                                    }
                                    Be = X;
                                    continue
                                }
                                if (X < 56320) {
                                    (G -= 3) > -1 && je.push(239, 191, 189), Be = X;
                                    continue
                                }
                                X = (Be - 55296 << 10 | X - 56320) + 65536
                            } else Be && (G -= 3) > -1 && je.push(239, 191, 189);
                            if (Be = null, X < 128) {
                                if ((G -= 1) < 0) break;
                                je.push(X)
                            } else if (X < 2048) {
                                if ((G -= 2) < 0) break;
                                je.push(X >> 6 | 192, X & 63 | 128)
                            } else if (X < 65536) {
                                if ((G -= 3) < 0) break;
                                je.push(X >> 12 | 224, X >> 6 & 63 | 128, X & 63 | 128)
                            } else if (X < 1114112) {
                                if ((G -= 4) < 0) break;
                                je.push(X >> 18 | 240, X >> 12 & 63 | 128, X >> 6 & 63 | 128, X & 63 | 128)
                            } else throw new Error("Invalid code point")
                        }
                        return je
                    }

                    function Nr(oe) {
                        const G = [];
                        for (let X = 0; X < oe.length; ++X) G.push(oe.charCodeAt(X) & 255);
                        return G
                    }

                    function ir(oe, G) {
                        let X, ve, Be;
                        const je = [];
                        for (let tt = 0; tt < oe.length && !((G -= 2) < 0); ++tt) X = oe.charCodeAt(tt), ve = X >> 8, Be = X % 256, je.push(Be), je.push(ve);
                        return je
                    }

                    function jt(oe) {
                        return g.toByteArray(cr(oe))
                    }

                    function Se(oe, G, X, ve) {
                        let Be;
                        for (Be = 0; Be < ve && !(Be + X >= G.length || Be >= oe.length); ++Be) G[Be + X] = oe[Be];
                        return Be
                    }

                    function _e(oe, G) {
                        return oe instanceof G || oe != null && oe.constructor != null && oe.constructor.name != null && oe.constructor.name === G.name
                    }

                    function Ge(oe) {
                        return oe !== oe
                    }

                    const Le = function () {
                        const oe = "0123456789abcdef", G = new Array(256);
                        for (let X = 0; X < 16; ++X) {
                            const ve = X * 16;
                            for (let Be = 0; Be < 16; ++Be) G[ve + Be] = oe[X] + oe[Be]
                        }
                        return G
                    }();

                    function Ue(oe) {
                        return typeof BigInt > "u" ? Qe : oe
                    }

                    function Qe() {
                        throw new Error("BigInt not supported")
                    }
                },
                "./node_modules/css-loader/dist/runtime/api.js": m => {
                    m.exports = function (x) {
                        var h = [];
                        return h.toString = function () {
                            return this.map(function (w) {
                                var v = "", E = typeof w[5] < "u";
                                return w[4] && (v += "@supports (".concat(w[4], ") {")), w[2] && (v += "@media ".concat(w[2], " {")), E && (v += "@layer".concat(w[5].length > 0 ? " ".concat(w[5]) : "", " {")), v += x(w), E && (v += "}"), w[2] && (v += "}"), w[4] && (v += "}"), v
                            }).join("")
                        }, h.i = function (w, v, E, p, C) {
                            typeof w == "string" && (w = [[null, w, void 0]]);
                            var M = {};
                            if (E) for (var b = 0; b < this.length; b++) {
                                var B = this[b][0];
                                B != null && (M[B] = !0)
                            }
                            for (var R = 0; R < w.length; R++) {
                                var I = [].concat(w[R]);
                                E && M[I[0]] || (typeof C < "u" && (typeof I[5] > "u" || (I[1] = "@layer".concat(I[5].length > 0 ? " ".concat(I[5]) : "", " {").concat(I[1], "}")), I[5] = C), v && (I[2] && (I[1] = "@media ".concat(I[2], " {").concat(I[1], "}")), I[2] = v), p && (I[4] ? (I[1] = "@supports (".concat(I[4], ") {").concat(I[1], "}"), I[4] = p) : I[4] = "".concat(p)), h.push(I))
                            }
                        }, h
                    }
                },
                "./node_modules/css-loader/dist/runtime/getUrl.js": m => {
                    m.exports = function (x, h) {
                        return h || (h = {}), x && (x = String(x.__esModule ? x.default : x), /^['"].*['"]$/.test(x) && (x = x.slice(1, -1)), h.hash && (x += h.hash), /["'() \t\n]|(%20)/.test(x) || h.needQuotes ? '"'.concat(x.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : x)
                    }
                },
                "./node_modules/css-loader/dist/runtime/sourceMaps.js": m => {
                    m.exports = function (x) {
                        var h = x[1], g = x[3];
                        if (!g) return h;
                        if (typeof btoa == "function") {
                            var w = btoa(unescape(encodeURIComponent(JSON.stringify(g)))),
                                v = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(w),
                                E = "/*# ".concat(v, " */");
                            return [h].concat([E]).join(`
`)
                        }
                        return [h].join(`
`)
                    }
                },
                "./node_modules/debug/src/browser.js": (m, x, h) => {
                    x.formatArgs = w, x.save = v, x.load = E, x.useColors = g, x.storage = p(), x.destroy = (() => {
                        let M = !1;
                        return () => {
                            M || (M = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
                        }
                    })(), x.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

                    function g() {
                        return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
                    }

                    function w(M) {
                        if (M[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + M[0] + (this.useColors ? "%c " : " ") + "+" + m.exports.humanize(this.diff), !this.useColors) return;
                        const b = "color: " + this.color;
                        M.splice(1, 0, b, "color: inherit");
                        let B = 0, R = 0;
                        M[0].replace(/%[a-zA-Z%]/g, I => {
                            I !== "%%" && (B++, I === "%c" && (R = B))
                        }), M.splice(R, 0, b)
                    }

                    x.log = console.debug || console.log || (() => {
                    });

                    function v(M) {
                        try {
                            M ? x.storage.setItem("debug", M) : x.storage.removeItem("debug")
                        } catch {
                        }
                    }

                    function E() {
                        let M;
                        try {
                            M = x.storage.getItem("debug")
                        } catch {
                        }
                        return !M && typeof process < "u" && "env" in process && (M = i.DEBUG), M
                    }

                    function p() {
                        try {
                            return localStorage
                        } catch {
                        }
                    }

                    m.exports = h("./node_modules/debug/src/common.js")(x);
                    const {formatters: C} = m.exports;
                    C.j = function (M) {
                        try {
                            return JSON.stringify(M)
                        } catch (b) {
                            return "[UnexpectedJSONParseError]: " + b.message
                        }
                    }
                },
                "./node_modules/debug/src/common.js": (m, x, h) => {
                    function g(w) {
                        E.debug = E, E.default = E, E.coerce = R, E.disable = M, E.enable = C, E.enabled = b, E.humanize = h("./node_modules/ms/index.js"), E.destroy = I, Object.keys(w).forEach(L => {
                            E[L] = w[L]
                        }), E.names = [], E.skips = [], E.formatters = {};

                        function v(L) {
                            let O = 0;
                            for (let N = 0; N < L.length; N++) O = (O << 5) - O + L.charCodeAt(N), O |= 0;
                            return E.colors[Math.abs(O) % E.colors.length]
                        }

                        E.selectColor = v;

                        function E(L) {
                            let O, N = null, F, V;

                            function U(...j) {
                                if (!U.enabled) return;
                                const Y = U, fe = Number(new Date), se = fe - (O || fe);
                                Y.diff = se, Y.prev = O, Y.curr = fe, O = fe, j[0] = E.coerce(j[0]), typeof j[0] != "string" && j.unshift("%O");
                                let pe = 0;
                                j[0] = j[0].replace(/%([a-zA-Z%])/g, (he, Z) => {
                                    if (he === "%%") return "%";
                                    pe++;
                                    const H = E.formatters[Z];
                                    if (typeof H == "function") {
                                        const ae = j[pe];
                                        he = H.call(Y, ae), j.splice(pe, 1), pe--
                                    }
                                    return he
                                }), E.formatArgs.call(Y, j), (Y.log || E.log).apply(Y, j)
                            }

                            return U.namespace = L, U.useColors = E.useColors(), U.color = E.selectColor(L), U.extend = p, U.destroy = E.destroy, Object.defineProperty(U, "enabled", {
                                enumerable: !0,
                                configurable: !1,
                                get: () => N !== null ? N : (F !== E.namespaces && (F = E.namespaces, V = E.enabled(L)), V),
                                set: j => {
                                    N = j
                                }
                            }), typeof E.init == "function" && E.init(U), U
                        }

                        function p(L, O) {
                            const N = E(this.namespace + (typeof O > "u" ? ":" : O) + L);
                            return N.log = this.log, N
                        }

                        function C(L) {
                            E.save(L), E.namespaces = L, E.names = [], E.skips = [];
                            let O;
                            const N = (typeof L == "string" ? L : "").split(/[\s,]+/), F = N.length;
                            for (O = 0; O < F; O++) N[O] && (L = N[O].replace(/\*/g, ".*?"), L[0] === "-" ? E.skips.push(new RegExp("^" + L.slice(1) + "$")) : E.names.push(new RegExp("^" + L + "$")))
                        }

                        function M() {
                            const L = [...E.names.map(B), ...E.skips.map(B).map(O => "-" + O)].join(",");
                            return E.enable(""), L
                        }

                        function b(L) {
                            if (L[L.length - 1] === "*") return !0;
                            let O, N;
                            for (O = 0, N = E.skips.length; O < N; O++) if (E.skips[O].test(L)) return !1;
                            for (O = 0, N = E.names.length; O < N; O++) if (E.names[O].test(L)) return !0;
                            return !1
                        }

                        function B(L) {
                            return L.toString().substring(2, L.toString().length - 2).replace(/\.\*\?$/, "*")
                        }

                        function R(L) {
                            return L instanceof Error ? L.stack || L.message : L
                        }

                        function I() {
                            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
                        }

                        return E.enable(E.load()), E
                    }

                    m.exports = g
                },
                "./node_modules/deep-assign/index.js": (m, x, h) => {
                    var g = h("./node_modules/is-obj/index.js"), w = Object.prototype.hasOwnProperty,
                        v = Object.prototype.propertyIsEnumerable;

                    function E(M) {
                        if (M == null) throw new TypeError("Sources cannot be null or undefined");
                        return Object(M)
                    }

                    function p(M, b, B) {
                        var R = b[B];
                        if (R != null) {
                            if (w.call(M, B) && (M[B] === void 0 || M[B] === null)) throw new TypeError("Cannot convert undefined or null to object (" + B + ")");
                            !w.call(M, B) || !g(R) ? M[B] = R : M[B] = C(Object(M[B]), b[B])
                        }
                    }

                    function C(M, b) {
                        if (M === b) return M;
                        b = Object(b);
                        for (var B in b) w.call(b, B) && p(M, b, B);
                        if (Object.getOwnPropertySymbols) for (var R = Object.getOwnPropertySymbols(b), I = 0; I < R.length; I++) v.call(b, R[I]) && p(M, b, R[I]);
                        return M
                    }

                    m.exports = function (b) {
                        b = E(b);
                        for (var B = 1; B < arguments.length; B++) C(b, arguments[B]);
                        return b
                    }
                },
                "./node_modules/dtype/index.js": m => {
                    m.exports = function (x) {
                        switch (x) {
                            case"int8":
                                return Int8Array;
                            case"int16":
                                return Int16Array;
                            case"int32":
                                return Int32Array;
                            case"uint8":
                                return Uint8Array;
                            case"uint16":
                                return Uint16Array;
                            case"uint32":
                                return Uint32Array;
                            case"float32":
                                return Float32Array;
                            case"float64":
                                return Float64Array;
                            case"array":
                                return Array;
                            case"uint8_clamped":
                                return Uint8ClampedArray
                        }
                    }
                },
                "./node_modules/global/window.js": (m, x, h) => {
                    var g;
                    typeof window < "u" ? g = window : typeof h.g < "u" ? g = h.g : typeof self < "u" ? g = self : g = {}, m.exports = g
                },
                "./node_modules/ieee754/index.js": (m, x) => {/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
                    x.read = function (h, g, w, v, E) {
                        var p, C, M = E * 8 - v - 1, b = (1 << M) - 1, B = b >> 1, R = -7, I = w ? E - 1 : 0,
                            L = w ? -1 : 1, O = h[g + I];
                        for (I += L, p = O & (1 << -R) - 1, O >>= -R, R += M; R > 0; p = p * 256 + h[g + I], I += L, R -= 8) ;
                        for (C = p & (1 << -R) - 1, p >>= -R, R += v; R > 0; C = C * 256 + h[g + I], I += L, R -= 8) ;
                        if (p === 0) p = 1 - B; else {
                            if (p === b) return C ? NaN : (O ? -1 : 1) * (1 / 0);
                            C = C + Math.pow(2, v), p = p - B
                        }
                        return (O ? -1 : 1) * C * Math.pow(2, p - v)
                    }, x.write = function (h, g, w, v, E, p) {
                        var C, M, b, B = p * 8 - E - 1, R = (1 << B) - 1, I = R >> 1,
                            L = E === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, O = v ? 0 : p - 1, N = v ? 1 : -1,
                            F = g < 0 || g === 0 && 1 / g < 0 ? 1 : 0;
                        for (g = Math.abs(g), isNaN(g) || g === 1 / 0 ? (M = isNaN(g) ? 1 : 0, C = R) : (C = Math.floor(Math.log(g) / Math.LN2), g * (b = Math.pow(2, -C)) < 1 && (C--, b *= 2), C + I >= 1 ? g += L / b : g += L * Math.pow(2, 1 - I), g * b >= 2 && (C++, b /= 2), C + I >= R ? (M = 0, C = R) : C + I >= 1 ? (M = (g * b - 1) * Math.pow(2, E), C = C + I) : (M = g * Math.pow(2, I - 1) * Math.pow(2, E), C = 0)); E >= 8; h[w + O] = M & 255, O += N, M /= 256, E -= 8) ;
                        for (C = C << E | M, B += E; B > 0; h[w + O] = C & 255, O += N, C /= 256, B -= 8) ;
                        h[w + O - N] |= F * 128
                    }
                },
                "./node_modules/is-buffer/index.js": m => {/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
                    m.exports = function (g) {
                        return g != null && (x(g) || h(g) || !!g._isBuffer)
                    };

                    function x(g) {
                        return !!g.constructor && typeof g.constructor.isBuffer == "function" && g.constructor.isBuffer(g)
                    }

                    function h(g) {
                        return typeof g.readFloatLE == "function" && typeof g.slice == "function" && x(g.slice(0, 0))
                    }
                },
                "./node_modules/is-function/index.js": m => {
                    m.exports = h;
                    var x = Object.prototype.toString;

                    function h(g) {
                        if (!g) return !1;
                        var w = x.call(g);
                        return w === "[object Function]" || typeof g == "function" && w !== "[object RegExp]" || typeof window < "u" && (g === window.setTimeout || g === window.alert || g === window.confirm || g === window.prompt)
                    }
                },
                "./node_modules/is-obj/index.js": m => {
                    m.exports = function (x) {
                        var h = typeof x;
                        return x !== null && (h === "object" || h === "function")
                    }
                },
                "./node_modules/layout-bmfont-text/index.js": (m, x, h) => {
                    var g = h("./node_modules/word-wrapper/index.js"), w = h("./node_modules/xtend/immutable.js"),
                        v = h("./node_modules/as-number/index.js"),
                        E = ["x", "e", "a", "o", "n", "s", "r", "c", "u", "m", "v", "w", "z"], p = ["m", "w"],
                        C = ["H", "I", "N", "E", "F", "K", "L", "T", "U", "V", "W", "X", "Y", "Z"], M = 9, b = 32,
                        B = 0, R = 1, I = 2;
                    m.exports = function (ue) {
                        return new L(ue)
                    };

                    function L(pe) {
                        this.glyphs = [], this._measure = this.computeMetrics.bind(this), this.update(pe)
                    }

                    L.prototype.update = function (pe) {
                        if (pe = w({measure: this._measure}, pe), this._opt = pe, this._opt.tabSize = v(this._opt.tabSize, 4), !pe.font) throw new Error("must provide a valid bitmap font");
                        var ue = this.glyphs, he = pe.text || "", Z = pe.font;
                        this._setupSpaceGlyphs(Z);
                        var H = g.lines(he, pe), ae = pe.width || 0;
                        ue.length = 0;
                        var ee = H.reduce(function (an, En) {
                                return Math.max(an, En.width, ae)
                            }, 0), me = 0, Re = 0, ke = v(pe.lineHeight, Z.common.lineHeight), Ve = Z.common.base,
                            He = ke - Ve, ot = pe.letterSpacing || 0, gt = ke * H.length - He, Bt = fe(this._opt.align);
                        Re -= gt, this._width = ee, this._height = gt, this._descender = ke - Ve, this._baseline = Ve, this._xHeight = V(Z), this._capHeight = j(Z), this._lineHeight = ke, this._ascender = ke - He - this._xHeight;
                        var Rt = this;
                        H.forEach(function (an, En) {
                            for (var Nn = an.start, oi = an.end, pi = an.width, hi, Vn = Nn; Vn < oi; Vn++) {
                                var yi = he.charCodeAt(Vn), nr = Rt.getGlyph(Z, yi);
                                if (nr) {
                                    hi && (me += Y(Z, hi.id, nr.id));
                                    var Oi = me;
                                    Bt === R ? Oi += (ee - pi) / 2 : Bt === I && (Oi += ee - pi), ue.push({
                                        position: [Oi, Re],
                                        data: nr,
                                        index: Vn,
                                        line: En
                                    }), me += nr.xadvance + ot, hi = nr
                                }
                            }
                            Re += ke, me = 0
                        }), this._linesTotal = H.length
                    }, L.prototype._setupSpaceGlyphs = function (pe) {
                        if (this._fallbackSpaceGlyph = null, this._fallbackTabGlyph = null, !(!pe.chars || pe.chars.length === 0)) {
                            var ue = F(pe, b) || U(pe) || pe.chars[0], he = this._opt.tabSize * ue.xadvance;
                            this._fallbackSpaceGlyph = ue, this._fallbackTabGlyph = w(ue, {
                                x: 0,
                                y: 0,
                                xadvance: he,
                                id: M,
                                xoffset: 0,
                                yoffset: 0,
                                width: 0,
                                height: 0
                            })
                        }
                    }, L.prototype.getGlyph = function (pe, ue) {
                        var he = F(pe, ue);
                        return he || (ue === M ? this._fallbackTabGlyph : ue === b ? this._fallbackSpaceGlyph : null)
                    }, L.prototype.computeMetrics = function (pe, ue, he, Z) {
                        var H = this._opt.letterSpacing || 0, ae = this._opt.font, ee = 0, me = 0, Re = 0, ke, Ve;
                        if (!ae.chars || ae.chars.length === 0) return {start: ue, end: ue, width: 0};
                        he = Math.min(pe.length, he);
                        for (var He = ue; He < he; He++) {
                            var ot = pe.charCodeAt(He), ke = this.getGlyph(ae, ot);
                            if (ke) {
                                ke.xoffset;
                                var gt = Ve ? Y(ae, Ve.id, ke.id) : 0;
                                ee += gt;
                                var Bt = ee + ke.xadvance + H, Rt = ee + ke.width;
                                if (Rt >= Z || Bt >= Z) break;
                                ee = Bt, me = Rt, Ve = ke
                            }
                            Re++
                        }
                        return Ve && (me += Ve.xoffset), {start: ue, end: ue + Re, width: me}
                    }, ["width", "height", "descender", "ascender", "xHeight", "baseline", "capHeight", "lineHeight"].forEach(O);

                    function O(pe) {
                        Object.defineProperty(L.prototype, pe, {get: N(pe), configurable: !0})
                    }

                    function N(pe) {
                        return new Function(["return function " + pe + "() {", "  return this._" + pe, "}"].join(`
`))()
                    }

                    function F(pe, ue) {
                        if (!pe.chars || pe.chars.length === 0) return null;
                        var he = se(pe.chars, ue);
                        return he >= 0 ? pe.chars[he] : null
                    }

                    function V(pe) {
                        for (var ue = 0; ue < E.length; ue++) {
                            var he = E[ue].charCodeAt(0), Z = se(pe.chars, he);
                            if (Z >= 0) return pe.chars[Z].height
                        }
                        return 0
                    }

                    function U(pe) {
                        for (var ue = 0; ue < p.length; ue++) {
                            var he = p[ue].charCodeAt(0), Z = se(pe.chars, he);
                            if (Z >= 0) return pe.chars[Z]
                        }
                        return 0
                    }

                    function j(pe) {
                        for (var ue = 0; ue < C.length; ue++) {
                            var he = C[ue].charCodeAt(0), Z = se(pe.chars, he);
                            if (Z >= 0) return pe.chars[Z].height
                        }
                        return 0
                    }

                    function Y(pe, ue, he) {
                        if (!pe.kernings || pe.kernings.length === 0) return 0;
                        for (var Z = pe.kernings, H = 0; H < Z.length; H++) {
                            var ae = Z[H];
                            if (ae.first === ue && ae.second === he) return ae.amount
                        }
                        return 0
                    }

                    function fe(pe) {
                        return pe === "center" ? R : pe === "right" ? I : B
                    }

                    function se(pe, ue, he) {
                        he = he || 0;
                        for (var Z = he; Z < pe.length; Z++) if (pe[Z].id === ue) return Z;
                        return -1
                    }
                },
                "./node_modules/load-bmfont/browser.js": (m, x, h) => {
                    var g = h("./node_modules/buffer/index.js").Buffer, w = h("./node_modules/xhr/index.js"),
                        v = function () {
                        }, E = h("./node_modules/parse-bmfont-ascii/index.js"),
                        p = h("./node_modules/parse-bmfont-xml/lib/browser.js"),
                        C = h("./node_modules/parse-bmfont-binary/index.js"),
                        M = h("./node_modules/load-bmfont/lib/is-binary.js"),
                        b = h("./node_modules/xtend/immutable.js"), B = function () {
                            return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest
                        }();
                    m.exports = function (L, O) {
                        O = typeof O == "function" ? O : v, typeof L == "string" ? L = {uri: L} : L || (L = {});
                        var N = L.binary;
                        N && (L = I(L)), w(L, function (F, V, U) {
                            if (F) return O(F);
                            if (!/^2/.test(V.statusCode)) return O(new Error("http status code: " + V.statusCode));
                            if (!U) return O(new Error("no body result"));
                            var j = !1;
                            if (R(U)) {
                                var Y = new Uint8Array(U);
                                U = g.from(Y, "binary")
                            }
                            M(U) && (j = !0, typeof U == "string" && (U = g.from(U, "binary"))), j || (g.isBuffer(U) && (U = U.toString(L.encoding)), U = U.trim());
                            var fe;
                            try {
                                var se = V.headers["content-type"];
                                j ? fe = C(U) : /json/.test(se) || U.charAt(0) === "{" ? fe = JSON.parse(U) : /xml/.test(se) || U.charAt(0) === "<" ? fe = p(U) : fe = E(U)
                            } catch (pe) {
                                O(new Error("error parsing font " + pe.message)), O = v
                            }
                            O(null, fe)
                        })
                    };

                    function R(L) {
                        var O = Object.prototype.toString;
                        return O.call(L) === "[object ArrayBuffer]"
                    }

                    function I(L) {
                        if (B) return b(L, {responseType: "arraybuffer"});
                        if (typeof self.XMLHttpRequest > "u") throw new Error("your browser does not support XHR loading");
                        var O = new self.XMLHttpRequest;
                        return O.overrideMimeType("text/plain; charset=x-user-defined"), b({xhr: O}, L)
                    }
                },
                "./node_modules/load-bmfont/lib/is-binary.js": (m, x, h) => {
                    var g = h("./node_modules/buffer/index.js").Buffer, w = h("./node_modules/buffer-equal/index.js"),
                        v = g.from([66, 77, 70, 3]);
                    m.exports = function (E) {
                        return typeof E == "string" ? E.substring(0, 3) === "BMF" : E.length > 4 && w(E.slice(0, 4), v)
                    }
                },
                "./node_modules/ms/index.js": m => {
                    var x = 1e3, h = x * 60, g = h * 60, w = g * 24, v = w * 7, E = w * 365.25;
                    m.exports = function (B, R) {
                        R = R || {};
                        var I = typeof B;
                        if (I === "string" && B.length > 0) return p(B);
                        if (I === "number" && isFinite(B)) return R.long ? M(B) : C(B);
                        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(B))
                    };

                    function p(B) {
                        if (B = String(B), !(B.length > 100)) {
                            var R = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(B);
                            if (R) {
                                var I = parseFloat(R[1]), L = (R[2] || "ms").toLowerCase();
                                switch (L) {
                                    case"years":
                                    case"year":
                                    case"yrs":
                                    case"yr":
                                    case"y":
                                        return I * E;
                                    case"weeks":
                                    case"week":
                                    case"w":
                                        return I * v;
                                    case"days":
                                    case"day":
                                    case"d":
                                        return I * w;
                                    case"hours":
                                    case"hour":
                                    case"hrs":
                                    case"hr":
                                    case"h":
                                        return I * g;
                                    case"minutes":
                                    case"minute":
                                    case"mins":
                                    case"min":
                                    case"m":
                                        return I * h;
                                    case"seconds":
                                    case"second":
                                    case"secs":
                                    case"sec":
                                    case"s":
                                        return I * x;
                                    case"milliseconds":
                                    case"millisecond":
                                    case"msecs":
                                    case"msec":
                                    case"ms":
                                        return I;
                                    default:
                                        return
                                }
                            }
                        }
                    }

                    function C(B) {
                        var R = Math.abs(B);
                        return R >= w ? Math.round(B / w) + "d" : R >= g ? Math.round(B / g) + "h" : R >= h ? Math.round(B / h) + "m" : R >= x ? Math.round(B / x) + "s" : B + "ms"
                    }

                    function M(B) {
                        var R = Math.abs(B);
                        return R >= w ? b(B, R, w, "day") : R >= g ? b(B, R, g, "hour") : R >= h ? b(B, R, h, "minute") : R >= x ? b(B, R, x, "second") : B + " ms"
                    }

                    function b(B, R, I, L) {
                        var O = R >= I * 1.5;
                        return Math.round(B / I) + " " + L + (O ? "s" : "")
                    }
                },
                "./node_modules/parse-bmfont-ascii/index.js": m => {
                    m.exports = function (v) {
                        if (!v) throw new Error("no data provided");
                        v = v.toString().trim();
                        var E = {pages: [], chars: [], kernings: []}, p = v.split(/\r\n?|\n/g);
                        if (p.length === 0) throw new Error("no data in BMFont file");
                        for (var C = 0; C < p.length; C++) {
                            var M = x(p[C], C);
                            if (M) if (M.key === "page") {
                                if (typeof M.data.id != "number") throw new Error("malformed file at line " + C + " -- needs page id=N");
                                if (typeof M.data.file != "string") throw new Error("malformed file at line " + C + ' -- needs page file="path"');
                                E.pages[M.data.id] = M.data.file
                            } else M.key === "chars" || M.key === "kernings" || (M.key === "char" ? E.chars.push(M.data) : M.key === "kerning" ? E.kernings.push(M.data) : E[M.key] = M.data)
                        }
                        return E
                    };

                    function x(w, v) {
                        if (w = w.replace(/\t+/g, " ").trim(), !w) return null;
                        var E = w.indexOf(" ");
                        if (E === -1) throw new Error("no named row at line " + v);
                        var p = w.substring(0, E);
                        w = w.substring(E + 1), w = w.replace(/letter=[\'\"]\S+[\'\"]/gi, ""), w = w.split("="), w = w.map(function (R) {
                            return R.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g)
                        });
                        for (var C = [], M = 0; M < w.length; M++) {
                            var b = w[M];
                            M === 0 ? C.push({
                                key: b[0],
                                data: ""
                            }) : M === w.length - 1 ? C[C.length - 1].data = h(b[0]) : (C[C.length - 1].data = h(b[0]), C.push({
                                key: b[1],
                                data: ""
                            }))
                        }
                        var B = {key: p, data: {}};
                        return C.forEach(function (R) {
                            B.data[R.key] = R.data
                        }), B
                    }

                    function h(w) {
                        return !w || w.length === 0 ? "" : w.indexOf('"') === 0 || w.indexOf("'") === 0 ? w.substring(1, w.length - 1) : w.indexOf(",") !== -1 ? g(w) : parseInt(w, 10)
                    }

                    function g(w) {
                        return w.split(",").map(function (v) {
                            return parseInt(v, 10)
                        })
                    }
                },
                "./node_modules/parse-bmfont-binary/index.js": m => {
                    var x = [66, 77, 70];
                    m.exports = function (B) {
                        if (B.length < 6) throw new Error("invalid buffer length for BMFont");
                        var R = x.every(function (F, V) {
                            return B.readUInt8(V) === F
                        });
                        if (!R) throw new Error("BMFont missing BMF byte header");
                        var I = 3, L = B.readUInt8(I++);
                        if (L > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
                        for (var O = {kernings: [], chars: []}, N = 0; N < 5; N++) I += h(O, B, I);
                        return O
                    };

                    function h(b, B, R) {
                        if (R > B.length - 1) return 0;
                        var I = B.readUInt8(R++), L = B.readInt32LE(R);
                        switch (R += 4, I) {
                            case 1:
                                b.info = g(B, R);
                                break;
                            case 2:
                                b.common = w(B, R);
                                break;
                            case 3:
                                b.pages = v(B, R, L);
                                break;
                            case 4:
                                b.chars = E(B, R, L);
                                break;
                            case 5:
                                b.kernings = p(B, R, L);
                                break
                        }
                        return 5 + L
                    }

                    function g(b, B) {
                        var R = {};
                        R.size = b.readInt16LE(B);
                        var I = b.readUInt8(B + 2);
                        return R.smooth = I >> 7 & 1, R.unicode = I >> 6 & 1, R.italic = I >> 5 & 1, R.bold = I >> 4 & 1, I >> 3 & 1 && (R.fixedHeight = 1), R.charset = b.readUInt8(B + 3) || "", R.stretchH = b.readUInt16LE(B + 4), R.aa = b.readUInt8(B + 6), R.padding = [b.readInt8(B + 7), b.readInt8(B + 8), b.readInt8(B + 9), b.readInt8(B + 10)], R.spacing = [b.readInt8(B + 11), b.readInt8(B + 12)], R.outline = b.readUInt8(B + 13), R.face = M(b, B + 14), R
                    }

                    function w(b, B) {
                        var R = {};
                        return R.lineHeight = b.readUInt16LE(B), R.base = b.readUInt16LE(B + 2), R.scaleW = b.readUInt16LE(B + 4), R.scaleH = b.readUInt16LE(B + 6), R.pages = b.readUInt16LE(B + 8), b.readUInt8(B + 10), R.packed = 0, R.alphaChnl = b.readUInt8(B + 11), R.redChnl = b.readUInt8(B + 12), R.greenChnl = b.readUInt8(B + 13), R.blueChnl = b.readUInt8(B + 14), R
                    }

                    function v(b, B, R) {
                        for (var I = [], L = C(b, B), O = L.length + 1, N = R / O, F = 0; F < N; F++) I[F] = b.slice(B, B + L.length).toString("utf8"), B += O;
                        return I
                    }

                    function E(b, B, R) {
                        for (var I = [], L = R / 20, O = 0; O < L; O++) {
                            var N = {}, F = O * 20;
                            N.id = b.readUInt32LE(B + 0 + F), N.x = b.readUInt16LE(B + 4 + F), N.y = b.readUInt16LE(B + 6 + F), N.width = b.readUInt16LE(B + 8 + F), N.height = b.readUInt16LE(B + 10 + F), N.xoffset = b.readInt16LE(B + 12 + F), N.yoffset = b.readInt16LE(B + 14 + F), N.xadvance = b.readInt16LE(B + 16 + F), N.page = b.readUInt8(B + 18 + F), N.chnl = b.readUInt8(B + 19 + F), I[O] = N
                        }
                        return I
                    }

                    function p(b, B, R) {
                        for (var I = [], L = R / 10, O = 0; O < L; O++) {
                            var N = {}, F = O * 10;
                            N.first = b.readUInt32LE(B + 0 + F), N.second = b.readUInt32LE(B + 4 + F), N.amount = b.readInt16LE(B + 8 + F), I[O] = N
                        }
                        return I
                    }

                    function C(b, B) {
                        for (var R = B; R < b.length && b[R] !== 0; R++) ;
                        return b.slice(B, R)
                    }

                    function M(b, B) {
                        return C(b, B).toString("utf8")
                    }
                },
                "./node_modules/parse-bmfont-xml/lib/browser.js": (m, x, h) => {
                    var g = h("./node_modules/parse-bmfont-xml/lib/parse-attribs.js"),
                        w = h("./node_modules/xml-parse-from-string/index.js"), v = {
                            scaleh: "scaleH",
                            scalew: "scaleW",
                            stretchh: "stretchH",
                            lineheight: "lineHeight",
                            alphachnl: "alphaChnl",
                            redchnl: "redChnl",
                            greenchnl: "greenChnl",
                            bluechnl: "blueChnl"
                        };
                    m.exports = function (b) {
                        b = b.toString();
                        var B = w(b), R = {pages: [], chars: [], kernings: []};
                        ["info", "common"].forEach(function (U) {
                            var j = B.getElementsByTagName(U)[0];
                            j && (R[U] = g(E(j)))
                        });
                        var I = B.getElementsByTagName("pages")[0];
                        if (!I) throw new Error("malformed file -- no <pages> element");
                        for (var L = I.getElementsByTagName("page"), O = 0; O < L.length; O++) {
                            var N = L[O], F = parseInt(N.getAttribute("id"), 10), V = N.getAttribute("file");
                            if (isNaN(F)) throw new Error('malformed file -- page "id" attribute is NaN');
                            if (!V) throw new Error('malformed file -- needs page "file" attribute');
                            R.pages[parseInt(F, 10)] = V
                        }
                        return ["chars", "kernings"].forEach(function (U) {
                            var j = B.getElementsByTagName(U)[0];
                            if (j) for (var Y = U.substring(0, U.length - 1), fe = j.getElementsByTagName(Y), se = 0; se < fe.length; se++) {
                                var pe = fe[se];
                                R[U].push(g(E(pe)))
                            }
                        }), R
                    };

                    function E(M) {
                        var b = p(M);
                        return b.reduce(function (B, R) {
                            var I = C(R.nodeName);
                            return B[I] = R.nodeValue, B
                        }, {})
                    }

                    function p(M) {
                        for (var b = [], B = 0; B < M.attributes.length; B++) b.push(M.attributes[B]);
                        return b
                    }

                    function C(M) {
                        return v[M.toLowerCase()] || M
                    }
                },
                "./node_modules/parse-bmfont-xml/lib/parse-attribs.js": m => {
                    var x = "chasrset";
                    m.exports = function (w) {
                        x in w && (w.charset = w[x], delete w[x]);
                        for (var v in w) v === "face" || v === "charset" || (v === "padding" || v === "spacing" ? w[v] = h(w[v]) : w[v] = parseInt(w[v], 10));
                        return w
                    };

                    function h(g) {
                        return g.split(",").map(function (w) {
                            return parseInt(w, 10)
                        })
                    }
                },
                "./node_modules/parse-headers/parse-headers.js": m => {
                    var x = function (g) {
                        return g.replace(/^\s+|\s+$/g, "")
                    }, h = function (g) {
                        return Object.prototype.toString.call(g) === "[object Array]"
                    };
                    m.exports = function (g) {
                        if (!g) return {};
                        for (var w = {}, v = x(g).split(`
`), E = 0; E < v.length; E++) {
                            var p = v[E], C = p.indexOf(":"), M = x(p.slice(0, C)).toLowerCase(), b = x(p.slice(C + 1));
                            typeof w[M] > "u" ? w[M] = b : h(w[M]) ? w[M].push(b) : w[M] = [w[M], b]
                        }
                        return w
                    }
                },
                "./node_modules/quad-indices/index.js": (m, x, h) => {
                    var g = h("./node_modules/dtype/index.js"), w = h("./node_modules/an-array/index.js"),
                        v = h("./node_modules/is-buffer/index.js"), E = [0, 2, 3], p = [2, 1, 3];
                    m.exports = function (M, b) {
                        (!M || !(w(M) || v(M))) && (b = M || {}, M = null), typeof b == "number" ? b = {count: b} : b = b || {};
                        for (var B = typeof b.type == "string" ? b.type : "uint16", R = typeof b.count == "number" ? b.count : 1, I = b.start || 0, L = b.clockwise !== !1 ? E : p, O = L[0], N = L[1], F = L[2], V = R * 6, U = M || new (g(B))(V), j = 0, Y = 0; j < V; j += 6, Y += 4) {
                            var fe = j + I;
                            U[fe + 0] = Y + 0, U[fe + 1] = Y + 1, U[fe + 2] = Y + 2, U[fe + 3] = Y + O, U[fe + 4] = Y + N, U[fe + 5] = Y + F
                        }
                        return U
                    }
                },
                "./node_modules/super-animejs/lib/anime.es.js": (m, x, h) => {
                    h.r(x), h.d(x, {default: () => Qo});
                    var g = {
                            update: null,
                            begin: null,
                            loopBegin: null,
                            changeBegin: null,
                            change: null,
                            changeComplete: null,
                            loopComplete: null,
                            complete: null,
                            loop: 1,
                            direction: "normal",
                            autoplay: !0,
                            timelineOffset: 0
                        }, w = {duration: 1e3, delay: 0, endDelay: 0, easing: "easeOutElastic(1, .5)", round: 0},
                        v = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective"],
                        E = {CSS: {}, springs: {}};

                    function p(De, Ke, rt) {
                        return Math.min(Math.max(De, Ke), rt)
                    }

                    function C(De, Ke) {
                        return De.indexOf(Ke) > -1
                    }

                    function M(De, Ke) {
                        return De.apply(null, Ke)
                    }

                    var b = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i, B = /^rgb/, R = /^hsl/, I = {
                        arr: function (De) {
                            return Array.isArray(De)
                        }, obj: function (De) {
                            return C(Object.prototype.toString.call(De), "Object")
                        }, pth: function (De) {
                            return I.obj(De) && De.hasOwnProperty("totalLength")
                        }, svg: function (De) {
                            return De instanceof SVGElement
                        }, inp: function (De) {
                            return De instanceof HTMLInputElement
                        }, dom: function (De) {
                            return De.nodeType || I.svg(De)
                        }, str: function (De) {
                            return typeof De == "string"
                        }, fnc: function (De) {
                            return typeof De == "function"
                        }, und: function (De) {
                            return typeof De > "u"
                        }, hex: function (De) {
                            return b.test(De)
                        }, rgb: function (De) {
                            return B.test(De)
                        }, hsl: function (De) {
                            return R.test(De)
                        }, col: function (De) {
                            return I.hex(De) || I.rgb(De) || I.hsl(De)
                        }, key: function (De) {
                            return !g.hasOwnProperty(De) && !w.hasOwnProperty(De) && De !== "targets" && De !== "keyframes"
                        }
                    }, L = /\(([^)]+)\)/;

                    function O(De) {
                        var Ke = L.exec(De);
                        return Ke ? Ke[1].split(",").map(function (rt) {
                            return parseFloat(rt)
                        }) : []
                    }

                    function N(De, Ke) {
                        var rt = O(De), Ct = p(I.und(rt[0]) ? 1 : rt[0], .1, 100),
                            dt = p(I.und(rt[1]) ? 100 : rt[1], .1, 100), Lt = p(I.und(rt[2]) ? 10 : rt[2], .1, 100),
                            Kt = p(I.und(rt[3]) ? 0 : rt[3], .1, 100), Rn = Math.sqrt(dt / Ct),
                            xn = Lt / (2 * Math.sqrt(dt * Ct)), Dt = xn < 1 ? Rn * Math.sqrt(1 - xn * xn) : 0, Hn = 1,
                            jn = xn < 1 ? (xn * Rn + -Kt) / Dt : -Kt + Rn;

                        function Wn(li) {
                            var mi = Ke ? Ke * li / 1e3 : li;
                            return xn < 1 ? mi = Math.exp(-mi * xn * Rn) * (Hn * Math.cos(Dt * mi) + jn * Math.sin(Dt * mi)) : mi = (Hn + jn * mi) * Math.exp(-mi * Rn), li === 0 || li === 1 ? li : 1 - mi
                        }

                        function Wi() {
                            var li = E.springs[De];
                            if (li) return li;
                            for (var mi = 1 / 6, ki = 0, yr = 0; ;) if (ki += mi, Wn(ki) === 1) {
                                if (yr++, yr >= 16) break
                            } else yr = 0;
                            var Ur = ki * mi * 1e3;
                            return E.springs[De] = Ur, Ur
                        }

                        return Ke ? Wn : Wi
                    }

                    function F(De, Ke) {
                        De === void 0 && (De = 1), Ke === void 0 && (Ke = .5);
                        var rt = p(De, 1, 10), Ct = p(Ke, .1, 2);
                        return function (dt) {
                            return dt === 0 || dt === 1 ? dt : -rt * Math.pow(2, 10 * (dt - 1)) * Math.sin((dt - 1 - Ct / (Math.PI * 2) * Math.asin(1 / rt)) * (Math.PI * 2) / Ct)
                        }
                    }

                    function V(De) {
                        return De === void 0 && (De = 10), function (Ke) {
                            return Math.round(Ke * De) * (1 / De)
                        }
                    }

                    var U = function () {
                        var De = 11, Ke = 1 / (De - 1);

                        function rt(Hn, jn) {
                            return 1 - 3 * jn + 3 * Hn
                        }

                        function Ct(Hn, jn) {
                            return 3 * jn - 6 * Hn
                        }

                        function dt(Hn) {
                            return 3 * Hn
                        }

                        function Lt(Hn, jn, Wn) {
                            return ((rt(jn, Wn) * Hn + Ct(jn, Wn)) * Hn + dt(jn)) * Hn
                        }

                        function Kt(Hn, jn, Wn) {
                            return 3 * rt(jn, Wn) * Hn * Hn + 2 * Ct(jn, Wn) * Hn + dt(jn)
                        }

                        function Rn(Hn, jn, Wn, Wi, li) {
                            var mi, ki, yr = 0;
                            do ki = jn + (Wn - jn) / 2, mi = Lt(ki, Wi, li) - Hn, mi > 0 ? Wn = ki : jn = ki; while (Math.abs(mi) > 1e-7 && ++yr < 10);
                            return ki
                        }

                        function xn(Hn, jn, Wn, Wi) {
                            for (var li = 0; li < 4; ++li) {
                                var mi = Kt(jn, Wn, Wi);
                                if (mi === 0) return jn;
                                var ki = Lt(jn, Wn, Wi) - Hn;
                                jn -= ki / mi
                            }
                            return jn
                        }

                        function Dt(Hn, jn, Wn, Wi) {
                            if (!(0 <= Hn && Hn <= 1 && 0 <= Wn && Wn <= 1)) return;
                            var li = new Float32Array(De);
                            if (Hn !== jn || Wn !== Wi) for (var mi = 0; mi < De; ++mi) li[mi] = Lt(mi * Ke, Hn, Wn);

                            function ki(yr) {
                                for (var Ur = 0, Cn = 1, Ai = De - 1; Cn !== Ai && li[Cn] <= yr; ++Cn) Ur += Ke;
                                --Cn;
                                var _r = (yr - li[Cn]) / (li[Cn + 1] - li[Cn]), ri = Ur + _r * Ke, $ = Kt(ri, Hn, Wn);
                                return $ >= .001 ? xn(yr, ri, Hn, Wn) : $ === 0 ? ri : Rn(yr, Ur, Ur + Ke, Hn, Wn)
                            }

                            return function (yr) {
                                return Hn === jn && Wn === Wi || yr === 0 || yr === 1 ? yr : Lt(ki(yr), jn, Wi)
                            }
                        }

                        return Dt
                    }(), j = function () {
                        var De = ["Quad", "Cubic", "Quart", "Quint", "Sine", "Expo", "Circ", "Back", "Elastic"], Ke = {
                            In: [[.55, .085, .68, .53], [.55, .055, .675, .19], [.895, .03, .685, .22], [.755, .05, .855, .06], [.47, 0, .745, .715], [.95, .05, .795, .035], [.6, .04, .98, .335], [.6, -.28, .735, .045], F],
                            Out: [[.25, .46, .45, .94], [.215, .61, .355, 1], [.165, .84, .44, 1], [.23, 1, .32, 1], [.39, .575, .565, 1], [.19, 1, .22, 1], [.075, .82, .165, 1], [.175, .885, .32, 1.275], function (Kt, Rn) {
                                return function (xn) {
                                    return 1 - F(Kt, Rn)(1 - xn)
                                }
                            }],
                            InOut: [[.455, .03, .515, .955], [.645, .045, .355, 1], [.77, 0, .175, 1], [.86, 0, .07, 1], [.445, .05, .55, .95], [1, 0, 0, 1], [.785, .135, .15, .86], [.68, -.55, .265, 1.55], function (Kt, Rn) {
                                return function (xn) {
                                    return xn < .5 ? F(Kt, Rn)(xn * 2) / 2 : 1 - F(Kt, Rn)(xn * -2 + 2) / 2
                                }
                            }]
                        }, rt = {linear: [.25, .25, .75, .75]};
                        for (var Ct in Ke) for (var dt = 0, Lt = Ke[Ct].length; dt < Lt; dt++) rt["ease" + Ct + De[dt]] = Ke[Ct][dt];
                        return rt
                    }();

                    function Y(De, Ke) {
                        if (I.fnc(De)) return De;
                        var rt = De.split("(")[0], Ct = j[rt], dt = O(De);
                        switch (rt) {
                            case"spring":
                                return N(De, Ke);
                            case"cubicBezier":
                                return M(U, dt);
                            case"steps":
                                return M(V, dt);
                            default:
                                return I.fnc(Ct) ? M(Ct, dt) : M(U, Ct)
                        }
                    }

                    function fe(De) {
                        try {
                            var Ke = document.querySelectorAll(De);
                            return Ke
                        } catch {
                            return
                        }
                    }

                    var se = [];

                    function pe(De, Ke) {
                        for (var rt = se, Ct = De.length, dt = arguments.length >= 2 ? arguments[1] : void 0, Lt = 0; Lt < Ct; Lt++) if (Lt in De) {
                            var Kt = De[Lt];
                            Ke.call(dt, Kt, Lt, De) && rt.push(Kt)
                        }
                        return se = De, se.length = 0, rt
                    }

                    function ue(De, Ke) {
                        Ke || (Ke = []);
                        for (var rt = 0, Ct = De.length; rt < Ct; rt++) {
                            var dt = De[rt];
                            Array.isArray(dt) ? ue(dt, Ke) : Ke.push(dt)
                        }
                        return Ke
                    }

                    function he(De) {
                        return I.arr(De) ? De : (I.str(De) && (De = fe(De) || De), De instanceof NodeList || De instanceof HTMLCollection ? [].slice.call(De) : [De])
                    }

                    function Z(De, Ke) {
                        return De.some(function (rt) {
                            return rt === Ke
                        })
                    }

                    function H(De) {
                        var Ke = {};
                        for (var rt in De) Ke[rt] = De[rt];
                        return Ke
                    }

                    function ae(De, Ke) {
                        var rt = H(De);
                        for (var Ct in De) rt[Ct] = Ke.hasOwnProperty(Ct) ? Ke[Ct] : De[Ct];
                        return rt
                    }

                    function ee(De, Ke) {
                        var rt = H(De);
                        for (var Ct in Ke) rt[Ct] = I.und(De[Ct]) ? Ke[Ct] : De[Ct];
                        return rt
                    }

                    var me = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g;

                    function Re(De) {
                        var Ke = me.exec(De);
                        return Ke ? "rgba(" + Ke[1] + ",1)" : De
                    }

                    var ke = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, Ve = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;

                    function He(De) {
                        var Ke = De.replace(ke, function (Kt, Rn, xn, Dt) {
                                return Rn + Rn + xn + xn + Dt + Dt
                            }), rt = Ve.exec(Ke), Ct = parseInt(rt[1], 16), dt = parseInt(rt[2], 16),
                            Lt = parseInt(rt[3], 16);
                        return "rgba(" + Ct + "," + dt + "," + Lt + ",1)"
                    }

                    var ot = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g,
                        gt = /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g;

                    function Bt(De) {
                        var Ke = ot.exec(De) || gt.exec(De), rt = parseInt(Ke[1], 10) / 360,
                            Ct = parseInt(Ke[2], 10) / 100, dt = parseInt(Ke[3], 10) / 100, Lt = Ke[4] || 1;

                        function Kt(Wn, Wi, li) {
                            return li < 0 && (li += 1), li > 1 && (li -= 1), li < .16666666666666666 ? Wn + (Wi - Wn) * 6 * li : li < .5 ? Wi : li < .6666666666666666 ? Wn + (Wi - Wn) * (.6666666666666666 - li) * 6 : Wn
                        }

                        var Rn, xn, Dt;
                        if (Ct == 0) Rn = xn = Dt = dt; else {
                            var Hn = dt < .5 ? dt * (1 + Ct) : dt + Ct - dt * Ct, jn = 2 * dt - Hn;
                            Rn = Kt(jn, Hn, rt + .3333333333333333), xn = Kt(jn, Hn, rt), Dt = Kt(jn, Hn, rt - .3333333333333333)
                        }
                        return "rgba(" + Rn * 255 + "," + xn * 255 + "," + Dt * 255 + "," + Lt + ")"
                    }

                    function Rt(De) {
                        if (I.rgb(De)) return Re(De);
                        if (I.hex(De)) return He(De);
                        if (I.hsl(De)) return Bt(De)
                    }

                    var an = /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/;

                    function En(De) {
                        var Ke = an.exec(De);
                        if (Ke) return Ke[2]
                    }

                    function Nn(De) {
                        if (C(De, "translate") || De === "perspective") return "px";
                        if (C(De, "rotate") || C(De, "skew")) return "deg"
                    }

                    function oi(De, Ke) {
                        return I.fnc(De) ? De(Ke.target, Ke.id, Ke.total) : De
                    }

                    function pi(De, Ke) {
                        return De.getAttribute(Ke)
                    }

                    function hi(De, Ke, rt) {
                        var Ct = En(Ke);
                        if (Z([rt, "deg", "rad", "turn"], Ct)) return Ke;
                        var dt = E.CSS[Ke + rt];
                        if (!I.und(dt)) return dt;
                        var Lt = 100, Kt = document.createElement(De.tagName),
                            Rn = De.parentNode && De.parentNode !== document ? De.parentNode : document.body;
                        Rn.appendChild(Kt), Kt.style.position = "absolute", Kt.style.width = Lt + rt;
                        var xn = Lt / Kt.offsetWidth;
                        Rn.removeChild(Kt);
                        var Dt = xn * parseFloat(Ke);
                        return E.CSS[Ke + rt] = Dt, Dt
                    }

                    function Vn(De, Ke, rt) {
                        if (Ke in De.style) {
                            var Ct = Ke.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
                                dt = De.style[Ke] || getComputedStyle(De).getPropertyValue(Ct) || "0";
                            return rt ? hi(De, dt, rt) : dt
                        }
                    }

                    function yi(De, Ke) {
                        if (I.dom(De) && !I.inp(De) && (pi(De, Ke) || I.svg(De) && De[Ke])) return "attribute";
                        if (I.dom(De) && Z(v, Ke)) return "transform";
                        if (I.dom(De) && Ke !== "transform" && Vn(De, Ke)) return "css";
                        if (De[Ke] != null) return "object"
                    }

                    var nr = /(\w+)\(([^)]*)\)/g;

                    function Oi(De) {
                        if (I.dom(De)) {
                            for (var Ke = De.style.transform || "", rt = new Map, Ct; Ct = nr.exec(Ke);) rt.set(Ct[1], Ct[2]);
                            return rt
                        }
                    }

                    function Rr(De, Ke, rt, Ct) {
                        var dt = C(Ke, "scale") ? 1 : 0 + Nn(Ke), Lt = Oi(De).get(Ke) || dt;
                        return rt && (rt.transforms.list.set(Ke, Lt), rt.transforms.last = Ke), Ct ? hi(De, Lt, Ct) : Lt
                    }

                    function Ji(De, Ke, rt, Ct) {
                        switch (yi(De, Ke)) {
                            case"transform":
                                return Rr(De, Ke, Ct, rt);
                            case"css":
                                return Vn(De, Ke, rt);
                            case"attribute":
                                return pi(De, Ke);
                            default:
                                return De[Ke] || 0
                        }
                    }

                    var Pi = /^(\*=|\+=|-=)/;

                    function Br(De, Ke) {
                        var rt = Pi.exec(De);
                        if (!rt) return De;
                        var Ct = En(De) || 0, dt = parseFloat(Ke), Lt = parseFloat(De.replace(rt[0], ""));
                        switch (rt[0][0]) {
                            case"+":
                                return dt + Lt + Ct;
                            case"-":
                                return dt - Lt + Ct;
                            case"*":
                                return dt * Lt + Ct
                        }
                    }

                    var cr = /\s/g;

                    function ss(De, Ke) {
                        if (I.col(De)) return Rt(De);
                        var rt = En(De), Ct = rt ? De.substr(0, De.length - rt.length) : De;
                        return Ke && !cr.test(De) ? Ct + Ke : Ct
                    }

                    function Nr(De, Ke) {
                        return Math.sqrt(Math.pow(Ke.x - De.x, 2) + Math.pow(Ke.y - De.y, 2))
                    }

                    function ir(De) {
                        return Math.PI * 2 * pi(De, "r")
                    }

                    function jt(De) {
                        return pi(De, "width") * 2 + pi(De, "height") * 2
                    }

                    function Se(De) {
                        return Nr({x: pi(De, "x1"), y: pi(De, "y1")}, {x: pi(De, "x2"), y: pi(De, "y2")})
                    }

                    function _e(De) {
                        for (var Ke = De.points, rt = 0, Ct, dt = 0; dt < Ke.numberOfItems; dt++) {
                            var Lt = Ke.getItem(dt);
                            dt > 0 && (rt += Nr(Ct, Lt)), Ct = Lt
                        }
                        return rt
                    }

                    function Ge(De) {
                        var Ke = De.points;
                        return _e(De) + Nr(Ke.getItem(Ke.numberOfItems - 1), Ke.getItem(0))
                    }

                    function Le(De) {
                        if (De.getTotalLength) return De.getTotalLength();
                        switch (De.tagName.toLowerCase()) {
                            case"circle":
                                return ir(De);
                            case"rect":
                                return jt(De);
                            case"line":
                                return Se(De);
                            case"polyline":
                                return _e(De);
                            case"polygon":
                                return Ge(De)
                        }
                    }

                    function Ue(De) {
                        var Ke = Le(De);
                        return De.setAttribute("stroke-dasharray", Ke), Ke
                    }

                    function Qe(De) {
                        for (var Ke = De.parentNode; I.svg(Ke) && (Ke = Ke.parentNode, !!I.svg(Ke.parentNode));) ;
                        return Ke
                    }

                    function oe(De, Ke) {
                        var rt = Ke || {}, Ct = rt.el || Qe(De), dt = Ct.getBoundingClientRect(),
                            Lt = pi(Ct, "viewBox"), Kt = dt.width, Rn = dt.height,
                            xn = rt.viewBox || (Lt ? Lt.split(" ") : [0, 0, Kt, Rn]);
                        return {el: Ct, viewBox: xn, x: xn[0] / 1, y: xn[1] / 1, w: Kt / xn[2], h: Rn / xn[3]}
                    }

                    function G(De, Ke) {
                        var rt = I.str(De) ? fe(De)[0] : De, Ct = Ke || 100;
                        return function (dt) {
                            return {property: dt, el: rt, svg: oe(rt), totalLength: Le(rt) * (Ct / 100)}
                        }
                    }

                    function X(De, Ke) {
                        function rt(Rn) {
                            Rn === void 0 && (Rn = 0);
                            var xn = Ke + Rn >= 1 ? Ke + Rn : 0;
                            return De.el.getPointAtLength(xn)
                        }

                        var Ct = oe(De.el, De.svg), dt = rt(), Lt = rt(-1), Kt = rt(1);
                        switch (De.property) {
                            case"x":
                                return (dt.x - Ct.x) * Ct.w;
                            case"y":
                                return (dt.y - Ct.y) * Ct.h;
                            case"angle":
                                return Math.atan2(Kt.y - Lt.y, Kt.x - Lt.x) * 180 / Math.PI
                        }
                    }

                    var ve = /-?\d*\.?\d+/g;

                    function Be(De, Ke) {
                        var rt = ss(I.pth(De) ? De.totalLength : De, Ke) + "";
                        return {
                            original: rt,
                            numbers: rt.match(ve) ? rt.match(ve).map(Number) : [0],
                            strings: I.str(De) || Ke ? rt.split(ve) : []
                        }
                    }

                    function je(De) {
                        var Ke = De ? ue(I.arr(De) ? De.map(he) : he(De)) : [];
                        return pe(Ke, function (rt, Ct, dt) {
                            return dt.indexOf(rt) === Ct
                        })
                    }

                    function tt(De) {
                        var Ke = je(De);
                        return Ke.map(function (rt, Ct) {
                            return {target: rt, id: Ct, total: Ke.length, transforms: {list: Oi(rt)}}
                        })
                    }

                    var Yt = /^spring/;

                    function cn(De, Ke) {
                        var rt = H(Ke);
                        if (Yt.test(rt.easing) && (rt.duration = N(rt.easing)), I.arr(De)) {
                            var Ct = De.length, dt = Ct === 2 && !I.obj(De[0]);
                            dt ? De = {value: De} : I.fnc(Ke.duration) || (rt.duration = Ke.duration / Ct)
                        }
                        var Lt = I.arr(De) ? De : [De];
                        return Lt.map(function (Kt, Rn) {
                            var xn = I.obj(Kt) && !I.pth(Kt) ? Kt : {value: Kt};
                            return I.und(xn.delay) && (xn.delay = Rn ? 0 : Ke.delay), I.und(xn.endDelay) && (xn.endDelay = Rn === Lt.length - 1 ? Ke.endDelay : 0), xn
                        }).map(function (Kt) {
                            return ee(Kt, rt)
                        })
                    }

                    function $t(De) {
                        for (var Ke = pe(ue(De.map(function (Lt) {
                            return Object.keys(Lt)
                        })), function (Lt) {
                            return I.key(Lt)
                        }).reduce(function (Lt, Kt) {
                            return Lt.indexOf(Kt) < 0 && Lt.push(Kt), Lt
                        }, []), rt = {}, Ct = function (Lt) {
                            var Kt = Ke[Lt];
                            rt[Kt] = De.map(function (Rn) {
                                var xn = {};
                                for (var Dt in Rn) I.key(Dt) ? Dt == Kt && (xn.value = Rn[Dt]) : xn[Dt] = Rn[Dt];
                                return xn
                            })
                        }, dt = 0; dt < Ke.length; dt++) Ct(dt);
                        return rt
                    }

                    function en(De, Ke) {
                        var rt = [], Ct = Ke.keyframes;
                        Ct && (Ke = ee($t(Ct), Ke));
                        for (var dt in Ke) I.key(dt) && rt.push({name: dt, tweens: cn(Ke[dt], De)});
                        return rt
                    }

                    function Sn(De, Ke) {
                        var rt = {};
                        for (var Ct in De) {
                            var dt = oi(De[Ct], Ke);
                            I.arr(dt) && (dt = dt.map(function (Lt) {
                                return oi(Lt, Ke)
                            }), dt.length === 1 && (dt = dt[0])), rt[Ct] = dt
                        }
                        return rt.duration = parseFloat(rt.duration), rt.delay = parseFloat(rt.delay), rt
                    }

                    function Gi(De, Ke) {
                        var rt;
                        return De.tweens.map(function (Ct) {
                            var dt = Sn(Ct, Ke), Lt = dt.value, Kt = I.arr(Lt) ? Lt[1] : Lt, Rn = En(Kt),
                                xn = Ji(Ke.target, De.name, Rn, Ke), Dt = rt ? rt.to.original : xn,
                                Hn = I.arr(Lt) ? Lt[0] : Dt, jn = En(Hn) || En(xn), Wn = Rn || jn;
                            return I.und(Kt) && (Kt = Dt), dt.from = Be(Hn, Wn), dt.to = Be(Br(Kt, Hn), Wn), dt.start = rt ? rt.end : 0, dt.end = dt.start + dt.delay + dt.duration + dt.endDelay, dt.easing = Y(dt.easing, dt.duration), dt.isPath = I.pth(Lt), dt.isColor = I.col(dt.from.original), dt.isColor && (dt.round = 1), rt = dt, dt
                        })
                    }

                    var qn = {
                        css: function (De, Ke, rt) {
                            return De.style[Ke] = rt
                        }, attribute: function (De, Ke, rt) {
                            return De.setAttribute(Ke, rt)
                        }, object: function (De, Ke, rt) {
                            return De[Ke] = rt
                        }, transform: function (De, Ke, rt, Ct, dt) {
                            if (Ct.list.set(Ke, rt), Ke === Ct.last || dt) {
                                var Lt = "";
                                Ct.list.forEach(function (Kt, Rn) {
                                    Lt += Rn + "(" + Kt + ") "
                                }), De.style.transform = Lt
                            }
                        }
                    };

                    function fr(De, Ke) {
                        for (var rt = tt(De), Ct = 0, dt = rt.length; Ct < dt; Ct++) {
                            var Lt = rt[Ct];
                            for (var Kt in Ke) {
                                var Rn = oi(Ke[Kt], Lt), xn = Lt.target, Dt = En(Rn), Hn = Ji(xn, Kt, Dt, Lt),
                                    jn = Dt || En(Hn), Wn = Br(ss(Rn, jn), Hn), Wi = yi(xn, Kt);
                                qn[Wi](xn, Kt, Wn, Lt.transforms, !0)
                            }
                        }
                    }

                    function Vi(De, Ke) {
                        var rt = yi(De.target, Ke.name);
                        if (rt) {
                            var Ct = Gi(Ke, De), dt = Ct[Ct.length - 1];
                            return {
                                type: rt,
                                property: Ke.name,
                                animatable: De,
                                tweens: Ct,
                                duration: dt.end,
                                delay: Ct[0].delay,
                                endDelay: dt.endDelay
                            }
                        }
                    }

                    function Zi(De, Ke) {
                        return pe(ue(De.map(function (rt) {
                            return Ke.map(function (Ct) {
                                return Vi(rt, Ct)
                            })
                        })), function (rt) {
                            return !I.und(rt)
                        })
                    }

                    function co(De, Ke) {
                        var rt = De.length, Ct = function (Lt) {
                            return Lt.timelineOffset ? Lt.timelineOffset : 0
                        }, dt = {};
                        return dt.duration = rt ? Math.max.apply(Math, De.map(function (Lt) {
                            return Ct(Lt) + Lt.duration
                        })) : Ke.duration, dt.delay = rt ? Math.min.apply(Math, De.map(function (Lt) {
                            return Ct(Lt) + Lt.delay
                        })) : Ke.delay, dt.endDelay = rt ? dt.duration - Math.max.apply(Math, De.map(function (Lt) {
                            return Ct(Lt) + Lt.duration - Lt.endDelay
                        })) : Ke.endDelay, dt
                    }

                    var pr = 0;

                    function $s(De) {
                        var Ke = ae(g, De), rt = ae(w, De), Ct = en(rt, De), dt = tt(De.targets), Lt = Zi(dt, Ct),
                            Kt = co(Lt, rt), Rn = pr;
                        return pr++, ee(Ke, {
                            id: Rn,
                            children: [],
                            animatables: dt,
                            animations: Lt,
                            duration: Kt.duration,
                            delay: Kt.delay,
                            endDelay: Kt.endDelay
                        })
                    }

                    var Or = [], ws = [], Eo, bs = function () {
                        function De() {
                            Eo = requestAnimationFrame(Ke)
                        }

                        function Ke(rt) {
                            var Ct = Or.length;
                            if (Ct) {
                                for (var dt = 0; dt < Ct;) {
                                    var Lt = Or[dt];
                                    if (!Lt.paused) Lt.tick(rt); else {
                                        var Kt = Or.indexOf(Lt);
                                        Kt > -1 && (Or.splice(Kt, 1), Ct = Or.length)
                                    }
                                    dt++
                                }
                                De()
                            } else Eo = cancelAnimationFrame(Eo)
                        }

                        return De
                    }();

                    function kr() {
                        if (document.hidden) {
                            for (var De = 0, Ke = Or.length; De < Ke; De++) activeInstance[De].pause();
                            ws = Or.slice(0), Or = []
                        } else for (var rt = 0, Ct = ws.length; rt < Ct; rt++) ws[rt].play()
                    }

                    document.addEventListener("visibilitychange", kr);

                    function Hi(De) {
                        De === void 0 && (De = {});
                        var Ke = 0, rt = 0, Ct = 0, dt, Lt = 0, Kt = null;

                        function Rn() {
                            return window.Promise && new Promise(function (Cn) {
                                return Kt = Cn
                            })
                        }

                        var xn = Rn(), Dt = $s(De);

                        function Hn() {
                            Dt.reversed = !Dt.reversed;
                            for (var Cn = 0, Ai = dt.length; Cn < Ai; Cn++) dt[Cn].reversed = Dt.reversed
                        }

                        function jn(Cn) {
                            return Dt.reversed ? Dt.duration - Cn : Cn
                        }

                        function Wn() {
                            Ke = 0, rt = jn(Dt.currentTime) * (1 / Hi.speed)
                        }

                        function Wi(Cn, Ai) {
                            Ai && Ai.seek(Cn - Ai.timelineOffset)
                        }

                        function li(Cn) {
                            if (Dt.reversePlayback) for (var _r = Lt; _r--;) Wi(Cn, dt[_r]); else for (var Ai = 0; Ai < Lt; Ai++) Wi(Cn, dt[Ai])
                        }

                        function mi(Cn) {
                            for (var Ai = 0, _r = Dt.animations, ri = _r.length; Ai < ri;) {
                                var $ = _r[Ai], re = $.animatable, Ae = $.tweens, xe = Ae.length - 1, Oe = Ae[xe];
                                xe && (Oe = pe(Ae, function (Jt) {
                                    return Cn < Jt.end
                                })[0] || Oe);
                                for (var Ze = p(Cn - Oe.start - Oe.delay, 0, Oe.duration) / Oe.duration, at = isNaN(Ze) ? 1 : Oe.easing(Ze), wt = Oe.to.strings, kt = Oe.round, et = [], _t = Oe.to.numbers.length, ce = void 0, de = 0; de < _t; de++) {
                                    var we = void 0, Ee = Oe.to.numbers[de], Me = Oe.from.numbers[de] || 0;
                                    Oe.isPath ? we = X(Oe.value, at * Ee) : we = Me + at * (Ee - Me), kt && (Oe.isColor && de > 2 || (we = Math.round(we * kt) / kt)), et.push(we)
                                }
                                var st = wt.length;
                                if (!st) ce = et[0]; else {
                                    ce = wt[0];
                                    for (var ut = 0; ut < st; ut++) {
                                        wt[ut];
                                        var Vt = wt[ut + 1], Ft = et[ut];
                                        isNaN(Ft) || (Vt ? ce += Ft + Vt : ce += Ft + " ")
                                    }
                                }
                                qn[$.type](re.target, $.property, ce, re.transforms), $.currentValue = ce, Ai++
                            }
                        }

                        function ki(Cn) {
                            Dt[Cn] && !Dt.passThrough && Dt[Cn](Dt)
                        }

                        function yr() {
                            Dt.remaining && Dt.remaining !== !0 && Dt.remaining--
                        }

                        function Ur(Cn) {
                            var Ai = Dt.duration, _r = Dt.delay, ri = Ai - Dt.endDelay, $ = jn(Cn);
                            Dt.progress = p($ / Ai * 100, 0, 100), Dt.reversePlayback = $ < Dt.currentTime, dt && li($), !Dt.began && Dt.currentTime > 0 && (Dt.began = !0, ki("begin"), ki("loopBegin")), $ <= _r && Dt.currentTime !== 0 && mi(0), ($ >= ri && Dt.currentTime !== Ai || !Ai) && mi(Ai), $ > _r && $ < ri ? (Dt.changeBegan || (Dt.changeBegan = !0, Dt.changeCompleted = !1, ki("changeBegin")), ki("change"), mi($)) : Dt.changeBegan && (Dt.changeCompleted = !0, Dt.changeBegan = !1, ki("changeComplete")), Dt.currentTime = p($, 0, Ai), Dt.began && ki("update"), Cn >= Ai && (rt = 0, yr(), Dt.remaining ? (Ke = Ct, ki("loopComplete"), ki("loopBegin"), Dt.direction === "alternate" && Hn()) : (Dt.paused = !0, Dt.completed || (Dt.completed = !0, ki("loopComplete"), ki("complete"), "Promise" in window && (Kt(), xn = Rn()))))
                        }

                        return Dt.reset = function () {
                            var Cn = Dt.direction;
                            Dt.passThrough = !1, Dt.currentTime = 0, Dt.progress = 0, Dt.paused = !0, Dt.began = !1, Dt.changeBegan = !1, Dt.completed = !1, Dt.changeCompleted = !1, Dt.reversePlayback = !1, Dt.reversed = Cn === "reverse", Dt.remaining = Dt.loop, dt = Dt.children, Lt = dt.length;
                            for (var Ai = Lt; Ai--;) Dt.children[Ai].reset();
                            (Dt.reversed && Dt.loop !== !0 || Cn === "alternate" && Dt.loop === 1) && Dt.remaining++, mi(0)
                        }, Dt.set = function (Cn, Ai) {
                            return fr(Cn, Ai), Dt
                        }, Dt.tick = function (Cn) {
                            Ct = Cn, Ke || (Ke = Ct), Ur((Ct + (rt - Ke)) * Hi.speed)
                        }, Dt.seek = function (Cn) {
                            Ur(jn(Cn))
                        }, Dt.pause = function () {
                            Dt.paused = !0, Wn()
                        }, Dt.play = function () {
                            Dt.paused && (Dt.paused = !1, Or.push(Dt), Wn(), Eo || bs())
                        }, Dt.reverse = function () {
                            Hn(), Wn()
                        }, Dt.restart = function () {
                            Dt.reset(), Dt.play()
                        }, Dt.finished = xn, Dt.reset(), Dt.autoplay && Dt.play(), Dt
                    }

                    function Qr(De, Ke) {
                        for (var rt = Ke.length; rt--;) Z(De, Ke[rt].animatable.target) && Ke.splice(rt, 1)
                    }

                    function ua(De) {
                        for (var Ke = je(De), rt = Or.length; rt--;) {
                            var Ct = Or[rt], dt = Ct.animations, Lt = Ct.children;
                            Qr(Ke, dt);
                            for (var Kt = Lt.length; Kt--;) {
                                var Rn = Lt[Kt], xn = Rn.animations;
                                Qr(Ke, xn), !xn.length && !Rn.children.length && Lt.splice(Kt, 1)
                            }
                            !dt.length && !Lt.length && Ct.pause()
                        }
                    }

                    function xo(De, Ke) {
                        Ke === void 0 && (Ke = {});
                        var rt = Ke.direction || "normal", Ct = Ke.easing ? Y(Ke.easing) : null, dt = Ke.grid,
                            Lt = Ke.axis, Kt = Ke.from || 0, Rn = Kt === "first", xn = Kt === "center",
                            Dt = Kt === "last", Hn = I.arr(De), jn = parseFloat(Hn ? De[0] : De),
                            Wn = Hn ? parseFloat(De[1]) : 0, Wi = En(Hn ? De[1] : De) || 0,
                            li = Ke.start || 0 + (Hn ? jn : 0), mi = [], ki = 0;
                        return function (yr, Ur, Cn) {
                            if (Rn && (Kt = 0), xn && (Kt = (Cn - 1) / 2), Dt && (Kt = Cn - 1), !mi.length) {
                                for (var Ai = 0; Ai < Cn; Ai++) {
                                    if (!dt) mi.push(Math.abs(Kt - Ai)); else {
                                        var _r = xn ? (dt[0] - 1) / 2 : Kt % dt[0],
                                            ri = xn ? (dt[1] - 1) / 2 : Math.floor(Kt / dt[0]), $ = Ai % dt[0],
                                            re = Math.floor(Ai / dt[0]), Ae = _r - $, xe = ri - re,
                                            Oe = Math.sqrt(Ae * Ae + xe * xe);
                                        Lt === "x" && (Oe = -Ae), Lt === "y" && (Oe = -xe), mi.push(Oe)
                                    }
                                    ki = Math.max.apply(Math, mi)
                                }
                                Ct && (mi = mi.map(function (at) {
                                    return Ct(at / ki) * ki
                                })), rt === "reverse" && (mi = mi.map(function (at) {
                                    return Lt ? at < 0 ? at * -1 : -at : Math.abs(ki - at)
                                }))
                            }
                            var Ze = Hn ? (Wn - jn) / ki : jn;
                            return li + Ze * (Math.round(mi[Ur] * 100) / 100) + Wi
                        }
                    }

                    function Ea(De) {
                        De === void 0 && (De = {});
                        var Ke = Hi(De);
                        return Ke.duration = 0, Ke.add = function (rt, Ct) {
                            var dt = Or.indexOf(Ke), Lt = Ke.children;
                            dt > -1 && Or.splice(dt, 1);

                            function Kt(Wn) {
                                Wn.passThrough = !0
                            }

                            for (var Rn = 0; Rn < Lt.length; Rn++) Kt(Lt[Rn]);
                            var xn = ee(rt, ae(w, De));
                            xn.targets = xn.targets || De.targets;
                            var Dt = Ke.duration;
                            xn.autoplay = !1, xn.direction = Ke.direction, xn.timelineOffset = I.und(Ct) ? Dt : Br(Ct, Dt), Kt(Ke), Ke.seek(xn.timelineOffset);
                            var Hn = Hi(xn);
                            Kt(Hn), Lt.push(Hn);
                            var jn = co(Lt, De);
                            return Ke.delay = jn.delay, Ke.endDelay = jn.endDelay, Ke.duration = jn.duration, Ke.seek(0), Ke.reset(), Ke.autoplay && Ke.play(), Ke
                        }, Ke
                    }

                    Hi.version = "3.0.0", Hi.speed = 1, Hi.running = Or, Hi.remove = ua, Hi.get = Ji, Hi.set = fr, Hi.convertPx = hi, Hi.path = G, Hi.setDashoffset = Ue, Hi.stagger = xo, Hi.timeline = Ea, Hi.easing = Y, Hi.penner = j, Hi.random = function (De, Ke) {
                        return Math.floor(Math.random() * (Ke - De + 1)) + De
                    };
                    const Qo = Hi
                },
                "./node_modules/three-bmfont-text/index.js": (m, x, h) => {
                    var g = h("./node_modules/layout-bmfont-text/index.js"),
                        w = h("./node_modules/quad-indices/index.js"),
                        v = h("./node_modules/three-bmfont-text/lib/vertices.js"),
                        E = h("./node_modules/three-bmfont-text/lib/utils.js");
                    m.exports = function (M) {
                        return new p(M)
                    };

                    class p extends THREE.BufferGeometry {
                        constructor(M) {
                            super(), typeof M == "string" && (M = {text: M}), this._opt = Object.assign({}, M), M && this.update(M)
                        }

                        update(M) {
                            if (typeof M == "string" && (M = {text: M}), M = Object.assign({}, this._opt, M), !M.font) throw new TypeError("must specify a { font } in options");
                            this.layout = g(M);
                            var b = M.flipY !== !1, B = M.font, R = B.common.scaleW, I = B.common.scaleH,
                                L = this.layout.glyphs.filter(function (U) {
                                    var j = U.data;
                                    return j.width * j.height > 0
                                });
                            this.visibleGlyphs = L;
                            var O = v.positions(L), N = v.uvs(L, R, I, b),
                                F = w([], {clockwise: !0, type: "uint16", count: L.length});
                            if (this.setIndex(F), this.setAttribute("position", new THREE.BufferAttribute(O, 2)), this.setAttribute("uv", new THREE.BufferAttribute(N, 2)), !M.multipage && "page" in this.attributes) this.removeAttribute("page"); else if (M.multipage) {
                                var V = v.pages(L);
                                this.setAttribute("page", new THREE.BufferAttribute(V, 1))
                            }
                            this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere()
                        }

                        computeBoundingSphere() {
                            this.boundingSphere === null && (this.boundingSphere = new THREE.Sphere);
                            var M = this.attributes.position.array, b = this.attributes.position.itemSize;
                            if (!M || !b || M.length < 2) {
                                this.boundingSphere.radius = 0, this.boundingSphere.center.set(0, 0, 0);
                                return
                            }
                            E.computeSphere(M, this.boundingSphere), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
                        }

                        computeBoundingBox() {
                            this.boundingBox === null && (this.boundingBox = new THREE.Box3);
                            var M = this.boundingBox, b = this.attributes.position.array,
                                B = this.attributes.position.itemSize;
                            if (!b || !B || b.length < 2) {
                                M.makeEmpty();
                                return
                            }
                            E.computeBox(b, M)
                        }
                    }
                },
                "./node_modules/three-bmfont-text/lib/utils.js": m => {
                    var x = 2, h = {min: [0, 0], max: [0, 0]};

                    function g(w) {
                        var v = w.length / x;
                        h.min[0] = w[0], h.min[1] = w[1], h.max[0] = w[0], h.max[1] = w[1];
                        for (var E = 0; E < v; E++) {
                            var p = w[E * x + 0], C = w[E * x + 1];
                            h.min[0] = Math.min(p, h.min[0]), h.min[1] = Math.min(C, h.min[1]), h.max[0] = Math.max(p, h.max[0]), h.max[1] = Math.max(C, h.max[1])
                        }
                    }

                    m.exports.computeBox = function (w, v) {
                        g(w), v.min.set(h.min[0], h.min[1], 0), v.max.set(h.max[0], h.max[1], 0)
                    }, m.exports.computeSphere = function (w, v) {
                        g(w);
                        var E = h.min[0], p = h.min[1], C = h.max[0], M = h.max[1], b = C - E, B = M - p,
                            R = Math.sqrt(b * b + B * B);
                        v.center.set(E + b / 2, p + B / 2, 0), v.radius = R / 2
                    }
                },
                "./node_modules/three-bmfont-text/lib/vertices.js": m => {
                    m.exports.pages = function (h) {
                        var g = new Float32Array(h.length * 4 * 1), w = 0;
                        return h.forEach(function (v) {
                            var E = v.data.page || 0;
                            g[w++] = E, g[w++] = E, g[w++] = E, g[w++] = E
                        }), g
                    }, m.exports.uvs = function (h, g, w, v) {
                        var E = new Float32Array(h.length * 4 * 2), p = 0;
                        return h.forEach(function (C) {
                            var M = C.data, b = M.x + M.width, B = M.y + M.height, R = M.x / g, I = M.y / w, L = b / g,
                                O = B / w;
                            v && (I = (w - M.y) / w, O = (w - B) / w), E[p++] = R, E[p++] = I, E[p++] = R, E[p++] = O, E[p++] = L, E[p++] = O, E[p++] = L, E[p++] = I
                        }), E
                    }, m.exports.positions = function (h) {
                        var g = new Float32Array(h.length * 4 * 2), w = 0;
                        return h.forEach(function (v) {
                            var E = v.data, p = v.position[0] + E.xoffset, C = v.position[1] + E.yoffset, M = E.width,
                                b = E.height;
                            g[w++] = p, g[w++] = C, g[w++] = p, g[w++] = C + b, g[w++] = p + M, g[w++] = C + b, g[w++] = p + M, g[w++] = C
                        }), g
                    }
                },
                "./node_modules/webvr-polyfill/build/webvr-polyfill.js": function (m, x, h) {/**
                 * @license
                 * webvr-polyfill
                 * Copyright (c) 2015-2017 Google
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 *//**
                 * @license
                 * cardboard-vr-display
                 * Copyright (c) 2015-2017 Google
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 *//**
                 * @license
                 * webvr-polyfill-dpdb
                 * Copyright (c) 2017 Google
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 *//**
                 * @license
                 * wglu-preserve-state
                 * Copyright (c) 2016, Brandon Jones.
                 *
                 * Permission is hereby granted, free of charge, to any person obtaining a copy
                 * of this software and associated documentation files (the "Software"), to deal
                 * in the Software without restriction, including without limitation the rights
                 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                 * copies of the Software, and to permit persons to whom the Software is
                 * furnished to do so, subject to the following conditions:
                 *
                 * The above copyright notice and this permission notice shall be included in
                 * all copies or substantial portions of the Software.
                 *
                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                 * THE SOFTWARE.
                 */
                    /**
                     * @license
                     * nosleep.js
                     * Copyright (c) 2017, Rich Tibbett
                     *
                     * Permission is hereby granted, free of charge, to any person obtaining a copy
                     * of this software and associated documentation files (the "Software"), to deal
                     * in the Software without restriction, including without limitation the rights
                     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                     * copies of the Software, and to permit persons to whom the Software is
                     * furnished to do so, subject to the following conditions:
                     *
                     * The above copyright notice and this permission notice shall be included in
                     * all copies or substantial portions of the Software.
                     *
                     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                     * THE SOFTWARE.
                     */(function (g, w) {
                        m.exports = w()
                    })(this, function () {
                        var g = typeof window < "u" ? window : typeof h.g < "u" ? h.g : typeof self < "u" ? self : {};

                        function w(F) {
                            return F && F.__esModule && Object.prototype.hasOwnProperty.call(F, "default") ? F.default : F
                        }

                        function v(F, V) {
                            return V = {exports: {}}, F(V, V.exports), V.exports
                        }

                        var E = function () {
                            return /Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent)
                        }, p = function (V, U) {
                            for (var j = 0, Y = V.length; j < Y; j++) U[j] = V[j]
                        }, C = function (V, U) {
                            for (var j in U) U.hasOwnProperty(j) && (V[j] = U[j]);
                            return V
                        }, M = v(function (F, V) {/**
                         * @license
                         * cardboard-vr-display
                         * Copyright (c) 2015-2017 Google
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         * http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         *//**
                         * @license
                         * gl-preserve-state
                         * Copyright (c) 2016, Brandon Jones.
                         *
                         * Permission is hereby granted, free of charge, to any person obtaining a copy
                         * of this software and associated documentation files (the "Software"), to deal
                         * in the Software without restriction, including without limitation the rights
                         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                         * copies of the Software, and to permit persons to whom the Software is
                         * furnished to do so, subject to the following conditions:
                         *
                         * The above copyright notice and this permission notice shall be included in
                         * all copies or substantial portions of the Software.
                         *
                         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                         * THE SOFTWARE.
                         *//**
                         * @license
                         * webvr-polyfill-dpdb
                         * Copyright (c) 2015-2017 Google
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         * http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                            /**
                             * @license
                             * nosleep.js
                             * Copyright (c) 2017, Rich Tibbett
                             *
                             * Permission is hereby granted, free of charge, to any person obtaining a copy
                             * of this software and associated documentation files (the "Software"), to deal
                             * in the Software without restriction, including without limitation the rights
                             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                             * copies of the Software, and to permit persons to whom the Software is
                             * furnished to do so, subject to the following conditions:
                             *
                             * The above copyright notice and this permission notice shall be included in
                             * all copies or substantial portions of the Software.
                             *
                             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                             * THE SOFTWARE.
                             */(function (U, j) {
                                F.exports = j()
                            })(g, function () {
                                var U = function ($, re) {
                                    if (!($ instanceof re)) throw new TypeError("Cannot call a class as a function")
                                }, j = function () {
                                    function $(re, Ae) {
                                        for (var xe = 0; xe < Ae.length; xe++) {
                                            var Oe = Ae[xe];
                                            Oe.enumerable = Oe.enumerable || !1, Oe.configurable = !0, "value" in Oe && (Oe.writable = !0), Object.defineProperty(re, Oe.key, Oe)
                                        }
                                    }

                                    return function (re, Ae, xe) {
                                        return Ae && $(re.prototype, Ae), xe && $(re, xe), re
                                    }
                                }(), Y = function () {
                                    function $(re, Ae) {
                                        var xe = [], Oe = !0, Ze = !1, at = void 0;
                                        try {
                                            for (var wt = re[Symbol.iterator](), kt; !(Oe = (kt = wt.next()).done) && (xe.push(kt.value), !(Ae && xe.length === Ae)); Oe = !0) ;
                                        } catch (et) {
                                            Ze = !0, at = et
                                        } finally {
                                            try {
                                                !Oe && wt.return && wt.return()
                                            } finally {
                                                if (Ze) throw at
                                            }
                                        }
                                        return xe
                                    }

                                    return function (re, Ae) {
                                        if (Array.isArray(re)) return re;
                                        if (Symbol.iterator in Object(re)) return $(re, Ae);
                                        throw new TypeError("Invalid attempt to destructure non-iterable instance")
                                    }
                                }(), fe = .001, se = 1, pe = function (re, Ae) {
                                    return "data:" + re + "," + encodeURIComponent(Ae)
                                }, ue = function (re, Ae, xe) {
                                    return re + (Ae - re) * xe
                                }, he = function () {
                                    var $ = /iPad|iPhone|iPod/.test(navigator.platform);
                                    return function () {
                                        return $
                                    }
                                }(), Z = function () {
                                    var $ = navigator.userAgent.indexOf("Version") !== -1 && navigator.userAgent.indexOf("Android") !== -1 && navigator.userAgent.indexOf("Chrome") !== -1;
                                    return function () {
                                        return $
                                    }
                                }(), H = function () {
                                    var $ = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                                    return function () {
                                        return $
                                    }
                                }(), ae = function () {
                                    var $ = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
                                    return function () {
                                        return $
                                    }
                                }(), ee = function () {
                                    var $ = navigator.userAgent.match(/.*Chrome\/([0-9]+)/),
                                        re = $ ? parseInt($[1], 10) : null;
                                    return function () {
                                        return re
                                    }
                                }(), me = function () {
                                    var $ = !1;
                                    return $ = he() && H() && navigator.userAgent.indexOf("13_4") !== -1, function () {
                                        return $
                                    }
                                }(), Re = function () {
                                    var $ = !1;
                                    if (ee() === 65) {
                                        var re = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
                                        if (re) {
                                            var Ae = re[1].split("."), xe = Y(Ae, 4);
                                            xe[0], xe[1];
                                            var Oe = xe[2], Ze = xe[3];
                                            $ = parseInt(Oe, 10) === 3325 && parseInt(Ze, 10) < 148
                                        }
                                    }
                                    return function () {
                                        return $
                                    }
                                }(), ke = function () {
                                    var $ = navigator.userAgent.indexOf("R7 Build") !== -1;
                                    return function () {
                                        return $
                                    }
                                }(), Ve = function () {
                                    var re = window.orientation == 90 || window.orientation == -90;
                                    return ke() ? !re : re
                                }, He = function (re) {
                                    return !(isNaN(re) || re <= fe || re > se)
                                }, ot = function () {
                                    return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio
                                }, gt = function () {
                                    return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio
                                }, Bt = function (re) {
                                    if (Z()) return !1;
                                    if (re.requestFullscreen) re.requestFullscreen(); else if (re.webkitRequestFullscreen) re.webkitRequestFullscreen(); else if (re.mozRequestFullScreen) re.mozRequestFullScreen(); else if (re.msRequestFullscreen) re.msRequestFullscreen(); else return !1;
                                    return !0
                                }, Rt = function () {
                                    if (document.exitFullscreen) document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); else if (document.mozCancelFullScreen) document.mozCancelFullScreen(); else if (document.msExitFullscreen) document.msExitFullscreen(); else return !1;
                                    return !0
                                }, an = function () {
                                    return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement
                                }, En = function (re, Ae, xe, Oe) {
                                    var Ze = re.createShader(re.VERTEX_SHADER);
                                    re.shaderSource(Ze, Ae), re.compileShader(Ze);
                                    var at = re.createShader(re.FRAGMENT_SHADER);
                                    re.shaderSource(at, xe), re.compileShader(at);
                                    var wt = re.createProgram();
                                    re.attachShader(wt, Ze), re.attachShader(wt, at);
                                    for (var kt in Oe) re.bindAttribLocation(wt, Oe[kt], kt);
                                    return re.linkProgram(wt), re.deleteShader(Ze), re.deleteShader(at), wt
                                }, Nn = function (re, Ae) {
                                    for (var xe = {}, Oe = re.getProgramParameter(Ae, re.ACTIVE_UNIFORMS), Ze = "", at = 0; at < Oe; at++) {
                                        var wt = re.getActiveUniform(Ae, at);
                                        Ze = wt.name.replace("[0]", ""), xe[Ze] = re.getUniformLocation(Ae, Ze)
                                    }
                                    return xe
                                }, oi = function (re, Ae, xe, Oe, Ze, at, wt) {
                                    var kt = 1 / (Ae - xe), et = 1 / (Oe - Ze), _t = 1 / (at - wt);
                                    return re[0] = -2 * kt, re[1] = 0, re[2] = 0, re[3] = 0, re[4] = 0, re[5] = -2 * et, re[6] = 0, re[7] = 0, re[8] = 0, re[9] = 0, re[10] = 2 * _t, re[11] = 0, re[12] = (Ae + xe) * kt, re[13] = (Ze + Oe) * et, re[14] = (wt + at) * _t, re[15] = 1, re
                                }, pi = function () {
                                    var re = !1;
                                    return function (Ae) {
                                        (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(Ae) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(Ae.substr(0, 4))) && (re = !0)
                                    }(navigator.userAgent || navigator.vendor || window.opera), re
                                }, hi = function (re, Ae) {
                                    for (var xe in Ae) Ae.hasOwnProperty(xe) && (re[xe] = Ae[xe]);
                                    return re
                                }, Vn = function (re) {
                                    if (he()) {
                                        var Ae = re.style.width, xe = re.style.height;
                                        re.style.width = parseInt(Ae) + 1 + "px", re.style.height = parseInt(xe) + "px", setTimeout(function () {
                                            re.style.width = Ae, re.style.height = xe
                                        }, 100)
                                    }
                                    window.canvas = re
                                }, yi = function () {
                                    var $ = Math.PI / 180, re = Math.PI * .25;

                                    function Ae(et, _t, ce, de) {
                                        var we = Math.tan(_t ? _t.upDegrees * $ : re),
                                            Ee = Math.tan(_t ? _t.downDegrees * $ : re),
                                            Me = Math.tan(_t ? _t.leftDegrees * $ : re),
                                            st = Math.tan(_t ? _t.rightDegrees * $ : re), ut = 2 / (Me + st),
                                            Vt = 2 / (we + Ee);
                                        return et[0] = ut, et[1] = 0, et[2] = 0, et[3] = 0, et[4] = 0, et[5] = Vt, et[6] = 0, et[7] = 0, et[8] = -((Me - st) * ut * .5), et[9] = (we - Ee) * Vt * .5, et[10] = de / (ce - de), et[11] = -1, et[12] = 0, et[13] = 0, et[14] = de * ce / (ce - de), et[15] = 0, et
                                    }

                                    function xe(et, _t, ce) {
                                        var de = _t[0], we = _t[1], Ee = _t[2], Me = _t[3], st = de + de, ut = we + we,
                                            Vt = Ee + Ee, Ft = de * st, Jt = de * ut, sn = de * Vt, Pt = we * ut,
                                            gn = we * Vt, un = Ee * Vt, _n = Me * st, yn = Me * ut, bi = Me * Vt;
                                        return et[0] = 1 - (Pt + un), et[1] = Jt + bi, et[2] = sn - yn, et[3] = 0, et[4] = Jt - bi, et[5] = 1 - (Ft + un), et[6] = gn + _n, et[7] = 0, et[8] = sn + yn, et[9] = gn - _n, et[10] = 1 - (Ft + Pt), et[11] = 0, et[12] = ce[0], et[13] = ce[1], et[14] = ce[2], et[15] = 1, et
                                    }

                                    function Oe(et, _t, ce) {
                                        var de = ce[0], we = ce[1], Ee = ce[2], Me, st, ut, Vt, Ft, Jt, sn, Pt, gn, un,
                                            _n, yn;
                                        return _t === et ? (et[12] = _t[0] * de + _t[4] * we + _t[8] * Ee + _t[12], et[13] = _t[1] * de + _t[5] * we + _t[9] * Ee + _t[13], et[14] = _t[2] * de + _t[6] * we + _t[10] * Ee + _t[14], et[15] = _t[3] * de + _t[7] * we + _t[11] * Ee + _t[15]) : (Me = _t[0], st = _t[1], ut = _t[2], Vt = _t[3], Ft = _t[4], Jt = _t[5], sn = _t[6], Pt = _t[7], gn = _t[8], un = _t[9], _n = _t[10], yn = _t[11], et[0] = Me, et[1] = st, et[2] = ut, et[3] = Vt, et[4] = Ft, et[5] = Jt, et[6] = sn, et[7] = Pt, et[8] = gn, et[9] = un, et[10] = _n, et[11] = yn, et[12] = Me * de + Ft * we + gn * Ee + _t[12], et[13] = st * de + Jt * we + un * Ee + _t[13], et[14] = ut * de + sn * we + _n * Ee + _t[14], et[15] = Vt * de + Pt * we + yn * Ee + _t[15]), et
                                    }

                                    function Ze(et, _t) {
                                        var ce = _t[0], de = _t[1], we = _t[2], Ee = _t[3], Me = _t[4], st = _t[5],
                                            ut = _t[6], Vt = _t[7], Ft = _t[8], Jt = _t[9], sn = _t[10], Pt = _t[11],
                                            gn = _t[12], un = _t[13], _n = _t[14], yn = _t[15], bi = ce * st - de * Me,
                                            Ii = ce * ut - we * Me, _i = ce * Vt - Ee * Me, gi = de * ut - we * st,
                                            Yr = de * Vt - Ee * st, Mr = we * Vt - Ee * ut, _s = Ft * un - Jt * gn,
                                            ha = Ft * _n - sn * gn, jo = Ft * yn - Pt * gn, zs = Jt * _n - sn * un,
                                            Wo = Jt * yn - Pt * un, Ms = sn * yn - Pt * _n,
                                            rr = bi * Ms - Ii * Wo + _i * zs + gi * jo - Yr * ha + Mr * _s;
                                        return rr ? (rr = 1 / rr, et[0] = (st * Ms - ut * Wo + Vt * zs) * rr, et[1] = (we * Wo - de * Ms - Ee * zs) * rr, et[2] = (un * Mr - _n * Yr + yn * gi) * rr, et[3] = (sn * Yr - Jt * Mr - Pt * gi) * rr, et[4] = (ut * jo - Me * Ms - Vt * ha) * rr, et[5] = (ce * Ms - we * jo + Ee * ha) * rr, et[6] = (_n * _i - gn * Mr - yn * Ii) * rr, et[7] = (Ft * Mr - sn * _i + Pt * Ii) * rr, et[8] = (Me * Wo - st * jo + Vt * _s) * rr, et[9] = (de * jo - ce * Wo - Ee * _s) * rr, et[10] = (gn * Yr - un * _i + yn * bi) * rr, et[11] = (Jt * _i - Ft * Yr - Pt * bi) * rr, et[12] = (st * ha - Me * zs - ut * _s) * rr, et[13] = (ce * zs - de * ha + we * _s) * rr, et[14] = (un * Ii - gn * gi - _n * bi) * rr, et[15] = (Ft * gi - Jt * Ii + sn * bi) * rr, et) : null
                                    }

                                    var at = new Float32Array([0, 0, 0, 1]), wt = new Float32Array([0, 0, 0]);

                                    function kt(et, _t, ce, de, we, Ee) {
                                        Ae(et, de || null, Ee.depthNear, Ee.depthFar);
                                        var Me = ce.orientation || at, st = ce.position || wt;
                                        xe(_t, Me, st), we && Oe(_t, _t, we), Ze(_t, _t)
                                    }

                                    return function (et, _t, ce) {
                                        return !et || !_t ? !1 : (et.pose = _t, et.timestamp = _t.timestamp, kt(et.leftProjectionMatrix, et.leftViewMatrix, _t, ce._getFieldOfView("left"), ce._getEyeOffset("left"), ce), kt(et.rightProjectionMatrix, et.rightViewMatrix, _t, ce._getFieldOfView("right"), ce._getEyeOffset("right"), ce), !0)
                                    }
                                }(), nr = function () {
                                    var re = window.self !== window.top, Ae = Oi(document.referrer),
                                        xe = Oi(window.location.href);
                                    return re && Ae !== xe
                                }, Oi = function (re) {
                                    var Ae, xe = re.indexOf("://");
                                    xe !== -1 ? Ae = xe + 3 : Ae = 0;
                                    var Oe = re.indexOf("/", Ae);
                                    return Oe === -1 && (Oe = re.length), re.substring(0, Oe)
                                }, Rr = function (re) {
                                    if (re.w > 1) return console.warn("getQuaternionAngle: w > 1"), 0;
                                    var Ae = 2 * Math.acos(re.w);
                                    return Ae
                                }, Ji = function () {
                                    var $ = {};
                                    return function (re, Ae) {
                                        $[re] === void 0 && (console.warn("webvr-polyfill: " + Ae), $[re] = !0)
                                    }
                                }(), Pi = function (re, Ae) {
                                    var xe = Ae ? "Please use " + Ae + " instead." : "";
                                    Ji(re, re + " has been deprecated. This may not work on native WebVR displays. " + xe)
                                };

                                function Br($, re, Ae) {
                                    if (!re) {
                                        Ae($);
                                        return
                                    }
                                    for (var xe = [], Oe = null, Ze = 0; Ze < re.length; ++Ze) {
                                        var at = re[Ze];
                                        switch (at) {
                                            case $.TEXTURE_BINDING_2D:
                                            case $.TEXTURE_BINDING_CUBE_MAP:
                                                var wt = re[++Ze];
                                                if (wt < $.TEXTURE0 || wt > $.TEXTURE31) {
                                                    console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit"), xe.push(null, null);
                                                    break
                                                }
                                                Oe || (Oe = $.getParameter($.ACTIVE_TEXTURE)), $.activeTexture(wt), xe.push($.getParameter(at), null);
                                                break;
                                            case $.ACTIVE_TEXTURE:
                                                Oe = $.getParameter($.ACTIVE_TEXTURE), xe.push(null);
                                                break;
                                            default:
                                                xe.push($.getParameter(at));
                                                break
                                        }
                                    }
                                    Ae($);
                                    for (var Ze = 0; Ze < re.length; ++Ze) {
                                        var at = re[Ze], kt = xe[Ze];
                                        switch (at) {
                                            case $.ACTIVE_TEXTURE:
                                                break;
                                            case $.ARRAY_BUFFER_BINDING:
                                                $.bindBuffer($.ARRAY_BUFFER, kt);
                                                break;
                                            case $.COLOR_CLEAR_VALUE:
                                                $.clearColor(kt[0], kt[1], kt[2], kt[3]);
                                                break;
                                            case $.COLOR_WRITEMASK:
                                                $.colorMask(kt[0], kt[1], kt[2], kt[3]);
                                                break;
                                            case $.CURRENT_PROGRAM:
                                                $.useProgram(kt);
                                                break;
                                            case $.ELEMENT_ARRAY_BUFFER_BINDING:
                                                $.bindBuffer($.ELEMENT_ARRAY_BUFFER, kt);
                                                break;
                                            case $.FRAMEBUFFER_BINDING:
                                                $.bindFramebuffer($.FRAMEBUFFER, kt);
                                                break;
                                            case $.RENDERBUFFER_BINDING:
                                                $.bindRenderbuffer($.RENDERBUFFER, kt);
                                                break;
                                            case $.TEXTURE_BINDING_2D:
                                                var wt = re[++Ze];
                                                if (wt < $.TEXTURE0 || wt > $.TEXTURE31) break;
                                                $.activeTexture(wt), $.bindTexture($.TEXTURE_2D, kt);
                                                break;
                                            case $.TEXTURE_BINDING_CUBE_MAP:
                                                var wt = re[++Ze];
                                                if (wt < $.TEXTURE0 || wt > $.TEXTURE31) break;
                                                $.activeTexture(wt), $.bindTexture($.TEXTURE_CUBE_MAP, kt);
                                                break;
                                            case $.VIEWPORT:
                                                $.viewport(kt[0], kt[1], kt[2], kt[3]);
                                                break;
                                            case $.BLEND:
                                            case $.CULL_FACE:
                                            case $.DEPTH_TEST:
                                            case $.SCISSOR_TEST:
                                            case $.STENCIL_TEST:
                                                kt ? $.enable(at) : $.disable(at);
                                                break;
                                            default:
                                                console.log("No GL restore behavior for 0x" + at.toString(16));
                                                break
                                        }
                                        Oe && $.activeTexture(Oe)
                                    }
                                }

                                var cr = Br,
                                    ss = ["attribute vec2 position;", "attribute vec3 texCoord;", "varying vec2 vTexCoord;", "uniform vec4 viewportOffsetScale[2];", "void main() {", "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];", "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;", "  gl_Position = vec4( position, 1.0, 1.0 );", "}"].join(`
`),
                                    Nr = ["precision mediump float;", "uniform sampler2D diffuse;", "varying vec2 vTexCoord;", "void main() {", "  gl_FragColor = texture2D(diffuse, vTexCoord);", "}"].join(`
`);

                                function ir($, re, Ae, xe) {
                                    this.gl = $, this.cardboardUI = re, this.bufferScale = Ae, this.dirtySubmitFrameBindings = xe, this.ctxAttribs = $.getContextAttributes(), this.instanceExt = $.getExtension("ANGLE_instanced_arrays"), this.meshWidth = 20, this.meshHeight = 20, this.bufferWidth = $.drawingBufferWidth, this.bufferHeight = $.drawingBufferHeight, this.realBindFramebuffer = $.bindFramebuffer, this.realEnable = $.enable, this.realDisable = $.disable, this.realColorMask = $.colorMask, this.realClearColor = $.clearColor, this.realViewport = $.viewport, he() || (this.realCanvasWidth = Object.getOwnPropertyDescriptor($.canvas.__proto__, "width"), this.realCanvasHeight = Object.getOwnPropertyDescriptor($.canvas.__proto__, "height")), this.isPatched = !1, this.lastBoundFramebuffer = null, this.cullFace = !1, this.depthTest = !1, this.blend = !1, this.scissorTest = !1, this.stencilTest = !1, this.viewport = [0, 0, 0, 0], this.colorMask = [!0, !0, !0, !0], this.clearColor = [0, 0, 0, 0], this.attribs = {
                                        position: 0,
                                        texCoord: 1
                                    }, this.program = En($, ss, Nr, this.attribs), this.uniforms = Nn($, this.program), this.viewportOffsetScale = new Float32Array(8), this.setTextureBounds(), this.vertexBuffer = $.createBuffer(), this.indexBuffer = $.createBuffer(), this.indexCount = 0, this.renderTarget = $.createTexture(), this.framebuffer = $.createFramebuffer(), this.depthStencilBuffer = null, this.depthBuffer = null, this.stencilBuffer = null, this.ctxAttribs.depth && this.ctxAttribs.stencil ? this.depthStencilBuffer = $.createRenderbuffer() : this.ctxAttribs.depth ? this.depthBuffer = $.createRenderbuffer() : this.ctxAttribs.stencil && (this.stencilBuffer = $.createRenderbuffer()), this.patch(), this.onResize()
                                }

                                ir.prototype.destroy = function () {
                                    var $ = this.gl;
                                    this.unpatch(), $.deleteProgram(this.program), $.deleteBuffer(this.vertexBuffer), $.deleteBuffer(this.indexBuffer), $.deleteTexture(this.renderTarget), $.deleteFramebuffer(this.framebuffer), this.depthStencilBuffer && $.deleteRenderbuffer(this.depthStencilBuffer), this.depthBuffer && $.deleteRenderbuffer(this.depthBuffer), this.stencilBuffer && $.deleteRenderbuffer(this.stencilBuffer), this.cardboardUI && this.cardboardUI.destroy()
                                }, ir.prototype.onResize = function () {
                                    var $ = this.gl, re = this,
                                        Ae = [$.RENDERBUFFER_BINDING, $.TEXTURE_BINDING_2D, $.TEXTURE0];
                                    cr($, Ae, function (xe) {
                                        re.realBindFramebuffer.call(xe, xe.FRAMEBUFFER, null), re.scissorTest && re.realDisable.call(xe, xe.SCISSOR_TEST), re.realColorMask.call(xe, !0, !0, !0, !0), re.realViewport.call(xe, 0, 0, xe.drawingBufferWidth, xe.drawingBufferHeight), re.realClearColor.call(xe, 0, 0, 0, 1), xe.clear(xe.COLOR_BUFFER_BIT), re.realBindFramebuffer.call(xe, xe.FRAMEBUFFER, re.framebuffer), xe.bindTexture(xe.TEXTURE_2D, re.renderTarget), xe.texImage2D(xe.TEXTURE_2D, 0, re.ctxAttribs.alpha ? xe.RGBA : xe.RGB, re.bufferWidth, re.bufferHeight, 0, re.ctxAttribs.alpha ? xe.RGBA : xe.RGB, xe.UNSIGNED_BYTE, null), xe.texParameteri(xe.TEXTURE_2D, xe.TEXTURE_MAG_FILTER, xe.LINEAR), xe.texParameteri(xe.TEXTURE_2D, xe.TEXTURE_MIN_FILTER, xe.LINEAR), xe.texParameteri(xe.TEXTURE_2D, xe.TEXTURE_WRAP_S, xe.CLAMP_TO_EDGE), xe.texParameteri(xe.TEXTURE_2D, xe.TEXTURE_WRAP_T, xe.CLAMP_TO_EDGE), xe.framebufferTexture2D(xe.FRAMEBUFFER, xe.COLOR_ATTACHMENT0, xe.TEXTURE_2D, re.renderTarget, 0), re.ctxAttribs.depth && re.ctxAttribs.stencil ? (xe.bindRenderbuffer(xe.RENDERBUFFER, re.depthStencilBuffer), xe.renderbufferStorage(xe.RENDERBUFFER, xe.DEPTH_STENCIL, re.bufferWidth, re.bufferHeight), xe.framebufferRenderbuffer(xe.FRAMEBUFFER, xe.DEPTH_STENCIL_ATTACHMENT, xe.RENDERBUFFER, re.depthStencilBuffer)) : re.ctxAttribs.depth ? (xe.bindRenderbuffer(xe.RENDERBUFFER, re.depthBuffer), xe.renderbufferStorage(xe.RENDERBUFFER, xe.DEPTH_COMPONENT16, re.bufferWidth, re.bufferHeight), xe.framebufferRenderbuffer(xe.FRAMEBUFFER, xe.DEPTH_ATTACHMENT, xe.RENDERBUFFER, re.depthBuffer)) : re.ctxAttribs.stencil && (xe.bindRenderbuffer(xe.RENDERBUFFER, re.stencilBuffer), xe.renderbufferStorage(xe.RENDERBUFFER, xe.STENCIL_INDEX8, re.bufferWidth, re.bufferHeight), xe.framebufferRenderbuffer(xe.FRAMEBUFFER, xe.STENCIL_ATTACHMENT, xe.RENDERBUFFER, re.stencilBuffer)), !xe.checkFramebufferStatus(xe.FRAMEBUFFER) === xe.FRAMEBUFFER_COMPLETE && console.error("Framebuffer incomplete!"), re.realBindFramebuffer.call(xe, xe.FRAMEBUFFER, re.lastBoundFramebuffer), re.scissorTest && re.realEnable.call(xe, xe.SCISSOR_TEST), re.realColorMask.apply(xe, re.colorMask), re.realViewport.apply(xe, re.viewport), re.realClearColor.apply(xe, re.clearColor)
                                    }), this.cardboardUI && this.cardboardUI.onResize()
                                }, ir.prototype.patch = function () {
                                    if (!this.isPatched) {
                                        var $ = this, re = this.gl.canvas, Ae = this.gl;
                                        he() || (re.width = ot() * this.bufferScale, re.height = gt() * this.bufferScale, Object.defineProperty(re, "width", {
                                            configurable: !0,
                                            enumerable: !0,
                                            get: function () {
                                                return $.bufferWidth
                                            },
                                            set: function (Oe) {
                                                $.bufferWidth = Oe, $.realCanvasWidth.set.call(re, Oe), $.onResize()
                                            }
                                        }), Object.defineProperty(re, "height", {
                                            configurable: !0,
                                            enumerable: !0,
                                            get: function () {
                                                return $.bufferHeight
                                            },
                                            set: function (Oe) {
                                                $.bufferHeight = Oe, $.realCanvasHeight.set.call(re, Oe), $.onResize()
                                            }
                                        })), this.lastBoundFramebuffer = Ae.getParameter(Ae.FRAMEBUFFER_BINDING), this.lastBoundFramebuffer == null && (this.lastBoundFramebuffer = this.framebuffer, this.gl.bindFramebuffer(Ae.FRAMEBUFFER, this.framebuffer)), this.gl.bindFramebuffer = function (xe, Oe) {
                                            $.lastBoundFramebuffer = Oe || $.framebuffer, $.realBindFramebuffer.call(Ae, xe, $.lastBoundFramebuffer)
                                        }, this.cullFace = Ae.getParameter(Ae.CULL_FACE), this.depthTest = Ae.getParameter(Ae.DEPTH_TEST), this.blend = Ae.getParameter(Ae.BLEND), this.scissorTest = Ae.getParameter(Ae.SCISSOR_TEST), this.stencilTest = Ae.getParameter(Ae.STENCIL_TEST), Ae.enable = function (xe) {
                                            switch (xe) {
                                                case Ae.CULL_FACE:
                                                    $.cullFace = !0;
                                                    break;
                                                case Ae.DEPTH_TEST:
                                                    $.depthTest = !0;
                                                    break;
                                                case Ae.BLEND:
                                                    $.blend = !0;
                                                    break;
                                                case Ae.SCISSOR_TEST:
                                                    $.scissorTest = !0;
                                                    break;
                                                case Ae.STENCIL_TEST:
                                                    $.stencilTest = !0;
                                                    break
                                            }
                                            $.realEnable.call(Ae, xe)
                                        }, Ae.disable = function (xe) {
                                            switch (xe) {
                                                case Ae.CULL_FACE:
                                                    $.cullFace = !1;
                                                    break;
                                                case Ae.DEPTH_TEST:
                                                    $.depthTest = !1;
                                                    break;
                                                case Ae.BLEND:
                                                    $.blend = !1;
                                                    break;
                                                case Ae.SCISSOR_TEST:
                                                    $.scissorTest = !1;
                                                    break;
                                                case Ae.STENCIL_TEST:
                                                    $.stencilTest = !1;
                                                    break
                                            }
                                            $.realDisable.call(Ae, xe)
                                        }, this.colorMask = Ae.getParameter(Ae.COLOR_WRITEMASK), Ae.colorMask = function (xe, Oe, Ze, at) {
                                            $.colorMask[0] = xe, $.colorMask[1] = Oe, $.colorMask[2] = Ze, $.colorMask[3] = at, $.realColorMask.call(Ae, xe, Oe, Ze, at)
                                        }, this.clearColor = Ae.getParameter(Ae.COLOR_CLEAR_VALUE), Ae.clearColor = function (xe, Oe, Ze, at) {
                                            $.clearColor[0] = xe, $.clearColor[1] = Oe, $.clearColor[2] = Ze, $.clearColor[3] = at, $.realClearColor.call(Ae, xe, Oe, Ze, at)
                                        }, this.viewport = Ae.getParameter(Ae.VIEWPORT), Ae.viewport = function (xe, Oe, Ze, at) {
                                            $.viewport[0] = xe, $.viewport[1] = Oe, $.viewport[2] = Ze, $.viewport[3] = at, $.realViewport.call(Ae, xe, Oe, Ze, at)
                                        }, this.isPatched = !0, Vn(re)
                                    }
                                }, ir.prototype.unpatch = function () {
                                    if (this.isPatched) {
                                        var $ = this.gl, re = this.gl.canvas;
                                        he() || (Object.defineProperty(re, "width", this.realCanvasWidth), Object.defineProperty(re, "height", this.realCanvasHeight)), re.width = this.bufferWidth, re.height = this.bufferHeight, $.bindFramebuffer = this.realBindFramebuffer, $.enable = this.realEnable, $.disable = this.realDisable, $.colorMask = this.realColorMask, $.clearColor = this.realClearColor, $.viewport = this.realViewport, this.lastBoundFramebuffer == this.framebuffer && $.bindFramebuffer($.FRAMEBUFFER, null), this.isPatched = !1, setTimeout(function () {
                                            Vn(re)
                                        }, 1)
                                    }
                                }, ir.prototype.setTextureBounds = function ($, re) {
                                    $ || ($ = [0, 0, .5, 1]), re || (re = [.5, 0, .5, 1]), this.viewportOffsetScale[0] = $[0], this.viewportOffsetScale[1] = $[1], this.viewportOffsetScale[2] = $[2], this.viewportOffsetScale[3] = $[3], this.viewportOffsetScale[4] = re[0], this.viewportOffsetScale[5] = re[1], this.viewportOffsetScale[6] = re[2], this.viewportOffsetScale[7] = re[3]
                                }, ir.prototype.submitFrame = function () {
                                    var $ = this.gl, re = this, Ae = [];
                                    if (this.dirtySubmitFrameBindings || Ae.push($.CURRENT_PROGRAM, $.ARRAY_BUFFER_BINDING, $.ELEMENT_ARRAY_BUFFER_BINDING, $.TEXTURE_BINDING_2D, $.TEXTURE0), cr($, Ae, function (Oe) {
                                        re.realBindFramebuffer.call(Oe, Oe.FRAMEBUFFER, null);
                                        var Ze = 0, at = 0;
                                        re.instanceExt && (Ze = Oe.getVertexAttrib(re.attribs.position, re.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE), at = Oe.getVertexAttrib(re.attribs.texCoord, re.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)), re.cullFace && re.realDisable.call(Oe, Oe.CULL_FACE), re.depthTest && re.realDisable.call(Oe, Oe.DEPTH_TEST), re.blend && re.realDisable.call(Oe, Oe.BLEND), re.scissorTest && re.realDisable.call(Oe, Oe.SCISSOR_TEST), re.stencilTest && re.realDisable.call(Oe, Oe.STENCIL_TEST), re.realColorMask.call(Oe, !0, !0, !0, !0), re.realViewport.call(Oe, 0, 0, Oe.drawingBufferWidth, Oe.drawingBufferHeight), (re.ctxAttribs.alpha || he()) && (re.realClearColor.call(Oe, 0, 0, 0, 1), Oe.clear(Oe.COLOR_BUFFER_BIT)), Oe.useProgram(re.program), Oe.bindBuffer(Oe.ELEMENT_ARRAY_BUFFER, re.indexBuffer), Oe.bindBuffer(Oe.ARRAY_BUFFER, re.vertexBuffer), Oe.enableVertexAttribArray(re.attribs.position), Oe.enableVertexAttribArray(re.attribs.texCoord), Oe.vertexAttribPointer(re.attribs.position, 2, Oe.FLOAT, !1, 20, 0), Oe.vertexAttribPointer(re.attribs.texCoord, 3, Oe.FLOAT, !1, 20, 8), re.instanceExt && (Ze != 0 && re.instanceExt.vertexAttribDivisorANGLE(re.attribs.position, 0), at != 0 && re.instanceExt.vertexAttribDivisorANGLE(re.attribs.texCoord, 0)), Oe.activeTexture(Oe.TEXTURE0), Oe.uniform1i(re.uniforms.diffuse, 0), Oe.bindTexture(Oe.TEXTURE_2D, re.renderTarget), Oe.uniform4fv(re.uniforms.viewportOffsetScale, re.viewportOffsetScale), Oe.drawElements(Oe.TRIANGLES, re.indexCount, Oe.UNSIGNED_SHORT, 0), re.cardboardUI && re.cardboardUI.renderNoState(), re.realBindFramebuffer.call(re.gl, Oe.FRAMEBUFFER, re.framebuffer), re.ctxAttribs.preserveDrawingBuffer || (re.realClearColor.call(Oe, 0, 0, 0, 0), Oe.clear(Oe.COLOR_BUFFER_BIT)), re.dirtySubmitFrameBindings || re.realBindFramebuffer.call(Oe, Oe.FRAMEBUFFER, re.lastBoundFramebuffer), re.cullFace && re.realEnable.call(Oe, Oe.CULL_FACE), re.depthTest && re.realEnable.call(Oe, Oe.DEPTH_TEST), re.blend && re.realEnable.call(Oe, Oe.BLEND), re.scissorTest && re.realEnable.call(Oe, Oe.SCISSOR_TEST), re.stencilTest && re.realEnable.call(Oe, Oe.STENCIL_TEST), re.realColorMask.apply(Oe, re.colorMask), re.realViewport.apply(Oe, re.viewport), (re.ctxAttribs.alpha || !re.ctxAttribs.preserveDrawingBuffer) && re.realClearColor.apply(Oe, re.clearColor), re.instanceExt && (Ze != 0 && re.instanceExt.vertexAttribDivisorANGLE(re.attribs.position, Ze), at != 0 && re.instanceExt.vertexAttribDivisorANGLE(re.attribs.texCoord, at))
                                    }), he()) {
                                        var xe = $.canvas;
                                        (xe.width != re.bufferWidth || xe.height != re.bufferHeight) && (re.bufferWidth = xe.width, re.bufferHeight = xe.height, re.onResize())
                                    }
                                }, ir.prototype.updateDeviceInfo = function ($) {
                                    var re = this.gl, Ae = this,
                                        xe = [re.ARRAY_BUFFER_BINDING, re.ELEMENT_ARRAY_BUFFER_BINDING];
                                    cr(re, xe, function (Oe) {
                                        var Ze = Ae.computeMeshVertices_(Ae.meshWidth, Ae.meshHeight, $);
                                        if (Oe.bindBuffer(Oe.ARRAY_BUFFER, Ae.vertexBuffer), Oe.bufferData(Oe.ARRAY_BUFFER, Ze, Oe.STATIC_DRAW), !Ae.indexCount) {
                                            var at = Ae.computeMeshIndices_(Ae.meshWidth, Ae.meshHeight);
                                            Oe.bindBuffer(Oe.ELEMENT_ARRAY_BUFFER, Ae.indexBuffer), Oe.bufferData(Oe.ELEMENT_ARRAY_BUFFER, at, Oe.STATIC_DRAW), Ae.indexCount = at.length
                                        }
                                    })
                                }, ir.prototype.computeMeshVertices_ = function ($, re, Ae) {
                                    for (var xe = new Float32Array(2 * $ * re * 5), Oe = Ae.getLeftEyeVisibleTanAngles(), Ze = Ae.getLeftEyeNoLensTanAngles(), at = Ae.getLeftEyeVisibleScreenRect(Ze), wt = 0, kt = 0; kt < 2; kt++) {
                                        for (var et = 0; et < re; et++) for (var _t = 0; _t < $; _t++, wt++) {
                                            var ce = _t / ($ - 1), de = et / (re - 1), we = ce, Ee = de,
                                                Me = ue(Oe[0], Oe[2], ce), st = ue(Oe[3], Oe[1], de),
                                                ut = Math.sqrt(Me * Me + st * st),
                                                Vt = Ae.distortion.distortInverse(ut), Ft = Me * Vt / ut,
                                                Jt = st * Vt / ut;
                                            ce = (Ft - Ze[0]) / (Ze[2] - Ze[0]), de = (Jt - Ze[3]) / (Ze[1] - Ze[3]), ce = (at.x + ce * at.width - .5) * 2, de = (at.y + de * at.height - .5) * 2, xe[wt * 5 + 0] = ce, xe[wt * 5 + 1] = de, xe[wt * 5 + 2] = we, xe[wt * 5 + 3] = Ee, xe[wt * 5 + 4] = kt
                                        }
                                        var sn = Oe[2] - Oe[0];
                                        Oe[0] = -(sn + Oe[0]), Oe[2] = sn - Oe[2], sn = Ze[2] - Ze[0], Ze[0] = -(sn + Ze[0]), Ze[2] = sn - Ze[2], at.x = 1 - (at.x + at.width)
                                    }
                                    return xe
                                }, ir.prototype.computeMeshIndices_ = function ($, re) {
                                    for (var Ae = new Uint16Array(2 * ($ - 1) * (re - 1) * 6), xe = $ / 2, Oe = re / 2, Ze = 0, at = 0, wt = 0; wt < 2; wt++) for (var kt = 0; kt < re; kt++) for (var et = 0; et < $; et++, Ze++) et == 0 || kt == 0 || (et <= xe == kt <= Oe ? (Ae[at++] = Ze, Ae[at++] = Ze - $ - 1, Ae[at++] = Ze - $, Ae[at++] = Ze - $ - 1, Ae[at++] = Ze, Ae[at++] = Ze - 1) : (Ae[at++] = Ze - 1, Ae[at++] = Ze - $, Ae[at++] = Ze, Ae[at++] = Ze - $, Ae[at++] = Ze - 1, Ae[at++] = Ze - $ - 1));
                                    return Ae
                                }, ir.prototype.getOwnPropertyDescriptor_ = function ($, re) {
                                    var Ae = Object.getOwnPropertyDescriptor($, re);
                                    return (Ae.get === void 0 || Ae.set === void 0) && (Ae.configurable = !0, Ae.enumerable = !0, Ae.get = function () {
                                        return this.getAttribute(re)
                                    }, Ae.set = function (xe) {
                                        this.setAttribute(re, xe)
                                    }), Ae
                                };
                                var jt = ["attribute vec2 position;", "uniform mat4 projectionMat;", "void main() {", "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );", "}"].join(`
`), Se = ["precision mediump float;", "uniform vec4 color;", "void main() {", "  gl_FragColor = color;", "}"].join(`
`), _e = Math.PI / 180, Ge = 60, Le = 12, Ue = 20, Qe = 1, oe = .75, G = .3125, X = 4, ve = 28, Be = 1.5;

                                function je($) {
                                    this.gl = $, this.attribs = {position: 0}, this.program = En($, jt, Se, this.attribs), this.uniforms = Nn($, this.program), this.vertexBuffer = $.createBuffer(), this.gearOffset = 0, this.gearVertexCount = 0, this.arrowOffset = 0, this.arrowVertexCount = 0, this.projMat = new Float32Array(16), this.listener = null, this.onResize()
                                }

                                je.prototype.destroy = function () {
                                    var $ = this.gl;
                                    this.listener && $.canvas.removeEventListener("click", this.listener, !1), $.deleteProgram(this.program), $.deleteBuffer(this.vertexBuffer)
                                }, je.prototype.listen = function ($, re) {
                                    var Ae = this.gl.canvas;
                                    this.listener = function (xe) {
                                        var Oe = Ae.clientWidth / 2, Ze = ve * Be;
                                        xe.clientX > Oe - Ze && xe.clientX < Oe + Ze && xe.clientY > Ae.clientHeight - Ze ? $(xe) : xe.clientX < Ze && xe.clientY < Ze && re(xe)
                                    }, Ae.addEventListener("click", this.listener, !1)
                                }, je.prototype.onResize = function () {
                                    var $ = this.gl, re = this, Ae = [$.ARRAY_BUFFER_BINDING];
                                    cr($, Ae, function (xe) {
                                        var Oe = [], Ze = xe.drawingBufferWidth / 2,
                                            at = Math.max(screen.width, screen.height) * window.devicePixelRatio,
                                            wt = xe.drawingBufferWidth / at, kt = wt * window.devicePixelRatio,
                                            et = X * kt / 2, _t = ve * Be * kt, ce = ve * kt / 2,
                                            de = (ve * Be - ve) * kt;
                                        Oe.push(Ze - et, _t), Oe.push(Ze - et, xe.drawingBufferHeight), Oe.push(Ze + et, _t), Oe.push(Ze + et, xe.drawingBufferHeight), re.gearOffset = Oe.length / 2;

                                        function we(Vt, Ft) {
                                            var Jt = (90 - Vt) * _e, sn = Math.cos(Jt), Pt = Math.sin(Jt);
                                            Oe.push(G * sn * ce + Ze, G * Pt * ce + ce), Oe.push(Ft * sn * ce + Ze, Ft * Pt * ce + ce)
                                        }

                                        for (var Ee = 0; Ee <= 6; Ee++) {
                                            var Me = Ee * Ge;
                                            we(Me, Qe), we(Me + Le, Qe), we(Me + Ue, oe), we(Me + (Ge - Ue), oe), we(Me + (Ge - Le), Qe)
                                        }
                                        re.gearVertexCount = Oe.length / 2 - re.gearOffset, re.arrowOffset = Oe.length / 2;

                                        function st(Vt, Ft) {
                                            Oe.push(de + Vt, xe.drawingBufferHeight - de - Ft)
                                        }

                                        var ut = et / Math.sin(45 * _e);
                                        st(0, ce), st(ce, 0), st(ce + ut, ut), st(ut, ce + ut), st(ut, ce - ut), st(0, ce), st(ce, ce * 2), st(ce + ut, ce * 2 - ut), st(ut, ce - ut), st(0, ce), st(ut, ce - et), st(ve * kt, ce - et), st(ut, ce + et), st(ve * kt, ce + et), re.arrowVertexCount = Oe.length / 2 - re.arrowOffset, xe.bindBuffer(xe.ARRAY_BUFFER, re.vertexBuffer), xe.bufferData(xe.ARRAY_BUFFER, new Float32Array(Oe), xe.STATIC_DRAW)
                                    })
                                }, je.prototype.render = function () {
                                    var $ = this.gl, re = this,
                                        Ae = [$.CULL_FACE, $.DEPTH_TEST, $.BLEND, $.SCISSOR_TEST, $.STENCIL_TEST, $.COLOR_WRITEMASK, $.VIEWPORT, $.CURRENT_PROGRAM, $.ARRAY_BUFFER_BINDING];
                                    cr($, Ae, function (xe) {
                                        xe.disable(xe.CULL_FACE), xe.disable(xe.DEPTH_TEST), xe.disable(xe.BLEND), xe.disable(xe.SCISSOR_TEST), xe.disable(xe.STENCIL_TEST), xe.colorMask(!0, !0, !0, !0), xe.viewport(0, 0, xe.drawingBufferWidth, xe.drawingBufferHeight), re.renderNoState()
                                    })
                                }, je.prototype.renderNoState = function () {
                                    var $ = this.gl;
                                    $.useProgram(this.program), $.bindBuffer($.ARRAY_BUFFER, this.vertexBuffer), $.enableVertexAttribArray(this.attribs.position), $.vertexAttribPointer(this.attribs.position, 2, $.FLOAT, !1, 8, 0), $.uniform4f(this.uniforms.color, 1, 1, 1, 1), oi(this.projMat, 0, $.drawingBufferWidth, 0, $.drawingBufferHeight, .1, 1024), $.uniformMatrix4fv(this.uniforms.projectionMat, !1, this.projMat), $.drawArrays($.TRIANGLE_STRIP, 0, 4), $.drawArrays($.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount), $.drawArrays($.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount)
                                };

                                function tt($) {
                                    this.coefficients = $
                                }

                                tt.prototype.distortInverse = function ($) {
                                    for (var re = 0, Ae = 1, xe = $ - this.distort(re); Math.abs(Ae - re) > 1e-4;) {
                                        var Oe = $ - this.distort(Ae), Ze = Ae - Oe * ((Ae - re) / (Oe - xe));
                                        re = Ae, Ae = Ze, xe = Oe
                                    }
                                    return Ae
                                }, tt.prototype.distort = function ($) {
                                    for (var re = $ * $, Ae = 0, xe = 0; xe < this.coefficients.length; xe++) Ae = re * (Ae + this.coefficients[xe]);
                                    return (Ae + 1) * $
                                };
                                var Yt = Math.PI / 180, cn = 180 / Math.PI, $t = function (re, Ae, xe) {
                                    this.x = re || 0, this.y = Ae || 0, this.z = xe || 0
                                };
                                $t.prototype = {
                                    constructor: $t, set: function (re, Ae, xe) {
                                        return this.x = re, this.y = Ae, this.z = xe, this
                                    }, copy: function (re) {
                                        return this.x = re.x, this.y = re.y, this.z = re.z, this
                                    }, length: function () {
                                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                                    }, normalize: function () {
                                        var re = this.length();
                                        if (re !== 0) {
                                            var Ae = 1 / re;
                                            this.multiplyScalar(Ae)
                                        } else this.x = 0, this.y = 0, this.z = 0;
                                        return this
                                    }, multiplyScalar: function (re) {
                                        this.x *= re, this.y *= re, this.z *= re
                                    }, applyQuaternion: function (re) {
                                        var Ae = this.x, xe = this.y, Oe = this.z, Ze = re.x, at = re.y, wt = re.z,
                                            kt = re.w, et = kt * Ae + at * Oe - wt * xe,
                                            _t = kt * xe + wt * Ae - Ze * Oe, ce = kt * Oe + Ze * xe - at * Ae,
                                            de = -Ze * Ae - at * xe - wt * Oe;
                                        return this.x = et * kt + de * -Ze + _t * -wt - ce * -at, this.y = _t * kt + de * -at + ce * -Ze - et * -wt, this.z = ce * kt + de * -wt + et * -at - _t * -Ze, this
                                    }, dot: function (re) {
                                        return this.x * re.x + this.y * re.y + this.z * re.z
                                    }, crossVectors: function (re, Ae) {
                                        var xe = re.x, Oe = re.y, Ze = re.z, at = Ae.x, wt = Ae.y, kt = Ae.z;
                                        return this.x = Oe * kt - Ze * wt, this.y = Ze * at - xe * kt, this.z = xe * wt - Oe * at, this
                                    }
                                };
                                var en = function (re, Ae, xe, Oe) {
                                    this.x = re || 0, this.y = Ae || 0, this.z = xe || 0, this.w = Oe !== void 0 ? Oe : 1
                                };
                                en.prototype = {
                                    constructor: en, set: function (re, Ae, xe, Oe) {
                                        return this.x = re, this.y = Ae, this.z = xe, this.w = Oe, this
                                    }, copy: function (re) {
                                        return this.x = re.x, this.y = re.y, this.z = re.z, this.w = re.w, this
                                    }, setFromEulerXYZ: function (re, Ae, xe) {
                                        var Oe = Math.cos(re / 2), Ze = Math.cos(Ae / 2), at = Math.cos(xe / 2),
                                            wt = Math.sin(re / 2), kt = Math.sin(Ae / 2), et = Math.sin(xe / 2);
                                        return this.x = wt * Ze * at + Oe * kt * et, this.y = Oe * kt * at - wt * Ze * et, this.z = Oe * Ze * et + wt * kt * at, this.w = Oe * Ze * at - wt * kt * et, this
                                    }, setFromEulerYXZ: function (re, Ae, xe) {
                                        var Oe = Math.cos(re / 2), Ze = Math.cos(Ae / 2), at = Math.cos(xe / 2),
                                            wt = Math.sin(re / 2), kt = Math.sin(Ae / 2), et = Math.sin(xe / 2);
                                        return this.x = wt * Ze * at + Oe * kt * et, this.y = Oe * kt * at - wt * Ze * et, this.z = Oe * Ze * et - wt * kt * at, this.w = Oe * Ze * at + wt * kt * et, this
                                    }, setFromAxisAngle: function (re, Ae) {
                                        var xe = Ae / 2, Oe = Math.sin(xe);
                                        return this.x = re.x * Oe, this.y = re.y * Oe, this.z = re.z * Oe, this.w = Math.cos(xe), this
                                    }, multiply: function (re) {
                                        return this.multiplyQuaternions(this, re)
                                    }, multiplyQuaternions: function (re, Ae) {
                                        var xe = re.x, Oe = re.y, Ze = re.z, at = re.w, wt = Ae.x, kt = Ae.y, et = Ae.z,
                                            _t = Ae.w;
                                        return this.x = xe * _t + at * wt + Oe * et - Ze * kt, this.y = Oe * _t + at * kt + Ze * wt - xe * et, this.z = Ze * _t + at * et + xe * kt - Oe * wt, this.w = at * _t - xe * wt - Oe * kt - Ze * et, this
                                    }, inverse: function () {
                                        return this.x *= -1, this.y *= -1, this.z *= -1, this.normalize(), this
                                    }, normalize: function () {
                                        var re = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                                        return re === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (re = 1 / re, this.x = this.x * re, this.y = this.y * re, this.z = this.z * re, this.w = this.w * re), this
                                    }, slerp: function (re, Ae) {
                                        if (Ae === 0) return this;
                                        if (Ae === 1) return this.copy(re);
                                        var xe = this.x, Oe = this.y, Ze = this.z, at = this.w,
                                            wt = at * re.w + xe * re.x + Oe * re.y + Ze * re.z;
                                        if (wt < 0 ? (this.w = -re.w, this.x = -re.x, this.y = -re.y, this.z = -re.z, wt = -wt) : this.copy(re), wt >= 1) return this.w = at, this.x = xe, this.y = Oe, this.z = Ze, this;
                                        var kt = Math.acos(wt), et = Math.sqrt(1 - wt * wt);
                                        if (Math.abs(et) < .001) return this.w = .5 * (at + this.w), this.x = .5 * (xe + this.x), this.y = .5 * (Oe + this.y), this.z = .5 * (Ze + this.z), this;
                                        var _t = Math.sin((1 - Ae) * kt) / et, ce = Math.sin(Ae * kt) / et;
                                        return this.w = at * _t + this.w * ce, this.x = xe * _t + this.x * ce, this.y = Oe * _t + this.y * ce, this.z = Ze * _t + this.z * ce, this
                                    }, setFromUnitVectors: function () {
                                        var $, re, Ae = 1e-6;
                                        return function (xe, Oe) {
                                            return $ === void 0 && ($ = new $t), re = xe.dot(Oe) + 1, re < Ae ? (re = 0, Math.abs(xe.x) > Math.abs(xe.z) ? $.set(-xe.y, xe.x, 0) : $.set(0, -xe.z, xe.y)) : $.crossVectors(xe, Oe), this.x = $.x, this.y = $.y, this.z = $.z, this.w = re, this.normalize(), this
                                        }
                                    }()
                                };

                                function Sn($) {
                                    this.width = $.width || ot(), this.height = $.height || gt(), this.widthMeters = $.widthMeters, this.heightMeters = $.heightMeters, this.bevelMeters = $.bevelMeters
                                }

                                var Gi = new Sn({widthMeters: .11, heightMeters: .062, bevelMeters: .004}),
                                    qn = new Sn({widthMeters: .1038, heightMeters: .0584, bevelMeters: .004}), fr = {
                                        CardboardV1: new Zi({
                                            id: "CardboardV1",
                                            label: "Cardboard I/O 2014",
                                            fov: 40,
                                            interLensDistance: .06,
                                            baselineLensDistance: .035,
                                            screenLensDistance: .042,
                                            distortionCoefficients: [.441, .156],
                                            inverseCoefficients: [-.4410035, .42756155, -.4804439, .5460139, -.58821183, .5733938, -.48303202, .33299083, -.17573841, .0651772, -.01488963, .001559834]
                                        }),
                                        CardboardV2: new Zi({
                                            id: "CardboardV2",
                                            label: "Cardboard I/O 2015",
                                            fov: 60,
                                            interLensDistance: .064,
                                            baselineLensDistance: .035,
                                            screenLensDistance: .039,
                                            distortionCoefficients: [.34, .55],
                                            inverseCoefficients: [-.33836704, -.18162185, .862655, -1.2462051, 1.0560602, -.58208317, .21609078, -.05444823, .009177956, -.0009904169, 6183535e-11, -16981803e-13]
                                        })
                                    };

                                function Vi($, re) {
                                    this.viewer = fr.CardboardV2, this.updateDeviceParams($), this.distortion = new tt(this.viewer.distortionCoefficients);
                                    for (var Ae = 0; Ae < re.length; Ae++) {
                                        var xe = re[Ae];
                                        fr[xe.id] = new Zi(xe)
                                    }
                                }

                                Vi.prototype.updateDeviceParams = function ($) {
                                    this.device = this.determineDevice_($) || this.device
                                }, Vi.prototype.getDevice = function () {
                                    return this.device
                                }, Vi.prototype.setViewer = function ($) {
                                    this.viewer = $, this.distortion = new tt(this.viewer.distortionCoefficients)
                                }, Vi.prototype.determineDevice_ = function ($) {
                                    if (!$) return he() ? (console.warn("Using fallback iOS device measurements."), qn) : (console.warn("Using fallback Android device measurements."), Gi);
                                    var re = .0254, Ae = re / $.xdpi, xe = re / $.ydpi, Oe = ot(), Ze = gt();
                                    return new Sn({
                                        widthMeters: Ae * Oe,
                                        heightMeters: xe * Ze,
                                        bevelMeters: $.bevelMm * .001
                                    })
                                }, Vi.prototype.getDistortedFieldOfViewLeftEye = function () {
                                    var $ = this.viewer, re = this.device, Ae = this.distortion,
                                        xe = $.screenLensDistance, Oe = (re.widthMeters - $.interLensDistance) / 2,
                                        Ze = $.interLensDistance / 2, at = $.baselineLensDistance - re.bevelMeters,
                                        wt = re.heightMeters - at, kt = cn * Math.atan(Ae.distort(Oe / xe)),
                                        et = cn * Math.atan(Ae.distort(Ze / xe)),
                                        _t = cn * Math.atan(Ae.distort(at / xe)),
                                        ce = cn * Math.atan(Ae.distort(wt / xe));
                                    return {
                                        leftDegrees: Math.min(kt, $.fov),
                                        rightDegrees: Math.min(et, $.fov),
                                        downDegrees: Math.min(_t, $.fov),
                                        upDegrees: Math.min(ce, $.fov)
                                    }
                                }, Vi.prototype.getLeftEyeVisibleTanAngles = function () {
                                    var $ = this.viewer, re = this.device, Ae = this.distortion,
                                        xe = Math.tan(-Yt * $.fov), Oe = Math.tan(Yt * $.fov),
                                        Ze = Math.tan(Yt * $.fov), at = Math.tan(-Yt * $.fov), wt = re.widthMeters / 4,
                                        kt = re.heightMeters / 2, et = $.baselineLensDistance - re.bevelMeters - kt,
                                        _t = $.interLensDistance / 2 - wt, ce = -et, de = $.screenLensDistance,
                                        we = Ae.distort((_t - wt) / de), Ee = Ae.distort((ce + kt) / de),
                                        Me = Ae.distort((_t + wt) / de), st = Ae.distort((ce - kt) / de),
                                        ut = new Float32Array(4);
                                    return ut[0] = Math.max(xe, we), ut[1] = Math.min(Oe, Ee), ut[2] = Math.min(Ze, Me), ut[3] = Math.max(at, st), ut
                                }, Vi.prototype.getLeftEyeNoLensTanAngles = function () {
                                    var $ = this.viewer, re = this.device, Ae = this.distortion,
                                        xe = new Float32Array(4), Oe = Ae.distortInverse(Math.tan(-Yt * $.fov)),
                                        Ze = Ae.distortInverse(Math.tan(Yt * $.fov)),
                                        at = Ae.distortInverse(Math.tan(Yt * $.fov)),
                                        wt = Ae.distortInverse(Math.tan(-Yt * $.fov)), kt = re.widthMeters / 4,
                                        et = re.heightMeters / 2, _t = $.baselineLensDistance - re.bevelMeters - et,
                                        ce = $.interLensDistance / 2 - kt, de = -_t, we = $.screenLensDistance,
                                        Ee = (ce - kt) / we, Me = (de + et) / we, st = (ce + kt) / we,
                                        ut = (de - et) / we;
                                    return xe[0] = Math.max(Oe, Ee), xe[1] = Math.min(Ze, Me), xe[2] = Math.min(at, st), xe[3] = Math.max(wt, ut), xe
                                }, Vi.prototype.getLeftEyeVisibleScreenRect = function ($) {
                                    var re = this.viewer, Ae = this.device, xe = re.screenLensDistance,
                                        Oe = (Ae.widthMeters - re.interLensDistance) / 2,
                                        Ze = re.baselineLensDistance - Ae.bevelMeters,
                                        at = ($[0] * xe + Oe) / Ae.widthMeters, wt = ($[1] * xe + Ze) / Ae.heightMeters,
                                        kt = ($[2] * xe + Oe) / Ae.widthMeters, et = ($[3] * xe + Ze) / Ae.heightMeters;
                                    return {x: at, y: et, width: kt - at, height: wt - et}
                                }, Vi.prototype.getFieldOfViewLeftEye = function ($) {
                                    return $ ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye()
                                }, Vi.prototype.getFieldOfViewRightEye = function ($) {
                                    var re = this.getFieldOfViewLeftEye($);
                                    return {
                                        leftDegrees: re.rightDegrees,
                                        rightDegrees: re.leftDegrees,
                                        upDegrees: re.upDegrees,
                                        downDegrees: re.downDegrees
                                    }
                                }, Vi.prototype.getUndistortedFieldOfViewLeftEye = function () {
                                    var $ = this.getUndistortedParams_();
                                    return {
                                        leftDegrees: cn * Math.atan($.outerDist),
                                        rightDegrees: cn * Math.atan($.innerDist),
                                        downDegrees: cn * Math.atan($.bottomDist),
                                        upDegrees: cn * Math.atan($.topDist)
                                    }
                                }, Vi.prototype.getUndistortedViewportLeftEye = function () {
                                    var $ = this.getUndistortedParams_(), re = this.viewer, Ae = this.device,
                                        xe = re.screenLensDistance, Oe = Ae.widthMeters / xe, Ze = Ae.heightMeters / xe,
                                        at = Ae.width / Oe, wt = Ae.height / Ze,
                                        kt = Math.round(($.eyePosX - $.outerDist) * at),
                                        et = Math.round(($.eyePosY - $.bottomDist) * wt);
                                    return {
                                        x: kt,
                                        y: et,
                                        width: Math.round(($.eyePosX + $.innerDist) * at) - kt,
                                        height: Math.round(($.eyePosY + $.topDist) * wt) - et
                                    }
                                }, Vi.prototype.getUndistortedParams_ = function () {
                                    var $ = this.viewer, re = this.device, Ae = this.distortion,
                                        xe = $.screenLensDistance, Oe = $.interLensDistance / 2 / xe,
                                        Ze = re.widthMeters / xe, at = re.heightMeters / xe, wt = Ze / 2 - Oe,
                                        kt = ($.baselineLensDistance - re.bevelMeters) / xe, et = $.fov,
                                        _t = Ae.distortInverse(Math.tan(Yt * et)), ce = Math.min(wt, _t),
                                        de = Math.min(Oe, _t), we = Math.min(kt, _t), Ee = Math.min(at - kt, _t);
                                    return {
                                        outerDist: ce,
                                        innerDist: de,
                                        topDist: Ee,
                                        bottomDist: we,
                                        eyePosX: wt,
                                        eyePosY: kt
                                    }
                                };

                                function Zi($) {
                                    this.id = $.id, this.label = $.label, this.fov = $.fov, this.interLensDistance = $.interLensDistance, this.baselineLensDistance = $.baselineLensDistance, this.screenLensDistance = $.screenLensDistance, this.distortionCoefficients = $.distortionCoefficients, this.inverseCoefficients = $.inverseCoefficients
                                }

                                Vi.Viewers = fr;
                                var co = 1, pr = "2019-11-09T17:36:14Z", $s = [{
                                        type: "android",
                                        rules: [{mdmh: "asus/*/Nexus 7/*"}, {ua: "Nexus 7"}],
                                        dpi: [320.8, 323],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "asus/*/ASUS_X00PD/*"}, {ua: "ASUS_X00PD"}],
                                        dpi: 245,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "asus/*/ASUS_X008D/*"}, {ua: "ASUS_X008D"}],
                                        dpi: 282,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "asus/*/ASUS_Z00AD/*"}, {ua: "ASUS_Z00AD"}],
                                        dpi: [403, 404.6],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Google/*/Pixel 2 XL/*"}, {ua: "Pixel 2 XL"}],
                                        dpi: 537.9,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Google/*/Pixel 3 XL/*"}, {ua: "Pixel 3 XL"}],
                                        dpi: [558.5, 553.8],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Google/*/Pixel XL/*"}, {ua: "Pixel XL"}],
                                        dpi: [537.9, 533],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Google/*/Pixel 3/*"}, {ua: "Pixel 3"}],
                                        dpi: 442.4,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Google/*/Pixel 2/*"}, {ua: "Pixel 2"}],
                                        dpi: 441,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Google/*/Pixel/*"}, {ua: "Pixel"}],
                                        dpi: [432.6, 436.7],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "HTC/*/HTC6435LVW/*"}, {ua: "HTC6435LVW"}],
                                        dpi: [449.7, 443.3],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "HTC/*/HTC One XL/*"}, {ua: "HTC One XL"}],
                                        dpi: [315.3, 314.6],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "htc/*/Nexus 9/*"}, {ua: "Nexus 9"}],
                                        dpi: 289,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "HTC/*/HTC One M9/*"}, {ua: "HTC One M9"}],
                                        dpi: [442.5, 443.3],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "HTC/*/HTC One_M8/*"}, {ua: "HTC One_M8"}],
                                        dpi: [449.7, 447.4],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "HTC/*/HTC One/*"}, {ua: "HTC One"}],
                                        dpi: 472.8,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Huawei/*/Nexus 6P/*"}, {ua: "Nexus 6P"}],
                                        dpi: [515.1, 518],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Huawei/*/BLN-L24/*"}, {ua: "HONORBLN-L24"}],
                                        dpi: 480,
                                        bw: 4,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Huawei/*/BKL-L09/*"}, {ua: "BKL-L09"}],
                                        dpi: 403,
                                        bw: 3.47,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LENOVO/*/Lenovo PB2-690Y/*"}, {ua: "Lenovo PB2-690Y"}],
                                        dpi: [457.2, 454.713],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/Nexus 5X/*"}, {ua: "Nexus 5X"}],
                                        dpi: [422, 419.9],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/LGMS345/*"}, {ua: "LGMS345"}],
                                        dpi: [221.7, 219.1],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/LG-D800/*"}, {ua: "LG-D800"}],
                                        dpi: [422, 424.1],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/LG-D850/*"}, {ua: "LG-D850"}],
                                        dpi: [537.9, 541.9],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/VS985 4G/*"}, {ua: "VS985 4G"}],
                                        dpi: [537.9, 535.6],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/Nexus 5/*"}, {ua: "Nexus 5 B"}],
                                        dpi: [442.4, 444.8],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/Nexus 4/*"}, {ua: "Nexus 4"}],
                                        dpi: [319.8, 318.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/LG-P769/*"}, {ua: "LG-P769"}],
                                        dpi: [240.6, 247.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/LGMS323/*"}, {ua: "LGMS323"}],
                                        dpi: [206.6, 204.6],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "LGE/*/LGLS996/*"}, {ua: "LGLS996"}],
                                        dpi: [403.4, 401.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Micromax/*/4560MMX/*"}, {ua: "4560MMX"}],
                                        dpi: [240, 219.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Micromax/*/A250/*"}, {ua: "Micromax A250"}],
                                        dpi: [480, 446.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Micromax/*/Micromax AQ4501/*"}, {ua: "Micromax AQ4501"}],
                                        dpi: 240,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/G5/*"}, {ua: "Moto G (5) Plus"}],
                                        dpi: [403.4, 403],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/DROID RAZR/*"}, {ua: "DROID RAZR"}],
                                        dpi: [368.1, 256.7],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT830C/*"}, {ua: "XT830C"}],
                                        dpi: [254, 255.9],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1021/*"}, {ua: "XT1021"}],
                                        dpi: [254, 256.7],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1023/*"}, {ua: "XT1023"}],
                                        dpi: [254, 256.7],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1028/*"}, {ua: "XT1028"}],
                                        dpi: [326.6, 327.6],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1034/*"}, {ua: "XT1034"}],
                                        dpi: [326.6, 328.4],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1053/*"}, {ua: "XT1053"}],
                                        dpi: [315.3, 316.1],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1562/*"}, {ua: "XT1562"}],
                                        dpi: [403.4, 402.7],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/Nexus 6/*"}, {ua: "Nexus 6 B"}],
                                        dpi: [494.3, 489.7],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1063/*"}, {ua: "XT1063"}],
                                        dpi: [295, 296.6],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1064/*"}, {ua: "XT1064"}],
                                        dpi: [295, 295.6],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1092/*"}, {ua: "XT1092"}],
                                        dpi: [422, 424.1],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/XT1095/*"}, {ua: "XT1095"}],
                                        dpi: [422, 423.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "motorola/*/G4/*"}, {ua: "Moto G (4)"}],
                                        dpi: 401,
                                        bw: 4,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/A0001/*"}, {ua: "A0001"}],
                                        dpi: [403.4, 401],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONE E1001/*"}, {ua: "ONE E1001"}],
                                        dpi: [442.4, 441.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONE E1003/*"}, {ua: "ONE E1003"}],
                                        dpi: [442.4, 441.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONE E1005/*"}, {ua: "ONE E1005"}],
                                        dpi: [442.4, 441.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONE A2001/*"}, {ua: "ONE A2001"}],
                                        dpi: [391.9, 405.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONE A2003/*"}, {ua: "ONE A2003"}],
                                        dpi: [391.9, 405.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONE A2005/*"}, {ua: "ONE A2005"}],
                                        dpi: [391.9, 405.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONEPLUS A3000/*"}, {ua: "ONEPLUS A3000"}],
                                        dpi: 401,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONEPLUS A3003/*"}, {ua: "ONEPLUS A3003"}],
                                        dpi: 401,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONEPLUS A3010/*"}, {ua: "ONEPLUS A3010"}],
                                        dpi: 401,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONEPLUS A5000/*"}, {ua: "ONEPLUS A5000 "}],
                                        dpi: [403.411, 399.737],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONE A5010/*"}, {ua: "ONEPLUS A5010"}],
                                        dpi: [403, 400],
                                        bw: 2,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONEPLUS A6000/*"}, {ua: "ONEPLUS A6000"}],
                                        dpi: 401,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONEPLUS A6003/*"}, {ua: "ONEPLUS A6003"}],
                                        dpi: 401,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONEPLUS A6010/*"}, {ua: "ONEPLUS A6010"}],
                                        dpi: 401,
                                        bw: 2,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OnePlus/*/ONEPLUS A6013/*"}, {ua: "ONEPLUS A6013"}],
                                        dpi: 401,
                                        bw: 2,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "OPPO/*/X909/*"}, {ua: "X909"}],
                                        dpi: [442.4, 444.1],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/GT-I9082/*"}, {ua: "GT-I9082"}],
                                        dpi: [184.7, 185.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G360P/*"}, {ua: "SM-G360P"}],
                                        dpi: [196.7, 205.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/Nexus S/*"}, {ua: "Nexus S"}],
                                        dpi: [234.5, 229.8],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/GT-I9300/*"}, {ua: "GT-I9300"}],
                                        dpi: [304.8, 303.9],
                                        bw: 5,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-T230NU/*"}, {ua: "SM-T230NU"}],
                                        dpi: 216,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SGH-T399/*"}, {ua: "SGH-T399"}],
                                        dpi: [217.7, 231.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SGH-M919/*"}, {ua: "SGH-M919"}],
                                        dpi: [440.8, 437.7],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-N9005/*"}, {ua: "SM-N9005"}],
                                        dpi: [386.4, 387],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SAMSUNG-SM-N900A/*"}, {ua: "SAMSUNG-SM-N900A"}],
                                        dpi: [386.4, 387.7],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/GT-I9500/*"}, {ua: "GT-I9500"}],
                                        dpi: [442.5, 443.3],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/GT-I9505/*"}, {ua: "GT-I9505"}],
                                        dpi: 439.4,
                                        bw: 4,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G900F/*"}, {ua: "SM-G900F"}],
                                        dpi: [415.6, 431.6],
                                        bw: 5,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G900M/*"}, {ua: "SM-G900M"}],
                                        dpi: [415.6, 431.6],
                                        bw: 5,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G800F/*"}, {ua: "SM-G800F"}],
                                        dpi: 326.8,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G906S/*"}, {ua: "SM-G906S"}],
                                        dpi: [562.7, 572.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/GT-I9300/*"}, {ua: "GT-I9300"}],
                                        dpi: [306.7, 304.8],
                                        bw: 5,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-T535/*"}, {ua: "SM-T535"}],
                                        dpi: [142.6, 136.4],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-N920C/*"}, {ua: "SM-N920C"}],
                                        dpi: [515.1, 518.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-N920P/*"}, {ua: "SM-N920P"}],
                                        dpi: [386.3655, 390.144],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-N920W8/*"}, {ua: "SM-N920W8"}],
                                        dpi: [515.1, 518.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/GT-I9300I/*"}, {ua: "GT-I9300I"}],
                                        dpi: [304.8, 305.8],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/GT-I9195/*"}, {ua: "GT-I9195"}],
                                        dpi: [249.4, 256.7],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SPH-L520/*"}, {ua: "SPH-L520"}],
                                        dpi: [249.4, 255.9],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SAMSUNG-SGH-I717/*"}, {ua: "SAMSUNG-SGH-I717"}],
                                        dpi: 285.8,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SPH-D710/*"}, {ua: "SPH-D710"}],
                                        dpi: [217.7, 204.2],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/GT-N7100/*"}, {ua: "GT-N7100"}],
                                        dpi: 265.1,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SCH-I605/*"}, {ua: "SCH-I605"}],
                                        dpi: 265.1,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/Galaxy Nexus/*"}, {ua: "Galaxy Nexus"}],
                                        dpi: [315.3, 314.2],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-N910H/*"}, {ua: "SM-N910H"}],
                                        dpi: [515.1, 518],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-N910C/*"}, {ua: "SM-N910C"}],
                                        dpi: [515.2, 520.2],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G130M/*"}, {ua: "SM-G130M"}],
                                        dpi: [165.9, 164.8],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G928I/*"}, {ua: "SM-G928I"}],
                                        dpi: [515.1, 518.4],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G920F/*"}, {ua: "SM-G920F"}],
                                        dpi: 580.6,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G920P/*"}, {ua: "SM-G920P"}],
                                        dpi: [522.5, 577],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G925F/*"}, {ua: "SM-G925F"}],
                                        dpi: 580.6,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G925V/*"}, {ua: "SM-G925V"}],
                                        dpi: [522.5, 576.6],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G930F/*"}, {ua: "SM-G930F"}],
                                        dpi: 576.6,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G935F/*"}, {ua: "SM-G935F"}],
                                        dpi: 533,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G950F/*"}, {ua: "SM-G950F"}],
                                        dpi: [562.707, 565.293],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G955U/*"}, {ua: "SM-G955U"}],
                                        dpi: [522.514, 525.762],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G955F/*"}, {ua: "SM-G955F"}],
                                        dpi: [522.514, 525.762],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G960F/*"}, {ua: "SM-G960F"}],
                                        dpi: [569.575, 571.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G9600/*"}, {ua: "SM-G9600"}],
                                        dpi: [569.575, 571.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G960T/*"}, {ua: "SM-G960T"}],
                                        dpi: [569.575, 571.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G960N/*"}, {ua: "SM-G960N"}],
                                        dpi: [569.575, 571.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G960U/*"}, {ua: "SM-G960U"}],
                                        dpi: [569.575, 571.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G9608/*"}, {ua: "SM-G9608"}],
                                        dpi: [569.575, 571.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G960FD/*"}, {ua: "SM-G960FD"}],
                                        dpi: [569.575, 571.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G960W/*"}, {ua: "SM-G960W"}],
                                        dpi: [569.575, 571.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G965F/*"}, {ua: "SM-G965F"}],
                                        dpi: 529,
                                        bw: 2,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Sony/*/C6903/*"}, {ua: "C6903"}],
                                        dpi: [442.5, 443.3],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Sony/*/D6653/*"}, {ua: "D6653"}],
                                        dpi: [428.6, 427.6],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Sony/*/E6653/*"}, {ua: "E6653"}],
                                        dpi: [428.6, 425.7],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Sony/*/E6853/*"}, {ua: "E6853"}],
                                        dpi: [403.4, 401.9],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Sony/*/SGP321/*"}, {ua: "SGP321"}],
                                        dpi: [224.7, 224.1],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "TCT/*/ALCATEL ONE TOUCH Fierce/*"}, {ua: "ALCATEL ONE TOUCH Fierce"}],
                                        dpi: [240, 247.5],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "THL/*/thl 5000/*"}, {ua: "thl 5000"}],
                                        dpi: [480, 443.3],
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Fly/*/IQ4412/*"}, {ua: "IQ4412"}],
                                        dpi: 307.9,
                                        bw: 3,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "ZTE/*/ZTE Blade L2/*"}, {ua: "ZTE Blade L2"}],
                                        dpi: 240,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "BENEVE/*/VR518/*"}, {ua: "VR518"}],
                                        dpi: 480,
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "ios",
                                        rules: [{res: [640, 960]}],
                                        dpi: [325.1, 328.4],
                                        bw: 4,
                                        ac: 1e3
                                    }, {
                                        type: "ios",
                                        rules: [{res: [640, 1136]}],
                                        dpi: [317.1, 320.2],
                                        bw: 3,
                                        ac: 1e3
                                    }, {type: "ios", rules: [{res: [750, 1334]}], dpi: 326.4, bw: 4, ac: 1e3}, {
                                        type: "ios",
                                        rules: [{res: [1242, 2208]}],
                                        dpi: [453.6, 458.4],
                                        bw: 4,
                                        ac: 1e3
                                    }, {
                                        type: "ios",
                                        rules: [{res: [1125, 2001]}],
                                        dpi: [410.9, 415.4],
                                        bw: 4,
                                        ac: 1e3
                                    }, {
                                        type: "ios",
                                        rules: [{res: [1125, 2436]}],
                                        dpi: 458,
                                        bw: 4,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Huawei/*/EML-L29/*"}, {ua: "EML-L29"}],
                                        dpi: 428,
                                        bw: 3.45,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "Nokia/*/Nokia 7.1/*"}, {ua: "Nokia 7.1"}],
                                        dpi: [432, 431.9],
                                        bw: 3,
                                        ac: 500
                                    }, {
                                        type: "ios",
                                        rules: [{res: [1242, 2688]}],
                                        dpi: 458,
                                        bw: 4,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G570M/*"}, {ua: "SM-G570M"}],
                                        dpi: 320,
                                        bw: 3.684,
                                        ac: 1e3
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G970F/*"}, {ua: "SM-G970F"}],
                                        dpi: 438,
                                        bw: 2.281,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G973F/*"}, {ua: "SM-G973F"}],
                                        dpi: 550,
                                        bw: 2.002,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G975F/*"}, {ua: "SM-G975F"}],
                                        dpi: 522,
                                        bw: 2.054,
                                        ac: 500
                                    }, {
                                        type: "android",
                                        rules: [{mdmh: "samsung/*/SM-G977F/*"}, {ua: "SM-G977F"}],
                                        dpi: 505,
                                        bw: 2.334,
                                        ac: 500
                                    }, {type: "ios", rules: [{res: [828, 1792]}], dpi: 326, bw: 5, ac: 500}],
                                    Or = {format: co, last_updated: pr, devices: $s};

                                function ws($, re) {
                                    if (this.dpdb = Or, this.recalculateDeviceParams_(), $) {
                                        this.onDeviceParamsUpdated = re;
                                        var Ae = new XMLHttpRequest, xe = this;
                                        Ae.open("GET", $, !0), Ae.addEventListener("load", function () {
                                            xe.loading = !1, Ae.status >= 200 && Ae.status <= 299 ? (xe.dpdb = JSON.parse(Ae.response), xe.recalculateDeviceParams_()) : console.error("Error loading online DPDB!")
                                        }), Ae.send()
                                    }
                                }

                                ws.prototype.getDeviceParams = function () {
                                    return this.deviceParams
                                }, ws.prototype.recalculateDeviceParams_ = function () {
                                    var $ = this.calcDeviceParams_();
                                    $ ? (this.deviceParams = $, this.onDeviceParamsUpdated && this.onDeviceParamsUpdated(this.deviceParams)) : console.error("Failed to recalculate device parameters.")
                                }, ws.prototype.calcDeviceParams_ = function () {
                                    var $ = this.dpdb;
                                    if (!$) return console.error("DPDB not available."), null;
                                    if ($.format != 1) return console.error("DPDB has unexpected format version."), null;
                                    if (!$.devices || !$.devices.length) return console.error("DPDB does not have a devices section."), null;
                                    var re = navigator.userAgent || navigator.vendor || window.opera, Ae = ot(),
                                        xe = gt();
                                    if (!$.devices) return console.error("DPDB has no devices section."), null;
                                    for (var Oe = 0; Oe < $.devices.length; Oe++) {
                                        var Ze = $.devices[Oe];
                                        if (!Ze.rules) {
                                            console.warn("Device[" + Oe + "] has no rules section.");
                                            continue
                                        }
                                        if (Ze.type != "ios" && Ze.type != "android") {
                                            console.warn("Device[" + Oe + "] has invalid type.");
                                            continue
                                        }
                                        if (he() == (Ze.type == "ios")) {
                                            for (var at = !1, wt = 0; wt < Ze.rules.length; wt++) {
                                                var kt = Ze.rules[wt];
                                                if (this.ruleMatches_(kt, re, Ae, xe)) {
                                                    at = !0;
                                                    break
                                                }
                                            }
                                            if (at) {
                                                var et = Ze.dpi[0] || Ze.dpi, _t = Ze.dpi[1] || Ze.dpi;
                                                return new Eo({xdpi: et, ydpi: _t, bevelMm: Ze.bw})
                                            }
                                        }
                                    }
                                    return console.warn("No DPDB device match."), null
                                }, ws.prototype.ruleMatches_ = function ($, re, Ae, xe) {
                                    if (!$.ua && !$.res || ($.ua && $.ua.substring(0, 2) === "SM" && ($.ua = $.ua.substring(0, 7)), $.ua && re.indexOf($.ua) < 0)) return !1;
                                    if ($.res) {
                                        if (!$.res[0] || !$.res[1]) return !1;
                                        var Oe = $.res[0], Ze = $.res[1];
                                        if (Math.min(Ae, xe) != Math.min(Oe, Ze) || Math.max(Ae, xe) != Math.max(Oe, Ze)) return !1
                                    }
                                    return !0
                                };

                                function Eo($) {
                                    this.xdpi = $.xdpi, this.ydpi = $.ydpi, this.bevelMm = $.bevelMm
                                }

                                function bs($, re) {
                                    this.set($, re)
                                }

                                bs.prototype.set = function ($, re) {
                                    this.sample = $, this.timestampS = re
                                }, bs.prototype.copy = function ($) {
                                    this.set($.sample, $.timestampS)
                                };

                                function kr($, re) {
                                    this.kFilter = $, this.isDebug = re, this.currentAccelMeasurement = new bs, this.currentGyroMeasurement = new bs, this.previousGyroMeasurement = new bs, he() ? this.filterQ = new en(-1, 0, 0, 1) : this.filterQ = new en(1, 0, 0, 1), this.previousFilterQ = new en, this.previousFilterQ.copy(this.filterQ), this.accelQ = new en, this.isOrientationInitialized = !1, this.estimatedGravity = new $t, this.measuredGravity = new $t, this.gyroIntegralQ = new en
                                }

                                kr.prototype.addAccelMeasurement = function ($, re) {
                                    this.currentAccelMeasurement.set($, re)
                                }, kr.prototype.addGyroMeasurement = function ($, re) {
                                    this.currentGyroMeasurement.set($, re);
                                    var Ae = re - this.previousGyroMeasurement.timestampS;
                                    He(Ae) && this.run_(), this.previousGyroMeasurement.copy(this.currentGyroMeasurement)
                                }, kr.prototype.run_ = function () {
                                    if (!this.isOrientationInitialized) {
                                        this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample), this.previousFilterQ.copy(this.accelQ), this.isOrientationInitialized = !0;
                                        return
                                    }
                                    var $ = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS,
                                        re = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, $);
                                    this.gyroIntegralQ.multiply(re), this.filterQ.copy(this.previousFilterQ), this.filterQ.multiply(re);
                                    var Ae = new en;
                                    Ae.copy(this.filterQ), Ae.inverse(), this.estimatedGravity.set(0, 0, -1), this.estimatedGravity.applyQuaternion(Ae), this.estimatedGravity.normalize(), this.measuredGravity.copy(this.currentAccelMeasurement.sample), this.measuredGravity.normalize();
                                    var xe = new en;
                                    xe.setFromUnitVectors(this.estimatedGravity, this.measuredGravity), xe.inverse(), this.isDebug && console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", cn * Rr(xe), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
                                    var Oe = new en;
                                    Oe.copy(this.filterQ), Oe.multiply(xe), this.filterQ.slerp(Oe, 1 - this.kFilter), this.previousFilterQ.copy(this.filterQ)
                                }, kr.prototype.getOrientation = function () {
                                    return this.filterQ
                                }, kr.prototype.accelToQuaternion_ = function ($) {
                                    var re = new $t;
                                    re.copy($), re.normalize();
                                    var Ae = new en;
                                    return Ae.setFromUnitVectors(new $t(0, 0, -1), re), Ae.inverse(), Ae
                                }, kr.prototype.gyroToQuaternionDelta_ = function ($, re) {
                                    var Ae = new en, xe = new $t;
                                    return xe.copy($), xe.normalize(), Ae.setFromAxisAngle(xe, $.length() * re), Ae
                                };

                                function Hi($, re) {
                                    this.predictionTimeS = $, this.isDebug = re, this.previousQ = new en, this.previousTimestampS = null, this.deltaQ = new en, this.outQ = new en
                                }

                                Hi.prototype.getPrediction = function ($, re, Ae) {
                                    if (!this.previousTimestampS) return this.previousQ.copy($), this.previousTimestampS = Ae, $;
                                    var xe = new $t;
                                    xe.copy(re), xe.normalize();
                                    var Oe = re.length();
                                    if (Oe < Yt * 20) return this.isDebug && console.log("Moving slowly, at %s deg/s: no prediction", (cn * Oe).toFixed(1)), this.outQ.copy($), this.previousQ.copy($), this.outQ;
                                    var Ze = Oe * this.predictionTimeS;
                                    return this.deltaQ.setFromAxisAngle(xe, Ze), this.outQ.copy(this.previousQ), this.outQ.multiply(this.deltaQ), this.previousQ.copy($), this.previousTimestampS = Ae, this.outQ
                                };

                                function Qr($, re, Ae, xe) {
                                    this.yawOnly = Ae, this.accelerometer = new $t, this.gyroscope = new $t, this.filter = new kr($, xe), this.posePredictor = new Hi(re, xe), this.isFirefoxAndroid = ae(), this.isIOS = he();
                                    var Oe = ee();
                                    this.isDeviceMotionInRadians = !this.isIOS && Oe && Oe < 66, this.isWithoutDeviceMotion = Re() || me(), this.filterToWorldQ = new en, he() ? this.filterToWorldQ.setFromAxisAngle(new $t(1, 0, 0), Math.PI / 2) : this.filterToWorldQ.setFromAxisAngle(new $t(1, 0, 0), -Math.PI / 2), this.inverseWorldToScreenQ = new en, this.worldToScreenQ = new en, this.originalPoseAdjustQ = new en, this.originalPoseAdjustQ.setFromAxisAngle(new $t(0, 0, 1), -window.orientation * Math.PI / 180), this.setScreenTransform_(), Ve() && this.filterToWorldQ.multiply(this.inverseWorldToScreenQ), this.resetQ = new en, this.orientationOut_ = new Float32Array(4), this.start()
                                }

                                Qr.prototype.getPosition = function () {
                                    return null
                                }, Qr.prototype.getOrientation = function () {
                                    var $ = void 0;
                                    if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
                                        this.deviceOrientationFixQ = this.deviceOrientationFixQ || function () {
                                            var Oe = new en().setFromAxisAngle(new $t(0, 0, -1), 0), Ze = new en;
                                            return window.orientation === -90 ? Ze.setFromAxisAngle(new $t(0, 1, 0), Math.PI / -2) : Ze.setFromAxisAngle(new $t(0, 1, 0), Math.PI / 2), Oe.multiply(Ze)
                                        }(), this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function () {
                                            var Oe = new en;
                                            return Oe.setFromAxisAngle(new $t(1, 0, 0), -Math.PI / 2), Oe
                                        }(), $ = this._deviceOrientationQ;
                                        var Ae = new en;
                                        return Ae.copy($), Ae.multiply(this.deviceOrientationFilterToWorldQ), Ae.multiply(this.resetQ), Ae.multiply(this.worldToScreenQ), Ae.multiplyQuaternions(this.deviceOrientationFixQ, Ae), this.yawOnly && (Ae.x = 0, Ae.z = 0, Ae.normalize()), this.orientationOut_[0] = Ae.x, this.orientationOut_[1] = Ae.y, this.orientationOut_[2] = Ae.z, this.orientationOut_[3] = Ae.w, this.orientationOut_
                                    } else {
                                        var re = this.filter.getOrientation();
                                        $ = this.posePredictor.getPrediction(re, this.gyroscope, this.previousTimestampS)
                                    }
                                    var Ae = new en;
                                    return Ae.copy(this.filterToWorldQ), Ae.multiply(this.resetQ), Ae.multiply($), Ae.multiply(this.worldToScreenQ), this.yawOnly && (Ae.x = 0, Ae.z = 0, Ae.normalize()), this.orientationOut_[0] = Ae.x, this.orientationOut_[1] = Ae.y, this.orientationOut_[2] = Ae.z, this.orientationOut_[3] = Ae.w, this.orientationOut_
                                }, Qr.prototype.resetPose = function () {
                                    this.resetQ.copy(this.filter.getOrientation()), this.resetQ.x = 0, this.resetQ.y = 0, this.resetQ.z *= -1, this.resetQ.normalize(), Ve() && this.resetQ.multiply(this.inverseWorldToScreenQ), this.resetQ.multiply(this.originalPoseAdjustQ)
                                }, Qr.prototype.onDeviceOrientation_ = function ($) {
                                    this._deviceOrientationQ = this._deviceOrientationQ || new en;
                                    var re = $.alpha, Ae = $.beta, xe = $.gamma;
                                    re = (re || 0) * Math.PI / 180, Ae = (Ae || 0) * Math.PI / 180, xe = (xe || 0) * Math.PI / 180, this._deviceOrientationQ.setFromEulerYXZ(Ae, re, -xe)
                                }, Qr.prototype.onDeviceMotion_ = function ($) {
                                    this.updateDeviceMotion_($)
                                }, Qr.prototype.updateDeviceMotion_ = function ($) {
                                    var re = $.accelerationIncludingGravity, Ae = $.rotationRate,
                                        xe = $.timeStamp / 1e3, Oe = xe - this.previousTimestampS;
                                    if (Oe < 0) {
                                        Ji("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion"), this.previousTimestampS = xe;
                                        return
                                    } else if (Oe <= fe || Oe > se) {
                                        Ji("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range."), this.previousTimestampS = xe;
                                        return
                                    }
                                    this.accelerometer.set(-re.x, -re.y, -re.z), Ae && (ke() ? this.gyroscope.set(-Ae.beta, Ae.alpha, Ae.gamma) : this.gyroscope.set(Ae.alpha, Ae.beta, Ae.gamma), this.isDeviceMotionInRadians || this.gyroscope.multiplyScalar(Math.PI / 180), this.filter.addGyroMeasurement(this.gyroscope, xe)), this.filter.addAccelMeasurement(this.accelerometer, xe), this.previousTimestampS = xe
                                }, Qr.prototype.onOrientationChange_ = function ($) {
                                    this.setScreenTransform_()
                                }, Qr.prototype.onMessage_ = function ($) {
                                    var re = $.data;
                                    if (!(!re || !re.type)) {
                                        var Ae = re.type.toLowerCase();
                                        Ae === "devicemotion" && this.updateDeviceMotion_(re.deviceMotionEvent)
                                    }
                                }, Qr.prototype.setScreenTransform_ = function () {
                                    switch (this.worldToScreenQ.set(0, 0, 0, 1), window.orientation) {
                                        case 0:
                                            break;
                                        case 90:
                                            this.worldToScreenQ.setFromAxisAngle(new $t(0, 0, 1), -Math.PI / 2);
                                            break;
                                        case-90:
                                            this.worldToScreenQ.setFromAxisAngle(new $t(0, 0, 1), Math.PI / 2);
                                            break
                                    }
                                    this.inverseWorldToScreenQ.copy(this.worldToScreenQ), this.inverseWorldToScreenQ.inverse()
                                }, Qr.prototype.start = function () {
                                    this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this), this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this), this.onMessageCallback_ = this.onMessage_.bind(this), this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this), he() && nr() && window.addEventListener("message", this.onMessageCallback_), window.addEventListener("orientationchange", this.onOrientationChangeCallback_), this.isWithoutDeviceMotion ? window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_) : window.addEventListener("devicemotion", this.onDeviceMotionCallback_)
                                }, Qr.prototype.stop = function () {
                                    window.removeEventListener("devicemotion", this.onDeviceMotionCallback_), window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_), window.removeEventListener("orientationchange", this.onOrientationChangeCallback_), window.removeEventListener("message", this.onMessageCallback_)
                                };
                                var ua = 60, xo = new $t(1, 0, 0), Ea = new $t(0, 0, 1), Qo = new en;
                                Qo.setFromAxisAngle(xo, -Math.PI / 2), Qo.multiply(new en().setFromAxisAngle(Ea, Math.PI / 2));
                                var De = function () {
                                        function $(re) {
                                            U(this, $), this.config = re, this.sensor = null, this.fusionSensor = null, this._out = new Float32Array(4), this.api = null, this.errors = [], this._sensorQ = new en, this._outQ = new en, this._onSensorRead = this._onSensorRead.bind(this), this._onSensorError = this._onSensorError.bind(this), this.init()
                                        }

                                        return j($, [{
                                            key: "init", value: function () {
                                                var Ae = null;
                                                try {
                                                    Ae = new RelativeOrientationSensor({
                                                        frequency: ua,
                                                        referenceFrame: "screen"
                                                    }), Ae.addEventListener("error", this._onSensorError)
                                                } catch (xe) {
                                                    this.errors.push(xe), xe.name === "SecurityError" ? (console.error("Cannot construct sensors due to the Feature Policy"), console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.'), this.useDeviceMotion()) : xe.name === "ReferenceError" ? this.useDeviceMotion() : console.error(xe)
                                                }
                                                Ae && (this.api = "sensor", this.sensor = Ae, this.sensor.addEventListener("reading", this._onSensorRead), this.sensor.start())
                                            }
                                        }, {
                                            key: "useDeviceMotion", value: function () {
                                                this.api = "devicemotion", this.fusionSensor = new Qr(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG), this.sensor && (this.sensor.removeEventListener("reading", this._onSensorRead), this.sensor.removeEventListener("error", this._onSensorError), this.sensor = null)
                                            }
                                        }, {
                                            key: "getOrientation", value: function () {
                                                if (this.fusionSensor) return this.fusionSensor.getOrientation();
                                                if (!this.sensor || !this.sensor.quaternion) return this._out[0] = this._out[1] = this._out[2] = 0, this._out[3] = 1, this._out;
                                                var Ae = this.sensor.quaternion;
                                                this._sensorQ.set(Ae[0], Ae[1], Ae[2], Ae[3]);
                                                var xe = this._outQ;
                                                return xe.copy(Qo), xe.multiply(this._sensorQ), this.config.YAW_ONLY && (xe.x = xe.z = 0, xe.normalize()), this._out[0] = xe.x, this._out[1] = xe.y, this._out[2] = xe.z, this._out[3] = xe.w, this._out
                                            }
                                        }, {
                                            key: "_onSensorError", value: function (Ae) {
                                                this.errors.push(Ae.error), Ae.error.name === "NotAllowedError" ? console.error("Permission to access sensor was denied") : Ae.error.name === "NotReadableError" ? console.error("Sensor could not be read") : console.error(Ae.error), this.useDeviceMotion()
                                            }
                                        }, {
                                            key: "_onSensorRead", value: function () {
                                            }
                                        }]), $
                                    }(),
                                    Ke = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";

                                function rt() {
                                    this.loadIcon_();
                                    var $ = document.createElement("div"), at = $.style;
                                    at.position = "fixed", at.top = 0, at.right = 0, at.bottom = 0, at.left = 0, at.backgroundColor = "gray", at.fontFamily = "sans-serif", at.zIndex = 1e6;
                                    var re = document.createElement("img");
                                    re.src = this.icon;
                                    var at = re.style;
                                    at.marginLeft = "25%", at.marginTop = "25%", at.width = "50%", $.appendChild(re);
                                    var Ae = document.createElement("div"), at = Ae.style;
                                    at.textAlign = "center", at.fontSize = "16px", at.lineHeight = "24px", at.margin = "24px 25%", at.width = "50%", Ae.innerHTML = "Place your phone into your Cardboard viewer.", $.appendChild(Ae);
                                    var xe = document.createElement("div"), at = xe.style;
                                    at.backgroundColor = "#CFD8DC", at.position = "fixed", at.bottom = 0, at.width = "100%", at.height = "48px", at.padding = "14px 24px", at.boxSizing = "border-box", at.color = "#656A6B", $.appendChild(xe);
                                    var Oe = document.createElement("div");
                                    Oe.style.float = "left", Oe.innerHTML = "No Cardboard viewer?";
                                    var Ze = document.createElement("a");
                                    Ze.href = "https://www.google.com/get/cardboard/get-cardboard/", Ze.innerHTML = "get one", Ze.target = "_blank";
                                    var at = Ze.style;
                                    at.float = "right", at.fontWeight = 600, at.textTransform = "uppercase", at.borderLeft = "1px solid gray", at.paddingLeft = "24px", at.textDecoration = "none", at.color = "#656A6B", xe.appendChild(Oe), xe.appendChild(Ze), this.overlay = $, this.text = Ae, this.hide()
                                }

                                rt.prototype.show = function ($) {
                                    !$ && !this.overlay.parentElement ? document.body.appendChild(this.overlay) : $ && (this.overlay.parentElement && this.overlay.parentElement != $ && this.overlay.parentElement.removeChild(this.overlay), $.appendChild(this.overlay)), this.overlay.style.display = "block";
                                    var re = this.overlay.querySelector("img"), Ae = re.style;
                                    Ve() ? (Ae.width = "20%", Ae.marginLeft = "40%", Ae.marginTop = "3%") : (Ae.width = "50%", Ae.marginLeft = "25%", Ae.marginTop = "25%")
                                }, rt.prototype.hide = function () {
                                    this.overlay.style.display = "none"
                                }, rt.prototype.showTemporarily = function ($, re) {
                                    this.show(re), this.timer = setTimeout(this.hide.bind(this), $)
                                }, rt.prototype.disableShowTemporarily = function () {
                                    clearTimeout(this.timer)
                                }, rt.prototype.update = function () {
                                    this.disableShowTemporarily(), !Ve() && pi() ? this.show() : this.hide()
                                }, rt.prototype.loadIcon_ = function () {
                                    this.icon = pe("image/svg+xml", Ke)
                                };
                                var Ct = "CardboardV1", dt = "WEBVR_CARDBOARD_VIEWER",
                                    Lt = "webvr-polyfill-viewer-selector";

                                function Kt($) {
                                    try {
                                        this.selectedKey = localStorage.getItem(dt)
                                    } catch (re) {
                                        console.error("Failed to load viewer profile: %s", re)
                                    }
                                    this.selectedKey || (this.selectedKey = $ || Ct), this.dialog = this.createDialog_(Vi.Viewers), this.root = null, this.onChangeCallbacks_ = []
                                }

                                Kt.prototype.show = function ($) {
                                    this.root = $, $.appendChild(this.dialog);
                                    var re = this.dialog.querySelector("#" + this.selectedKey);
                                    re.checked = !0, this.dialog.style.display = "block"
                                }, Kt.prototype.hide = function () {
                                    this.root && this.root.contains(this.dialog) && this.root.removeChild(this.dialog), this.dialog.style.display = "none"
                                }, Kt.prototype.getCurrentViewer = function () {
                                    return Vi.Viewers[this.selectedKey]
                                }, Kt.prototype.getSelectedKey_ = function () {
                                    var $ = this.dialog.querySelector("input[name=field]:checked");
                                    return $ ? $.id : null
                                }, Kt.prototype.onChange = function ($) {
                                    this.onChangeCallbacks_.push($)
                                }, Kt.prototype.fireOnChange_ = function ($) {
                                    for (var re = 0; re < this.onChangeCallbacks_.length; re++) this.onChangeCallbacks_[re]($)
                                }, Kt.prototype.onSave_ = function () {
                                    if (this.selectedKey = this.getSelectedKey_(), !this.selectedKey || !Vi.Viewers[this.selectedKey]) {
                                        console.error("ViewerSelector.onSave_: this should never happen!");
                                        return
                                    }
                                    this.fireOnChange_(Vi.Viewers[this.selectedKey]);
                                    try {
                                        localStorage.setItem(dt, this.selectedKey)
                                    } catch ($) {
                                        console.error("Failed to save viewer profile: %s", $)
                                    }
                                    this.hide()
                                }, Kt.prototype.createDialog_ = function ($) {
                                    var re = document.createElement("div");
                                    re.classList.add(Lt), re.style.display = "none";
                                    var Ae = document.createElement("div"), Ze = Ae.style;
                                    Ze.position = "fixed", Ze.left = 0, Ze.top = 0, Ze.width = "100%", Ze.height = "100%", Ze.background = "rgba(0, 0, 0, 0.3)", Ae.addEventListener("click", this.hide.bind(this));
                                    var xe = 280, Oe = document.createElement("div"), Ze = Oe.style;
                                    Ze.boxSizing = "border-box", Ze.position = "fixed", Ze.top = "24px", Ze.left = "50%", Ze.marginLeft = -xe / 2 + "px", Ze.width = xe + "px", Ze.padding = "24px", Ze.overflow = "hidden", Ze.background = "#fafafa", Ze.fontFamily = "'Roboto', sans-serif", Ze.boxShadow = "0px 5px 20px #666", Oe.appendChild(this.createH1_("Select your viewer"));
                                    for (var at in $) Oe.appendChild(this.createChoice_(at, $[at].label));
                                    return Oe.appendChild(this.createButton_("Save", this.onSave_.bind(this))), re.appendChild(Ae), re.appendChild(Oe), re
                                }, Kt.prototype.createH1_ = function ($) {
                                    var re = document.createElement("h1"), Ae = re.style;
                                    return Ae.color = "black", Ae.fontSize = "20px", Ae.fontWeight = "bold", Ae.marginTop = 0, Ae.marginBottom = "24px", re.innerHTML = $, re
                                }, Kt.prototype.createChoice_ = function ($, re) {
                                    var Ae = document.createElement("div");
                                    Ae.style.marginTop = "8px", Ae.style.color = "black";
                                    var xe = document.createElement("input");
                                    xe.style.fontSize = "30px", xe.setAttribute("id", $), xe.setAttribute("type", "radio"), xe.setAttribute("value", $), xe.setAttribute("name", "field");
                                    var Oe = document.createElement("label");
                                    return Oe.style.marginLeft = "4px", Oe.setAttribute("for", $), Oe.innerHTML = re, Ae.appendChild(xe), Ae.appendChild(Oe), Ae
                                }, Kt.prototype.createButton_ = function ($, re) {
                                    var Ae = document.createElement("button");
                                    Ae.innerHTML = $;
                                    var xe = Ae.style;
                                    return xe.float = "right", xe.textTransform = "uppercase", xe.color = "#1094f7", xe.fontSize = "14px", xe.letterSpacing = 0, xe.border = 0, xe.background = "none", xe.marginTop = "16px", Ae.addEventListener("click", re), Ae
                                };
                                var Rn = typeof window < "u" ? window : typeof g < "u" ? g : typeof self < "u" ? self : {};

                                function xn($) {
                                    return $ && $.__esModule && Object.prototype.hasOwnProperty.call($, "default") ? $.default : $
                                }

                                function Dt($, re) {
                                    return re = {exports: {}}, $(re, re.exports), re.exports
                                }

                                var Hn = Dt(function ($, re) {
                                        (function (xe, Oe) {
                                            $.exports = Oe()
                                        })(Rn, function () {
                                            return function (Ae) {
                                                var xe = {};

                                                function Oe(Ze) {
                                                    if (xe[Ze]) return xe[Ze].exports;
                                                    var at = xe[Ze] = {i: Ze, l: !1, exports: {}};
                                                    return Ae[Ze].call(at.exports, at, at.exports, Oe), at.l = !0, at.exports
                                                }

                                                return Oe.m = Ae, Oe.c = xe, Oe.d = function (Ze, at, wt) {
                                                    Oe.o(Ze, at) || Object.defineProperty(Ze, at, {
                                                        configurable: !1,
                                                        enumerable: !0,
                                                        get: wt
                                                    })
                                                }, Oe.n = function (Ze) {
                                                    var at = Ze && Ze.__esModule ? function () {
                                                        return Ze.default
                                                    } : function () {
                                                        return Ze
                                                    };
                                                    return Oe.d(at, "a", at), at
                                                }, Oe.o = function (Ze, at) {
                                                    return Object.prototype.hasOwnProperty.call(Ze, at)
                                                }, Oe.p = "", Oe(Oe.s = 0)
                                            }([function (Ae, xe, Oe) {
                                                var Ze = function () {
                                                    function _t(ce, de) {
                                                        for (var we = 0; we < de.length; we++) {
                                                            var Ee = de[we];
                                                            Ee.enumerable = Ee.enumerable || !1, Ee.configurable = !0, "value" in Ee && (Ee.writable = !0), Object.defineProperty(ce, Ee.key, Ee)
                                                        }
                                                    }

                                                    return function (ce, de, we) {
                                                        return de && _t(ce.prototype, de), we && _t(ce, we), ce
                                                    }
                                                }();

                                                function at(_t, ce) {
                                                    if (!(_t instanceof ce)) throw new TypeError("Cannot call a class as a function")
                                                }

                                                var wt = Oe(1),
                                                    kt = typeof navigator < "u" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream,
                                                    et = function () {
                                                        function _t() {
                                                            at(this, _t), kt ? this.noSleepTimer = null : (this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("playsinline", ""), this.noSleepVideo.setAttribute("src", wt), this.noSleepVideo.addEventListener("timeupdate", (function (ce) {
                                                                this.noSleepVideo.currentTime > .5 && (this.noSleepVideo.currentTime = Math.random())
                                                            }).bind(this)))
                                                        }

                                                        return Ze(_t, [{
                                                            key: "enable", value: function () {
                                                                kt ? (this.disable(), this.noSleepTimer = window.setInterval(function () {
                                                                    window.location.href = "/", window.setTimeout(window.stop, 0)
                                                                }, 15e3)) : this.noSleepVideo.play()
                                                            }
                                                        }, {
                                                            key: "disable", value: function () {
                                                                kt ? this.noSleepTimer && (window.clearInterval(this.noSleepTimer), this.noSleepTimer = null) : this.noSleepVideo.pause()
                                                            }
                                                        }]), _t
                                                    }();
                                                Ae.exports = et
                                            }, function (Ae, xe, Oe) {
                                                Ae.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA="
                                            }])
                                        })
                                    }), jn = xn(Hn), Wn = 1e3, Wi = [0, 0, .5, 1], li = [.5, 0, .5, 1],
                                    mi = window.requestAnimationFrame, ki = window.cancelAnimationFrame;

                                function yr() {
                                    this.leftProjectionMatrix = new Float32Array(16), this.leftViewMatrix = new Float32Array(16), this.rightProjectionMatrix = new Float32Array(16), this.rightViewMatrix = new Float32Array(16), this.pose = null
                                }

                                function Ur($) {
                                    Object.defineProperties(this, {
                                        hasPosition: {
                                            writable: !1,
                                            enumerable: !0,
                                            value: $.hasPosition
                                        },
                                        hasExternalDisplay: {writable: !1, enumerable: !0, value: $.hasExternalDisplay},
                                        canPresent: {writable: !1, enumerable: !0, value: $.canPresent},
                                        maxLayers: {writable: !1, enumerable: !0, value: $.maxLayers},
                                        hasOrientation: {
                                            enumerable: !0, get: function () {
                                                return Pi("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData"), $.hasOrientation
                                            }
                                        }
                                    })
                                }

                                function Cn($) {
                                    $ = $ || {};
                                    var re = "wakelock" in $ ? $.wakelock : !0;
                                    this.isPolyfilled = !0, this.displayId = Wn++, this.displayName = "", this.depthNear = .01, this.depthFar = 1e4, this.isPresenting = !1, Object.defineProperty(this, "isConnected", {
                                        get: function () {
                                            return Pi("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay"), !1
                                        }
                                    }), this.capabilities = new Ur({
                                        hasPosition: !1,
                                        hasOrientation: !1,
                                        hasExternalDisplay: !1,
                                        canPresent: !1,
                                        maxLayers: 1
                                    }), this.stageParameters = null, this.waitingForPresent_ = !1, this.layer_ = null, this.originalParent_ = null, this.fullscreenElement_ = null, this.fullscreenWrapper_ = null, this.fullscreenElementCachedStyle_ = null, this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null, re && pi() && (this.wakelock_ = new jn)
                                }

                                Cn.prototype.getFrameData = function ($) {
                                    return yi($, this._getPose(), this)
                                }, Cn.prototype.getPose = function () {
                                    return Pi("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData"), this._getPose()
                                }, Cn.prototype.resetPose = function () {
                                    return Pi("VRDisplay.prototype.resetPose"), this._resetPose()
                                }, Cn.prototype.getImmediatePose = function () {
                                    return Pi("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData"), this._getPose()
                                }, Cn.prototype.requestAnimationFrame = function ($) {
                                    return mi($)
                                }, Cn.prototype.cancelAnimationFrame = function ($) {
                                    return ki($)
                                }, Cn.prototype.wrapForFullscreen = function ($) {
                                    if (he()) return $;
                                    if (!this.fullscreenWrapper_) {
                                        this.fullscreenWrapper_ = document.createElement("div");
                                        var re = ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important", "left: 0 !important", "right: 0 !important", "border: 0", "margin: 0", "padding: 0", "z-index: 999999 !important", "position: fixed"];
                                        this.fullscreenWrapper_.setAttribute("style", re.join("; ") + ";"), this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper")
                                    }
                                    if (this.fullscreenElement_ == $) return this.fullscreenWrapper_;
                                    if (this.fullscreenElement_ && (this.originalParent_ ? this.originalParent_.appendChild(this.fullscreenElement_) : this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_)), this.fullscreenElement_ = $, this.originalParent_ = $.parentElement, this.originalParent_ || document.body.appendChild($), !this.fullscreenWrapper_.parentElement) {
                                        var Ae = this.fullscreenElement_.parentElement;
                                        Ae.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_), Ae.removeChild(this.fullscreenElement_)
                                    }
                                    this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild), this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
                                    var xe = this;

                                    function Oe() {
                                        if (xe.fullscreenElement_) {
                                            var Ze = ["position: absolute", "top: 0", "left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0", "margin: 0", "padding: 0"];
                                            xe.fullscreenElement_.setAttribute("style", Ze.join("; ") + ";")
                                        }
                                    }

                                    return Oe(), this.fullscreenWrapper_
                                }, Cn.prototype.removeFullscreenWrapper = function () {
                                    if (this.fullscreenElement_) {
                                        var $ = this.fullscreenElement_;
                                        this.fullscreenElementCachedStyle_ ? $.setAttribute("style", this.fullscreenElementCachedStyle_) : $.removeAttribute("style"), this.fullscreenElement_ = null, this.fullscreenElementCachedStyle_ = null;
                                        var re = this.fullscreenWrapper_.parentElement;
                                        return this.fullscreenWrapper_.removeChild($), this.originalParent_ === re ? re.insertBefore($, this.fullscreenWrapper_) : this.originalParent_ && this.originalParent_.appendChild($), re.removeChild(this.fullscreenWrapper_), $
                                    }
                                }, Cn.prototype.requestPresent = function ($) {
                                    var re = this.isPresenting, Ae = this;
                                    return $ instanceof Array || (Pi("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument"), $ = [$]), new Promise(function (xe, Oe) {
                                        if (!Ae.capabilities.canPresent) {
                                            Oe(new Error("VRDisplay is not capable of presenting."));
                                            return
                                        }
                                        if ($.length == 0 || $.length > Ae.capabilities.maxLayers) {
                                            Oe(new Error("Invalid number of layers."));
                                            return
                                        }
                                        var Ze = $[0];
                                        if (!Ze.source) {
                                            xe();
                                            return
                                        }
                                        var at = Ze.leftBounds || Wi, wt = Ze.rightBounds || li;
                                        if (re) {
                                            var kt = Ae.layer_;
                                            kt.source !== Ze.source && (kt.source = Ze.source);
                                            for (var et = 0; et < 4; et++) kt.leftBounds[et] = at[et], kt.rightBounds[et] = wt[et];
                                            Ae.wrapForFullscreen(Ae.layer_.source), Ae.updatePresent_(), xe();
                                            return
                                        }
                                        if (Ae.layer_ = {
                                            predistorted: Ze.predistorted,
                                            source: Ze.source,
                                            leftBounds: at.slice(0),
                                            rightBounds: wt.slice(0)
                                        }, Ae.waitingForPresent_ = !1, Ae.layer_ && Ae.layer_.source) {
                                            var _t = Ae.wrapForFullscreen(Ae.layer_.source), ce = function () {
                                                var Ee = an();
                                                Ae.isPresenting = _t === Ee, Ae.isPresenting ? (screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape-primary").catch(function (Me) {
                                                    console.error("screen.orientation.lock() failed due to", Me.message)
                                                }), Ae.waitingForPresent_ = !1, Ae.beginPresent_(), xe()) : (screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), Ae.removeFullscreenWrapper(), Ae.disableWakeLock(), Ae.endPresent_(), Ae.removeFullscreenListeners_()), Ae.fireVRDisplayPresentChange_()
                                            }, de = function () {
                                                Ae.waitingForPresent_ && (Ae.removeFullscreenWrapper(), Ae.removeFullscreenListeners_(), Ae.disableWakeLock(), Ae.waitingForPresent_ = !1, Ae.isPresenting = !1, Oe(new Error("Unable to present.")))
                                            };
                                            Ae.addFullscreenListeners_(_t, ce, de), Bt(_t) ? (Ae.enableWakeLock(), Ae.waitingForPresent_ = !0) : (he() || Z()) && (Ae.enableWakeLock(), Ae.isPresenting = !0, Ae.beginPresent_(), Ae.fireVRDisplayPresentChange_(), xe())
                                        }
                                        !Ae.waitingForPresent_ && !he() && (Rt(), Oe(new Error("Unable to present.")))
                                    })
                                }, Cn.prototype.exitPresent = function () {
                                    var $ = this.isPresenting, re = this;
                                    return this.isPresenting = !1, this.layer_ = null, this.disableWakeLock(), new Promise(function (Ae, xe) {
                                        $ ? (!Rt() && he() && (re.endPresent_(), re.fireVRDisplayPresentChange_()), Z() && (re.removeFullscreenWrapper(), re.removeFullscreenListeners_(), re.endPresent_(), re.fireVRDisplayPresentChange_()), Ae()) : xe(new Error("Was not presenting to VRDisplay."))
                                    })
                                }, Cn.prototype.getLayers = function () {
                                    return this.layer_ ? [this.layer_] : []
                                }, Cn.prototype.fireVRDisplayPresentChange_ = function () {
                                    var $ = new CustomEvent("vrdisplaypresentchange", {detail: {display: this}});
                                    window.dispatchEvent($)
                                }, Cn.prototype.fireVRDisplayConnect_ = function () {
                                    var $ = new CustomEvent("vrdisplayconnect", {detail: {display: this}});
                                    window.dispatchEvent($)
                                }, Cn.prototype.addFullscreenListeners_ = function ($, re, Ae) {
                                    this.removeFullscreenListeners_(), this.fullscreenEventTarget_ = $, this.fullscreenChangeHandler_ = re, this.fullscreenErrorHandler_ = Ae, re && (document.fullscreenEnabled ? $.addEventListener("fullscreenchange", re, !1) : document.webkitFullscreenEnabled ? $.addEventListener("webkitfullscreenchange", re, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenchange", re, !1) : document.msFullscreenEnabled && $.addEventListener("msfullscreenchange", re, !1)), Ae && (document.fullscreenEnabled ? $.addEventListener("fullscreenerror", Ae, !1) : document.webkitFullscreenEnabled ? $.addEventListener("webkitfullscreenerror", Ae, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenerror", Ae, !1) : document.msFullscreenEnabled && $.addEventListener("msfullscreenerror", Ae, !1))
                                }, Cn.prototype.removeFullscreenListeners_ = function () {
                                    if (this.fullscreenEventTarget_) {
                                        var $ = this.fullscreenEventTarget_;
                                        if (this.fullscreenChangeHandler_) {
                                            var re = this.fullscreenChangeHandler_;
                                            $.removeEventListener("fullscreenchange", re, !1), $.removeEventListener("webkitfullscreenchange", re, !1), document.removeEventListener("mozfullscreenchange", re, !1), $.removeEventListener("msfullscreenchange", re, !1)
                                        }
                                        if (this.fullscreenErrorHandler_) {
                                            var Ae = this.fullscreenErrorHandler_;
                                            $.removeEventListener("fullscreenerror", Ae, !1), $.removeEventListener("webkitfullscreenerror", Ae, !1), document.removeEventListener("mozfullscreenerror", Ae, !1), $.removeEventListener("msfullscreenerror", Ae, !1)
                                        }
                                        this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null
                                    }
                                }, Cn.prototype.enableWakeLock = function () {
                                    this.wakelock_ && this.wakelock_.enable()
                                }, Cn.prototype.disableWakeLock = function () {
                                    this.wakelock_ && this.wakelock_.disable()
                                }, Cn.prototype.beginPresent_ = function () {
                                }, Cn.prototype.endPresent_ = function () {
                                }, Cn.prototype.submitFrame = function ($) {
                                }, Cn.prototype.getEyeParameters = function ($) {
                                    return null
                                };
                                var Ai = {
                                    ADDITIONAL_VIEWERS: [],
                                    DEFAULT_VIEWER: "",
                                    MOBILE_WAKE_LOCK: !0,
                                    DEBUG: !1,
                                    DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
                                    K_FILTER: .98,
                                    PREDICTION_TIME_S: .04,
                                    CARDBOARD_UI_DISABLED: !1,
                                    ROTATE_INSTRUCTIONS_DISABLED: !1,
                                    YAW_ONLY: !1,
                                    BUFFER_SCALE: .5,
                                    DIRTY_SUBMIT_FRAME_BINDINGS: !1
                                }, _r = {LEFT: "left", RIGHT: "right"};

                                function ri($) {
                                    var re = hi({}, Ai);
                                    $ = hi(re, $ || {}), Cn.call(this, {wakelock: $.MOBILE_WAKE_LOCK}), this.config = $, this.displayName = "Cardboard VRDisplay", this.capabilities = new Ur({
                                        hasPosition: !1,
                                        hasOrientation: !0,
                                        hasExternalDisplay: !1,
                                        canPresent: !0,
                                        maxLayers: 1
                                    }), this.stageParameters = null, this.bufferScale_ = this.config.BUFFER_SCALE, this.poseSensor_ = new De(this.config), this.distorter_ = null, this.cardboardUI_ = null, this.dpdb_ = new ws(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this)), this.deviceInfo_ = new Vi(this.dpdb_.getDeviceParams(), $.ADDITIONAL_VIEWERS), this.viewerSelector_ = new Kt($.DEFAULT_VIEWER), this.viewerSelector_.onChange(this.onViewerChanged_.bind(this)), this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer()), this.config.ROTATE_INSTRUCTIONS_DISABLED || (this.rotateInstructions_ = new rt), he() && window.addEventListener("resize", this.onResize_.bind(this))
                                }

                                return ri.prototype = Object.create(Cn.prototype), ri.prototype._getPose = function () {
                                    return {
                                        position: null,
                                        orientation: this.poseSensor_.getOrientation(),
                                        linearVelocity: null,
                                        linearAcceleration: null,
                                        angularVelocity: null,
                                        angularAcceleration: null
                                    }
                                }, ri.prototype._resetPose = function () {
                                    this.poseSensor_.resetPose && this.poseSensor_.resetPose()
                                }, ri.prototype._getFieldOfView = function ($) {
                                    var re;
                                    if ($ == _r.LEFT) re = this.deviceInfo_.getFieldOfViewLeftEye(); else if ($ == _r.RIGHT) re = this.deviceInfo_.getFieldOfViewRightEye(); else return console.error("Invalid eye provided: %s", $), null;
                                    return re
                                }, ri.prototype._getEyeOffset = function ($) {
                                    var re;
                                    if ($ == _r.LEFT) re = [-this.deviceInfo_.viewer.interLensDistance * .5, 0, 0]; else if ($ == _r.RIGHT) re = [this.deviceInfo_.viewer.interLensDistance * .5, 0, 0]; else return console.error("Invalid eye provided: %s", $), null;
                                    return re
                                }, ri.prototype.getEyeParameters = function ($) {
                                    var re = this._getEyeOffset($), Ae = this._getFieldOfView($), xe = {
                                        offset: re,
                                        renderWidth: this.deviceInfo_.device.width * .5 * this.bufferScale_,
                                        renderHeight: this.deviceInfo_.device.height * this.bufferScale_
                                    };
                                    return Object.defineProperty(xe, "fieldOfView", {
                                        enumerable: !0, get: function () {
                                            return Pi("VRFieldOfView", "VRFrameData's projection matrices"), Ae
                                        }
                                    }), xe
                                }, ri.prototype.onDeviceParamsUpdated_ = function ($) {
                                    this.config.DEBUG && console.log("DPDB reported that device params were updated."), this.deviceInfo_.updateDeviceParams($), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_)
                                }, ri.prototype.updateBounds_ = function () {
                                    this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds) && this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds)
                                }, ri.prototype.beginPresent_ = function () {
                                    var $ = this.layer_.source.getContext("webgl");
                                    $ || ($ = this.layer_.source.getContext("experimental-webgl")), $ || ($ = this.layer_.source.getContext("webgl2")), $ && (this.layer_.predistorted ? this.config.CARDBOARD_UI_DISABLED || ($.canvas.width = ot() * this.bufferScale_, $.canvas.height = gt() * this.bufferScale_, this.cardboardUI_ = new je($)) : (this.config.CARDBOARD_UI_DISABLED || (this.cardboardUI_ = new je($)), this.distorter_ = new ir($, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS), this.distorter_.updateDeviceInfo(this.deviceInfo_)), this.cardboardUI_ && this.cardboardUI_.listen((function (re) {
                                        this.viewerSelector_.show(this.layer_.source.parentElement), re.stopPropagation(), re.preventDefault()
                                    }).bind(this), (function (re) {
                                        this.exitPresent(), re.stopPropagation(), re.preventDefault()
                                    }).bind(this)), this.rotateInstructions_ && (Ve() && pi() ? this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement) : this.rotateInstructions_.update()), this.orientationHandler = this.onOrientationChange_.bind(this), window.addEventListener("orientationchange", this.orientationHandler), this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this), window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler), this.fireVRDisplayDeviceParamsChange_())
                                }, ri.prototype.endPresent_ = function () {
                                    this.distorter_ && (this.distorter_.destroy(), this.distorter_ = null), this.cardboardUI_ && (this.cardboardUI_.destroy(), this.cardboardUI_ = null), this.rotateInstructions_ && this.rotateInstructions_.hide(), this.viewerSelector_.hide(), window.removeEventListener("orientationchange", this.orientationHandler), window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler)
                                }, ri.prototype.updatePresent_ = function () {
                                    this.endPresent_(), this.beginPresent_()
                                }, ri.prototype.submitFrame = function ($) {
                                    if (this.distorter_) this.updateBounds_(), this.distorter_.submitFrame(); else if (this.cardboardUI_ && this.layer_) {
                                        var re = this.layer_.source.getContext("webgl");
                                        re || (re = this.layer_.source.getContext("experimental-webgl")), re || (re = this.layer_.source.getContext("webgl2"));
                                        var Ae = re.canvas;
                                        (Ae.width != this.lastWidth || Ae.height != this.lastHeight) && this.cardboardUI_.onResize(), this.lastWidth = Ae.width, this.lastHeight = Ae.height, this.cardboardUI_.render()
                                    }
                                }, ri.prototype.onOrientationChange_ = function ($) {
                                    this.viewerSelector_.hide(), this.rotateInstructions_ && this.rotateInstructions_.update(), this.onResize_()
                                }, ri.prototype.onResize_ = function ($) {
                                    if (this.layer_) {
                                        var re = this.layer_.source.getContext("webgl");
                                        re || (re = this.layer_.source.getContext("experimental-webgl")), re || (re = this.layer_.source.getContext("webgl2"));
                                        var Ae = ["position: absolute", "top: 0", "left: 0", "width: 100vw", "height: 100vh", "border: 0", "margin: 0", "padding: 0px", "box-sizing: content-box"];
                                        re.canvas.setAttribute("style", Ae.join("; ") + ";"), Vn(re.canvas)
                                    }
                                }, ri.prototype.onViewerChanged_ = function ($) {
                                    this.deviceInfo_.setViewer($), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_), this.fireVRDisplayDeviceParamsChange_()
                                }, ri.prototype.fireVRDisplayDeviceParamsChange_ = function () {
                                    var $ = new CustomEvent("vrdisplaydeviceparamschange", {
                                        detail: {
                                            vrdisplay: this,
                                            deviceInfo: this.deviceInfo_
                                        }
                                    });
                                    window.dispatchEvent($)
                                }, ri.VRFrameData = yr, ri.VRDisplay = Cn, ri
                            })
                        }), b = w(M), B = "0.10.12", R = {
                            ADDITIONAL_VIEWERS: [],
                            DEFAULT_VIEWER: "",
                            PROVIDE_MOBILE_VRDISPLAY: !0,
                            MOBILE_WAKE_LOCK: !0,
                            DEBUG: !1,
                            DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
                            K_FILTER: .98,
                            PREDICTION_TIME_S: .04,
                            CARDBOARD_UI_DISABLED: !1,
                            ROTATE_INSTRUCTIONS_DISABLED: !1,
                            YAW_ONLY: !1,
                            BUFFER_SCALE: .5,
                            DIRTY_SUBMIT_FRAME_BINDINGS: !1
                        };

                        function I(F) {
                            this.config = C(C({}, R), F), this.polyfillDisplays = [], this.enabled = !1, this.hasNative = "getVRDisplays" in navigator, this.native = {}, this.native.getVRDisplays = navigator.getVRDisplays, this.native.VRFrameData = window.VRFrameData, this.native.VRDisplay = window.VRDisplay, (!this.hasNative || this.config.PROVIDE_MOBILE_VRDISPLAY && E()) && (this.enable(), this.getVRDisplays().then(function (V) {
                                V && V[0] && V[0].fireVRDisplayConnect_ && V[0].fireVRDisplayConnect_()
                            }))
                        }

                        I.prototype.getPolyfillDisplays = function () {
                            if (this._polyfillDisplaysPopulated) return this.polyfillDisplays;
                            if (E()) {
                                var F = new b({
                                    ADDITIONAL_VIEWERS: this.config.ADDITIONAL_VIEWERS,
                                    DEFAULT_VIEWER: this.config.DEFAULT_VIEWER,
                                    MOBILE_WAKE_LOCK: this.config.MOBILE_WAKE_LOCK,
                                    DEBUG: this.config.DEBUG,
                                    DPDB_URL: this.config.DPDB_URL,
                                    CARDBOARD_UI_DISABLED: this.config.CARDBOARD_UI_DISABLED,
                                    K_FILTER: this.config.K_FILTER,
                                    PREDICTION_TIME_S: this.config.PREDICTION_TIME_S,
                                    ROTATE_INSTRUCTIONS_DISABLED: this.config.ROTATE_INSTRUCTIONS_DISABLED,
                                    YAW_ONLY: this.config.YAW_ONLY,
                                    BUFFER_SCALE: this.config.BUFFER_SCALE,
                                    DIRTY_SUBMIT_FRAME_BINDINGS: this.config.DIRTY_SUBMIT_FRAME_BINDINGS
                                });
                                this.polyfillDisplays.push(F)
                            }
                            return this._polyfillDisplaysPopulated = !0, this.polyfillDisplays
                        }, I.prototype.enable = function () {
                            if (this.enabled = !0, this.hasNative && this.native.VRFrameData) {
                                var F = this.native.VRFrameData, V = new this.native.VRFrameData,
                                    U = this.native.VRDisplay.prototype.getFrameData;
                                window.VRDisplay.prototype.getFrameData = function (j) {
                                    if (j instanceof F) {
                                        U.call(this, j);
                                        return
                                    }
                                    U.call(this, V), j.pose = V.pose, p(V.leftProjectionMatrix, j.leftProjectionMatrix), p(V.rightProjectionMatrix, j.rightProjectionMatrix), p(V.leftViewMatrix, j.leftViewMatrix), p(V.rightViewMatrix, j.rightViewMatrix)
                                }
                            }
                            navigator.getVRDisplays = this.getVRDisplays.bind(this), window.VRDisplay = b.VRDisplay, window.VRFrameData = b.VRFrameData
                        }, I.prototype.getVRDisplays = function () {
                            var F = this;
                            return this.config, this.hasNative ? this.native.getVRDisplays.call(navigator).then(function (V) {
                                return V.length > 0 ? V : F.getPolyfillDisplays()
                            }) : Promise.resolve(this.getPolyfillDisplays())
                        }, I.version = B, I.VRFrameData = b.VRFrameData, I.VRDisplay = b.VRDisplay;
                        var L = Object.freeze({default: I}), O = L && I || L;
                        typeof g < "u" && g.window && (g.document || (g.document = g.window.document), g.navigator || (g.navigator = g.window.navigator));
                        var N = O;
                        return N
                    })
                },
                "./node_modules/word-wrapper/index.js": m => {
                    var x = /\n/, h = `
`, g = /\s/;
                    m.exports = function (M, b) {
                        var B = m.exports.lines(M, b);
                        return B.map(function (R) {
                            return M.substring(R.start, R.end)
                        }).join(`
`)
                    }, m.exports.lines = function (b, B) {
                        if (B = B || {}, B.width === 0 && B.mode !== "nowrap") return [];
                        b = b || "";
                        var R = typeof B.width == "number" ? B.width : Number.MAX_VALUE, I = Math.max(0, B.start || 0),
                            L = typeof B.end == "number" ? B.end : b.length, O = B.mode, N = B.measure || C;
                        return O === "pre" ? E(N, b, I, L, R) : p(N, b, I, L, R, O)
                    };

                    function w(M, b, B, R) {
                        var I = M.indexOf(b, B);
                        return I === -1 || I > R ? R : I
                    }

                    function v(M) {
                        return g.test(M)
                    }

                    function E(M, b, B, R, I) {
                        for (var L = [], O = B, N = B; N < R && N < b.length; N++) {
                            var F = b.charAt(N), V = x.test(F);
                            if (V || N === R - 1) {
                                var U = V ? N : N + 1, j = M(b, O, U, I);
                                L.push(j), O = N + 1
                            }
                        }
                        return L
                    }

                    function p(M, b, B, R, I, L) {
                        var O = [], N = I;
                        for (L === "nowrap" && (N = Number.MAX_VALUE); B < R && B < b.length;) {
                            for (var F = w(b, h, B, R); B < F && v(b.charAt(B));) B++;
                            var V = M(b, B, F, N), U = B + (V.end - V.start), j = U + h.length;
                            if (U < F) {
                                for (; U > B && !v(b.charAt(U));) U--;
                                if (U === B) j > B + h.length && j--, U = j; else for (j = U; U > B && v(b.charAt(U - h.length));) U--
                            }
                            if (U >= B) {
                                var Y = M(b, B, U, N);
                                O.push(Y)
                            }
                            B = j
                        }
                        return O
                    }

                    function C(M, b, B, R) {
                        var I = Math.min(R, B - b);
                        return {start: b, end: b + I}
                    }
                },
                "./node_modules/xhr/index.js": (m, x, h) => {
                    var g = h("./node_modules/global/window.js"), w = h("./node_modules/is-function/index.js"),
                        v = h("./node_modules/parse-headers/parse-headers.js"),
                        E = h("./node_modules/xtend/immutable.js");
                    m.exports = b, m.exports.default = b, b.XMLHttpRequest = g.XMLHttpRequest || I, b.XDomainRequest = "withCredentials" in new b.XMLHttpRequest ? b.XMLHttpRequest : g.XDomainRequest, p(["get", "put", "post", "patch", "head", "delete"], function (L) {
                        b[L === "delete" ? "del" : L] = function (O, N, F) {
                            return N = M(O, N, F), N.method = L.toUpperCase(), B(N)
                        }
                    });

                    function p(L, O) {
                        for (var N = 0; N < L.length; N++) O(L[N])
                    }

                    function C(L) {
                        for (var O in L) if (L.hasOwnProperty(O)) return !1;
                        return !0
                    }

                    function M(L, O, N) {
                        var F = L;
                        return w(O) ? (N = O, typeof L == "string" && (F = {uri: L})) : F = E(O, {uri: L}), F.callback = N, F
                    }

                    function b(L, O, N) {
                        return O = M(L, O, N), B(O)
                    }

                    function B(L) {
                        if (typeof L.callback > "u") throw new Error("callback argument missing");
                        var O = !1, N = function (ke, Ve, He) {
                            O || (O = !0, L.callback(ke, Ve, He))
                        };

                        function F() {
                            Y.readyState === 4 && setTimeout(j, 0)
                        }

                        function V() {
                            var Re = void 0;
                            if (Y.response ? Re = Y.response : Re = Y.responseText || R(Y), ae) try {
                                Re = JSON.parse(Re)
                            } catch {
                            }
                            return Re
                        }

                        function U(Re) {
                            return clearTimeout(ee), Re instanceof Error || (Re = new Error("" + (Re || "Unknown XMLHttpRequest Error"))), Re.statusCode = 0, N(Re, me)
                        }

                        function j() {
                            if (!se) {
                                var Re;
                                clearTimeout(ee), L.useXDR && Y.status === void 0 ? Re = 200 : Re = Y.status === 1223 ? 204 : Y.status;
                                var ke = me, Ve = null;
                                return Re !== 0 ? (ke = {
                                    body: V(),
                                    statusCode: Re,
                                    method: ue,
                                    headers: {},
                                    url: pe,
                                    rawRequest: Y
                                }, Y.getAllResponseHeaders && (ke.headers = v(Y.getAllResponseHeaders()))) : Ve = new Error("Internal XMLHttpRequest Error"), N(Ve, ke, ke.body)
                            }
                        }

                        var Y = L.xhr || null;
                        Y || (L.cors || L.useXDR ? Y = new b.XDomainRequest : Y = new b.XMLHttpRequest);
                        var fe, se, pe = Y.url = L.uri || L.url, ue = Y.method = L.method || "GET",
                            he = L.body || L.data, Z = Y.headers = L.headers || {}, H = !!L.sync, ae = !1, ee,
                            me = {body: void 0, headers: {}, statusCode: 0, method: ue, url: pe, rawRequest: Y};
                        if ("json" in L && L.json !== !1 && (ae = !0, Z.accept || Z.Accept || (Z.Accept = "application/json"), ue !== "GET" && ue !== "HEAD" && (Z["content-type"] || Z["Content-Type"] || (Z["Content-Type"] = "application/json"), he = JSON.stringify(L.json === !0 ? he : L.json))), Y.onreadystatechange = F, Y.onload = j, Y.onerror = U, Y.onprogress = function () {
                        }, Y.onabort = function () {
                            se = !0
                        }, Y.ontimeout = U, Y.open(ue, pe, !H, L.username, L.password), H || (Y.withCredentials = !!L.withCredentials), !H && L.timeout > 0 && (ee = setTimeout(function () {
                            if (!se) {
                                se = !0, Y.abort("timeout");
                                var Re = new Error("XMLHttpRequest timeout");
                                Re.code = "ETIMEDOUT", U(Re)
                            }
                        }, L.timeout)), Y.setRequestHeader) for (fe in Z) Z.hasOwnProperty(fe) && Y.setRequestHeader(fe, Z[fe]); else if (L.headers && !C(L.headers)) throw new Error("Headers cannot be set on an XDomainRequest object");
                        return "responseType" in L && (Y.responseType = L.responseType), "beforeSend" in L && typeof L.beforeSend == "function" && L.beforeSend(Y), Y.send(he || null), Y
                    }

                    function R(L) {
                        try {
                            if (L.responseType === "document") return L.responseXML;
                            var O = L.responseXML && L.responseXML.documentElement.nodeName === "parsererror";
                            if (L.responseType === "" && !O) return L.responseXML
                        } catch {
                        }
                        return null
                    }

                    function I() {
                    }
                },
                "./node_modules/xml-parse-from-string/index.js": m => {
                    m.exports = function () {
                        return typeof self.DOMParser < "u" ? function (h) {
                            var g = new self.DOMParser;
                            return g.parseFromString(h, "application/xml")
                        } : typeof self.ActiveXObject < "u" && new self.ActiveXObject("Microsoft.XMLDOM") ? function (h) {
                            var g = new self.ActiveXObject("Microsoft.XMLDOM");
                            return g.async = "false", g.loadXML(h), g
                        } : function (h) {
                            var g = document.createElement("div");
                            return g.innerHTML = h, g
                        }
                    }()
                },
                "./node_modules/xtend/immutable.js": m => {
                    m.exports = h;
                    var x = Object.prototype.hasOwnProperty;

                    function h() {
                        for (var g = {}, w = 0; w < arguments.length; w++) {
                            var v = arguments[w];
                            for (var E in v) x.call(v, E) && (g[E] = v[E])
                        }
                        return g
                    }
                },
                "./src/components/anchored.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/index.js"),
                        v = w.debug("components:anchored:warn");
                    m.exports.Component = g("anchored", {
                        schema: {persistent: {default: !1}}, init: function () {
                            var p = this.el.sceneEl, C = p.getAttribute("webxr"), M = C.optionalFeatures;
                            M.indexOf("anchors") === -1 && (M.push("anchors"), this.el.sceneEl.setAttribute("webxr", C)), this.auxQuaternion = new THREE.Quaternion, this.onEnterVR = this.onEnterVR.bind(this), this.el.sceneEl.addEventListener("enter-vr", this.onEnterVR)
                        }, onEnterVR: function () {
                            this.anchor = void 0, this.requestPersistentAnchorPending = this.data.persistent, this.requestAnchorPending = !this.data.persistent
                        }, tick: function () {
                            var p = this.el.sceneEl, C = p.renderer.xr, M, b, B, R = this.el.object3D;
                            !p.is("ar-mode") && !p.is("vr-mode") || (!this.anchor && this.requestPersistentAnchorPending && this.restorePersistentAnchor(), !this.anchor && this.requestAnchorPending && this.createAnchor(), this.anchor && (M = p.frame, b = C.getReferenceSpace(), B = M.getPose(this.anchor.anchorSpace, b), R.matrix.elements = B.transform.matrix, R.matrix.decompose(R.position, R.rotation, R.scale)))
                        }, createAnchor: async function (C, M) {
                            var b = this.el.sceneEl, B = b.renderer.xr, R, I, L, O, N = this.el.object3D;
                            if (C = C || N.position, M = M || this.auxQuaternion.setFromEuler(N.rotation), !E(b)) {
                                v("This browser doesn't support the WebXR anchors module");
                                return
                            }
                            this.anchor && this.deleteAnchor(), R = b.frame, I = B.getReferenceSpace(), L = new XRRigidTransform({
                                x: C.x,
                                y: C.y,
                                z: C.z
                            }, {
                                x: M.x,
                                y: M.y,
                                z: M.z,
                                w: M.w
                            }), this.requestAnchorPending = !1, O = await R.createAnchor(L, I), this.data.persistent && (this.el.id ? (this.persistentHandle = await O.requestPersistentHandle(), localStorage.setItem(this.el.id, this.persistentHandle)) : v("The anchor won't be persisted because the entity has no assigned id.")), b.object3D.attach(this.el.object3D), this.anchor = O
                        }, restorePersistentAnchor: async function () {
                            var C = this.el.sceneEl.renderer.xr, M = C.getSession(), b = M.persistentAnchors, B;
                            if (this.requestPersistentAnchorPending = !1, !this.el.id) {
                                v("The entity associated to the persistent anchor cannot be retrieved because it doesn't have an assigned id."), this.requestAnchorPending = !0;
                                return
                            }
                            if (b) {
                                B = localStorage.getItem(this.el.id);
                                for (var R = 0; R < b.length; ++R) if (B === b[R]) {
                                    this.anchor = await M.restorePersistentAnchor(b[R]), this.anchor && (this.persistentHandle = b[R]);
                                    break
                                }
                                this.anchor || (this.requestAnchorPending = !0)
                            } else this.requestPersistentAnchorPending = !0
                        }, deleteAnchor: function () {
                            var p, C, M = this.anchor;
                            M && (p = this.el.sceneEl.renderer.xr, C = p.getSession(), M.delete(), this.el.sceneEl.object3D.add(this.el.object3D), this.persistentHandle && C.deletePersistentAnchor(this.persistentHandle), this.anchor = void 0)
                        }
                    });

                    function E(p) {
                        var C = p.renderer.xr, M = C.getSession();
                        return M && M.restorePersistentAnchor
                    }
                },
                "./src/components/animation.js": (m, x, h) => {
                    var g = h("./node_modules/super-animejs/lib/anime.es.js").default,
                        w = h("./src/core/component.js").components, v = h("./src/core/component.js").registerComponent,
                        E = h("./src/lib/three.js"), p = h("./src/utils/index.js"), C = new E.Color, M = new E.Color,
                        b = p.entity.getComponentProperty, B = p.entity.setComponentProperty, R = {}, I = "color",
                        L = "position", O = "rotation", N = "scale", F = "components", V = "object3D";
                    m.exports.Component = v("animation", {
                        schema: {
                            autoplay: {default: !0},
                            delay: {default: 0},
                            dir: {default: ""},
                            dur: {default: 1e3},
                            easing: {default: "easeInQuad"},
                            elasticity: {default: 400},
                            enabled: {default: !0},
                            from: {default: ""},
                            loop: {
                                default: 0, parse: function (Z) {
                                    return Z === !0 || Z === "true" ? !0 : Z === !1 || Z === "false" ? !1 : parseInt(Z, 10)
                                }
                            },
                            property: {default: ""},
                            startEvents: {type: "array"},
                            pauseEvents: {type: "array"},
                            resumeEvents: {type: "array"},
                            round: {default: !1},
                            to: {default: ""},
                            type: {default: ""},
                            isRawProperty: {default: !1}
                        }, multiple: !0, init: function () {
                            var Z = this;
                            this.eventDetail = {name: this.attrName}, this.time = 0, this.animation = null, this.animationIsPlaying = !1, this.onStartEvent = this.onStartEvent.bind(this), this.beginAnimation = this.beginAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.resumeAnimation = this.resumeAnimation.bind(this), this.fromColor = {}, this.toColor = {}, this.targets = {}, this.targetsArray = [], this.updateConfigForDefault = this.updateConfigForDefault.bind(this), this.updateConfigForRawColor = this.updateConfigForRawColor.bind(this), this.config = {
                                complete: function () {
                                    Z.animationIsPlaying = !1, Z.el.emit("animationcomplete", Z.eventDetail, !1), Z.id && Z.el.emit("animationcomplete__" + Z.id, Z.eventDetail, !1)
                                }
                            }
                        }, update: function (Z) {
                            var H = this.config, ae = this.data;
                            this.animationIsPlaying = !1, this.data.enabled && ae.property && (H.autoplay = !1, H.direction = ae.dir, H.duration = ae.dur, H.easing = ae.easing, H.elasticity = ae.elasticity, H.loop = ae.loop, H.round = ae.round, this.createAndStartAnimation())
                        }, tick: function (Z, H) {
                            this.animationIsPlaying && (this.time += H, this.animation.tick(this.time))
                        }, remove: function () {
                            this.pauseAnimation(), this.removeEventListeners()
                        }, pause: function () {
                            this.paused = !0, this.pausedWasPlaying = this.animationIsPlaying, this.pauseAnimation(), this.removeEventListeners()
                        }, play: function () {
                            this.paused && (this.paused = !1, this.addEventListeners(), this.pausedWasPlaying && (this.resumeAnimation(), this.pausedWasPlaying = !1))
                        }, createAndStartAnimation: function () {
                            var Z = this.data;
                            if (this.updateConfig(), this.animationIsPlaying = !1, this.animation = g(this.config), this.animation.began = !0, this.removeEventListeners(), this.addEventListeners(), !(!Z.autoplay || Z.startEvents && Z.startEvents.length)) {
                                if (Z.delay) {
                                    setTimeout(this.beginAnimation, Z.delay);
                                    return
                                }
                                this.beginAnimation()
                            }
                        }, beginAnimation: function () {
                            this.updateConfig(), this.animation.began = !0, this.time = 0, this.animationIsPlaying = !0, this.stopRelatedAnimations(), this.el.emit("animationbegin", this.eventDetail, !1)
                        }, pauseAnimation: function () {
                            this.animationIsPlaying = !1
                        }, resumeAnimation: function () {
                            this.animationIsPlaying = !0
                        }, onStartEvent: function () {
                            if (this.data.enabled) {
                                if (this.updateConfig(), this.animation && this.animation.pause(), this.animation = g(this.config), this.data.delay) {
                                    setTimeout(this.beginAnimation, this.data.delay);
                                    return
                                }
                                this.beginAnimation()
                            }
                        }, updateConfigForRawColor: function () {
                            var Z = this.config, H = this.data, ae = this.el, ee, me, Re;
                            if (!this.waitComponentInitRawProperty(this.updateConfigForRawColor)) {
                                ee = H.from === "" ? se(ae, H.property) : H.from, Re = H.to, this.setColorConfig(ee, Re), ee = this.fromColor, Re = this.toColor, this.targetsArray.length = 0, this.targetsArray.push(ee), Z.targets = this.targetsArray;
                                for (me in Re) Z[me] = Re[me];
                                Z.update = function () {
                                    var ke = {};
                                    return function (Ve) {
                                        var He;
                                        He = Ve.animatables[0].target, !(He.r === ke.r && He.g === ke.g && He.b === ke.b) && pe(ae, H.property, He, H.type)
                                    }
                                }()
                            }
                        }, updateConfigForDefault: function () {
                            var Z = this.config, H = this.data, ae = this.el, ee, me, Re, ke;
                            this.waitComponentInitRawProperty(this.updateConfigForDefault) || (H.from === "" ? ee = he(H) ? se(ae, H.property) : b(ae, H.property) : ee = H.from, ke = H.to, Re = !isNaN(ee || ke), Re ? (ee = parseFloat(ee), ke = parseFloat(ke)) : (ee = ee && ee.toString(), ke = ke && ke.toString()), me = H.to === "true" || H.to === "false" || H.to === !0 || H.to === !1, me && (ee = H.from === "true" || H.from === !0 ? 1 : 0, ke = H.to === "true" || H.to === !0 ? 1 : 0), this.targets.aframeProperty = ee, Z.targets = this.targets, Z.aframeProperty = ke, Z.update = function () {
                                var Ve;
                                return function (He) {
                                    var ot;
                                    ot = He.animatables[0].target.aframeProperty, ot !== Ve && (Ve = ot, me && (ot = ot >= 1), he(H) ? pe(ae, H.property, ot, H.type) : B(ae, H.property, ot))
                                }
                            }())
                        }, updateConfigForVector: function () {
                            var Z = this.config, H = this.data, ae = this.el, ee, me, Re;
                            me = H.from !== "" ? p.coordinates.parse(H.from) : b(ae, H.property), Re = p.coordinates.parse(H.to), H.property === O && (j(me), j(Re)), this.targetsArray.length = 0, this.targetsArray.push(me), Z.targets = this.targetsArray;
                            for (ee in Re) Z[ee] = Re[ee];
                            if (H.property === L || H.property === O || H.property === N) {
                                Z.update = function () {
                                    var ke = {};
                                    return function (Ve) {
                                        var He = Ve.animatables[0].target;
                                        He.x === ke.x && He.y === ke.y && He.z === ke.z || (ke.x = He.x, ke.y = He.y, ke.z = He.z, ae.object3D[H.property].set(He.x, He.y, He.z))
                                    }
                                }();
                                return
                            }
                            Z.update = function () {
                                var ke = {};
                                return function (Ve) {
                                    var He = Ve.animatables[0].target;
                                    He.x === ke.x && He.y === ke.y && He.z === ke.z || (ke.x = He.x, ke.y = He.y, ke.z = He.z, B(ae, H.property, He))
                                }
                            }()
                        }, updateConfig: function () {
                            var Z;
                            Z = U(this.el, this.data.property), he(this.data) && this.data.type === I ? this.updateConfigForRawColor() : Z === "vec2" || Z === "vec3" || Z === "vec4" ? this.updateConfigForVector() : this.updateConfigForDefault()
                        }, waitComponentInitRawProperty: function (Z) {
                            var H, ae = this.data, ee = this.el, me = this;
                            return ae.from !== "" || !ae.property.startsWith(F) || (H = ue(ae.property)[1], ee.components[H]) ? !1 : (ee.addEventListener("componentinitialized", function Re(ke) {
                                ke.detail.name === H && (Z(), me.animation = g(me.config), ee.removeEventListener("componentinitialized", Re))
                            }), !0)
                        }, stopRelatedAnimations: function () {
                            var Z, H;
                            for (H in this.el.components) Z = this.el.components[H], H !== this.attrName && Z.name === "animation" && Z.animationIsPlaying && Z.data.property === this.data.property && (Z.animationIsPlaying = !1)
                        }, addEventListeners: function () {
                            var Z = this.data, H = this.el;
                            Y(H, Z.startEvents, this.onStartEvent), Y(H, Z.pauseEvents, this.pauseAnimation), Y(H, Z.resumeEvents, this.resumeAnimation)
                        }, removeEventListeners: function () {
                            var Z = this.data, H = this.el;
                            fe(H, Z.startEvents, this.onStartEvent), fe(H, Z.pauseEvents, this.pauseAnimation), fe(H, Z.resumeEvents, this.resumeAnimation)
                        }, setColorConfig: function (Z, H) {
                            C.set(Z), M.set(H), Z = this.fromColor, H = this.toColor, Z.r = C.r, Z.g = C.g, Z.b = C.b, H.r = M.r, H.g = M.g, H.b = M.b
                        }
                    });

                    function U(Z, H) {
                        var ae, ee, me, Re;
                        return me = H.split("."), ee = me[0], Re = me[1], ae = Z.components[ee] || w[ee], !ae || Re && !ae.schema[Re] ? null : Re ? ae.schema[Re].type : ae.schema.type
                    }

                    function j(Z) {
                        Z.x = E.MathUtils.degToRad(Z.x), Z.y = E.MathUtils.degToRad(Z.y), Z.z = E.MathUtils.degToRad(Z.z)
                    }

                    function Y(Z, H, ae) {
                        var ee;
                        for (ee = 0; ee < H.length; ee++) Z.addEventListener(H[ee], ae)
                    }

                    function fe(Z, H, ae) {
                        var ee;
                        for (ee = 0; ee < H.length; ee++) Z.removeEventListener(H[ee], ae)
                    }

                    function se(Z, H) {
                        var ae, ee, me;
                        for (ee = ue(H), me = Z, ae = 0; ae < ee.length; ae++) me = me[ee[ae]];
                        if (me === void 0) throw console.log(Z), new Error("[animation] property (" + H + ") could not be found");
                        return me
                    }

                    function pe(Z, H, ae, ee) {
                        var me, Re, ke, Ve;
                        for (H.startsWith("object3D.rotation") && (ae = E.MathUtils.degToRad(ae)), Re = ue(H), Ve = Z, me = 0; me < Re.length - 1; me++) Ve = Ve[Re[me]];
                        if (ke = Re[Re.length - 1], ee === I) {
                            "r" in Ve[ke] ? (Ve[ke].r = ae.r, Ve[ke].g = ae.g, Ve[ke].b = ae.b) : (Ve[ke].x = ae.r, Ve[ke].y = ae.g, Ve[ke].z = ae.b);
                            return
                        }
                        Ve[ke] = ae
                    }

                    function ue(Z) {
                        return Z in R || (R[Z] = Z.split(".")), R[Z]
                    }

                    function he(Z) {
                        return Z.isRawProperty || Z.property.startsWith(F) || Z.property.startsWith(V)
                    }
                },
                "./src/components/camera.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js");
                    m.exports.Component = g("camera", {
                        schema: {
                            active: {default: !0},
                            far: {default: 1e4},
                            fov: {default: 80, min: 0},
                            near: {default: .005, min: 0},
                            spectator: {default: !1},
                            zoom: {default: 1, min: 0}
                        }, init: function () {
                            var v, E = this.el;
                            v = this.camera = new w.PerspectiveCamera, E.setObject3D("camera", v)
                        }, update: function (v) {
                            var E = this.data, p = this.camera;
                            p.aspect = E.aspect || window.innerWidth / window.innerHeight, p.far = E.far, p.fov = E.fov, p.near = E.near, p.zoom = E.zoom, p.updateProjectionMatrix(), this.updateActiveCamera(v), this.updateSpectatorCamera(v)
                        }, updateActiveCamera: function (v) {
                            var E = this.data, p = this.el, C = this.system;
                            v && v.active === E.active || E.spectator || (E.active && C.activeCameraEl !== p ? C.setActiveCamera(p) : !E.active && C.activeCameraEl === p && C.disableActiveCamera())
                        }, updateSpectatorCamera: function (v) {
                            var E = this.data, p = this.el, C = this.system;
                            v && v.spectator === E.spectator || (E.spectator && C.spectatorCameraEl !== p ? C.setSpectatorCamera(p) : !E.spectator && C.spectatorCameraEl === p && C.disableSpectatorCamera())
                        }, remove: function () {
                            this.el.removeObject3D("camera")
                        }
                    })
                },
                "./src/components/cursor.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/index.js"), v = {
                            CLICK: "click",
                            FUSING: "fusing",
                            MOUSEENTER: "mouseenter",
                            MOUSEDOWN: "mousedown",
                            MOUSELEAVE: "mouseleave",
                            MOUSEUP: "mouseup"
                        }, E = {FUSING: "cursor-fusing", HOVERING: "cursor-hovering", HOVERED: "cursor-hovered"},
                        p = {DOWN: ["mousedown", "touchstart"], UP: ["mouseup", "touchend"]},
                        C = {DOWN: ["selectstart"], UP: ["selectend"]}, M = "a-mouse-cursor-hover";
                    m.exports.Component = g("cursor", {
                        dependencies: ["raycaster"],
                        schema: {
                            downEvents: {default: []},
                            fuse: {default: w.device.isMobile()},
                            fuseTimeout: {default: 1500, min: 0},
                            mouseCursorStylesEnabled: {default: !0},
                            upEvents: {default: []},
                            rayOrigin: {default: "entity", oneOf: ["mouse", "entity", "xrselect"]}
                        },
                        after: ["tracked-controls"],
                        multiple: !0,
                        init: function () {
                            var b = this;
                            this.fuseTimeout = void 0, this.cursorDownEl = null, this.intersectedEl = null, this.canvasBounds = document.body.getBoundingClientRect(), this.isCursorDown = !1, this.activeXRInput = null, this.updateCanvasBounds = w.debounce(function () {
                                b.canvasBounds = b.el.sceneEl.canvas.getBoundingClientRect()
                            }, 500), this.eventDetail = {}, this.intersectedEventDetail = {cursorEl: this.el}, this.onCursorDown = this.onCursorDown.bind(this), this.onCursorUp = this.onCursorUp.bind(this), this.onIntersection = this.onIntersection.bind(this), this.onIntersectionCleared = this.onIntersectionCleared.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onEnterVR = this.onEnterVR.bind(this)
                        },
                        update: function (b) {
                            this.data.rayOrigin !== b.rayOrigin && this.updateMouseEventListeners()
                        },
                        tick: function () {
                            var b = this.el.sceneEl.frame, B = this.activeXRInput;
                            this.data.rayOrigin === "xrselect" && b && B && this.onMouseMove({
                                frame: b,
                                inputSource: B,
                                type: "fakeselectevent"
                            })
                        },
                        play: function () {
                            this.addEventListeners()
                        },
                        pause: function () {
                            this.removeEventListeners()
                        },
                        remove: function () {
                            var b = this.el;
                            b.removeState(E.HOVERING), b.removeState(E.FUSING), clearTimeout(this.fuseTimeout), this.intersectedEl && this.intersectedEl.removeState(E.HOVERED), this.removeEventListeners()
                        },
                        addEventListeners: function () {
                            var b, B = this.data, R = this.el, I = this;

                            function L() {
                                b = R.sceneEl.canvas, !(B.downEvents.length || B.upEvents.length) && (p.DOWN.forEach(function (O) {
                                    b.addEventListener(O, I.onCursorDown, {passive: !1})
                                }), p.UP.forEach(function (O) {
                                    b.addEventListener(O, I.onCursorUp, {passive: !1})
                                }))
                            }

                            b = R.sceneEl.canvas, b ? L() : R.sceneEl.addEventListener("render-target-loaded", L), B.downEvents.forEach(function (O) {
                                R.addEventListener(O, I.onCursorDown)
                            }), B.upEvents.forEach(function (O) {
                                R.addEventListener(O, I.onCursorUp)
                            }), R.addEventListener("raycaster-intersection", this.onIntersection), R.addEventListener("raycaster-closest-entity-changed", this.onIntersection), R.addEventListener("raycaster-intersection-cleared", this.onIntersectionCleared), R.sceneEl.addEventListener("rendererresize", this.updateCanvasBounds), R.sceneEl.addEventListener("enter-vr", this.onEnterVR), window.addEventListener("resize", this.updateCanvasBounds), window.addEventListener("scroll", this.updateCanvasBounds), this.updateMouseEventListeners()
                        },
                        removeEventListeners: function () {
                            var b, B = this.data, R = this.el, I = this;
                            b = R.sceneEl.canvas, b && !B.downEvents.length && !B.upEvents.length && (p.DOWN.forEach(function (L) {
                                b.removeEventListener(L, I.onCursorDown)
                            }), p.UP.forEach(function (L) {
                                b.removeEventListener(L, I.onCursorUp)
                            })), B.downEvents.forEach(function (L) {
                                R.removeEventListener(L, I.onCursorDown)
                            }), B.upEvents.forEach(function (L) {
                                R.removeEventListener(L, I.onCursorUp)
                            }), R.removeEventListener("raycaster-intersection", this.onIntersection), R.removeEventListener("raycaster-intersection-cleared", this.onIntersectionCleared), b.removeEventListener("mousemove", this.onMouseMove), b.removeEventListener("touchstart", this.onMouseMove), b.removeEventListener("touchmove", this.onMouseMove), R.sceneEl.removeEventListener("rendererresize", this.updateCanvasBounds), R.sceneEl.removeEventListener("enter-vr", this.onEnterVR), window.removeEventListener("resize", this.updateCanvasBounds), window.removeEventListener("scroll", this.updateCanvasBounds)
                        },
                        updateMouseEventListeners: function () {
                            var b, B = this.el;
                            b = B.sceneEl.canvas, b.removeEventListener("mousemove", this.onMouseMove), b.removeEventListener("touchmove", this.onMouseMove), B.setAttribute("raycaster", "useWorldCoordinates", !1), this.data.rayOrigin === "mouse" && (b.addEventListener("mousemove", this.onMouseMove), b.addEventListener("touchmove", this.onMouseMove, {passive: !1}), B.setAttribute("raycaster", "useWorldCoordinates", !0), this.updateCanvasBounds())
                        },
                        onMouseMove: function () {
                            var b = new THREE.Vector3, B = new THREE.Vector2, R = new THREE.Vector3,
                                I = {origin: R, direction: b};
                            return function (L) {
                                var O = this.canvasBounds, N = this.el.sceneEl.camera, F, V, U, j, Y, fe, se, pe;
                                N.parent.updateMatrixWorld(), L.type === "touchmove" || L.type === "touchstart" ? V = L.touches.item(0) : V = L, F = V.clientX - O.left, U = V.clientY - O.top, B.x = F / O.width * 2 - 1, B.y = -(U / O.height) * 2 + 1, this.data.rayOrigin === "xrselect" && (L.type === "selectstart" || L.type === "fakeselectevent") ? (j = L.frame, Y = L.inputSource, fe = this.el.renderer.xr.getReferenceSpace(), se = j.getPose(Y.targetRaySpace, fe), pe = se.transform, b.set(0, 0, -1), b.applyQuaternion(pe.orientation), R.copy(pe.position)) : L.type === "fakeselectout" ? (b.set(0, 1, 0), R.set(0, 9999, 0)) : N && N.isPerspectiveCamera ? (R.setFromMatrixPosition(N.matrixWorld), b.set(B.x, B.y, .5).unproject(N).sub(R).normalize()) : N && N.isOrthographicCamera ? (R.set(B.x, B.y, (N.near + N.far) / (N.near - N.far)).unproject(N), b.set(0, 0, -1).transformDirection(N.matrixWorld)) : console.error("AFRAME.Raycaster: Unsupported camera type: " + N.type), this.el.setAttribute("raycaster", I), L.type === "touchmove" && L.preventDefault()
                            }
                        }(),
                        onCursorDown: function (b) {
                            this.isCursorDown = !0, this.data.rayOrigin === "mouse" && b.type === "touchstart" && (this.onMouseMove(b), this.el.components.raycaster.checkIntersections(), b.preventDefault()), this.data.rayOrigin === "xrselect" && b.type === "selectstart" && (this.activeXRInput = b.inputSource, this.onMouseMove(b), this.el.components.raycaster.checkIntersections(), this.el.components.raycaster.intersectedEls.length && this.el.sceneEl.components["ar-hit-test"] !== void 0 && this.el.sceneEl.getAttribute("ar-hit-test").enabled && (this.el.sceneEl.setAttribute("ar-hit-test", "enabled", !1), this.reenableARHitTest = !0)), this.twoWayEmit(v.MOUSEDOWN, b), this.cursorDownEl = this.intersectedEl
                        },
                        onCursorUp: function (b) {
                            if (this.isCursorDown) {
                                this.isCursorDown = !1;
                                var B = this.data;
                                this.twoWayEmit(v.MOUSEUP, b), this.reenableARHitTest === !0 && (this.el.sceneEl.setAttribute("ar-hit-test", "enabled", !0), this.reenableARHitTest = void 0), this.cursorDownEl && this.cursorDownEl !== this.intersectedEl && (this.intersectedEventDetail.intersection = null, this.cursorDownEl.emit(v.MOUSEUP, this.intersectedEventDetail)), (!B.fuse || B.rayOrigin === "mouse" || B.rayOrigin === "xrselect") && this.intersectedEl && this.cursorDownEl === this.intersectedEl && this.twoWayEmit(v.CLICK, b), B.rayOrigin === "xrselect" && this.activeXRInput === b.inputSource && this.onMouseMove({type: "fakeselectout"}), this.activeXRInput = null, this.cursorDownEl = null, b.type === "touchend" && b.preventDefault()
                            }
                        },
                        onIntersection: function (b) {
                            var B, R = this.el, I, L, O;
                            I = b.detail.els[0] === R ? 1 : 0, O = b.detail.intersections[I], L = b.detail.els[I], L && this.intersectedEl !== L && (this.intersectedEl && (B = this.el.components.raycaster.getIntersection(this.intersectedEl), B && B.distance <= O.distance) || (this.clearCurrentIntersection(!0), this.setIntersection(L, O)))
                        },
                        onIntersectionCleared: function (b) {
                            var B = b.detail.clearedEls;
                            B.indexOf(this.intersectedEl) !== -1 && this.clearCurrentIntersection()
                        },
                        onEnterVR: function () {
                            this.clearCurrentIntersection(!0);
                            var b = this.el.sceneEl.xrSession, B = this;
                            b && this.data.rayOrigin !== "mouse" && (C.DOWN.forEach(function (R) {
                                b.addEventListener(R, B.onCursorDown)
                            }), C.UP.forEach(function (R) {
                                b.addEventListener(R, B.onCursorUp)
                            }))
                        },
                        setIntersection: function (b, B) {
                            var R = this.el, I = this.data, L = this;
                            this.intersectedEl !== b && (this.intersectedEl = b, R.addState(E.HOVERING), b.addState(E.HOVERED), this.twoWayEmit(v.MOUSEENTER), this.data.mouseCursorStylesEnabled && this.data.rayOrigin === "mouse" && this.el.sceneEl.canvas.classList.add(M), !(I.fuseTimeout === 0 || !I.fuse || I.rayOrigin === "xrselect" || I.rayOrigin === "mouse") && (R.addState(E.FUSING), this.twoWayEmit(v.FUSING), this.fuseTimeout = setTimeout(function () {
                                R.removeState(E.FUSING), L.twoWayEmit(v.CLICK)
                            }, I.fuseTimeout)))
                        },
                        clearCurrentIntersection: function (b) {
                            var B, R, I, L = this.el;
                            this.intersectedEl && (this.intersectedEl.removeState(E.HOVERED), L.removeState(E.HOVERING), L.removeState(E.FUSING), this.twoWayEmit(v.MOUSELEAVE), this.data.mouseCursorStylesEnabled && this.data.rayOrigin === "mouse" && this.el.sceneEl.canvas.classList.remove(M), this.intersectedEl = null, clearTimeout(this.fuseTimeout), b !== !0 && (I = this.el.components.raycaster.intersections, I.length !== 0 && (B = I[0].object.el === L ? 1 : 0, R = I[B], R && this.setIntersection(R.object.el, R))))
                        },
                        twoWayEmit: function (b, B) {
                            var R = this.el, I = this.intersectedEl, L;

                            function O(N, F) {
                                B instanceof MouseEvent ? N.mouseEvent = B : typeof TouchEvent < "u" && B instanceof TouchEvent && (N.touchEvent = B)
                            }

                            L = this.el.components.raycaster.getIntersection(I), this.eventDetail.intersectedEl = I, this.eventDetail.intersection = L, O(this.eventDetail), R.emit(b, this.eventDetail), I && (this.intersectedEventDetail.intersection = L, O(this.intersectedEventDetail), I.emit(b, this.intersectedEventDetail))
                        }
                    })
                },
                "./src/components/generic-tracked-controller-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/tracked-controls.js"),
                        v = w.checkControllerPresentAndSetup, E = w.emitIfAxesChanged, p = w.onButtonEvent,
                        C = "generic", M = {
                            axes: {touchpad: [0, 1], thumbstick: [2, 3]},
                            buttons: ["trigger", "squeeze", "touchpad", "thumbstick"]
                        };
                    m.exports.Component = g("generic-tracked-controller-controls", {
                        schema: {
                            hand: {default: ""},
                            defaultModel: {default: !0},
                            defaultModelColor: {default: "gray"},
                            orientationOffset: {type: "vec3"},
                            disabled: {default: !1}
                        }, after: ["tracked-controls"], mapping: M, bindMethods: function () {
                            this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        }, init: function () {
                            var b = this;
                            this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (B) {
                                p(B.detail.id, "down", b)
                            }, this.onButtonUp = function (B) {
                                p(B.detail.id, "up", b)
                            }, this.onButtonTouchStart = function (B) {
                                p(B.detail.id, "touchstart", b)
                            }, this.onButtonTouchEnd = function (B) {
                                p(B.detail.id, "touchend", b)
                            }, this.controllerPresent = !1, this.wasControllerConnected = !1, this.lastControllerCheck = 0, this.bindMethods(), this.el.addEventListener("controllerconnected", function (B) {
                                B.detail.name !== b.name && (b.wasControllerConnected = !0, b.removeEventListeners(), b.removeControllersUpdateListener())
                            })
                        }, addEventListeners: function () {
                            var b = this.el;
                            b.addEventListener("buttonchanged", this.onButtonChanged), b.addEventListener("buttondown", this.onButtonDown), b.addEventListener("buttonup", this.onButtonUp), b.addEventListener("touchstart", this.onButtonTouchStart), b.addEventListener("touchend", this.onButtonTouchEnd), b.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0
                        }, removeEventListeners: function () {
                            var b = this.el;
                            b.removeEventListener("buttonchanged", this.onButtonChanged), b.removeEventListener("buttondown", this.onButtonDown), b.removeEventListener("buttonup", this.onButtonUp), b.removeEventListener("touchstart", this.onButtonTouchStart), b.removeEventListener("touchend", this.onButtonTouchEnd), b.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1
                        }, checkIfControllerPresent: function () {
                            var b = this.data, B = b.hand ? b.hand : void 0;
                            v(this, C, {hand: B, iterateControllerProfiles: !0})
                        }, play: function () {
                            this.wasControllerConnected || (this.checkIfControllerPresent(), this.addControllersUpdateListener())
                        }, pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        }, injectTrackedControls: function () {
                            var b = this.el, B = this.data;
                            if (this.el.components["tracked-controls"]) {
                                this.removeEventListeners();
                                return
                            }
                            b.setAttribute("tracked-controls", {
                                hand: B.hand,
                                idPrefix: C,
                                orientationOffset: B.orientationOffset,
                                iterateControllerProfiles: !0
                            }), this.data.defaultModel && this.initDefaultModel()
                        }, addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, onControllersUpdate: function () {
                            this.wasControllerConnected && this.checkIfControllerPresent()
                        }, onButtonChanged: function (b) {
                            var B = this.mapping.buttons[b.detail.id];
                            B && this.el.emit(B + "changed", b.detail.state)
                        }, onAxisMoved: function (b) {
                            E(this, this.mapping.axes, b)
                        }, initDefaultModel: function () {
                            var b = this.modelEl = document.createElement("a-entity");
                            b.setAttribute("geometry", {
                                primitive: "sphere",
                                radius: .03
                            }), b.setAttribute("material", {color: this.data.color}), this.el.appendChild(b), this.el.emit("controllermodelready", {
                                name: "generic-tracked-controller-controls",
                                model: this.modelEl,
                                rayOrigin: {origin: {x: 0, y: 0, z: -.01}, direction: {x: 0, y: 0, z: -1}}
                            })
                        }
                    })
                },
                "./src/components/geometry.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").geometries, w = h("./src/core/geometry.js").geometryNames,
                        v = h("./src/core/component.js").registerComponent, E = h("./src/lib/three.js"),
                        p = new E.BufferGeometry;
                    m.exports.Component = v("geometry", {
                        schema: {
                            buffer: {default: !0},
                            primitive: {default: "box", oneOf: w, schemaChange: !0},
                            skipCache: {default: !1}
                        }, init: function () {
                            this.geometry = null
                        }, update: function (C) {
                            var M = this.data, b = this.el, B, R = this.system;
                            this.geometry && (R.unuseGeometry(C), this.geometry = null), this.geometry = R.getOrCreateGeometry(M), B = b.getObject3D("mesh"), B ? B.geometry = this.geometry : (B = new E.Mesh, B.geometry = this.geometry, this.el.getAttribute("material") || (B.material = new E.MeshStandardMaterial({
                                color: Math.random() * 16777215,
                                metalness: 0,
                                roughness: .5
                            })), b.setObject3D("mesh", B))
                        }, remove: function () {
                            this.system.unuseGeometry(this.data), this.el.getObject3D("mesh").geometry = p, this.geometry = null
                        }, updateSchema: function (C) {
                            var M = this.oldData && this.oldData.primitive, b = C.primitive, B = g[b] && g[b].schema;
                            if (!B) throw new Error("Unknown geometry schema `" + b + "`");
                            M && M === b || this.extendSchema(B)
                        }
                    })
                },
                "./src/components/gltf-model.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = h("./src/utils/index.js"), E = v.debug("components:gltf-model:warn");
                    m.exports.Component = g("gltf-model", {
                        schema: {type: "model"}, init: function () {
                            var p = this, C = this.system.getDRACOLoader(), M = this.system.getMeshoptDecoder(),
                                b = this.system.getKTX2Loader();
                            this.model = null, this.loader = new w.GLTFLoader, C && this.loader.setDRACOLoader(C), M ? this.ready = M.then(function (B) {
                                p.loader.setMeshoptDecoder(B)
                            }) : this.ready = Promise.resolve(), b && this.loader.setKTX2Loader(b)
                        }, update: function () {
                            var p = this, C = this.el, M = this.data;
                            M && (this.remove(), this.ready.then(function () {
                                p.loader.load(M, function (B) {
                                    p.model = B.scene || B.scenes[0], p.model.animations = B.animations, C.setObject3D("mesh", p.model), C.emit("model-loaded", {
                                        format: "gltf",
                                        model: p.model
                                    })
                                }, void 0, function (B) {
                                    var R = B && B.message ? B.message : "Failed to load glTF model";
                                    E(R), C.emit("model-error", {format: "gltf", src: M})
                                })
                            }))
                        }, remove: function () {
                            this.model && this.el.removeObject3D("mesh")
                        }
                    })
                },
                "./src/components/grabbable.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    g("grabbable", {
                        init: function () {
                            this.el.setAttribute("obb-collider", "centerModel: true")
                        }
                    })
                },
                "./src/components/hand-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent,
                        w = h("./src/constants/index.js").AFRAME_CDN_ROOT, v = {
                            toonLeft: w + "controllers/hands/leftHand.glb",
                            toonRight: w + "controllers/hands/rightHand.glb",
                            lowPolyLeft: w + "controllers/hands/leftHandLow.glb",
                            lowPolyRight: w + "controllers/hands/rightHandLow.glb",
                            highPolyLeft: w + "controllers/hands/leftHandHigh.glb",
                            highPolyRight: w + "controllers/hands/rightHandHigh.glb"
                        }, E = {
                            open: "Open",
                            point: "Point",
                            pointThumb: "Point + Thumb",
                            fist: "Fist",
                            hold: "Hold",
                            thumbUp: "Thumb Up"
                        }, p = {};
                    p[E.fist] = "grip", p[E.thumbUp] = "pistol", p[E.point] = "pointing", m.exports.Component = g("hand-controls", {
                        schema: {
                            color: {default: "white", type: "color"},
                            hand: {default: "left"},
                            handModelStyle: {default: "lowPoly", oneOf: ["lowPoly", "highPoly", "toon"]}
                        }, after: ["tracked-controls"], init: function () {
                            var b = this, B = this.el;
                            this.pressedButtons = {}, this.touchedButtons = {}, this.loader = new THREE.GLTFLoader, this.loader.setCrossOrigin("anonymous"), this.onGripDown = function () {
                                b.handleButton("grip", "down")
                            }, this.onGripUp = function () {
                                b.handleButton("grip", "up")
                            }, this.onTrackpadDown = function () {
                                b.handleButton("trackpad", "down")
                            }, this.onTrackpadUp = function () {
                                b.handleButton("trackpad", "up")
                            }, this.onTrackpadTouchStart = function () {
                                b.handleButton("trackpad", "touchstart")
                            }, this.onTrackpadTouchEnd = function () {
                                b.handleButton("trackpad", "touchend")
                            }, this.onTriggerDown = function () {
                                b.handleButton("trigger", "down")
                            }, this.onTriggerUp = function () {
                                b.handleButton("trigger", "up")
                            }, this.onTriggerTouchStart = function () {
                                b.handleButton("trigger", "touchstart")
                            }, this.onTriggerTouchEnd = function () {
                                b.handleButton("trigger", "touchend")
                            }, this.onGripTouchStart = function () {
                                b.handleButton("grip", "touchstart")
                            }, this.onGripTouchEnd = function () {
                                b.handleButton("grip", "touchend")
                            }, this.onThumbstickDown = function () {
                                b.handleButton("thumbstick", "down")
                            }, this.onThumbstickUp = function () {
                                b.handleButton("thumbstick", "up")
                            }, this.onAorXTouchStart = function () {
                                b.handleButton("AorX", "touchstart")
                            }, this.onAorXTouchEnd = function () {
                                b.handleButton("AorX", "touchend")
                            }, this.onBorYTouchStart = function () {
                                b.handleButton("BorY", "touchstart")
                            }, this.onBorYTouchEnd = function () {
                                b.handleButton("BorY", "touchend")
                            }, this.onSurfaceTouchStart = function () {
                                b.handleButton("surface", "touchstart")
                            }, this.onSurfaceTouchEnd = function () {
                                b.handleButton("surface", "touchend")
                            }, this.onControllerConnected = this.onControllerConnected.bind(this), this.onControllerDisconnected = this.onControllerDisconnected.bind(this), B.addEventListener("controllerconnected", this.onControllerConnected), B.addEventListener("controllerdisconnected", this.onControllerDisconnected), B.object3D.visible = !1
                        }, play: function () {
                            this.addEventListeners()
                        }, pause: function () {
                            this.removeEventListeners()
                        }, tick: function (b, B) {
                            var R = this.el.getObject3D("mesh");
                            !R || !R.mixer || R.mixer.update(B / 1e3)
                        }, onControllerConnected: function () {
                            this.el.object3D.visible = !0
                        }, onControllerDisconnected: function () {
                            this.el.object3D.visible = !1
                        }, addEventListeners: function () {
                            var b = this.el;
                            b.addEventListener("gripdown", this.onGripDown), b.addEventListener("gripup", this.onGripUp), b.addEventListener("trackpaddown", this.onTrackpadDown), b.addEventListener("trackpadup", this.onTrackpadUp), b.addEventListener("trackpadtouchstart", this.onTrackpadTouchStart), b.addEventListener("trackpadtouchend", this.onTrackpadTouchEnd), b.addEventListener("triggerdown", this.onTriggerDown), b.addEventListener("triggerup", this.onTriggerUp), b.addEventListener("triggertouchstart", this.onTriggerTouchStart), b.addEventListener("triggertouchend", this.onTriggerTouchEnd), b.addEventListener("griptouchstart", this.onGripTouchStart), b.addEventListener("griptouchend", this.onGripTouchEnd), b.addEventListener("thumbstickdown", this.onThumbstickDown), b.addEventListener("thumbstickup", this.onThumbstickUp), b.addEventListener("abuttontouchstart", this.onAorXTouchStart), b.addEventListener("abuttontouchend", this.onAorXTouchEnd), b.addEventListener("bbuttontouchstart", this.onBorYTouchStart), b.addEventListener("bbuttontouchend", this.onBorYTouchEnd), b.addEventListener("xbuttontouchstart", this.onAorXTouchStart), b.addEventListener("xbuttontouchend", this.onAorXTouchEnd), b.addEventListener("ybuttontouchstart", this.onBorYTouchStart), b.addEventListener("ybuttontouchend", this.onBorYTouchEnd), b.addEventListener("surfacetouchstart", this.onSurfaceTouchStart), b.addEventListener("surfacetouchend", this.onSurfaceTouchEnd)
                        }, removeEventListeners: function () {
                            var b = this.el;
                            b.removeEventListener("gripdown", this.onGripDown), b.removeEventListener("gripup", this.onGripUp), b.removeEventListener("trackpaddown", this.onTrackpadDown), b.removeEventListener("trackpadup", this.onTrackpadUp), b.removeEventListener("trackpadtouchstart", this.onTrackpadTouchStart), b.removeEventListener("trackpadtouchend", this.onTrackpadTouchEnd), b.removeEventListener("triggerdown", this.onTriggerDown), b.removeEventListener("triggerup", this.onTriggerUp), b.removeEventListener("triggertouchstart", this.onTriggerTouchStart), b.removeEventListener("triggertouchend", this.onTriggerTouchEnd), b.removeEventListener("griptouchstart", this.onGripTouchStart), b.removeEventListener("griptouchend", this.onGripTouchEnd), b.removeEventListener("thumbstickdown", this.onThumbstickDown), b.removeEventListener("thumbstickup", this.onThumbstickUp), b.removeEventListener("abuttontouchstart", this.onAorXTouchStart), b.removeEventListener("abuttontouchend", this.onAorXTouchEnd), b.removeEventListener("bbuttontouchstart", this.onBorYTouchStart), b.removeEventListener("bbuttontouchend", this.onBorYTouchEnd), b.removeEventListener("xbuttontouchstart", this.onAorXTouchStart), b.removeEventListener("xbuttontouchend", this.onAorXTouchEnd), b.removeEventListener("ybuttontouchstart", this.onBorYTouchStart), b.removeEventListener("ybuttontouchend", this.onBorYTouchEnd), b.removeEventListener("surfacetouchstart", this.onSurfaceTouchStart), b.removeEventListener("surfacetouchend", this.onSurfaceTouchEnd)
                        }, update: function (b) {
                            var B, R = this.el, I = this.data.hand, L = this.data.handModelStyle, O = this.data.color,
                                N = this;
                            if (B = {hand: I, model: !1}, I !== b) {
                                var F = v[L + I.charAt(0).toUpperCase() + I.slice(1)];
                                this.loader.load(F, function (V) {
                                    var U = V.scene.children[0], j = I === "left" ? Math.PI / 2 : -Math.PI / 2,
                                        Y = R.sceneEl.hasWebXR ? -Math.PI / 2 : 0;
                                    U.mixer = new THREE.AnimationMixer(U), N.clips = V.animations, R.setObject3D("mesh", U), U.traverse(function (fe) {
                                        fe.isMesh && (fe.material.color = new THREE.Color(O))
                                    }), U.position.set(0, 0, 0), U.rotation.set(Y, 0, j), R.setAttribute("magicleap-controls", B), R.setAttribute("vive-controls", B), R.setAttribute("oculus-touch-controls", B), R.setAttribute("pico-controls", B), R.setAttribute("windows-motion-controls", B), R.setAttribute("hp-mixed-reality-controls", B)
                                })
                            }
                        }, remove: function () {
                            this.el.removeObject3D("mesh")
                        }, handleButton: function (b, B) {
                            var R, I = B === "down", L = B === "touchstart";
                            if (B.indexOf("touch") === 0) {
                                if (L === this.touchedButtons[b]) return;
                                this.touchedButtons[b] = L
                            } else {
                                if (I === this.pressedButtons[b]) return;
                                this.pressedButtons[b] = I
                            }
                            R = this.gesture, this.gesture = this.determineGesture(), this.gesture !== R && (this.animateGesture(this.gesture, R), this.emitGestureEvents(this.gesture, R))
                        }, determineGesture: function () {
                            var b, B = this.pressedButtons.grip,
                                R = this.pressedButtons.surface || this.touchedButtons.surface,
                                I = this.pressedButtons.trackpad || this.touchedButtons.trackpad,
                                L = this.pressedButtons.trigger || this.touchedButtons.trigger,
                                O = this.touchedButtons.AorX || this.touchedButtons.BorY,
                                N = M(this.el.components["tracked-controls"]);
                            return N ? B || L ? b = E.fist : I && (b = E.point) : B ? R || O || I ? b = L ? E.fist : E.point : b = L ? E.thumbUp : E.pointThumb : L && (b = E.hold), b
                        }, getClip: function (b) {
                            var B, R;
                            for (R = 0; R < this.clips.length; R++) if (B = this.clips[R], B.name === b) return B
                        }, animateGesture: function (b, B) {
                            if (b) {
                                this.playAnimation(b || E.open, B, !1);
                                return
                            }
                            this.playAnimation(B, B, !0)
                        }, emitGestureEvents: function (b, B) {
                            var R = this.el, I;
                            B !== b && (I = C(B, !1), I && R.emit(I), I = C(b, !0), I && R.emit(I))
                        }, playAnimation: function (b, B, R) {
                            var I, L, O = this.el.getObject3D("mesh"), N;
                            if (O) {
                                if (I = this.getClip(b), N = O.mixer.clipAction(I), R) {
                                    N.paused = !1, N.timeScale = -1;
                                    return
                                }
                                if (N.clampWhenFinished = !0, N.loop = THREE.LoopOnce, N.repetitions = 0, N.timeScale = 1, N.time = 0, N.weight = 1, !B) {
                                    O.mixer.stopAllAction(), N.play();
                                    return
                                }
                                I = this.getClip(B), N.reset(), N.play(), L = O.mixer.clipAction(I), L.crossFadeTo(N, .15, !0)
                            }
                        }
                    });

                    function C(b, B) {
                        var R;
                        if (b) {
                            if (R = p[b], R === "grip") return R + (B ? "close" : "open");
                            if (R === "point") return R + (B ? "up" : "down");
                            if (R === "pointing" || R === "pistol") return R + (B ? "start" : "end")
                        }
                    }

                    function M(b) {
                        var B = b && b.controller,
                            R = B && (B.id && B.id.indexOf("OpenVR ") === 0 || B.profiles && B.profiles[0] && B.profiles[0] === "htc-vive");
                        return R
                    }
                },
                "./src/components/hand-tracking-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/core/a-entity.js").AEntity,
                        v = h("./src/utils/tracked-controls.js"), E = v.checkControllerPresentAndSetup,
                        p = h("./src/constants/index.js").AFRAME_CDN_ROOT,
                        C = p + "controllers/oculus-hands/v4/left.glb", M = p + "controllers/oculus-hands/v4/right.glb",
                        b = ["wrist", "thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip", "index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip", "middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip", "ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip", "pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"],
                        B = 0, R = 4, I = 9, L = .015, O = .1;
                    m.exports.Component = g("hand-tracking-controls", {
                        schema: {
                            hand: {default: "right", oneOf: ["left", "right"]},
                            modelStyle: {default: "mesh", oneOf: ["dots", "mesh"]},
                            modelColor: {default: "white"},
                            modelOpacity: {default: 1}
                        }, after: ["tracked-controls"], bindMethods: function () {
                            this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this)
                        }, addEventListeners: function () {
                            this.el.addEventListener("model-loaded", this.onModelLoaded);
                            for (var N = 0; N < this.jointEls.length; ++N) this.jointEls[N].object3D.visible = !0
                        }, removeEventListeners: function () {
                            this.el.removeEventListener("model-loaded", this.onModelLoaded);
                            for (var N = 0; N < this.jointEls.length; ++N) this.jointEls[N].object3D.visible = !1
                        }, init: function () {
                            var N = this.el.sceneEl, F = N.getAttribute("webxr"), V = F.optionalFeatures;
                            V.indexOf("hand-tracking") === -1 && (V.push("hand-tracking"), N.setAttribute("webxr", F)), this.wristObject3D = new THREE.Object3D, this.el.sceneEl.object3D.add(this.wristObject3D), this.onModelLoaded = this.onModelLoaded.bind(this), this.onChildAttached = this.onChildAttached.bind(this), this.jointEls = [], this.controllerPresent = !1, this.isPinched = !1, this.pinchEventDetail = {
                                position: new THREE.Vector3,
                                wristRotation: new THREE.Quaternion
                            }, this.indexTipPosition = new THREE.Vector3, this.hasPoses = !1, this.jointPoses = new Float32Array(16 * b.length), this.jointRadii = new Float32Array(b.length), this.bindMethods(), this.updateReferenceSpace = this.updateReferenceSpace.bind(this), this.el.sceneEl.addEventListener("enter-vr", this.updateReferenceSpace), this.el.sceneEl.addEventListener("exit-vr", this.updateReferenceSpace), this.el.addEventListener("child-attached", this.onChildAttached), this.el.object3D.visible = !1, this.wristObject3D.visible = !1
                        }, onChildAttached: function (N) {
                            this.addChildEntity(N.detail.el)
                        }, update: function () {
                            this.updateModelMaterial()
                        }, updateModelMaterial: function () {
                            var N = this.jointEls, F = this.skinnedMesh, V = this.data.modelOpacity !== 1;
                            F && (this.skinnedMesh.material.color.set(this.data.modelColor), this.skinnedMesh.material.transparent = V, this.skinnedMesh.material.opacity = this.data.modelOpacity);
                            for (var U = 0; U < N.length; U++) N[U].setAttribute("material", {
                                color: this.data.modelColor,
                                transparent: V,
                                opacity: this.data.modelOpacity
                            })
                        }, updateReferenceSpace: function () {
                            var N = this, F = this.el.sceneEl.xrSession;
                            if (this.referenceSpace = void 0, !!F) {
                                var V = N.el.sceneEl.systems.webxr.sessionReferenceSpaceType;
                                F.requestReferenceSpace(V).then(function (U) {
                                    N.referenceSpace = U
                                }).catch(function (U) {
                                    throw N.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(V, "tracked-controls-webxr uses reference space " + V), U
                                })
                            }
                        }, checkIfControllerPresent: function () {
                            var N = this.data, F = N.hand ? N.hand : void 0;
                            E(this, "", {hand: F, iterateControllerProfiles: !0, handTracking: !0})
                        }, play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        }, tick: function () {
                            var N = this.el.sceneEl,
                                F = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller,
                                V = N.frame, U = this.el.components["tracked-controls-webxr"], j = this.referenceSpace;
                            !F || !V || !j || !U || (this.hasPoses = !1, F.hand && (this.el.object3D.position.set(0, 0, 0), this.el.object3D.rotation.set(0, 0, 0), this.hasPoses = V.fillPoses(F.hand.values(), j, this.jointPoses) && V.fillJointRadii(F.hand.values(), this.jointRadii), this.updateHandModel(), this.detectGesture(), this.updateWristObject()))
                        }, updateWristObject: function () {
                            var N = new THREE.Matrix4;
                            return function () {
                                var F = this.wristObject3D;
                                !F || !this.hasPoses || (N.fromArray(this.jointPoses, B * 16), F.position.setFromMatrixPosition(N), F.quaternion.setFromRotationMatrix(N))
                            }
                        }(), updateHandModel: function () {
                            this.data.modelStyle === "dots" && this.updateHandDotsModel(), this.data.modelStyle === "mesh" && this.updateHandMeshModel()
                        }, getBone: function (N) {
                            for (var F = this.bones, V = 0; V < F.length; V++) if (F[V].name === N) return F[V];
                            return null
                        }, updateHandMeshModel: function () {
                            var N = new THREE.Matrix4;
                            return function () {
                                var F = 0, V = this.jointPoses,
                                    U = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller;
                                if (!(!U || !this.mesh) && (this.mesh.visible = !1, !!this.hasPoses)) for (var j of U.hand.values()) {
                                    var Y = this.getBone(j.jointName);
                                    Y != null && (this.mesh.visible = !0, N.fromArray(V, F * 16), Y.position.setFromMatrixPosition(N), Y.quaternion.setFromRotationMatrix(N)), F++
                                }
                            }
                        }(), updateHandDotsModel: function () {
                            for (var N = this.jointPoses, F = this.jointRadii, V = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller, U, j, Y = 0; Y < V.hand.size; Y++) U = this.jointEls[Y], j = U.object3D, U.object3D.visible = this.hasPoses, this.hasPoses && (j.matrix.fromArray(N, Y * 16), j.matrix.decompose(j.position, j.rotation, j.scale), U.setAttribute("scale", {
                                x: F[Y],
                                y: F[Y],
                                z: F[Y]
                            }))
                        }, detectGesture: function () {
                            this.detectPinch()
                        }, detectPinch: function () {
                            var N = new THREE.Vector3, F = new THREE.Matrix4;
                            return function () {
                                var V = this.indexTipPosition, U = this.pinchEventDetail;
                                if (this.hasPoses) {
                                    N.setFromMatrixPosition(F.fromArray(this.jointPoses, R * 16)), V.setFromMatrixPosition(F.fromArray(this.jointPoses, I * 16)), U.wristRotation.setFromRotationMatrix(F.fromArray(this.jointPoses, B * 16));
                                    var j = V.distanceTo(N);
                                    j < L && this.isPinched === !1 && (this.isPinched = !0, this.pinchDistance = j, U.position.copy(V).add(N).multiplyScalar(.5), this.el.emit("pinchstarted", U)), j > this.pinchDistance + this.pinchDistance * O && this.isPinched === !0 && (this.isPinched = !1, U.position.copy(V).add(N).multiplyScalar(.5), this.el.emit("pinchended", U)), this.isPinched && (U.position.copy(V).add(N).multiplyScalar(.5), this.el.emit("pinchmoved", U))
                                }
                            }
                        }(), pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        }, injectTrackedControls: function () {
                            var N = this.el, F = this.data;
                            if (N.setAttribute("tracked-controls", {
                                id: "",
                                hand: F.hand,
                                iterateControllerProfiles: !0,
                                handTrackingEnabled: !0
                            }), this.mesh) {
                                this.mesh !== N.getObject3D("mesh") && N.setObject3D("mesh", this.mesh);
                                return
                            }
                            this.initDefaultModel()
                        }, addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, onControllersUpdate: function () {
                            var N = this.el, F;
                            this.checkIfControllerPresent(), F = N.components["tracked-controls"] && N.components["tracked-controls"].controller, this.mesh && F && F.hand && F.hand instanceof XRHand && N.setObject3D("mesh", this.mesh)
                        }, initDefaultModel: function () {
                            var N = this.data;
                            N.modelStyle === "dots" && this.initDotsModel(), N.modelStyle === "mesh" && this.initMeshHandModel(), this.el.object3D.visible = !0, this.wristObject3D.visible = !0
                        }, initDotsModel: function () {
                            if (this.jointEls.length === 0) {
                                for (var N = 0; N < b.length; ++N) {
                                    var F = this.jointEl = document.createElement("a-entity");
                                    F.setAttribute("geometry", {
                                        primitive: "sphere",
                                        radius: 1
                                    }), F.object3D.visible = !1, this.el.appendChild(F), this.jointEls.push(F)
                                }
                                this.updateModelMaterial()
                            }
                        }, initMeshHandModel: function () {
                            var N = this.data.hand === "left" ? C : M;
                            this.el.setAttribute("gltf-model", N)
                        }, onModelLoaded: function () {
                            var N = this.mesh = this.el.getObject3D("mesh").children[0],
                                F = this.skinnedMesh = N.getObjectByProperty("type", "SkinnedMesh");
                            this.skinnedMesh && (this.bones = F.skeleton.bones, this.el.removeObject3D("mesh"), N.position.set(0, 0, 0), N.rotation.set(0, 0, 0), F.frustumCulled = !1, F.material = new THREE.MeshStandardMaterial, this.updateModelMaterial(), this.setupChildrenEntities(), this.el.setObject3D("mesh", N))
                        }, setupChildrenEntities: function () {
                            for (var N = this.el.children, F = 0; F < N.length; ++F) N[F] instanceof w && this.addChildEntity(N[F])
                        }, addChildEntity: function (N) {
                            N instanceof w && this.wristObject3D.add(N.object3D)
                        }
                    })
                },
                "./src/components/hand-tracking-grab-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js");
                    g("hand-tracking-grab-controls", {
                        schema: {
                            hand: {default: "right", oneOf: ["left", "right"]},
                            color: {type: "color", default: "white"},
                            hoverColor: {type: "color", default: "#538df1"},
                            hoverEnabled: {default: !1}
                        }, init: function () {
                            var v = this.el, E = this.data, p;
                            E.hand === "right" ? p = "components.hand-tracking-controls.bones.3" : p = "components.hand-tracking-controls.bones.21", v.setAttribute("hand-tracking-controls", {hand: E.hand}), v.setAttribute("obb-collider", {
                                trackedObject3D: p,
                                size: .04
                            }), this.auxMatrix = new w.Matrix4, this.auxQuaternion = new w.Quaternion, this.auxQuaternion2 = new w.Quaternion, this.auxVector = new w.Vector3, this.auxVector2 = new w.Vector3, this.grabbingObjectPosition = new w.Vector3, this.grabbedObjectPosition = new w.Vector3, this.grabbedObjectPositionDelta = new w.Vector3, this.grabDeltaPosition = new w.Vector3, this.grabInitialRotation = new w.Quaternion, this.onCollisionStarted = this.onCollisionStarted.bind(this), this.el.addEventListener("obbcollisionstarted", this.onCollisionStarted), this.onCollisionEnded = this.onCollisionEnded.bind(this), this.el.addEventListener("obbcollisionended", this.onCollisionEnded), this.onPinchStarted = this.onPinchStarted.bind(this), this.el.addEventListener("pinchstarted", this.onPinchStarted), this.onPinchEnded = this.onPinchEnded.bind(this), this.el.addEventListener("pinchended", this.onPinchEnded), this.onPinchMoved = this.onPinchMoved.bind(this), this.el.addEventListener("pinchmoved", this.onPinchMoved)
                        }, transferEntityOwnership: function () {
                            for (var v, E = this.el.sceneEl.querySelectorAll("[hand-tracking-grab-controls]"), p = 0; p < E.length; ++p) v = E[p].components["hand-tracking-grab-controls"], v !== this && this.grabbedEl && this.grabbedEl === v.grabbedEl && v.releaseGrabbedEntity();
                            return !1
                        }, onCollisionStarted: function (v) {
                            var E = v.detail.withEl;
                            this.collidedEl || E.getAttribute("grabbable") && (this.collidedEl = E, this.grabbingObject3D = v.detail.trackedObject3D, this.data.hoverEnabled && this.el.setAttribute("hand-tracking-controls", "modelColor", this.data.hoverColor))
                        }, onCollisionEnded: function () {
                            this.collidedEl = void 0, !this.grabbedEl && (this.grabbingObject3D = void 0, this.data.hoverEnabled && this.el.setAttribute("hand-tracking-controls", "modelColor", this.data.color))
                        }, onPinchStarted: function (v) {
                            this.collidedEl && (this.pinchPosition = v.detail.position, this.wristRotation = v.detail.wristRotation, this.grabbedEl = this.collidedEl, this.transferEntityOwnership(), this.grab())
                        }, onPinchEnded: function () {
                            this.releaseGrabbedEntity()
                        }, onPinchMoved: function (v) {
                            this.wristRotation = v.detail.wristRotation
                        }, releaseGrabbedEntity: function () {
                            var v = this.grabbedEl;
                            v && (v.object3D.updateMatrixWorld = this.originalUpdateMatrixWorld, v.object3D.matrixAutoUpdate = !0, v.object3D.matrixWorldAutoUpdate = !0, v.object3D.matrixWorld.decompose(this.auxVector, this.auxQuaternion, this.auxVector2), v.object3D.position.copy(this.auxVector), v.object3D.quaternion.copy(this.auxQuaternion), this.el.emit("grabended", {grabbedEl: v}), this.grabbedEl = void 0)
                        }, grab: function () {
                            var v = this.grabbedEl, E;
                            E = v.object3D.getWorldPosition(this.grabbedObjectPosition), this.grabDeltaPosition.copy(E).sub(this.pinchPosition), this.grabInitialRotation.copy(this.auxQuaternion.copy(this.wristRotation).invert()), this.originalUpdateMatrixWorld = v.object3D.updateMatrixWorld, v.object3D.updateMatrixWorld = function () {
                            }, v.object3D.updateMatrixWorldChildren = function (p) {
                                for (var C = this.children, M = 0, b = C.length; M < b; M++) {
                                    var B = C[M];
                                    (B.matrixWorldAutoUpdate === !0 || p === !0) && B.updateMatrixWorld(!0)
                                }
                            }, v.object3D.matrixAutoUpdate = !1, v.object3D.matrixWorldAutoUpdate = !1, this.el.emit("grabstarted", {grabbedEl: v})
                        }, tock: function () {
                            var v = this.auxMatrix, E = this.auxQuaternion, p = this.auxQuaternion2, C,
                                M = this.grabbedEl;
                            M && (C = M.object3D, C.getWorldQuaternion(p), C.matrixWorld.identity(), v.identity(), v.makeTranslation(this.pinchPosition), C.matrixWorld.multiply(v), v.identity(), v.makeRotationFromQuaternion(E.copy(this.wristRotation).multiply(this.grabInitialRotation)), C.matrixWorld.multiply(v), v.identity(), v.makeTranslation(this.grabDeltaPosition), C.matrixWorld.multiply(v), v.identity(), v.makeRotationFromQuaternion(p), C.matrixWorld.multiply(v), v.makeScale(M.object3D.scale.x, M.object3D.scale.y, M.object3D.scale.z), C.matrixWorld.multiply(v), C.updateMatrixWorldChildren())
                        }
                    })
                },
                "./src/components/hide-on-enter-ar.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("hide-on-enter-ar", {
                        init: function () {
                            var w = this;
                            this.el.sceneEl.addEventListener("enter-vr", function () {
                                w.el.sceneEl.is("ar-mode") && (w.el.object3D.visible = !1)
                            }), this.el.sceneEl.addEventListener("exit-vr", function () {
                                w.el.object3D.visible = !0
                            })
                        }
                    })
                },
                "./src/components/hide-on-enter-vr.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("hide-on-enter-vr", {
                        init: function () {
                            var w = this;
                            this.el.sceneEl.addEventListener("enter-vr", function () {
                                w.el.sceneEl.is("vr-mode") && (w.el.object3D.visible = !1)
                            }), this.el.sceneEl.addEventListener("exit-vr", function () {
                                w.el.object3D.visible = !0
                            })
                        }
                    })
                },
                "./src/components/hp-mixed-reality-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = h("./src/utils/tracked-controls.js"), E = v.checkControllerPresentAndSetup,
                        p = v.emitIfAxesChanged, C = v.onButtonEvent, M = "hp-mixed-reality",
                        b = h("./src/constants/index.js").AFRAME_CDN_ROOT, B = b + "controllers/hp/mixed-reality/",
                        R = {x: 0, y: 0, z: .06}, I = {_x: Math.PI / 4, _y: 0, _z: 0, _order: "XYZ"}, L = {
                            left: {
                                axes: {touchpad: [2, 3]},
                                buttons: ["trigger", "grip", "none", "thumbstick", "xbutton", "ybutton"]
                            },
                            right: {
                                axes: {touchpad: [2, 3]},
                                buttons: ["trigger", "grip", "none", "thumbstick", "abutton", "bbutton"]
                            }
                        };
                    m.exports.Component = g("hp-mixed-reality-controls", {
                        schema: {hand: {default: "none"}, model: {default: !0}, orientationOffset: {type: "vec3"}},
                        mapping: L,
                        init: function () {
                            var O = this;
                            this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (N) {
                                C(N.detail.id, "down", O, O.data.hand)
                            }, this.onButtonUp = function (N) {
                                C(N.detail.id, "up", O, O.data.hand)
                            }, this.onButtonTouchEnd = function (N) {
                                C(N.detail.id, "touchend", O, O.data.hand)
                            }, this.onButtonTouchStart = function (N) {
                                C(N.detail.id, "touchstart", O, O.data.hand)
                            }, this.previousButtonValues = {}, this.bindMethods()
                        },
                        update: function () {
                            var O = this.data;
                            this.controllerIndex = O.hand === "right" ? 0 : O.hand === "left" ? 1 : 2
                        },
                        play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        },
                        pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        },
                        bindMethods: function () {
                            this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        },
                        addEventListeners: function () {
                            var O = this.el;
                            O.addEventListener("buttonchanged", this.onButtonChanged), O.addEventListener("buttondown", this.onButtonDown), O.addEventListener("buttonup", this.onButtonUp), O.addEventListener("touchstart", this.onButtonTouchStart), O.addEventListener("touchend", this.onButtonTouchEnd), O.addEventListener("axismove", this.onAxisMoved), O.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0
                        },
                        removeEventListeners: function () {
                            var O = this.el;
                            O.removeEventListener("buttonchanged", this.onButtonChanged), O.removeEventListener("buttondown", this.onButtonDown), O.removeEventListener("buttonup", this.onButtonUp), O.removeEventListener("touchstart", this.onButtonTouchStart), O.removeEventListener("touchend", this.onButtonTouchEnd), O.removeEventListener("axismove", this.onAxisMoved), O.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1
                        },
                        checkIfControllerPresent: function () {
                            var O = this.data;
                            E(this, M, {index: this.controllerIndex, hand: O.hand})
                        },
                        injectTrackedControls: function () {
                            var O = this.el, N = this.data;
                            O.setAttribute("tracked-controls", {
                                idPrefix: M,
                                hand: N.hand,
                                controller: this.controllerIndex,
                                orientationOffset: N.orientationOffset
                            }), this.data.model && this.el.setAttribute("gltf-model", B + this.data.hand + ".glb")
                        },
                        addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        },
                        removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        },
                        onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        },
                        onButtonChanged: function (O) {
                            var N = this.mapping[this.data.hand].buttons[O.detail.id], F;
                            N && (N === "trigger" && (F = O.detail.state.value, console.log("analog value of trigger press: " + F)), this.el.emit(N + "changed", O.detail.state))
                        },
                        onModelLoaded: function (O) {
                            var N = O.detail.model;
                            this.data.model && (N.position.copy(R), N.rotation.copy(I), this.el.emit("controllermodelready", {
                                name: "hp-mixed-reality-controls",
                                model: this.data.model,
                                rayOrigin: new w.Vector3(0, 0, 0)
                            }))
                        },
                        onAxisMoved: function (O) {
                            p(this, this.mapping.axes, O)
                        }
                    })
                },
                "./src/components/index.js": (m, x, h) => {
                    h("./src/components/animation.js"), h("./src/components/anchored.js"), h("./src/components/camera.js"), h("./src/components/cursor.js"), h("./src/components/geometry.js"), h("./src/components/generic-tracked-controller-controls.js"), h("./src/components/gltf-model.js"), h("./src/components/grabbable.js"), h("./src/components/hand-tracking-controls.js"), h("./src/components/hand-tracking-grab-controls.js"), h("./src/components/hand-controls.js"), h("./src/components/hide-on-enter-ar.js"), h("./src/components/hide-on-enter-vr.js"), h("./src/components/hp-mixed-reality-controls.js"), h("./src/components/layer.js"), h("./src/components/laser-controls.js"), h("./src/components/light.js"), h("./src/components/line.js"), h("./src/components/link.js"), h("./src/components/look-controls.js"), h("./src/components/magicleap-controls.js"), h("./src/components/material.js"), h("./src/components/obb-collider.js"), h("./src/components/obj-model.js"), h("./src/components/oculus-go-controls.js"), h("./src/components/oculus-touch-controls.js"), h("./src/components/pico-controls.js"), h("./src/components/position.js"), h("./src/components/raycaster.js"), h("./src/components/rotation.js"), h("./src/components/scale.js"), h("./src/components/shadow.js"), h("./src/components/sound.js"), h("./src/components/text.js"), h("./src/components/tracked-controls.js"), h("./src/components/tracked-controls-webvr.js"), h("./src/components/tracked-controls-webxr.js"), h("./src/components/visible.js"), h("./src/components/valve-index-controls.js"), h("./src/components/vive-controls.js"), h("./src/components/vive-focus-controls.js"), h("./src/components/wasd-controls.js"), h("./src/components/windows-motion-controls.js"), h("./src/components/scene/ar-hit-test.js"), h("./src/components/scene/background.js"), h("./src/components/scene/debug.js"), h("./src/components/scene/device-orientation-permission-ui.js"), h("./src/components/scene/embedded.js"), h("./src/components/scene/inspector.js"), h("./src/components/scene/fog.js"), h("./src/components/scene/keyboard-shortcuts.js"), h("./src/components/scene/pool.js"), h("./src/components/scene/real-world-meshing.js"), h("./src/components/scene/reflection.js"), h("./src/components/scene/screenshot.js"), h("./src/components/scene/stats.js"), h("./src/components/scene/xr-mode-ui.js")
                },
                "./src/components/laser-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/index.js");
                    g("laser-controls", {
                        schema: {
                            hand: {default: "right"},
                            model: {default: !0},
                            defaultModelColor: {type: "color", default: "grey"}
                        }, init: function () {
                            var v = this.config, E = this.data, p = this.el, C = this,
                                M = {hand: E.hand, model: E.model};
                            p.setAttribute("hp-mixed-reality-controls", M), p.setAttribute("magicleap-controls", M), p.setAttribute("oculus-go-controls", M), p.setAttribute("oculus-touch-controls", M), p.setAttribute("pico-controls", M), p.setAttribute("valve-index-controls", M), p.setAttribute("vive-controls", M), p.setAttribute("vive-focus-controls", M), p.setAttribute("windows-motion-controls", M), p.setAttribute("generic-tracked-controller-controls", {hand: M.hand}), p.addEventListener("controllerconnected", b), p.addEventListener("controllerdisconnected", B), p.addEventListener("controllermodelready", function (R) {
                                b(R), C.modelReady = !0
                            });

                            function b(R) {
                                var I = v[R.detail.name];
                                if (I) {
                                    var L = w.extend({showLine: !0}, I.raycaster || {});
                                    R.detail.rayOrigin && (L.origin = R.detail.rayOrigin.origin, L.direction = R.detail.rayOrigin.direction, L.showLine = !0), R.detail.rayOrigin || !C.modelReady ? p.setAttribute("raycaster", L) : p.setAttribute("raycaster", "showLine", !0), p.setAttribute("cursor", w.extend({fuse: !1}, I.cursor))
                                }
                            }

                            function B(R) {
                                var I = v[R.detail.name];
                                I && p.setAttribute("raycaster", "showLine", !1)
                            }
                        }, config: {
                            "generic-tracked-controller-controls": {
                                cursor: {
                                    downEvents: ["triggerdown"],
                                    upEvents: ["triggerup"]
                                }
                            },
                            "hp-mixed-reality-controls": {
                                cursor: {
                                    downEvents: ["triggerdown"],
                                    upEvents: ["triggerup"]
                                }, raycaster: {origin: {x: 0, y: 0, z: 0}}
                            },
                            "magicleap-controls": {
                                cursor: {
                                    downEvents: ["trackpaddown", "triggerdown"],
                                    upEvents: ["trackpadup", "triggerup"]
                                }
                            },
                            "oculus-go-controls": {
                                cursor: {downEvents: ["triggerdown"], upEvents: ["triggerup"]},
                                raycaster: {origin: {x: 0, y: 5e-4, z: 0}}
                            },
                            "oculus-touch-controls": {
                                cursor: {downEvents: ["triggerdown"], upEvents: ["triggerup"]},
                                raycaster: {origin: {x: 0, y: 0, z: 0}}
                            },
                            "pico-controls": {cursor: {downEvents: ["triggerdown"], upEvents: ["triggerup"]}},
                            "valve-index-controls": {cursor: {downEvents: ["triggerdown"], upEvents: ["triggerup"]}},
                            "vive-controls": {cursor: {downEvents: ["triggerdown"], upEvents: ["triggerup"]}},
                            "vive-focus-controls": {
                                cursor: {
                                    downEvents: ["trackpaddown", "triggerdown"],
                                    upEvents: ["trackpadup", "triggerup"]
                                }
                            },
                            "windows-motion-controls": {
                                cursor: {downEvents: ["triggerdown"], upEvents: ["triggerup"]},
                                raycaster: {showLine: !1}
                            }
                        }
                    })
                },
                "./src/components/layer.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/index.js"),
                        v = w.debug("components:layer:warn");
                    m.exports.Component = g("layer", {
                        schema: {
                            type: {default: "quad", oneOf: ["quad", "monocubemap", "stereocubemap"]},
                            src: {type: "map"},
                            rotateCubemap: {default: !1},
                            width: {default: 0},
                            height: {default: 0}
                        }, init: function () {
                            var p = this.el.sceneEl.renderer.getContext();
                            this.quaternion = new THREE.Quaternion, this.position = new THREE.Vector3, this.bindMethods(), this.needsRedraw = !1, this.frameBuffer = p.createFramebuffer();
                            var C = this.el.sceneEl.getAttribute("webxr"), M = C.requiredFeatures;
                            M.indexOf("layers") === -1 && (M.push("layers"), this.el.sceneEl.setAttribute("webxr", C)), this.el.sceneEl.addEventListener("enter-vr", this.onEnterVR), this.el.sceneEl.addEventListener("exit-vr", this.onExitVR)
                        }, bindMethods: function () {
                            this.onRequestedReferenceSpace = this.onRequestedReferenceSpace.bind(this), this.onEnterVR = this.onEnterVR.bind(this), this.onExitVR = this.onExitVR.bind(this)
                        }, update: function (p) {
                            this.data.src !== p.src && this.updateSrc()
                        }, updateSrc: function () {
                            var p = this.data.type;
                            if (this.texture = void 0, p === "quad") {
                                this.loadQuadImage();
                                return
                            }
                            if (p === "monocubemap" || p === "stereocubemap") {
                                this.loadCubeMapImages();
                                return
                            }
                        }, loadCubeMapImages: function () {
                            var p, C = this.xrGLFactory, M = this.el.sceneEl.frame, b = this.data.src,
                                B = this.data.type;
                            this.visibilityChanged = !1, this.layer && (B !== "monocubemap" && B !== "stereocubemap" || (b.complete ? this.pendingCubeMapUpdate = !1 : this.pendingCubeMapUpdate = !0, this.loadingScreen ? this.loadingScreen = !1 : this.loadingScreen = !0, B === "monocubemap" ? (p = C.getSubImage(this.layer, M), this.loadCubeMapImage(p.colorTexture, b, 0)) : (p = C.getSubImage(this.layer, M, "left"), this.loadCubeMapImage(p.colorTexture, b, 0), p = C.getSubImage(this.layer, M, "right"), this.loadCubeMapImage(p.colorTexture, b, 6))))
                        }, loadQuadImage: function () {
                            var p = this.data.src, C = this;
                            this.el.sceneEl.systems.material.loadTexture(p, {src: p}, function (b) {
                                C.el.sceneEl.renderer.initTexture(b), C.texture = b, p.tagName === "VIDEO" && setTimeout(function () {
                                    C.textureIsVideo = !0
                                }, 1e3), C.layer && (C.layer.height = C.data.height / 2 || C.texture.image.height / 1e3, C.layer.width = C.data.width / 2 || C.texture.image.width / 1e3, C.needsRedraw = !0), C.updateQuadPanel()
                            })
                        }, preGenerateCubeMapTextures: function (p, C) {
                            this.data.type === "monocubemap" ? this.generateCubeMapTextures(p, 0, C) : (this.generateCubeMapTextures(p, 0, C), this.generateCubeMapTextures(p, 6, C))
                        }, generateCubeMapTextures: function (p, C, M) {
                            for (var b = this.data, B = this.cubeFaceSize, R = Math.min(p.width, p.height), I = [], L, O, N = 0; N < 6; N++) {
                                var F = document.createElement("CANVAS");
                                F.width = F.height = B;
                                var V = F.getContext("2d");
                                b.rotateCubemap && (N === 2 || N === 3) && (V.save(), V.translate(B, B), V.rotate(Math.PI)), V.drawImage(p, (N + C) * R, 0, R, R, 0, 0, B, B), V.restore(), M && M(), I.push(F)
                            }
                            return b.rotateCubemap && (L = I[0], O = I[1], I[0] = O, I[1] = L, L = I[4], O = I[5], I[4] = O, I[5] = L), M && M(), I
                        }, loadCubeMapImage: function (p, C, M) {
                            var b = this.el.sceneEl.renderer.getContext(), B;
                            b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !1), b.bindTexture(b.TEXTURE_CUBE_MAP, p), !C.complete || this.loadingScreen ? B = this.loadingScreenImages : B = this.generateCubeMapTextures(C, M);
                            var R = 0;
                            B.forEach(function (I, L) {
                                b.texSubImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + L, 0, 0, 0, b.RGBA, b.UNSIGNED_BYTE, I), R = b.getError()
                            }), R !== 0 && console.log("renderingError, WebGL Error Code: " + R), b.bindTexture(b.TEXTURE_CUBE_MAP, null)
                        }, tick: function () {
                            this.el.sceneEl.xrSession && (!this.layer && (this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode")) && this.initLayer(), this.updateTransform(), this.data.src.complete && (this.pendingCubeMapUpdate || this.loadingScreen || this.visibilityChanged) && this.loadCubeMapImages(), !(!this.needsRedraw && !this.layer.needsRedraw && !this.textureIsVideo) && (this.data.type === "quad" && this.draw(), this.needsRedraw = !1))
                        }, initLayer: function () {
                            var p = this, C = this.data.type;
                            if (this.el.sceneEl.xrSession.onvisibilitychange = function (M) {
                                p.visibilityChanged = M.session.visibilityState !== "hidden"
                            }, C === "quad") {
                                this.initQuadLayer();
                                return
                            }
                            if (C === "monocubemap" || C === "stereocubemap") {
                                this.initCubeMapLayer();
                                return
                            }
                        }, initQuadLayer: function () {
                            var p = this.el.sceneEl, C = p.renderer.getContext(),
                                M = this.xrGLFactory = new XRWebGLBinding(p.xrSession, C);
                            this.texture && (this.layer = M.createQuadLayer({
                                space: this.referenceSpace,
                                viewPixelHeight: 2048,
                                viewPixelWidth: 2048,
                                height: this.data.height / 2 || this.texture.image.height / 1e3,
                                width: this.data.width / 2 || this.texture.image.width / 1e3
                            }), this.initLoadingScreenImages(), p.renderer.xr.addLayer(this.layer))
                        }, initCubeMapLayer: function () {
                            var p = this.data.src, C = this.el.sceneEl, M = C.renderer.getContext(),
                                b = M.getParameter(M.MAX_CUBE_MAP_TEXTURE_SIZE),
                                B = this.cubeFaceSize = Math.min(b, Math.min(p.width, p.height)),
                                R = this.xrGLFactory = new XRWebGLBinding(C.xrSession, M);
                            this.layer = R.createCubeLayer({
                                space: this.referenceSpace,
                                viewPixelWidth: B,
                                viewPixelHeight: B,
                                layout: this.data.type === "monocubemap" ? "mono" : "stereo",
                                isStatic: !1
                            }), this.initLoadingScreenImages(), this.loadCubeMapImages(), C.renderer.xr.addLayer(this.layer)
                        }, initLoadingScreenImages: function () {
                            for (var p = this.cubeFaceSize, C = this.loadingScreenImages = [], M = 0; M < 6; M++) {
                                var b = document.createElement("CANVAS");
                                b.width = b.height = p;
                                var B = b.getContext("2d");
                                b.width = b.height = p, B.fillStyle = "black", B.fillRect(0, 0, p, p), M !== 2 && M !== 3 && (B.translate(p, 0), B.scale(-1, 1), B.fillStyle = "white", B.font = "30px Arial", B.fillText("Loading", p / 2, p / 2)), C.push(b)
                            }
                        }, destroyLayer: function () {
                            this.layer && (this.el.sceneEl.renderer.xr.removeLayer(this.layer), this.layer.destroy(), this.layer = void 0)
                        }, toggleCompositorLayer: function () {
                            this.enableCompositorLayer(!this.layerEnabled)
                        }, enableCompositorLayer: function (p) {
                            this.layerEnabled = p, this.quadPanelEl.object3D.visible = !this.layerEnabled
                        }, updateQuadPanel: function () {
                            var p = this.quadPanelEl;
                            this.quadPanelEl || (p = this.quadPanelEl = document.createElement("a-entity"), this.el.appendChild(p)), p.setAttribute("material", {
                                shader: "flat",
                                src: this.data.src,
                                transparent: !0
                            }), p.setAttribute("geometry", {
                                primitive: "plane",
                                height: this.data.height || this.texture.image.height / 1e3,
                                width: this.data.width || this.texture.image.height / 1e3
                            })
                        }, draw: function () {
                            var p = this.el.sceneEl, C = this.el.sceneEl.renderer.getContext(),
                                M = this.xrGLFactory.getSubImage(this.layer, p.frame),
                                b = p.renderer.properties.get(this.texture).__webglTexture,
                                B = C.getParameter(C.FRAMEBUFFER_BINDING);
                            C.viewport(M.viewport.x, M.viewport.y, M.viewport.width, M.viewport.height), C.bindFramebuffer(C.FRAMEBUFFER, this.frameBuffer), C.framebufferTexture2D(C.FRAMEBUFFER, C.COLOR_ATTACHMENT0, C.TEXTURE_2D, M.colorTexture, 0), E(C, b, M, this.data.src), C.bindFramebuffer(C.FRAMEBUFFER, B)
                        }, updateTransform: function () {
                            var p = this.el, C = this.position, M = this.quaternion;
                            p.object3D.updateMatrixWorld(), C.setFromMatrixPosition(p.object3D.matrixWorld), M.setFromRotationMatrix(p.object3D.matrixWorld), this.layerEnabled || C.set(0, 0, 1e8), this.layer.transform = new XRRigidTransform(C, M)
                        }, onEnterVR: function () {
                            var p = this.el.sceneEl, C = p.xrSession;
                            if (!p.hasWebXR || !XRWebGLBinding || !C) {
                                v("The layer component requires WebXR and the layers API enabled");
                                return
                            }
                            C.requestReferenceSpace("local-floor").then(this.onRequestedReferenceSpace), this.layerEnabled = !0, this.quadPanelEl && (this.quadPanelEl.object3D.visible = !1), this.data.src.play && this.data.src.play()
                        }, onExitVR: function () {
                            this.quadPanelEl && (this.quadPanelEl.object3D.visible = !0), this.destroyLayer()
                        }, onRequestedReferenceSpace: function (p) {
                            this.referenceSpace = p
                        }
                    });

                    function E(p, C, M, b) {
                        var B = p.createFramebuffer(), R = M.viewport.x, I = M.viewport.y,
                            L = M.viewport.x + M.viewport.width, O = M.viewport.y + M.viewport.height;
                        b.tagName === "VIDEO" && (p.bindTexture(p.TEXTURE_2D, C), p.texSubImage2D(p.TEXTURE_2D, 0, 0, 0, b.width, b.height, p.RGB, p.UNSIGNED_BYTE, b)), p.bindFramebuffer(p.READ_FRAMEBUFFER, B), p.framebufferTexture2D(p.READ_FRAMEBUFFER, p.COLOR_ATTACHMENT0, p.TEXTURE_2D, C, 0), p.readBuffer(p.COLOR_ATTACHMENT0), p.blitFramebuffer(0, 0, b.width, b.height, R, I, L, O, p.COLOR_BUFFER_BIT, p.NEAREST), p.bindFramebuffer(p.READ_FRAMEBUFFER, null), p.deleteFramebuffer(B)
                    }
                },
                "./src/components/light.js": (m, x, h) => {
                    var g = h("./src/utils/index.js"), w = g.diff, v = h("./src/utils/debug.js"),
                        E = h("./src/core/component.js").registerComponent, p = h("./src/lib/three.js"),
                        C = h("./src/utils/math.js"), M = p.MathUtils.degToRad, b = v("components:light:warn"),
                        B = new p.CubeTextureLoader, R = {};
                    m.exports.Component = E("light", {
                        schema: {
                            angle: {default: 60, if: {type: ["spot"]}},
                            color: {
                                type: "color",
                                if: {type: ["ambient", "directional", "hemisphere", "point", "spot"]}
                            },
                            envMap: {default: "", if: {type: ["probe"]}},
                            groundColor: {type: "color", if: {type: ["hemisphere"]}},
                            decay: {default: 1, if: {type: ["point", "spot"]}},
                            distance: {default: 0, min: 0, if: {type: ["point", "spot"]}},
                            intensity: {
                                default: 1,
                                min: 0,
                                if: {type: ["ambient", "directional", "hemisphere", "point", "spot", "probe"]}
                            },
                            penumbra: {default: 0, min: 0, max: 1, if: {type: ["spot"]}},
                            type: {
                                default: "directional",
                                oneOf: ["ambient", "directional", "hemisphere", "point", "spot", "probe"],
                                schemaChange: !0
                            },
                            target: {type: "selector", if: {type: ["spot", "directional"]}},
                            castShadow: {default: !1, if: {type: ["point", "spot", "directional"]}},
                            shadowBias: {default: 0, if: {castShadow: !0}},
                            shadowCameraFar: {default: 500, if: {castShadow: !0}},
                            shadowCameraFov: {default: 90, if: {castShadow: !0}},
                            shadowCameraNear: {default: .5, if: {castShadow: !0}},
                            shadowCameraTop: {default: 5, if: {castShadow: !0}},
                            shadowCameraRight: {default: 5, if: {castShadow: !0}},
                            shadowCameraBottom: {default: -5, if: {castShadow: !0}},
                            shadowCameraLeft: {default: -5, if: {castShadow: !0}},
                            shadowCameraVisible: {default: !1, if: {castShadow: !0}},
                            shadowCameraAutomatic: {default: "", if: {type: ["directional"]}},
                            shadowMapHeight: {default: 512, if: {castShadow: !0}},
                            shadowMapWidth: {default: 512, if: {castShadow: !0}},
                            shadowRadius: {default: 1, if: {castShadow: !0}}
                        }, init: function () {
                            var I = this.el;
                            this.light = null, this.defaultTarget = null, this.system.registerLight(I)
                        }, update: function (I) {
                            var L = this.data, O = w(L, I), N = this.light, F = this;
                            if (N && !("type" in O)) {
                                var V = !1;
                                Object.keys(O).forEach(function (U) {
                                    var j = L[U];
                                    switch (U) {
                                        case"color": {
                                            N.color.set(j);
                                            break
                                        }
                                        case"groundColor": {
                                            N.groundColor.set(j);
                                            break
                                        }
                                        case"angle": {
                                            N.angle = M(j);
                                            break
                                        }
                                        case"target": {
                                            j === null ? (L.type === "spot" || L.type === "directional") && (N.target = F.defaultTarget) : j.hasLoaded ? F.onSetTarget(j, N) : j.addEventListener("loaded", F.onSetTarget.bind(F, j, N));
                                            break
                                        }
                                        case"envMap":
                                            F.updateProbeMap(L, N);
                                            break;
                                        case"castShadow":
                                        case"shadowBias":
                                        case"shadowCameraFar":
                                        case"shadowCameraFov":
                                        case"shadowCameraNear":
                                        case"shadowCameraTop":
                                        case"shadowCameraRight":
                                        case"shadowCameraBottom":
                                        case"shadowCameraLeft":
                                        case"shadowCameraVisible":
                                        case"shadowMapHeight":
                                        case"shadowMapWidth":
                                        case"shadowRadius":
                                            V || (F.updateShadow(), V = !0);
                                            break;
                                        case"shadowCameraAutomatic":
                                            L.shadowCameraAutomatic ? F.shadowCameraAutomaticEls = Array.from(document.querySelectorAll(L.shadowCameraAutomatic)) : F.shadowCameraAutomaticEls = [];
                                            break;
                                        default:
                                            N[U] = j
                                    }
                                });
                                return
                            }
                            this.setLight(this.data), this.updateShadow()
                        }, tick: function () {
                            var I = new p.Box3, L = new p.Vector3, O = new p.Vector3, N = new p.Matrix4,
                                F = new p.Sphere, V = new p.Vector3;
                            return function () {
                                if (this.data.type === "directional" && this.light.shadow && this.light.shadow.camera instanceof p.OrthographicCamera && this.shadowCameraAutomaticEls.length) {
                                    var U = this.light.shadow.camera;
                                    U.getWorldDirection(L), U.getWorldPosition(O), N.copy(U.matrixWorld), N.invert(), U.near = 1, U.left = 1e5, U.right = -1e5, U.top = -1e5, U.bottom = 1e5, this.shadowCameraAutomaticEls.forEach(function (j) {
                                        I.setFromObject(j.object3D), I.getBoundingSphere(F);
                                        var Y = C.distanceOfPointFromPlane(O, L, F.center),
                                            fe = C.nearestPointInPlane(O, L, F.center, V), se = fe.applyMatrix4(N);
                                        U.near = Math.min(-Y - F.radius - 1, U.near), U.left = Math.min(-F.radius + se.x, U.left), U.right = Math.max(F.radius + se.x, U.right), U.top = Math.max(F.radius + se.y, U.top), U.bottom = Math.min(-F.radius + se.y, U.bottom)
                                    }), U.updateProjectionMatrix()
                                }
                            }
                        }(), setLight: function (I) {
                            var L = this.el, O = this.getLight(I);
                            O && (this.light && L.removeObject3D("light"), this.light = O, this.light.el = L, L.setObject3D("light", this.light), (I.type === "spot" || I.type === "directional" || I.type === "hemisphere") && L.getObject3D("light").translateY(-1), I.type === "spot" && (L.setObject3D("light-target", this.defaultTarget), L.getObject3D("light-target").position.set(0, 0, -1)), I.shadowCameraAutomatic ? this.shadowCameraAutomaticEls = Array.from(document.querySelectorAll(I.shadowCameraAutomatic)) : this.shadowCameraAutomaticEls = [])
                        }, updateShadow: function () {
                            var I = this.el, L = this.data, O = this.light;
                            O.castShadow = L.castShadow;
                            var N = I.getObject3D("cameraHelper");
                            if (L.shadowCameraVisible && !N ? I.setObject3D("cameraHelper", new p.CameraHelper(O.shadow.camera)) : !L.shadowCameraVisible && N && I.removeObject3D("cameraHelper"), !L.castShadow) return O;
                            O.shadow.bias = L.shadowBias, O.shadow.radius = L.shadowRadius, O.shadow.mapSize.height = L.shadowMapHeight, O.shadow.mapSize.width = L.shadowMapWidth, O.shadow.camera.near = L.shadowCameraNear, O.shadow.camera.far = L.shadowCameraFar, O.shadow.camera instanceof p.OrthographicCamera ? (O.shadow.camera.top = L.shadowCameraTop, O.shadow.camera.right = L.shadowCameraRight, O.shadow.camera.bottom = L.shadowCameraBottom, O.shadow.camera.left = L.shadowCameraLeft) : O.shadow.camera.fov = L.shadowCameraFov, O.shadow.camera.updateProjectionMatrix(), N && N.update()
                        }, getLight: function (I) {
                            var L = I.angle, O = new p.Color(I.color);
                            O = O.getHex();
                            var N = I.decay, F = I.distance, V = new p.Color(I.groundColor);
                            V = V.getHex();
                            var U = I.intensity, j = I.type, Y = I.target, fe = null;
                            switch (j.toLowerCase()) {
                                case"ambient":
                                    return new p.AmbientLight(O, U);
                                case"directional":
                                    return fe = new p.DirectionalLight(O, U), this.defaultTarget = fe.target, Y && (Y.hasLoaded ? this.onSetTarget(Y, fe) : Y.addEventListener("loaded", this.onSetTarget.bind(this, Y, fe))), fe;
                                case"hemisphere":
                                    return new p.HemisphereLight(O, V, U);
                                case"point":
                                    return new p.PointLight(O, U, F, N);
                                case"spot":
                                    return fe = new p.SpotLight(O, U, F, M(L), I.penumbra, N), this.defaultTarget = fe.target, Y && (Y.hasLoaded ? this.onSetTarget(Y, fe) : Y.addEventListener("loaded", this.onSetTarget.bind(this, Y, fe))), fe;
                                case"probe":
                                    return fe = new p.LightProbe, this.updateProbeMap(I, fe), fe;
                                default:
                                    b("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.", j)
                            }
                        }, updateProbeMap: function (I, L) {
                            I.envMap || L.copy(new p.LightProbe), R[I.envMap] instanceof window.Promise && R[I.envMap].then(function (O) {
                                L.copy(O)
                            }), R[I.envMap] instanceof p.LightProbe && L.copy(R[I.envMap]), R[I.envMap] = new window.Promise(function (O) {
                                g.srcLoader.validateCubemapSrc(I.envMap, function (F) {
                                    B.load(F, function (V) {
                                        var U = p.LightProbeGenerator.fromCubeTexture(V);
                                        R[I.envMap] = U, L.copy(U)
                                    })
                                })
                            })
                        }, onSetTarget: function (I, L) {
                            L.target = I.object3D
                        }, remove: function () {
                            var I = this.el;
                            I.removeObject3D("light"), I.getObject3D("cameraHelper") && I.removeObject3D("cameraHelper")
                        }
                    })
                },
                "./src/components/line.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("line", {
                        schema: {
                            start: {type: "vec3", default: {x: 0, y: 0, z: 0}},
                            end: {type: "vec3", default: {x: 0, y: 0, z: 0}},
                            color: {type: "color", default: "#74BEC1"},
                            opacity: {type: "number", default: 1},
                            visible: {default: !0}
                        }, multiple: !0, init: function () {
                            var v = this.data, E, p;
                            p = this.material = new THREE.LineBasicMaterial({
                                color: v.color,
                                opacity: v.opacity,
                                transparent: v.opacity < 1,
                                visible: v.visible
                            }), E = this.geometry = new THREE.BufferGeometry, E.setAttribute("position", new THREE.BufferAttribute(new Float32Array(6), 3)), this.line = new THREE.Line(E, p), this.el.setObject3D(this.attrName, this.line)
                        }, update: function (v) {
                            var E = this.data, p = this.geometry, C = !1, M = this.material,
                                b = p.attributes.position.array;
                            w(E.start, v.start) || (b[0] = E.start.x, b[1] = E.start.y, b[2] = E.start.z, C = !0), w(E.end, v.end) || (b[3] = E.end.x, b[4] = E.end.y, b[5] = E.end.z, C = !0), C && (p.attributes.position.needsUpdate = !0, p.computeBoundingSphere()), M.color.setStyle(E.color), M.opacity = E.opacity, M.transparent = E.opacity < 1, M.visible = E.visible
                        }, remove: function () {
                            this.el.removeObject3D(this.attrName, this.line)
                        }
                    });

                    function w(v, E) {
                        return !v || !E ? !1 : v.x === E.x && v.y === E.y && v.z === E.z
                    }
                },
                "./src/components/link.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent,
                        w = h("./src/core/shader.js").registerShader, v = h("./src/lib/three.js");
                    m.exports.Component = g("link", {
                        schema: {
                            backgroundColor: {default: "red", type: "color"},
                            borderColor: {default: "white", type: "color"},
                            highlighted: {default: !1},
                            highlightedColor: {default: "#24CAFF", type: "color"},
                            href: {default: ""},
                            image: {type: "asset"},
                            on: {default: "click"},
                            peekMode: {default: !1},
                            title: {default: ""},
                            titleColor: {default: "white", type: "color"},
                            visualAspectEnabled: {default: !1}
                        }, init: function () {
                            this.navigate = this.navigate.bind(this), this.previousQuaternion = void 0, this.quaternionClone = new v.Quaternion, this.hiddenEls = []
                        }, update: function (E) {
                            var p = this.data, C = this.el, M, b;
                            p.visualAspectEnabled && (this.initVisualAspect(), M = p.highlighted ? p.highlightedColor : p.backgroundColor, b = p.highlighted ? p.highlightedColor : p.borderColor, C.setAttribute("material", "backgroundColor", M), C.setAttribute("material", "strokeColor", b), p.on !== E.on && this.updateEventListener(), E.peekMode !== void 0 && p.peekMode !== E.peekMode && this.updatePeekMode(), !(!p.image || E.image === p.image) && C.setAttribute("material", "pano", typeof p.image == "string" ? p.image : p.image.src))
                        }, updatePeekMode: function () {
                            var E = this.el, p = this.sphereEl;
                            this.data.peekMode ? (this.hideAll(), E.getObject3D("mesh").visible = !1, p.setAttribute("visible", !0)) : (this.showAll(), E.getObject3D("mesh").visible = !0, p.setAttribute("visible", !1))
                        }, play: function () {
                            this.updateEventListener()
                        }, pause: function () {
                            this.removeEventListener()
                        }, updateEventListener: function () {
                            var E = this.el;
                            E.isPlaying && (this.removeEventListener(), E.addEventListener(this.data.on, this.navigate))
                        }, removeEventListener: function () {
                            var E = this.data.on;
                            E && this.el.removeEventListener(E, this.navigate)
                        }, initVisualAspect: function () {
                            var E = this.el, p, C, M;
                            !this.data.visualAspectEnabled || this.visualAspectInitialized || (M = this.textEl = this.textEl || document.createElement("a-entity"), C = this.sphereEl = this.sphereEl || document.createElement("a-entity"), p = this.semiSphereEl = this.semiSphereEl || document.createElement("a-entity"), E.setAttribute("geometry", {
                                primitive: "circle",
                                radius: 1,
                                segments: 64
                            }), E.setAttribute("material", {
                                shader: "portal",
                                pano: this.data.image,
                                side: "double"
                            }), M.setAttribute("text", {
                                color: this.data.titleColor,
                                align: "center",
                                font: "kelsonsans",
                                value: this.data.title || this.data.href,
                                width: 4
                            }), M.setAttribute("position", "0 1.5 0"), E.appendChild(M), p.setAttribute("geometry", {
                                primitive: "sphere",
                                radius: 1,
                                phiStart: 0,
                                segmentsWidth: 64,
                                segmentsHeight: 64,
                                phiLength: 180,
                                thetaStart: 0,
                                thetaLength: 360
                            }), p.setAttribute("material", {
                                shader: "portal",
                                borderEnabled: 0,
                                pano: this.data.image,
                                side: "back"
                            }), p.setAttribute("rotation", "0 180 0"), p.setAttribute("position", "0 0 0"), p.setAttribute("visible", !1), E.appendChild(p), C.setAttribute("geometry", {
                                primitive: "sphere",
                                radius: 10,
                                segmentsWidth: 64,
                                segmentsHeight: 64
                            }), C.setAttribute("material", {
                                shader: "portal",
                                borderEnabled: 0,
                                pano: this.data.image,
                                side: "back"
                            }), C.setAttribute("visible", !1), E.appendChild(C), this.visualAspectInitialized = !0)
                        }, navigate: function () {
                            window.location = this.data.href
                        }, tick: function () {
                            var E = new v.Vector3, p = new v.Vector3, C = new v.Quaternion, M = new v.Vector3;
                            return function () {
                                var b = this.el, B = b.object3D, R = b.sceneEl.camera, I, L, O = this.textEl;
                                if (this.data.visualAspectEnabled) if (B.updateMatrixWorld(), R.parent.updateMatrixWorld(), R.updateMatrixWorld(), B.matrix.decompose(p, C, M), p.setFromMatrixPosition(B.matrixWorld), E.setFromMatrixPosition(R.matrixWorld), L = p.distanceTo(E), L > 20) this.previousQuaternion || (this.quaternionClone.copy(C), this.previousQuaternion = this.quaternionClone), B.lookAt(E); else {
                                    if (I = this.calculateCameraPortalOrientation(), L < .5) {
                                        if (this.semiSphereEl.getAttribute("visible") === !0) return;
                                        O.setAttribute("text", "width", 1.5), I <= 0 ? (O.setAttribute("position", "0 0 0.75"), O.setAttribute("rotation", "0 180 0"), this.semiSphereEl.setAttribute("rotation", "0 0 0")) : (O.setAttribute("position", "0 0 -0.75"), O.setAttribute("rotation", "0 0 0"), this.semiSphereEl.setAttribute("rotation", "0 180 0")), b.getObject3D("mesh").visible = !1, this.semiSphereEl.setAttribute("visible", !0), this.peekCameraPortalOrientation = I
                                    } else I <= 0 ? O.setAttribute("rotation", "0 180 0") : O.setAttribute("rotation", "0 0 0"), O.setAttribute("text", "width", 5), O.setAttribute("position", "0 1.5 0"), b.getObject3D("mesh").visible = !0, this.semiSphereEl.setAttribute("visible", !1), this.peekCameraPortalOrientation = void 0;
                                    this.previousQuaternion && (B.quaternion.copy(this.previousQuaternion), this.previousQuaternion = void 0)
                                }
                            }
                        }(), hideAll: function () {
                            var E = this.el, p = this.hiddenEls, C = this;
                            p.length > 0 || E.sceneEl.object3D.traverse(function (M) {
                                M && M.el && M.el.hasAttribute("link-controls") || !M.el || M === E.sceneEl.object3D || M.el === E || M.el === C.sphereEl || M.el === E.sceneEl.cameraEl || M.el.getAttribute("visible") === !1 || M.el === C.textEl || M.el === C.semiSphereEl || (M.el.setAttribute("visible", !1), p.push(M.el))
                            })
                        }, showAll: function () {
                            this.hiddenEls.forEach(function (E) {
                                E.setAttribute("visible", !0)
                            }), this.hiddenEls = []
                        }, calculateCameraPortalOrientation: function () {
                            var E = new v.Matrix4, p = new v.Vector3, C = new v.Vector3(0, 0, 1),
                                M = new v.Vector3(0, 0, 0);
                            return function () {
                                var b = this.el, B = b.sceneEl.camera;
                                return p.set(0, 0, 0), C.set(0, 0, 1), M.set(0, 0, 0), b.object3D.matrixWorld.extractRotation(E), C.applyMatrix4(E), b.object3D.updateMatrixWorld(), b.object3D.localToWorld(M), B.parent.parent.updateMatrixWorld(), B.parent.updateMatrixWorld(), B.updateMatrixWorld(), B.localToWorld(p), p.sub(M).normalize(), C.normalize(), Math.sign(C.dot(p))
                            }
                        }(), remove: function () {
                            this.removeEventListener()
                        }
                    }), w("portal", {
                        schema: {
                            borderEnabled: {default: 1, type: "int", is: "uniform"},
                            backgroundColor: {default: "red", type: "color", is: "uniform"},
                            pano: {type: "map", is: "uniform"},
                            strokeColor: {default: "white", type: "color", is: "uniform"}
                        },
                        vertexShader: ["vec3 portalPosition;", "varying vec3 vWorldPosition;", "varying float vDistanceToCenter;", "varying float vDistance;", "void main() {", "vDistanceToCenter = clamp(length(position - vec3(0.0, 0.0, 0.0)), 0.0, 1.0);", "portalPosition = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;", "vDistance = length(portalPosition - cameraPosition);", "vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;", "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join(`
`),
                        fragmentShader: ["#define RECIPROCAL_PI2 0.15915494", "uniform sampler2D pano;", "uniform vec3 strokeColor;", "uniform vec3 backgroundColor;", "uniform float borderEnabled;", "varying float vDistanceToCenter;", "varying float vDistance;", "varying vec3 vWorldPosition;", "void main() {", "vec3 direction = normalize(vWorldPosition - cameraPosition);", "vec2 sampleUV;", "float borderThickness = clamp(exp(-vDistance / 50.0), 0.6, 0.95);", "sampleUV.y = clamp(direction.y * 0.5  + 0.5, 0.0, 1.0);", "sampleUV.x = atan(direction.z, -direction.x) * -RECIPROCAL_PI2 + 0.5;", "if (vDistanceToCenter > borderThickness && borderEnabled == 1.0) {", "gl_FragColor = vec4(strokeColor, 1.0);", "} else {", "gl_FragColor = mix(texture2D(pano, sampleUV), vec4(backgroundColor, 1.0), clamp(pow((vDistance / 15.0), 2.0), 0.0, 1.0));", "}", "}"].join(`
`)
                    })
                },
                "./src/components/look-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = h("./src/utils/index.js"), E = Math.PI / 2;
                    m.exports.Component = g("look-controls", {
                        dependencies: ["position", "rotation"],
                        schema: {
                            enabled: {default: !0},
                            magicWindowTrackingEnabled: {default: !0},
                            pointerLockEnabled: {default: !1},
                            reverseMouseDrag: {default: !1},
                            reverseTouchDrag: {default: !1},
                            touchEnabled: {default: !0},
                            mouseEnabled: {default: !0}
                        },
                        init: function () {
                            this.deltaYaw = 0, this.previousHMDPosition = new w.Vector3, this.hmdQuaternion = new w.Quaternion, this.magicWindowAbsoluteEuler = new w.Euler, this.magicWindowDeltaEuler = new w.Euler, this.position = new w.Vector3, this.magicWindowObject = new w.Object3D, this.rotation = {}, this.deltaRotation = {}, this.savedPose = null, this.pointerLocked = !1, this.setupMouseControls(), this.bindMethods(), this.previousMouseEvent = {}, this.setupMagicWindowControls(), this.savedPose = {
                                position: new w.Vector3,
                                rotation: new w.Euler
                            }, (this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode")) && this.onEnterVR()
                        },
                        setupMagicWindowControls: function () {
                            var p, C = this.data;
                            (v.device.isMobile() || v.device.isMobileDeviceRequestingDesktopSite()) && (p = this.magicWindowControls = new w.DeviceOrientationControls(this.magicWindowObject), typeof DeviceOrientationEvent < "u" && DeviceOrientationEvent.requestPermission && (p.enabled = !1, this.el.sceneEl.components["device-orientation-permission-ui"].permissionGranted ? p.enabled = C.magicWindowTrackingEnabled : this.el.sceneEl.addEventListener("deviceorientationpermissiongranted", function () {
                                p.enabled = C.magicWindowTrackingEnabled
                            })))
                        },
                        update: function (p) {
                            var C = this.data;
                            C.enabled !== p.enabled && this.updateGrabCursor(C.enabled), p && !C.magicWindowTrackingEnabled && p.magicWindowTrackingEnabled && (this.magicWindowAbsoluteEuler.set(0, 0, 0), this.magicWindowDeltaEuler.set(0, 0, 0)), this.magicWindowControls && (this.magicWindowControls.enabled = C.magicWindowTrackingEnabled), p && !C.pointerLockEnabled !== p.pointerLockEnabled && (this.removeEventListeners(), this.addEventListeners(), this.pointerLocked && this.exitPointerLock())
                        },
                        tick: function (p) {
                            var C = this.data;
                            C.enabled && this.updateOrientation()
                        },
                        play: function () {
                            this.addEventListeners()
                        },
                        pause: function () {
                            this.removeEventListeners(), this.pointerLocked && this.exitPointerLock()
                        },
                        remove: function () {
                            this.removeEventListeners(), this.pointerLocked && this.exitPointerLock()
                        },
                        bindMethods: function () {
                            this.onMouseDown = this.onMouseDown.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onMouseUp = this.onMouseUp.bind(this), this.onTouchStart = this.onTouchStart.bind(this), this.onTouchMove = this.onTouchMove.bind(this), this.onTouchEnd = this.onTouchEnd.bind(this), this.onEnterVR = this.onEnterVR.bind(this), this.onExitVR = this.onExitVR.bind(this), this.onPointerLockChange = this.onPointerLockChange.bind(this), this.onPointerLockError = this.onPointerLockError.bind(this)
                        },
                        setupMouseControls: function () {
                            this.mouseDown = !1, this.pitchObject = new w.Object3D, this.yawObject = new w.Object3D, this.yawObject.position.y = 10, this.yawObject.add(this.pitchObject)
                        },
                        addEventListeners: function () {
                            var p = this.el.sceneEl, C = p.canvas;
                            if (!C) {
                                p.addEventListener("render-target-loaded", this.addEventListeners.bind(this));
                                return
                            }
                            C.addEventListener("mousedown", this.onMouseDown, !1), window.addEventListener("mousemove", this.onMouseMove, !1), window.addEventListener("mouseup", this.onMouseUp, !1), C.addEventListener("touchstart", this.onTouchStart, {passive: !0}), window.addEventListener("touchmove", this.onTouchMove, {passive: !0}), window.addEventListener("touchend", this.onTouchEnd, {passive: !0}), p.addEventListener("enter-vr", this.onEnterVR), p.addEventListener("exit-vr", this.onExitVR), this.data.pointerLockEnabled && (document.addEventListener("pointerlockchange", this.onPointerLockChange, !1), document.addEventListener("mozpointerlockchange", this.onPointerLockChange, !1), document.addEventListener("pointerlockerror", this.onPointerLockError, !1))
                        },
                        removeEventListeners: function () {
                            var p = this.el.sceneEl, C = p && p.canvas;
                            C && (C.removeEventListener("mousedown", this.onMouseDown), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), C.removeEventListener("touchstart", this.onTouchStart), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd), p.removeEventListener("enter-vr", this.onEnterVR), p.removeEventListener("exit-vr", this.onExitVR), document.removeEventListener("pointerlockchange", this.onPointerLockChange, !1), document.removeEventListener("mozpointerlockchange", this.onPointerLockChange, !1), document.removeEventListener("pointerlockerror", this.onPointerLockError, !1))
                        },
                        updateOrientation: function () {
                            var p = this.el.object3D, C = this.pitchObject, M = this.yawObject, b = this.el.sceneEl;
                            (b.is("vr-mode") || b.is("ar-mode")) && b.checkHeadsetConnected() || (this.updateMagicWindowOrientation(), p.rotation.x = this.magicWindowDeltaEuler.x + C.rotation.x, p.rotation.y = this.magicWindowDeltaEuler.y + M.rotation.y, p.rotation.z = this.magicWindowDeltaEuler.z)
                        },
                        updateMagicWindowOrientation: function () {
                            var p = this.magicWindowAbsoluteEuler, C = this.magicWindowDeltaEuler;
                            this.magicWindowControls && this.magicWindowControls.enabled && (this.magicWindowControls.update(), p.setFromQuaternion(this.magicWindowObject.quaternion, "YXZ"), !this.previousMagicWindowYaw && p.y !== 0 && (this.previousMagicWindowYaw = p.y), this.previousMagicWindowYaw && (C.x = p.x, C.y += p.y - this.previousMagicWindowYaw, C.z = p.z, this.previousMagicWindowYaw = p.y))
                        },
                        onMouseMove: function (p) {
                            var C, M, b, B = this.pitchObject, R = this.previousMouseEvent, I = this.yawObject;
                            !this.data.enabled || !this.mouseDown && !this.pointerLocked || (this.pointerLocked ? (M = p.movementX || p.mozMovementX || 0, b = p.movementY || p.mozMovementY || 0) : (M = p.screenX - R.screenX, b = p.screenY - R.screenY), this.previousMouseEvent.screenX = p.screenX, this.previousMouseEvent.screenY = p.screenY, C = this.data.reverseMouseDrag ? 1 : -1, I.rotation.y += M * .002 * C, B.rotation.x += b * .002 * C, B.rotation.x = Math.max(-E, Math.min(E, B.rotation.x)))
                        },
                        onMouseDown: function (p) {
                            var C = this.el.sceneEl;
                            if (!(!this.data.enabled || !this.data.mouseEnabled || (C.is("vr-mode") || C.is("ar-mode")) && C.checkHeadsetConnected()) && p.button === 0) {
                                var M = C && C.canvas;
                                this.mouseDown = !0, this.previousMouseEvent.screenX = p.screenX, this.previousMouseEvent.screenY = p.screenY, this.showGrabbingCursor(), this.data.pointerLockEnabled && !this.pointerLocked && (M.requestPointerLock ? M.requestPointerLock() : M.mozRequestPointerLock && M.mozRequestPointerLock())
                            }
                        },
                        showGrabbingCursor: function () {
                            this.el.sceneEl.canvas.style.cursor = "grabbing"
                        },
                        hideGrabbingCursor: function () {
                            this.el.sceneEl.canvas.style.cursor = ""
                        },
                        onMouseUp: function () {
                            this.mouseDown = !1, this.hideGrabbingCursor()
                        },
                        onTouchStart: function (p) {
                            p.touches.length !== 1 || !this.data.touchEnabled || this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode") || (this.touchStart = {
                                x: p.touches[0].pageX,
                                y: p.touches[0].pageY
                            }, this.touchStarted = !0)
                        },
                        onTouchMove: function (p) {
                            var C, M = this.el.sceneEl.canvas, b, B = this.yawObject;
                            !this.touchStarted || !this.data.touchEnabled || (b = 2 * Math.PI * (p.touches[0].pageX - this.touchStart.x) / M.clientWidth, C = this.data.reverseTouchDrag ? 1 : -1, B.rotation.y -= b * .5 * C, this.touchStart = {
                                x: p.touches[0].pageX,
                                y: p.touches[0].pageY
                            })
                        },
                        onTouchEnd: function () {
                            this.touchStarted = !1
                        },
                        onEnterVR: function () {
                            var p = this.el.sceneEl;
                            p.checkHeadsetConnected() && (this.saveCameraPose(), this.el.object3D.position.set(0, 0, 0), this.el.object3D.rotation.set(0, 0, 0), p.hasWebXR && (this.el.object3D.matrixAutoUpdate = !1, this.el.object3D.updateMatrix()))
                        },
                        onExitVR: function () {
                            this.el.sceneEl.checkHeadsetConnected() && (this.restoreCameraPose(), this.previousHMDPosition.set(0, 0, 0), this.el.object3D.matrixAutoUpdate = !0)
                        },
                        onPointerLockChange: function () {
                            this.pointerLocked = !!(document.pointerLockElement || document.mozPointerLockElement)
                        },
                        onPointerLockError: function () {
                            this.pointerLocked = !1
                        },
                        exitPointerLock: function () {
                            document.exitPointerLock(), this.pointerLocked = !1
                        },
                        updateGrabCursor: function (p) {
                            var C = this.el.sceneEl;

                            function M() {
                                C.canvas.classList.add("a-grab-cursor")
                            }

                            function b() {
                                C.canvas.classList.remove("a-grab-cursor")
                            }

                            if (!C.canvas) {
                                p ? C.addEventListener("render-target-loaded", M) : C.addEventListener("render-target-loaded", b);
                                return
                            }
                            if (p) {
                                M();
                                return
                            }
                            b()
                        },
                        saveCameraPose: function () {
                            var p = this.el;
                            this.savedPose.position.copy(p.object3D.position), this.savedPose.rotation.copy(p.object3D.rotation), this.hasSavedPose = !0
                        },
                        restoreCameraPose: function () {
                            var p = this.el, C = this.savedPose;
                            this.hasSavedPose && (p.object3D.position.copy(C.position), p.object3D.rotation.copy(C.rotation), this.hasSavedPose = !1)
                        }
                    })
                },
                "./src/components/magicleap-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/tracked-controls.js"),
                        v = w.checkControllerPresentAndSetup, E = w.emitIfAxesChanged, p = w.onButtonEvent,
                        C = "magicleap", M = "-one", b = C + M, B = h("./src/constants/index.js").AFRAME_CDN_ROOT,
                        R = B + "controllers/magicleap/magicleap-one-controller.glb",
                        I = {axes: {touchpad: [0, 1]}, buttons: ["trigger", "grip", "touchpad", "menu"]};
                    m.exports.Component = g("magicleap-controls", {
                        schema: {hand: {default: "none"}, model: {default: !0}, orientationOffset: {type: "vec3"}},
                        mapping: I,
                        init: function () {
                            var L = this;
                            this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (O) {
                                p(O.detail.id, "down", L)
                            }, this.onButtonUp = function (O) {
                                p(O.detail.id, "up", L)
                            }, this.onButtonTouchEnd = function (O) {
                                p(O.detail.id, "touchend", L)
                            }, this.onButtonTouchStart = function (O) {
                                p(O.detail.id, "touchstart", L)
                            }, this.previousButtonValues = {}, this.bindMethods()
                        },
                        update: function () {
                            var L = this.data;
                            this.controllerIndex = L.hand === "right" ? 0 : L.hand === "left" ? 1 : 2
                        },
                        play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        },
                        pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        },
                        bindMethods: function () {
                            this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        },
                        addEventListeners: function () {
                            var L = this.el;
                            L.addEventListener("buttonchanged", this.onButtonChanged), L.addEventListener("buttondown", this.onButtonDown), L.addEventListener("buttonup", this.onButtonUp), L.addEventListener("touchstart", this.onButtonTouchStart), L.addEventListener("touchend", this.onButtonTouchEnd), L.addEventListener("axismove", this.onAxisMoved), L.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0
                        },
                        removeEventListeners: function () {
                            var L = this.el;
                            L.removeEventListener("buttonchanged", this.onButtonChanged), L.removeEventListener("buttondown", this.onButtonDown), L.removeEventListener("buttonup", this.onButtonUp), L.removeEventListener("touchstart", this.onButtonTouchStart), L.removeEventListener("touchend", this.onButtonTouchEnd), L.removeEventListener("axismove", this.onAxisMoved), L.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1
                        },
                        checkIfControllerPresent: function () {
                            var L = this.data;
                            v(this, b, {index: this.controllerIndex, hand: L.hand})
                        },
                        injectTrackedControls: function () {
                            var L = this.el, O = this.data;
                            L.setAttribute("tracked-controls", {
                                idPrefix: b,
                                hand: O.hand,
                                controller: this.controllerIndex,
                                orientationOffset: O.orientationOffset
                            }), this.data.model && this.el.setAttribute("gltf-model", R)
                        },
                        addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        },
                        removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        },
                        onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        },
                        onButtonChanged: function (L) {
                            var O = this.mapping.buttons[L.detail.id], N;
                            O && (O === "trigger" && (N = L.detail.state.value, console.log("analog value of trigger press: " + N)), this.el.emit(O + "changed", L.detail.state))
                        },
                        onModelLoaded: function (L) {
                            var O = L.detail.model;
                            O.scale.set(.01, .01, .01)
                        },
                        onAxisMoved: function (L) {
                            E(this, this.mapping.axes, L)
                        },
                        updateModel: function (L, O) {
                        },
                        setButtonColor: function (L, O) {
                        }
                    })
                },
                "./src/components/material.js": (m, x, h) => {
                    var g = h("./src/utils/index.js"), w = h("./src/core/component.js"), v = h("./src/lib/three.js"),
                        E = h("./src/core/shader.js"), p = g.debug("components:material:error"),
                        C = w.registerComponent, M = E.shaders, b = E.shaderNames;
                    m.exports.Component = C("material", {
                        schema: {
                            alphaTest: {default: 0, min: 0, max: 1},
                            depthTest: {default: !0},
                            depthWrite: {default: !0},
                            flatShading: {default: !1},
                            npot: {default: !1},
                            offset: {type: "vec2", default: {x: 0, y: 0}},
                            opacity: {default: 1, min: 0, max: 1},
                            repeat: {type: "vec2", default: {x: 1, y: 1}},
                            shader: {default: "standard", oneOf: b, schemaChange: !0},
                            side: {default: "front", oneOf: ["front", "back", "double"]},
                            transparent: {default: !1},
                            vertexColorsEnabled: {default: !1},
                            visible: {default: !0},
                            blending: {
                                default: "normal",
                                oneOf: ["none", "normal", "additive", "subtractive", "multiply"]
                            },
                            dithering: {default: !0},
                            anisotropy: {default: 0, min: 0}
                        }, init: function () {
                            this.material = null
                        }, update: function (L) {
                            var O = this.data;
                            (!this.shader || O.shader !== L.shader) && this.updateShader(O.shader), this.shader.update(this.data), this.updateMaterial(L)
                        }, updateSchema: function (L) {
                            var O, N, F, V;
                            N = L && L.shader, O = this.oldData && this.oldData.shader, V = N || O, F = M[V] && M[V].schema, F || p("Unknown shader schema " + V), !(O && N === O) && (this.extendSchema(F), this.updateBehavior())
                        }, updateBehavior: function () {
                            var L, O = this.el.sceneEl, N = this.schema, F = this, V;

                            function U(j, Y) {
                                var fe;
                                for (fe in V) V[fe] = j;
                                F.shader.update(V)
                            }

                            this.tick = void 0, V = {};
                            for (L in N) N[L].type === "time" && (this.tick = U, V[L] = !0);
                            O && (this.tick ? O.addBehavior(this) : O.removeBehavior(this))
                        }, updateShader: function (L) {
                            var O = this.data, N = M[L] && M[L].Shader, F;
                            if (!N) throw new Error("Unknown shader " + L);
                            F = this.shader = new N, F.el = this.el, F.init(O), this.setMaterial(F.material), this.updateSchema(O)
                        }, updateMaterial: function (L) {
                            var O = this.data, N = this.material, F;
                            N.alphaTest = O.alphaTest, N.depthTest = O.depthTest !== !1, N.depthWrite = O.depthWrite !== !1, N.opacity = O.opacity, N.flatShading = O.flatShading, N.side = B(O.side), N.transparent = O.transparent !== !1 || O.opacity < 1, N.vertexColors = O.vertexColorsEnabled, N.visible = O.visible, N.blending = R(O.blending), N.dithering = O.dithering;
                            for (F in L) break;
                            F && (L.alphaTest !== O.alphaTest || L.side !== O.side || L.vertexColorsEnabled !== O.vertexColorsEnabled) && (N.needsUpdate = !0)
                        }, remove: function () {
                            var L = new v.MeshBasicMaterial, O = this.material, N = this.el.getObject3D("mesh");
                            N && (N.material = L), I(O, this.system)
                        }, setMaterial: function (L) {
                            var O = this.el, N, F = this.system;
                            this.material && I(this.material, F), this.material = L, F.registerMaterial(L), N = O.getObject3D("mesh"), N ? N.material = L : O.addEventListener("object3dset", function V(U) {
                                U.detail.type !== "mesh" || U.target !== O || (O.getObject3D("mesh").material = L, O.removeEventListener("object3dset", V))
                            })
                        }
                    });

                    function B(L) {
                        switch (L) {
                            case"back":
                                return v.BackSide;
                            case"double":
                                return v.DoubleSide;
                            default:
                                return v.FrontSide
                        }
                    }

                    function R(L) {
                        switch (L) {
                            case"none":
                                return v.NoBlending;
                            case"additive":
                                return v.AdditiveBlending;
                            case"subtractive":
                                return v.SubtractiveBlending;
                            case"multiply":
                                return v.MultiplyBlending;
                            default:
                                return v.NormalBlending
                        }
                    }

                    function I(L, O) {
                        L.dispose(), O.unregisterMaterial(L), Object.keys(L).filter(function (N) {
                            return L[N] && L[N].isTexture
                        }).forEach(function (N) {
                            L[N].dispose()
                        })
                    }
                },
                "./src/components/obb-collider.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js");
                    g("obb-collider", {
                        schema: {
                            size: {default: 0},
                            trackedObject3D: {default: ""},
                            minimumColliderDimension: {default: .02},
                            centerModel: {default: !1}
                        }, init: function () {
                            this.previousScale = new w.Vector3().copy(this.el.object3D.scale), this.auxEuler = new w.Euler, this.boundingBox = new w.Box3, this.boundingBoxSize = new w.Vector3, this.updateCollider = this.updateCollider.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.updateBoundingBox = this.updateBoundingBox.bind(this), this.el.addEventListener("model-loaded", this.onModelLoaded), this.updateCollider(), this.system.addCollider(this.el)
                        }, remove: function () {
                            this.system.removeCollider(this.el)
                        }, update: function () {
                            this.data.trackedObject3D && (this.trackedObject3DPath = this.data.trackedObject3D.split("."))
                        }, onModelLoaded: function () {
                            this.data.centerModel && this.centerModel(), this.updateCollider()
                        }, centerModel: function () {
                            var v = this.el, E = v.components["gltf-model"] && v.components["gltf-model"].model, p, C;
                            E && (this.el.removeObject3D("mesh"), p = new w.Box3().setFromObject(E), C = p.getCenter(new w.Vector3), E.position.x += E.position.x - C.x, E.position.y += E.position.y - C.y, E.position.z += E.position.z - C.z, this.el.setObject3D("mesh", E))
                        }, updateCollider: function () {
                            var v = this.el, E = this.boundingBoxSize, p = this.aabb = this.aabb || new w.OBB;
                            if (this.obb = this.obb || new w.OBB, !v.hasLoaded) {
                                v.addEventListener("loaded", this.updateCollider);
                                return
                            }
                            this.updateBoundingBox(), p.halfSize.copy(E).multiplyScalar(.5), this.el.sceneEl.systems["obb-collider"].data.showColliders && this.showCollider()
                        }, showCollider: function () {
                            this.updateColliderMesh(), this.renderColliderMesh.visible = !0
                        }, updateColliderMesh: function () {
                            var v = this.renderColliderMesh, E = this.boundingBoxSize;
                            if (!v) {
                                this.initColliderMesh();
                                return
                            }
                            v.geometry.dispose(), v.geometry = new w.BoxGeometry(E.x, E.y, E.z)
                        }, hideCollider: function () {
                            this.renderColliderMesh && (this.renderColliderMesh.visible = !1)
                        }, initColliderMesh: function () {
                            var v, E, p;
                            v = this.boundingBoxSize, E = this.renderColliderGeometry = new w.BoxGeometry(v.x, v.y, v.z), p = this.renderColliderMesh = new w.Mesh(E, new w.MeshLambertMaterial({
                                color: 65280,
                                side: w.DoubleSide
                            })), p.matrixAutoUpdate = !1, p.matrixWorldAutoUpdate = !1, p.updateMatrixWorld = function () {
                            }, this.el.sceneEl.object3D.add(p)
                        }, updateBoundingBox: function () {
                            var v = new w.Vector3, E = new w.Vector3, p = new w.Quaternion, C = new w.Quaternion,
                                M = new w.Matrix4;
                            return function () {
                                var b = this.auxEuler, B = this.boundingBox, R = this.data.size,
                                    I = this.trackedObject3D || this.el.object3D, L = this.boundingBoxSize,
                                    O = this.data.minimumColliderDimension;
                                if (R) {
                                    this.boundingBoxSize.x = R, this.boundingBoxSize.y = R, this.boundingBoxSize.z = R;
                                    return
                                }
                                b.copy(I.rotation), I.rotation.set(0, 0, 0), I.parent.matrixWorld.decompose(v, p, E), M.compose(v, C, E), I.parent.matrixWorld.copy(M), B.setFromObject(I, !0), B.getSize(L), L.x = L.x < O ? O : L.x, L.y = L.y < O ? O : L.y, L.z = L.z < O ? O : L.z, I.parent.matrixWorld.compose(v, p, E), this.el.object3D.rotation.copy(b)
                            }
                        }(), checkTrackedObject: function () {
                            var v = this.trackedObject3DPath, E;
                            if (v && v.length && !this.trackedObject3D) {
                                E = this.el;
                                for (var p = 0; p < v.length && (E = E[v[p]], !!E); p++) ;
                                E && (this.trackedObject3D = E, this.updateCollider())
                            }
                            return this.trackedObject3D
                        }, tick: function () {
                            var v = new w.Vector3, E = new w.Vector3, p = new w.Quaternion, C = new w.Matrix4;
                            return function () {
                                var M = this.obb, b = this.renderColliderMesh,
                                    B = this.checkTrackedObject() || this.el.object3D;
                                B && (B.updateMatrix(), B.updateMatrixWorld(!0), B.matrixWorld.decompose(v, p, E), (Math.abs(E.x - this.previousScale.x) > 1e-4 || Math.abs(E.y - this.previousScale.y) > 1e-4 || Math.abs(E.z - this.previousScale.z) > 1e-4) && this.updateCollider(), this.previousScale.copy(E), E.set(1, 1, 1), C.compose(v, p, E), b && b.matrixWorld.copy(C), M.copy(this.aabb), M.applyMatrix4(C))
                            }
                        }()
                    })
                },
                "./src/components/obj-model.js": (m, x, h) => {
                    var g = h("./src/utils/debug.js"), w = h("./src/core/component.js").registerComponent,
                        v = h("./src/lib/three.js"), E = g("components:obj-model:warn");
                    m.exports.Component = w("obj-model", {
                        schema: {mtl: {type: "model"}, obj: {type: "model"}}, init: function () {
                            var p = this;
                            this.model = null, this.objLoader = new v.OBJLoader, this.mtlLoader = new v.MTLLoader(this.objLoader.manager), this.mtlLoader.crossOrigin = "", this.el.addEventListener("componentinitialized", function (C) {
                                p.model && C.detail.name === "material" && p.applyMaterial()
                            })
                        }, update: function () {
                            var p = this.data;
                            p.obj && (this.resetMesh(), this.loadObj(p.obj, p.mtl))
                        }, remove: function () {
                            this.resetMesh()
                        }, resetMesh: function () {
                            this.model && this.el.removeObject3D("mesh")
                        }, loadObj: function (p, C) {
                            var M = this, b = this.el, B = this.mtlLoader, R = this.objLoader,
                                I = this.el.sceneEl.systems.renderer, L = C.substr(0, C.lastIndexOf("/") + 1);
                            if (C) {
                                b.hasAttribute("material") && E("Material component properties are ignored when a .MTL is provided"), B.setResourcePath(L), B.load(C, function (O) {
                                    O.preload(), R.setMaterials(O), R.load(p, function (N) {
                                        M.model = N, M.model.traverse(function (F) {
                                            if (F.isMesh) {
                                                var V = F.material;
                                                V.map && I.applyColorCorrection(V.map), V.emissiveMap && I.applyColorCorrection(V.emissiveMap)
                                            }
                                        }), b.setObject3D("mesh", N), b.emit("model-loaded", {format: "obj", model: N})
                                    })
                                });
                                return
                            }
                            R.load(p, function (N) {
                                M.model = N, M.applyMaterial(), b.setObject3D("mesh", N), b.emit("model-loaded", {
                                    format: "obj",
                                    model: N
                                })
                            })
                        }, applyMaterial: function () {
                            var p = this.el.components.material;
                            p && this.model.traverse(function (C) {
                                C instanceof v.Mesh && (C.material = p.material)
                            })
                        }
                    })
                },
                "./src/components/oculus-go-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/tracked-controls.js"),
                        v = w.checkControllerPresentAndSetup, E = w.emitIfAxesChanged, p = w.onButtonEvent,
                        C = h("./src/utils/index.js").device.isWebXRAvailable, M = "oculus-go", b = "Oculus Go",
                        B = h("./src/constants/index.js").AFRAME_CDN_ROOT,
                        R = B + "controllers/oculus/go/oculus-go-controller.gltf", I = C ? M : b,
                        L = {axes: {trackpad: [0, 1]}, buttons: ["trackpad", "trigger"]},
                        O = {axes: {touchpad: [0, 1]}, buttons: ["trigger", "none", "touchpad"]}, N = C ? O : L;
                    m.exports.Component = g("oculus-go-controls", {
                        schema: {
                            hand: {default: ""},
                            buttonColor: {type: "color", default: "#FFFFFF"},
                            buttonTouchedColor: {type: "color", default: "#BBBBBB"},
                            buttonHighlightColor: {type: "color", default: "#7A7A7A"},
                            model: {default: !0},
                            orientationOffset: {type: "vec3"},
                            armModel: {default: !0}
                        }, mapping: N, bindMethods: function () {
                            this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        }, init: function () {
                            var F = this;
                            this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (V) {
                                p(V.detail.id, "down", F)
                            }, this.onButtonUp = function (V) {
                                p(V.detail.id, "up", F)
                            }, this.onButtonTouchStart = function (V) {
                                p(V.detail.id, "touchstart", F)
                            }, this.onButtonTouchEnd = function (V) {
                                p(V.detail.id, "touchend", F)
                            }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.bindMethods()
                        }, addEventListeners: function () {
                            var F = this.el;
                            F.addEventListener("buttonchanged", this.onButtonChanged), F.addEventListener("buttondown", this.onButtonDown), F.addEventListener("buttonup", this.onButtonUp), F.addEventListener("touchstart", this.onButtonTouchStart), F.addEventListener("touchend", this.onButtonTouchEnd), F.addEventListener("model-loaded", this.onModelLoaded), F.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0
                        }, removeEventListeners: function () {
                            var F = this.el;
                            F.removeEventListener("buttonchanged", this.onButtonChanged), F.removeEventListener("buttondown", this.onButtonDown), F.removeEventListener("buttonup", this.onButtonUp), F.removeEventListener("touchstart", this.onButtonTouchStart), F.removeEventListener("touchend", this.onButtonTouchEnd), F.removeEventListener("model-loaded", this.onModelLoaded), F.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1
                        }, checkIfControllerPresent: function () {
                            v(this, I, this.data.hand ? {hand: this.data.hand} : {})
                        }, play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        }, pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        }, injectTrackedControls: function () {
                            var F = this.el, V = this.data;
                            F.setAttribute("tracked-controls", {
                                armModel: V.armModel,
                                hand: V.hand,
                                idPrefix: I,
                                orientationOffset: V.orientationOffset
                            }), this.data.model && this.el.setAttribute("gltf-model", R)
                        }, addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        }, onModelLoaded: function (F) {
                            var V = F.detail.model, U;
                            F.target !== this.el || !this.data.model || (U = this.buttonMeshes = {}, U.trigger = V.getObjectByName("oculus_go_button_trigger"), U.trackpad = V.getObjectByName("oculus_go_touchpad"), U.touchpad = V.getObjectByName("oculus_go_touchpad"))
                        }, onButtonChanged: function (F) {
                            var V = this.mapping.buttons[F.detail.id];
                            V && this.el.emit(V + "changed", F.detail.state)
                        }, onAxisMoved: function (F) {
                            E(this, this.mapping.axes, F)
                        }, updateModel: function (F, V) {
                            this.data.model && this.updateButtonModel(F, V)
                        }, updateButtonModel: function (F, V) {
                            var U = this.buttonMeshes;
                            if (!(!U || !U[F])) {
                                var j, Y;
                                switch (V) {
                                    case"down":
                                        j = this.data.buttonHighlightColor;
                                        break;
                                    case"touchstart":
                                        j = this.data.buttonTouchedColor;
                                        break;
                                    default:
                                        j = this.data.buttonColor
                                }
                                Y = U[F], Y.material.color.set(j)
                            }
                        }
                    })
                },
                "./src/components/oculus-touch-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = h("./src/utils/tracked-controls.js"), E = v.checkControllerPresentAndSetup,
                        p = v.emitIfAxesChanged, C = v.onButtonEvent,
                        M = h("./src/utils/index.js").device.isWebXRAvailable, b = "oculus-touch", B = "Oculus Touch",
                        R = M ? b : B, I = h("./src/constants/index.js").AFRAME_CDN_ROOT,
                        L = I + "controllers/oculus/oculus-touch-controller-", O = I + "controllers/meta/", N = {
                            left: {
                                modelUrl: L + "left.gltf",
                                rayOrigin: {origin: {x: .008, y: -.01, z: 0}, direction: {x: 0, y: -.8, z: -1}},
                                modelPivotOffset: new w.Vector3(-.005, .003, -.055),
                                modelPivotRotation: new w.Euler(0, 0, 0)
                            },
                            right: {
                                modelUrl: L + "right.gltf",
                                rayOrigin: {origin: {x: -.008, y: -.01, z: 0}, direction: {x: 0, y: -.8, z: -1}},
                                modelPivotOffset: new w.Vector3(.005, .003, -.055),
                                modelPivotRotation: new w.Euler(0, 0, 0)
                            }
                        }, F = {
                            left: {
                                modelUrl: L + "left.gltf",
                                rayOrigin: {origin: {x: .002, y: -.005, z: -.03}, direction: {x: 0, y: -.8, z: -1}},
                                modelPivotOffset: new w.Vector3(-.005, .036, -.037),
                                modelPivotRotation: new w.Euler(Math.PI / 4.5, 0, 0)
                            },
                            right: {
                                modelUrl: L + "right.gltf",
                                rayOrigin: {origin: {x: -.002, y: -.005, z: -.03}, direction: {x: 0, y: -.8, z: -1}},
                                modelPivotOffset: new w.Vector3(.005, .036, -.037),
                                modelPivotRotation: new w.Euler(Math.PI / 4.5, 0, 0)
                            }
                        }, V = M ? F : N, U = "oculus-touch", j = {
                            "oculus-touch": V,
                            "oculus-touch-v2": {
                                left: {
                                    modelUrl: L + "gen2-left.gltf",
                                    rayOrigin: {origin: {x: -.006, y: -.03, z: -.04}, direction: {x: 0, y: -.9, z: -1}},
                                    modelPivotOffset: new w.Vector3(0, -.007, -.021),
                                    modelPivotRotation: new w.Euler(-Math.PI / 4, 0, 0)
                                },
                                right: {
                                    modelUrl: L + "gen2-right.gltf",
                                    rayOrigin: {origin: {x: .006, y: -.03, z: -.04}, direction: {x: 0, y: -.9, z: -1}},
                                    modelPivotOffset: new w.Vector3(0, -.007, -.021),
                                    modelPivotRotation: new w.Euler(-Math.PI / 4, 0, 0)
                                }
                            },
                            "oculus-touch-v3": {
                                left: {
                                    modelUrl: L + "v3-left.glb",
                                    rayOrigin: {
                                        origin: {x: .0065, y: -.0186, z: -.05},
                                        direction: {x: .12394785839500175, y: -.5944043672340157, z: -.7945567170519814}
                                    },
                                    modelPivotOffset: new w.Vector3(0, 0, 0),
                                    modelPivotRotation: new w.Euler(0, 0, 0)
                                },
                                right: {
                                    modelUrl: L + "v3-right.glb",
                                    rayOrigin: {
                                        origin: {x: -.0065, y: -.0186, z: -.05},
                                        direction: {x: -.12394785839500175, y: -.5944043672340157, z: -.7945567170519814}
                                    },
                                    modelPivotOffset: new w.Vector3(0, 0, 0),
                                    modelPivotRotation: new w.Euler(0, 0, 0)
                                }
                            },
                            "meta-quest-touch-pro": {
                                left: {
                                    modelUrl: O + "quest-touch-pro-left.glb",
                                    rayOrigin: {
                                        origin: {x: .0065, y: -.0186, z: -.05},
                                        direction: {x: .12394785839500175, y: -.5944043672340157, z: -.7945567170519814}
                                    },
                                    modelPivotOffset: new w.Vector3(0, 0, 0),
                                    modelPivotRotation: new w.Euler(0, 0, 0)
                                },
                                right: {
                                    modelUrl: O + "quest-touch-pro-right.glb",
                                    rayOrigin: {
                                        origin: {x: -.0065, y: -.0186, z: -.05},
                                        direction: {x: -.12394785839500175, y: -.5944043672340157, z: -.7945567170519814}
                                    },
                                    modelPivotOffset: new w.Vector3(0, 0, 0),
                                    modelPivotRotation: new w.Euler(0, 0, 0)
                                }
                            },
                            "meta-quest-touch-plus": {
                                left: {
                                    modelUrl: O + "quest-touch-plus-left.glb",
                                    rayOrigin: {
                                        origin: {x: .0065, y: -.0186, z: -.05},
                                        direction: {x: .12394785839500175, y: -.5944043672340157, z: -.7945567170519814}
                                    },
                                    modelPivotOffset: new w.Vector3(0, 0, 0),
                                    modelPivotRotation: new w.Euler(0, 0, 0)
                                },
                                right: {
                                    modelUrl: O + "quest-touch-plus-right.glb",
                                    rayOrigin: {
                                        origin: {x: -.0065, y: -.0186, z: -.05},
                                        direction: {x: -.12394785839500175, y: -.5944043672340157, z: -.7945567170519814}
                                    },
                                    modelPivotOffset: new w.Vector3(0, 0, 0),
                                    modelPivotRotation: new w.Euler(0, 0, 0)
                                }
                            }
                        }, Y = {
                            left: {
                                axes: {thumbstick: [0, 1]},
                                buttons: ["thumbstick", "trigger", "grip", "xbutton", "ybutton", "surface"]
                            },
                            right: {
                                axes: {thumbstick: [0, 1]},
                                buttons: ["thumbstick", "trigger", "grip", "abutton", "bbutton", "surface"]
                            }
                        }, fe = {
                            left: {
                                axes: {thumbstick: [2, 3]},
                                buttons: ["trigger", "grip", "none", "thumbstick", "xbutton", "ybutton", "surface"]
                            },
                            right: {
                                axes: {thumbstick: [2, 3]},
                                buttons: ["trigger", "grip", "none", "thumbstick", "abutton", "bbutton", "surface"]
                            }
                        }, se = M ? fe : Y;
                    m.exports.Component = g("oculus-touch-controls", {
                        schema: {
                            hand: {default: "left"},
                            buttonColor: {type: "color", default: "#999"},
                            buttonTouchColor: {type: "color", default: "#8AB"},
                            buttonHighlightColor: {type: "color", default: "#2DF"},
                            model: {default: !0},
                            controllerType: {
                                default: "auto",
                                oneOf: ["auto", "oculus-touch", "oculus-touch-v2", "oculus-touch-v3"]
                            },
                            orientationOffset: {type: "vec3", default: {x: 43, y: 0, z: 0}}
                        }, after: ["tracked-controls"], mapping: se, bindMethods: function () {
                            this.onButtonChanged = this.onButtonChanged.bind(this), this.onThumbstickMoved = this.onThumbstickMoved.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        }, init: function () {
                            var ue = this;
                            this.onButtonDown = function (he) {
                                C(he.detail.id, "down", ue, ue.data.hand)
                            }, this.onButtonUp = function (he) {
                                C(he.detail.id, "up", ue, ue.data.hand)
                            }, this.onButtonTouchStart = function (he) {
                                C(he.detail.id, "touchstart", ue, ue.data.hand)
                            }, this.onButtonTouchEnd = function (he) {
                                C(he.detail.id, "touchend", ue, ue.data.hand)
                            }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.previousButtonValues = {}, this.bindMethods(), this.triggerEuler = new w.Euler
                        }, addEventListeners: function () {
                            var ue = this.el;
                            ue.addEventListener("buttonchanged", this.onButtonChanged), ue.addEventListener("buttondown", this.onButtonDown), ue.addEventListener("buttonup", this.onButtonUp), ue.addEventListener("touchstart", this.onButtonTouchStart), ue.addEventListener("touchend", this.onButtonTouchEnd), ue.addEventListener("axismove", this.onAxisMoved), ue.addEventListener("model-loaded", this.onModelLoaded), ue.addEventListener("thumbstickmoved", this.onThumbstickMoved), this.controllerEventsActive = !0
                        }, removeEventListeners: function () {
                            var ue = this.el;
                            ue.removeEventListener("buttonchanged", this.onButtonChanged), ue.removeEventListener("buttondown", this.onButtonDown), ue.removeEventListener("buttonup", this.onButtonUp), ue.removeEventListener("touchstart", this.onButtonTouchStart), ue.removeEventListener("touchend", this.onButtonTouchEnd), ue.removeEventListener("axismove", this.onAxisMoved), ue.removeEventListener("model-loaded", this.onModelLoaded), ue.removeEventListener("thumbstickmoved", this.onThumbstickMoved), this.controllerEventsActive = !1
                        }, checkIfControllerPresent: function () {
                            E(this, R, {hand: this.data.hand, iterateControllerProfiles: !0})
                        }, play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        }, pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        }, loadModel: function (ue) {
                            var he = this.data, Z;
                            if (he.model) {
                                if (this.controllerObject3D) {
                                    this.el.setObject3D("mesh", this.controllerObject3D);
                                    return
                                }
                                if (this.displayModel = j[he.controllerType] || j[U], he.controllerType === "auto") {
                                    var H = this.el.sceneEl.systems["tracked-controls-webvr"];
                                    if (H && H.vrDisplay) {
                                        var ae = H.vrDisplay.displayName;
                                        /^Oculus Quest$/.test(ae) && (this.displayModel = j["oculus-touch-v2"])
                                    } else {
                                        Z = U;
                                        for (var ee = Object.keys(j), me = 0; me < ue.profiles.length; me++) if (ee.indexOf(ue.profiles[me]) !== -1) {
                                            Z = ue.profiles[me];
                                            break
                                        }
                                        this.displayModel = j[Z]
                                    }
                                }
                                var Re = this.displayModel[he.hand].modelUrl;
                                this.isTouchV3orPROorPlus = this.displayModel === j["oculus-touch-v3"] || this.displayModel === j["meta-quest-touch-pro"] || this.displayModel === j["meta-quest-touch-plus"], this.el.setAttribute("gltf-model", Re)
                            }
                        }, injectTrackedControls: function (ue) {
                            var he = this.data, Z = b,
                                H = he.hand === "right" ? "Oculus Touch (Right)" : "Oculus Touch (Left)",
                                ae = M ? Z : H;
                            this.el.setAttribute("tracked-controls", {
                                id: ae,
                                hand: he.hand,
                                orientationOffset: he.orientationOffset,
                                handTrackingEnabled: !1,
                                iterateControllerProfiles: !0,
                                space: "gripSpace"
                            }), this.loadModel(ue)
                        }, addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        }, onButtonChanged: function (ue) {
                            var he = this.mapping[this.data.hand].buttons[ue.detail.id];
                            if (he) {
                                if (this.isTouchV3orPROorPlus) this.onButtonChangedV3orPROorPlus(ue); else {
                                    var Z = this.buttonMeshes, H;
                                    (he === "trigger" || he === "grip") && (H = ue.detail.state.value), Z && (he === "trigger" && Z.trigger && (Z.trigger.rotation.x = this.originalXRotationTrigger - H * (Math.PI / 26)), he === "grip" && Z.grip && (H *= this.data.hand === "left" ? -1 : 1, Z.grip.position.x = this.originalXPositionGrip + H * .004))
                                }
                                this.el.emit(he + "changed", ue.detail.state)
                            }
                        }, onButtonChangedV3orPROorPlus: function (ue) {
                            var he = this.mapping[this.data.hand].buttons[ue.detail.id], Z = this.buttonObjects, H;
                            !Z || !Z[he] || (H = ue.detail.state.value, Z[he].quaternion.slerpQuaternions(this.buttonRanges[he].min.quaternion, this.buttonRanges[he].max.quaternion, H), Z[he].position.lerpVectors(this.buttonRanges[he].min.position, this.buttonRanges[he].max.position, H))
                        }, onModelLoaded: function (ue) {
                            if (!(ue.target !== this.el || !this.data.model)) {
                                if (this.isTouchV3orPROorPlus) this.onTouchV3orPROorPlusModelLoaded(ue); else {
                                    var he = this.controllerObject3D = ue.detail.model, Z;
                                    Z = this.buttonMeshes = {}, Z.grip = he.getObjectByName("buttonHand"), this.originalXPositionGrip = Z.grip && Z.grip.position.x, Z.trigger = he.getObjectByName("buttonTrigger"), this.originalXRotationTrigger = Z.trigger && Z.trigger.rotation.x, Z.thumbstick = he.getObjectByName("stick"), Z.xbutton = he.getObjectByName("buttonX"), Z.abutton = he.getObjectByName("buttonA"), Z.ybutton = he.getObjectByName("buttonY"), Z.bbutton = he.getObjectByName("buttonB")
                                }
                                for (var H in this.buttonMeshes) this.buttonMeshes[H] && pe(this.buttonMeshes[H]);
                                this.applyOffset(ue.detail.model), this.el.emit("controllermodelready", {
                                    name: "oculus-touch-controls",
                                    model: this.data.model,
                                    rayOrigin: this.displayModel[this.data.hand].rayOrigin
                                })
                            }
                        }, applyOffset: function (ue) {
                            ue.position.copy(this.displayModel[this.data.hand].modelPivotOffset), ue.rotation.copy(this.displayModel[this.data.hand].modelPivotRotation)
                        }, onTouchV3orPROorPlusModelLoaded: function (ue) {
                            var he = this.controllerObject3D = ue.detail.model, Z = this.buttonObjects = {},
                                H = this.buttonMeshes = {}, ae = this.buttonRanges = {};
                            H.grip = he.getObjectByName("squeeze"), Z.grip = he.getObjectByName("xr_standard_squeeze_pressed_value"), ae.grip = {
                                min: he.getObjectByName("xr_standard_squeeze_pressed_min"),
                                max: he.getObjectByName("xr_standard_squeeze_pressed_max")
                            }, Z.grip.minX = Z.grip.position.x, H.thumbstick = he.getObjectByName("thumbstick"), Z.thumbstick = he.getObjectByName("xr_standard_thumbstick_pressed_value"), ae.thumbstick = {
                                min: he.getObjectByName("xr_standard_thumbstick_pressed_min"),
                                max: he.getObjectByName("xr_standard_thumbstick_pressed_max")
                            }, Z.thumbstickXAxis = he.getObjectByName("xr_standard_thumbstick_xaxis_pressed_value"), ae.thumbstickXAxis = {
                                min: he.getObjectByName("xr_standard_thumbstick_xaxis_pressed_min"),
                                max: he.getObjectByName("xr_standard_thumbstick_xaxis_pressed_max")
                            }, Z.thumbstickYAxis = he.getObjectByName("xr_standard_thumbstick_yaxis_pressed_value"), ae.thumbstickYAxis = {
                                min: he.getObjectByName("xr_standard_thumbstick_yaxis_pressed_min"),
                                max: he.getObjectByName("xr_standard_thumbstick_yaxis_pressed_max")
                            }, H.trigger = he.getObjectByName("trigger"), Z.trigger = he.getObjectByName("xr_standard_trigger_pressed_value"), ae.trigger = {
                                min: he.getObjectByName("xr_standard_trigger_pressed_min"),
                                max: he.getObjectByName("xr_standard_trigger_pressed_max")
                            }, ae.trigger.diff = {
                                x: Math.abs(ae.trigger.max.rotation.x) - Math.abs(ae.trigger.min.rotation.x),
                                y: Math.abs(ae.trigger.max.rotation.y) - Math.abs(ae.trigger.min.rotation.y),
                                z: Math.abs(ae.trigger.max.rotation.z) - Math.abs(ae.trigger.min.rotation.z)
                            };
                            var ee = this.data.hand === "left" ? "x" : "a", me = this.data.hand === "left" ? "y" : "b",
                                Re = ee + "button", ke = me + "button";
                            H[Re] = he.getObjectByName(ee + "_button"), Z[Re] = he.getObjectByName(ee + "_button_pressed_value"), ae[Re] = {
                                min: he.getObjectByName(ee + "_button_pressed_min"),
                                max: he.getObjectByName(ee + "_button_pressed_max")
                            }, H[ke] = he.getObjectByName(me + "_button"), Z[ke] = he.getObjectByName(me + "_button_pressed_value"), ae[ke] = {
                                min: he.getObjectByName(me + "_button_pressed_min"),
                                max: he.getObjectByName(me + "_button_pressed_max")
                            }
                        }, onAxisMoved: function (ue) {
                            p(this, this.mapping[this.data.hand].axes, ue)
                        }, onThumbstickMoved: function (ue) {
                            if (!(!this.buttonMeshes || !this.buttonMeshes.thumbstick)) {
                                if (this.isTouchV3orPROorPlus) {
                                    this.updateThumbstickTouchV3orPROorPlus(ue);
                                    return
                                }
                                for (var he in ue.detail) this.buttonObjects.thumbstick.rotation[this.axisMap[he]] = this.buttonRanges.thumbstick.originalRotation[this.axisMap[he]] - Math.PI / 8 * ue.detail[he] * (he === "y" || this.data.hand === "right" ? -1 : 1)
                            }
                        }, axisMap: {y: "x", x: "z"}, updateThumbstickTouchV3orPROorPlus: function (ue) {
                            var he = (ue.detail.x + 1) / 2;
                            this.buttonObjects.thumbstickXAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickXAxis.min.quaternion, this.buttonRanges.thumbstickXAxis.max.quaternion, he);
                            var Z = (ue.detail.y + 1) / 2;
                            this.buttonObjects.thumbstickYAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickYAxis.min.quaternion, this.buttonRanges.thumbstickYAxis.max.quaternion, Z)
                        }, updateModel: function (ue, he) {
                            this.data.model && this.updateButtonModel(ue, he)
                        }, updateButtonModel: function (ue, he) {
                            var Z = this.buttonMeshes, H, ae;
                            Z && Z[ue] && (ae = he === "up" || he === "touchend" ? Z[ue].originalColor || this.data.buttonColor : he === "touchstart" ? this.data.buttonTouchColor : this.data.buttonHighlightColor, H = Z[ue], H.material.color.set(ae))
                        }
                    });

                    function pe(ue) {
                        ue.traverse(function (he) {
                            var Z;
                            he.type === "Mesh" && (Z = he.material.clone(), ue.originalColor = he.material.color, he.material.dispose(), he.material = Z)
                        })
                    }
                },
                "./src/components/pico-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = h("./src/utils/tracked-controls.js"), E = v.checkControllerPresentAndSetup,
                        p = v.emitIfAxesChanged, C = v.onButtonEvent, M = "pico-4",
                        b = h("./src/constants/index.js").AFRAME_CDN_ROOT, B = b + "controllers/pico/pico4/", R = {
                            left: {
                                axes: {touchpad: [2, 3]},
                                buttons: ["trigger", "squeeze", "none", "thumbstick", "xbutton", "ybutton"]
                            },
                            right: {
                                axes: {touchpad: [2, 3]},
                                buttons: ["trigger", "squeeze", "none", "thumbstick", "abutton", "bbutton"]
                            }
                        };
                    m.exports.Component = g("pico-controls", {
                        schema: {hand: {default: "none"}, model: {default: !0}, orientationOffset: {type: "vec3"}},
                        mapping: R,
                        init: function () {
                            var I = this;
                            this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (L) {
                                C(L.detail.id, "down", I, I.data.hand)
                            }, this.onButtonUp = function (L) {
                                C(L.detail.id, "up", I, I.data.hand)
                            }, this.onButtonTouchEnd = function (L) {
                                C(L.detail.id, "touchend", I, I.data.hand)
                            }, this.onButtonTouchStart = function (L) {
                                C(L.detail.id, "touchstart", I, I.data.hand)
                            }, this.bindMethods()
                        },
                        update: function () {
                            var I = this.data;
                            this.controllerIndex = I.hand === "right" ? 0 : I.hand === "left" ? 1 : 2
                        },
                        play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        },
                        pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        },
                        bindMethods: function () {
                            this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        },
                        addEventListeners: function () {
                            var I = this.el;
                            I.addEventListener("buttonchanged", this.onButtonChanged), I.addEventListener("buttondown", this.onButtonDown), I.addEventListener("buttonup", this.onButtonUp), I.addEventListener("touchstart", this.onButtonTouchStart), I.addEventListener("touchend", this.onButtonTouchEnd), I.addEventListener("axismove", this.onAxisMoved), I.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0
                        },
                        removeEventListeners: function () {
                            var I = this.el;
                            I.removeEventListener("buttonchanged", this.onButtonChanged), I.removeEventListener("buttondown", this.onButtonDown), I.removeEventListener("buttonup", this.onButtonUp), I.removeEventListener("touchstart", this.onButtonTouchStart), I.removeEventListener("touchend", this.onButtonTouchEnd), I.removeEventListener("axismove", this.onAxisMoved), I.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1
                        },
                        checkIfControllerPresent: function () {
                            var I = this.data;
                            E(this, M, {index: this.controllerIndex, hand: I.hand})
                        },
                        injectTrackedControls: function () {
                            var I = this.el, L = this.data;
                            I.setAttribute("tracked-controls", {
                                idPrefix: M,
                                hand: L.hand,
                                controller: this.controllerIndex,
                                orientationOffset: L.orientationOffset
                            }), this.data.model && this.el.setAttribute("gltf-model", B + this.data.hand + ".glb")
                        },
                        addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        },
                        removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        },
                        onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        },
                        onButtonChanged: function (I) {
                            var L = this.mapping[this.data.hand].buttons[I.detail.id], O;
                            L && (L === "trigger" && (O = I.detail.state.value, console.log("analog value of trigger press: " + O)), this.el.emit(L + "changed", I.detail.state))
                        },
                        onModelLoaded: function (I) {
                            I.target !== this.el || !this.data.model || this.el.emit("controllermodelready", {
                                name: "pico-controls",
                                model: this.data.model,
                                rayOrigin: new w.Vector3(0, 0, 0)
                            })
                        },
                        onAxisMoved: function (I) {
                            p(this, this.mapping.axes, I)
                        }
                    })
                },
                "./src/components/position.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("position", {
                        schema: {type: "vec3"}, update: function () {
                            var w = this.el.object3D, v = this.data;
                            w.position.set(v.x, v.y, v.z)
                        }, remove: function () {
                            this.el.object3D.position.set(0, 0, 0)
                        }
                    })
                },
                "./src/components/raycaster.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = h("./src/utils/index.js"), E = v.debug("components:raycaster:warn"), p = /^[\w\s-.,[\]#]*$/,
                        C = {childList: !0, attributes: !0, subtree: !0}, M = {
                            INTERSECT: "raycaster-intersected",
                            INTERSECTION: "raycaster-intersection",
                            INTERSECT_CLEAR: "raycaster-intersected-cleared",
                            INTERSECTION_CLEAR: "raycaster-intersection-cleared",
                            INTERSECTION_CLOSEST_ENTITY_CHANGED: "raycaster-closest-entity-changed"
                        };
                    m.exports.Component = g("raycaster", {
                        schema: {
                            autoRefresh: {default: !0},
                            direction: {type: "vec3", default: {x: 0, y: 0, z: -1}},
                            enabled: {default: !0},
                            far: {default: 1e3},
                            interval: {default: 0},
                            near: {default: 0},
                            objects: {default: ""},
                            origin: {type: "vec3"},
                            showLine: {default: !1},
                            lineColor: {default: "white"},
                            lineOpacity: {default: 1},
                            useWorldCoordinates: {default: !1}
                        }, multiple: !0, init: function () {
                            this.clearedIntersectedEls = [], this.unitLineEndVec3 = new w.Vector3, this.intersectedEls = [], this.intersections = [], this.newIntersectedEls = [], this.newIntersections = [], this.objects = [], this.prevCheckTime = void 0, this.prevIntersectedEls = [], this.rawIntersections = [], this.raycaster = new w.Raycaster, this.updateOriginDirection(), this.setDirty = this.setDirty.bind(this), this.updateLine = this.updateLine.bind(this), this.observer = new MutationObserver(this.setDirty), this.dirty = !0, this.lineEndVec3 = new w.Vector3, this.otherLineEndVec3 = new w.Vector3, this.lineData = {end: this.lineEndVec3}, this.getIntersection = this.getIntersection.bind(this), this.intersectedDetail = {
                                el: this.el,
                                getIntersection: this.getIntersection
                            }, this.intersectedClearedDetail = {el: this.el}, this.intersectionClearedDetail = {clearedEls: this.clearedIntersectedEls}, this.intersectionDetail = {}
                        }, update: function (B) {
                            var R = this.data, I = this.el, L = this.raycaster;
                            L.far = R.far, L.near = R.near, R.showLine && (R.far !== B.far || R.origin !== B.origin || R.direction !== B.direction || !B.showLine) && (this.unitLineEndVec3.copy(R.direction).normalize(), this.drawLine()), !R.showLine && B.showLine && I.removeAttribute("line"), R.objects !== B.objects && !p.test(R.objects) && E('[raycaster] Selector "' + R.objects + '" may not update automatically with DOM changes.'), R.objects || E('[raycaster] For performance, please define raycaster.objects when using raycaster or cursor components to whitelist which entities to intersect with. e.g., raycaster="objects: [data-raycastable]".'), R.autoRefresh !== B.autoRefresh && I.isPlaying && (R.autoRefresh ? this.addEventListeners() : this.removeEventListeners()), B.enabled && !R.enabled && this.clearAllIntersections(), this.setDirty()
                        }, play: function () {
                            this.addEventListeners()
                        }, pause: function () {
                            this.removeEventListeners()
                        }, remove: function () {
                            this.data.showLine && this.el.removeAttribute("line"), this.clearAllIntersections()
                        }, addEventListeners: function () {
                            this.data.autoRefresh && (this.observer.observe(this.el.sceneEl, C), this.el.sceneEl.addEventListener("object3dset", this.setDirty), this.el.sceneEl.addEventListener("object3dremove", this.setDirty))
                        }, removeEventListeners: function () {
                            this.observer.disconnect(), this.el.sceneEl.removeEventListener("object3dset", this.setDirty), this.el.sceneEl.removeEventListener("object3dremove", this.setDirty)
                        }, setDirty: function () {
                            this.dirty = !0
                        }, refreshObjects: function () {
                            var B = this.data, R;
                            R = B.objects ? this.el.sceneEl.querySelectorAll(B.objects) : this.el.sceneEl.querySelectorAll("*"), this.objects = this.flattenObject3DMaps(R), this.dirty = !1
                        }, tock: function (B) {
                            var R = this.data, I = this.prevCheckTime;
                            R.enabled && (I && B - I < R.interval || (this.prevCheckTime = B, this.checkIntersections()))
                        }, checkIntersections: function () {
                            var B = this.clearedIntersectedEls, R = this.el, I = this.data, L, O = this.intersectedEls,
                                N, F = this.intersections, V = this.newIntersectedEls, U = this.newIntersections,
                                j = this.prevIntersectedEls, Y = this.rawIntersections;
                            for (this.dirty && this.refreshObjects(), b(this.prevIntersectedEls, this.intersectedEls), this.updateOriginDirection(), Y.length = 0, this.raycaster.intersectObjects(this.objects, !0, Y), F.length = 0, O.length = 0, L = 0; L < Y.length; L++) N = Y[L], !(I.showLine && N.object === R.getObject3D("line")) && N.object.el && (F.push(N), O.push(N.object.el));
                            for (U.length = 0, V.length = 0, L = 0; L < F.length; L++) j.indexOf(F[L].object.el) === -1 && (U.push(F[L]), V.push(F[L].object.el));
                            for (B.length = 0, L = 0; L < j.length; L++) O.indexOf(j[L]) === -1 && (j[L].emit(M.INTERSECT_CLEAR, this.intersectedClearedDetail), B.push(j[L]));
                            for (B.length && R.emit(M.INTERSECTION_CLEAR, this.intersectionClearedDetail), L = 0; L < V.length; L++) V[L].emit(M.INTERSECT, this.intersectedDetail);
                            U.length && (this.intersectionDetail.els = V, this.intersectionDetail.intersections = U, R.emit(M.INTERSECTION, this.intersectionDetail)), (j.length === 0 && F.length > 0 || j.length > 0 && F.length === 0 || j.length && F.length && j[0] !== F[0].object.el) && (this.intersectionDetail.els = this.intersectedEls, this.intersectionDetail.intersections = F, R.emit(M.INTERSECTION_CLOSEST_ENTITY_CHANGED, this.intersectionDetail)), I.showLine && setTimeout(this.updateLine)
                        }, updateLine: function () {
                            var B = this.el, R = this.intersections, I;
                            R.length && (R[0].object.el === B && R[1] ? I = R[1].distance : I = R[0].distance), this.drawLine(I)
                        }, getIntersection: function (B) {
                            var R, I;
                            for (R = 0; R < this.intersections.length; R++) if (I = this.intersections[R], I.object.el === B) return I;
                            return null
                        }, updateOriginDirection: function () {
                            var B = new w.Vector3, R = new w.Vector3;
                            return function () {
                                var L = this.el, O = this.data;
                                if (O.useWorldCoordinates) {
                                    this.raycaster.set(O.origin, O.direction);
                                    return
                                }
                                L.object3D.updateMatrixWorld(), R.setFromMatrixPosition(L.object3D.matrixWorld), (O.origin.x !== 0 || O.origin.y !== 0 || O.origin.z !== 0) && (R = L.object3D.localToWorld(R.copy(O.origin))), B.copy(O.direction).transformDirection(L.object3D.matrixWorld).normalize(), this.raycaster.set(R, B)
                            }
                        }(), drawLine: function (B) {
                            var R = this.data, I = this.el, L;
                            L = this.lineData.end === this.lineEndVec3 ? this.otherLineEndVec3 : this.lineEndVec3, B === void 0 && (B = R.far === 1 / 0 ? 1e3 : R.far), this.lineData.start = R.origin, this.lineData.end = L.copy(this.unitLineEndVec3).multiplyScalar(B).add(R.origin), this.lineData.color = R.lineColor, this.lineData.opacity = R.lineOpacity, I.setAttribute("line", this.lineData)
                        }, flattenObject3DMaps: function (B) {
                            var R, I, L = this.objects, O = this.el.sceneEl.object3D;

                            function N(V) {
                                return V.parent ? N(V.parent) : V === O
                            }

                            for (L.length = 0, I = 0; I < B.length; I++) {
                                var F = B[I];
                                if (F.isEntity && F.object3D && N(F.object3D)) for (R in F.object3DMap) L.push(F.getObject3D(R))
                            }
                            return L
                        }, clearAllIntersections: function () {
                            var B;
                            for (B = 0; B < this.intersectedEls.length; B++) this.intersectedEls[B].emit(M.INTERSECT_CLEAR, this.intersectedClearedDetail);
                            b(this.clearedIntersectedEls, this.intersectedEls), this.intersectedEls.length = 0, this.intersections.length = 0, this.el.emit(M.INTERSECTION_CLEAR, this.intersectionClearedDetail)
                        }
                    });

                    function b(B, R) {
                        var I;
                        for (B.length = R.length, I = 0; I < R.length; I++) B[I] = R[I]
                    }
                },
                "./src/components/rotation.js": (m, x, h) => {
                    var g = h("./src/lib/three.js").MathUtils.degToRad,
                        w = h("./src/core/component.js").registerComponent;
                    m.exports.Component = w("rotation", {
                        schema: {type: "vec3"}, update: function () {
                            var v = this.data, E = this.el.object3D;
                            E.rotation.set(g(v.x), g(v.y), g(v.z), "YXZ")
                        }, remove: function () {
                            this.el.object3D.rotation.set(0, 0, 0)
                        }
                    })
                },
                "./src/components/scale.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("scale", {
                        schema: {type: "vec3", default: {x: 1, y: 1, z: 1}},
                        update: function () {
                            var w = this.data, v = this.el.object3D;
                            v.scale.set(w.x, w.y, w.z)
                        },
                        remove: function () {
                            this.el.object3D.scale.set(1, 1, 1)
                        }
                    })
                },
                "./src/components/scene/ar-hit-test.js": (m, x, h) => {
                    var g = "data:image/webp;base64,UklGRkQHAABXRUJQVlA4WAoAAAAQAAAA/wEA/wEAQUxQSL0DAAARDzD/ERGCjrY9sYYFfgo6aa1kJ7K0w9Lo3AadLSVeFxevQwj5kuM8RfR/Atw/C0+ozB/oUBrloFZs6ElSW88j1KA4yExNWQaqRZquIDF0JYmlq0hAuUDTFu66tng3teW7pa3cQf1V1edvur54M/Slm6Wv3Gx9zw0MXlQLntcsBN6wkHjTQuYtC4W3LTw8mGRVG57TbAROtxHfZNhInGkjc5aNwtk2Hg6Mvki14k+NkZzCwQgCxalcAv3kddRTPI1DcUrXId1FLf1uHpzaQz4tquhZVLlKesbVpqKeTj0n0F5PpXDlFN9UqmhalL/ImuZFo6KmToWLoKlddMprqlS8cKovBvHo2kTiFV2LN4msaxKZl3QNiair8xYRdDWivIvXVXmbcMqJ51UebZuFXxZt6xd4laxtciqRtA3Cv0nU1t+kEUFbI8JvCa+tvkm3FDlO/W+OR99+kWEp/YYo+tYfTVnf/K8cE/F///3vv//993eeL+a+uvjawLcX3xjYvJotBFY3kVjTRGFtE+BU2AiMbiQyhpHMWEYeBozAH5qNBYRDB5KBCaTDBKKBAZTDBoKBDjwHAN5ABeCJBsAZcAAC0YHHxAYSMYBiYgGZWEA2MYFCbCCZGAAIANFEB+AnYgMQTDQAYSJ2AN5EBZAm4gDgTDgAeSIu4DGygTIRN1CMLOCZiACykQlg4jsAycgA8AO+BxCNdJyDkcbwRirDGXGnx8w+FDPrkM3MQ9JQZMYhiiwV/RDMtIM3U1/DmXHUo+IR2kSR2ToWkQ1NIn2qf2J8LCqJKiDUiSADHY3whirhdHgZ94HKaR97PhE+twEUJUFoAcgyTct8hfSxSkShASDKdMJ/ritKHwgyQ0sD4D/miCxU5SbhOOUDTnZpccCjYP/i0bZ/8bAgtVGEoGapWIQXyzKVKLwgNJFk2rtMIgoNRJlOZF7SNSSyUEeQmbxBFKEmtYjEe8S8zOZ1AkJVCmS88FJOtF40Ksg4oUaFiygk3C8qlTVNyl8UTevCUdAE2t14PfVqU1FPp57TopKeQZWromddTQp6QOfTOEQt/ZDuipZ11w/wOiqO8dRORcc6BQEkDQMClaHcn5wV9yLbxsNZNgpn2sicYSNxuo34Js1G4FQbnuNsOPa28PCWhcKbFjJvWEi8ZiHwqgXPcxbc5db33Cx95WboSzddX7yp+vyN0+eul7ZyN7Xlu64t3jVt4c5pc4JLV5EYupJE0xUknC4nOjVlmaYpyLit53HCQ0+ScnqceNcS5dzUkd0/CwMAVlA4IGADAAAQXwCdASoAAgACP8ne6Wy/tjCpqJ/IA/A5CWlu4XYBG/Pz8AfwD8APz//f3v8E1fuHZnxKYACtfuHZnxKYACrYTb5mOslhxu843ecbvON3nG7zjd3a0VCn7G1MABVxwH/Xd25gAK1+4dmfEpe2+PHhQaj75++riG6FuYACtfuHZnxKYACRrK3q9xO8Ss3uWKnMhs/rDF1hi6wxdYYusMXWGI5QRcCFDZog5OgqNlse1NDuz/UoFa/cOzPiUwAEsAOK4/nu5eZHK2tlXxJfNYlMABWv3Dsz4bvNJ5YA/LtxJ38SmAArX7h2Z8Sk5vdZUYv7mZPiUwAFa/cOzPh21s5OgZxf1mfEpemRyFr/rM+JS9noA/LtxJ38SmAAlUJIotzAASn6TjdhK+D3Dsz4dyvB7h2Z8O2tnJ0DOL+sz4lL2nKLT4lL/+iSLOocxq639w7M34MNZdm55uJ8v8ra2cpVZnxKTq2F3PN/cNksAfl24k7+JTAASqrD37h2Z7b1W+VtbOUqsz4lJ1bC7nm/uGyWAPy7cSd/EpgAJVVh79w7M9t6rfK2tnKVWZ8Sk6thdzzf3DZLAH5duJO/iUwAEqqw9+4dme29VvlbWzlKrM+JSdWwu55v7hslgD8u3EnfxKYACVVYe/cOzPbeq3ytrZylVme0kYJ8557FLerqFrzIbPrrf3DZLAH5duJO/iUvaVMS9BoaF4p7pSDFTP1XMyfElelrM0DOL+sz4eBJ13nV1OppBGPuKb4YzXQgq9uH19uS/0+JS9t9fr6ZUlQBelDG6GMgq97otb5QMPJwtKyBTbFp8Sl7b6/X0ykkawEOsgdiE6Fi0vb/Eve6xkwsmug0Z4nGNHQO8839bpTsjpz7SWIJxKagvd1QWMa6FYT1KEw3j4XDT6vJ9Xk+nyfT5Pq8n1eEmk5dinMM/9Fcfz4Z3Dsz3KD2dw7LxBRxKrqUUGQPH/7zxr1KIfNpLEJ0MZB2ITM/0Z2EFoh12NlXnEcpYcbvON3nG7zjd5xu84vfcNIAAP7+y8ceyzbVxkakPYY4lcr72fqOnDwipv+yxC71wAADBrjKnAAAAAAAAAAAAAAw7oNGHttqWONcoFN/2WIDc2pa6WVFtFYROlsaMaTXdcOjXHz93+YxAglKa4AAAAA=",
                        w = h("./src/core/component.js").registerComponent, v = h("./src/lib/three.js"), E = 21,
                        p = function () {
                            var B = new v.Quaternion, R = new v.Vector3;

                            function I(L, O, N) {
                                O.position.copy(L.transform.position), O.quaternion.copy(L.transform.orientation), R.copy(N), B.copy(L.transform.orientation), R.applyQuaternion(B), O.position.sub(R)
                            }

                            return I
                        }();
                    p.tempFakePose = {transform: {orientation: new v.Quaternion, position: new v.Vector3}};

                    function C(B, R) {
                        this.renderer = B, this.xrHitTestSource = null, B.xr.addEventListener("sessionend", (function () {
                            this.xrHitTestSource = null
                        }).bind(this)), B.xr.addEventListener("sessionstart", (function () {
                            this.sessionStart(R)
                        }).bind(this)), this.renderer.xr.isPresenting && this.sessionStart(R)
                    }

                    C.prototype.previousFrameAnchors = new Set, C.prototype.anchorToObject3D = new Map;

                    function M(B) {
                        console.warn(B.message), console.warn('Cannot requestHitTestSource Are you missing: webxr="optionalFeatures: hit-test;" from <a-scene>?')
                    }

                    C.prototype.sessionStart = function (R) {
                        if (this.session = this.renderer.xr.getSession(), !("requestHitTestSource" in this.session)) {
                            M({message: "No requestHitTestSource on the session."});
                            return
                        }
                        R.space ? this.session.requestHitTestSource(R).then((function (I) {
                            this.xrHitTestSource = I
                        }).bind(this)).catch(M) : R.profile && this.session.requestHitTestSourceForTransientInput(R).then((function (I) {
                            this.xrHitTestSource = I, this.transient = !0
                        }).bind(this)).catch(M)
                    }, C.prototype.anchorFromLastHitTestResult = function (B, R) {
                        var I = this.lastHitTest;
                        if (I) {
                            var L = {object3D: B, offset: R};
                            Array.from(this.anchorToObject3D.entries()).forEach((function (O) {
                                var N = O[1].object3D, F = O[0];
                                N === B && (this.anchorToObject3D.delete(F), F.delete())
                            }).bind(this)), I.createAnchor && I.createAnchor().then((function (O) {
                                this.anchorToObject3D.set(O, L)
                            }).bind(this)).catch(function (O) {
                                console.warn(O.message), console.warn('Cannot create anchor, are you missing: webxr="optionalFeatures: anchors;" from <a-scene>?')
                            })
                        }
                    }, C.prototype.doHit = function (R) {
                        if (this.renderer.xr.isPresenting) {
                            var I = this.renderer.xr.getReferenceSpace(), L = R.getViewerPose(I), O, N;
                            if (this.xrHitTestSource && L) return this.transient ? (O = R.getHitTestResultsForTransientInput(this.xrHitTestSource), O.length > 0 ? (N = O[0].results, N.length > 0 ? (this.lastHitTest = N[0], N[0].getPose(I)) : !1) : !1) : (O = R.getHitTestResults(this.xrHitTestSource), O.length > 0 ? (this.lastHitTest = O[0], O[0].getPose(I)) : !1)
                        }
                    }, C.updateAnchorPoses = function (B, R) {
                        var I = B.trackedAnchors || C.prototype.previousFrameAnchors;
                        C.prototype.previousFrameAnchors.forEach(function (L) {
                            I.has(L) || C.prototype.anchorToObject3D.delete(L)
                        }), I.forEach(function (L) {
                            var O, N, F, V;
                            try {
                                O = B.getPose(L.anchorSpace, R)
                            } catch {
                            }
                            if (O) {
                                if (N = C.prototype.anchorToObject3D.get(L), !N) return;
                                F = N.offset, V = N.object3D, p(O, V, F)
                            }
                        })
                    };
                    var b;
                    m.exports.Component = w("ar-hit-test", {
                        schema: {
                            target: {type: "selector"},
                            enabled: {default: !0},
                            src: {default: g, type: "map"},
                            type: {default: "footprint", oneOf: ["footprint", "map"]},
                            footprintDepth: {default: .1},
                            mapSize: {type: "vec2", default: {x: .5, y: .5}}
                        }, sceneOnly: !0, init: function () {
                            this.hitTest = null, this.imageDataArray = new Uint8ClampedArray(1048576), this.imageData = new ImageData(this.imageDataArray, 512, 512), this.textureCache = new Map, this.orthoCam = new v.OrthographicCamera, this.orthoCam.layers.set(E), this.textureTarget = new v.WebGLRenderTarget(512, 512, {}), this.basicMaterial = new v.MeshBasicMaterial({
                                color: 0,
                                side: v.DoubleSide
                            }), this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.context.imageSmoothingEnabled = !1, this.canvas.width = 512, this.canvas.height = 512, this.canvasTexture = new v.CanvasTexture(this.canvas, {alpha: !0}), this.canvasTexture.flipY = !1;
                            var B = this.el.getAttribute("webxr"), R = B.optionalFeatures;
                            (!R.includes("hit-test") || !R.includes("anchors")) && (R.push("hit-test"), R.push("anchors"), this.el.setAttribute("webxr", B)), this.el.sceneEl.renderer.xr.addEventListener("sessionend", (function () {
                                this.hitTest = null
                            }).bind(this)), this.el.sceneEl.renderer.xr.addEventListener("sessionstart", (function () {
                                if (this.el.is("ar-mode")) {
                                    var I = this.el.sceneEl.renderer, L = this.session = I.xr.getSession();
                                    this.hasPosedOnce = !1, this.bboxMesh.visible = !1, b || (b = new Map), L.requestReferenceSpace("viewer").then((function (F) {
                                        this.hitTest = new C(I, {space: F}), b.set(F, this.hitTest), this.el.emit("ar-hit-test-start")
                                    }).bind(this));
                                    var O = "generic-touchscreen", N = new C(I, {profile: O});
                                    L.addEventListener("selectstart", (function (F) {
                                        if (this.data.enabled === !0) {
                                            var V = F.inputSource;
                                            this.bboxMesh.visible = !0, this.hasPosedOnce === !0 && (this.el.emit("ar-hit-test-select-start", {
                                                inputSource: V,
                                                position: this.bboxMesh.position,
                                                orientation: this.bboxMesh.quaternion
                                            }), V.profiles[0] === O ? this.hitTest = N : (this.hitTest = b.get(V) || new C(I, {space: V.targetRaySpace}), b.set(V, this.hitTest)))
                                        }
                                    }).bind(this)), L.addEventListener("selectend", (function (F) {
                                        if (!this.hitTest || this.data.enabled !== !0) {
                                            this.hitTest = null;
                                            return
                                        }
                                        var V = F.inputSource, U;
                                        this.hasPosedOnce === !0 && (this.bboxMesh.visible = !1, this.data.target && (U = this.data.target.object3D, U && (p.tempFakePose.transform.position.copy(this.bboxMesh.position), p.tempFakePose.transform.orientation.copy(this.bboxMesh.quaternion), p(p.tempFakePose, U, this.bboxOffset), U.visible = !0, this.hitTest.anchorFromLastHitTestResult(U, this.bboxOffset))), this.el.emit("ar-hit-test-select", {
                                            inputSource: V,
                                            position: this.bboxMesh.position,
                                            orientation: this.bboxMesh.quaternion
                                        })), this.hitTest = null
                                    }).bind(this))
                                }
                            }).bind(this)), this.bboxOffset = new v.Vector3, this.update = this.update.bind(this), this.makeBBox()
                        }, update: function () {
                            this.data.enabled === !1 && (this.hitTest = null, this.bboxMesh.visible = !1), this.data.target && (this.data.target.object3D ? (this.data.target.addEventListener("model-loaded", this.update), this.data.target.object3D.layers.enable(E), this.data.target.object3D.traverse(function (B) {
                                B.layers.enable(E)
                            })) : this.data.target.addEventListener("loaded", this.update, {once: !0})), this.bboxNeedsUpdate = !0
                        }, makeBBox: function () {
                            var B = new v.PlaneGeometry(1, 1),
                                R = new v.MeshBasicMaterial({transparent: !0, color: 16777215});
                            B.rotateX(-Math.PI / 2), B.rotateY(-Math.PI / 2), this.bbox = new v.Box3, this.bboxMesh = new v.Mesh(B, R), this.el.setObject3D("ar-hit-test", this.bboxMesh), this.bboxMesh.visible = !1
                        }, updateFootprint: function () {
                            var B, R = this.el.sceneEl.renderer, I, L, O = R.xr.enabled;
                            this.bboxMesh.material.map = this.canvasTexture, this.bboxMesh.material.needsUpdate = !0, this.orthoCam.rotation.set(-Math.PI / 2, 0, -Math.PI / 2), this.orthoCam.position.copy(this.bboxMesh.position), this.orthoCam.position.y -= this.bboxMesh.scale.y / 2, this.orthoCam.near = .1, this.orthoCam.far = this.orthoCam.near + this.data.footprintDepth * this.bboxMesh.scale.y, this.orthoCam.position.y += this.orthoCam.far, this.orthoCam.right = this.bboxMesh.scale.z / 2, this.orthoCam.left = -this.bboxMesh.scale.z / 2, this.orthoCam.top = this.bboxMesh.scale.x / 2, this.orthoCam.bottom = -this.bboxMesh.scale.x / 2, this.orthoCam.updateProjectionMatrix(), I = R.getRenderTarget(), R.setRenderTarget(this.textureTarget), R.xr.enabled = !1, L = this.el.object3D.background, this.el.object3D.overrideMaterial = this.basicMaterial, this.el.object3D.background = null, R.render(this.el.object3D, this.orthoCam), this.el.object3D.background = L, this.el.object3D.overrideMaterial = null, R.xr.enabled = O, R.setRenderTarget(I), R.readRenderTargetPixels(this.textureTarget, 0, 0, 512, 512, this.imageDataArray), this.context.putImageData(this.imageData, 0, 0), this.context.shadowColor = "white", this.context.shadowBlur = 10, this.context.drawImage(this.canvas, 0, 0), B = this.context.getImageData(0, 0, 512, 512);
                            for (var N = 0; N < 262144; N++) B.data[N * 4 + 3] !== 0 && B.data[N * 4 + 3] !== 255 && (B.data[N * 4 + 3] = 128);
                            this.context.putImageData(B, 0, 0), this.canvasTexture.needsUpdate = !0
                        }, tick: function () {
                            var B, R = this.el.sceneEl.frame, I = this.el.sceneEl.renderer;
                            if (R && C.updateAnchorPoses(R, I.xr.getReferenceSpace()), this.bboxNeedsUpdate) {
                                if (this.bboxNeedsUpdate = !1, !this.data.target || this.data.type === "map") {
                                    var L;
                                    this.textureCache.has(this.data.src) ? L = this.textureCache.get(this.data.src) : (L = new v.TextureLoader().load(this.data.src), this.textureCache.set(this.data.src, L)), this.bboxMesh.material.map = L, this.bboxMesh.material.needsUpdate = !0
                                }
                                this.data.target && this.data.target.object3D ? (this.bbox.setFromObject(this.data.target.object3D), this.bbox.getCenter(this.bboxMesh.position), this.bbox.getSize(this.bboxMesh.scale), this.data.type === "footprint" && (this.bboxMesh.scale.x *= 1.04, this.bboxMesh.scale.z *= 1.04, this.updateFootprint()), this.bboxMesh.position.y -= this.bboxMesh.scale.y / 2, this.bboxOffset.copy(this.bboxMesh.position), this.bboxOffset.sub(this.data.target.object3D.position)) : this.bboxMesh.scale.set(this.data.mapSize.x, 1, this.data.mapSize.y)
                            }
                            this.hitTest && (B = this.hitTest.doHit(R), B && (this.hasPosedOnce !== !0 && (this.hasPosedOnce = !0, this.el.emit("ar-hit-test-achieved")), this.bboxMesh.visible = !0, this.bboxMesh.position.copy(B.transform.position), this.bboxMesh.quaternion.copy(B.transform.orientation)))
                        }
                    })
                },
                "./src/components/scene/background.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("background", {
                        schema: {
                            color: {type: "color", default: "black"},
                            transparent: {default: !1}
                        }, sceneOnly: !0, update: function () {
                            var w = this.data, v = this.el.object3D;
                            w.transparent ? v.background = null : v.background = new THREE.Color(w.color)
                        }, remove: function () {
                            var w = this.el.object3D;
                            w.background = null
                        }
                    })
                },
                "./src/components/scene/debug.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("debug", {schema: {default: !0}, sceneOnly: !0})
                },
                "./src/components/scene/device-orientation-permission-ui.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/constants/index.js"),
                        v = "a-modal", E = "a-dialog", p = "a-dialog-text", C = "a-dialog-text-container",
                        M = "a-dialog-buttons-container", b = "a-dialog-button", B = "a-dialog-allow-button",
                        R = "a-dialog-deny-button", I = "a-dialog-ok-button";
                    m.exports.Component = g("device-orientation-permission-ui", {
                        schema: {
                            enabled: {default: !0},
                            deviceMotionMessage: {default: "This immersive website requires access to your device motion sensors."},
                            httpsMessage: {default: "Access this site over HTTPS to enter VR mode and grant access to the device sensors."},
                            denyButtonText: {default: "Deny"},
                            allowButtonText: {default: "Allow"},
                            cancelButtonText: {default: "Cancel"}
                        }, sceneOnly: !0, init: function () {
                            var F = this;
                            if (this.data.enabled) {
                                if (window.isSecureContext || this.showHTTPAlert(), typeof DeviceOrientationEvent > "u" || !DeviceOrientationEvent.requestPermission) {
                                    this.permissionGranted = !0;
                                    return
                                }
                                this.onDeviceMotionDialogAllowClicked = this.onDeviceMotionDialogAllowClicked.bind(this), this.onDeviceMotionDialogDenyClicked = this.onDeviceMotionDialogDenyClicked.bind(this), DeviceOrientationEvent.requestPermission().then(function () {
                                    F.el.emit("deviceorientationpermissiongranted"), F.permissionGranted = !0
                                }).catch(function () {
                                    F.devicePermissionDialogEl = L(F.data.denyButtonText, F.data.allowButtonText, F.data.deviceMotionMessage, F.onDeviceMotionDialogAllowClicked, F.onDeviceMotionDialogDenyClicked), F.el.appendChild(F.devicePermissionDialogEl)
                                })
                            }
                        }, remove: function () {
                            this.devicePermissionDialogEl && this.el.removeChild(this.devicePermissionDialogEl)
                        }, onDeviceMotionDialogDenyClicked: function () {
                            this.remove()
                        }, showHTTPAlert: function () {
                            var F = this, V = O(F.data.cancelButtonText, F.data.httpsMessage, function () {
                                F.el.removeChild(V)
                            });
                            this.el.appendChild(V)
                        }, onDeviceMotionDialogAllowClicked: function () {
                            var F = this;
                            this.el.emit("deviceorientationpermissionrequested"), DeviceOrientationEvent.requestPermission().then(function (V) {
                                V === "granted" ? (F.el.emit("deviceorientationpermissiongranted"), F.permissionGranted = !0) : F.el.emit("deviceorientationpermissionrejected"), F.remove()
                            }).catch(console.error)
                        }
                    });

                    function L(F, V, U, j, Y) {
                        var fe, se, pe;
                        return fe = document.createElement("div"), fe.classList.add(M), se = document.createElement("button"), se.classList.add(b, R), se.setAttribute(w.AFRAME_INJECTED, ""), se.innerHTML = F, fe.appendChild(se), pe = document.createElement("button"), pe.classList.add(b, B), pe.setAttribute(w.AFRAME_INJECTED, ""), pe.innerHTML = V, fe.appendChild(pe), pe.addEventListener("click", function (ue) {
                            ue.stopPropagation(), j()
                        }), se.addEventListener("click", function (ue) {
                            ue.stopPropagation(), Y()
                        }), N(U, fe)
                    }

                    function O(F, V, U) {
                        var j, Y;
                        return j = document.createElement("div"), j.classList.add(M), Y = document.createElement("button"), Y.classList.add(b, I), Y.setAttribute(w.AFRAME_INJECTED, ""), Y.innerHTML = F, j.appendChild(Y), Y.addEventListener("click", function (fe) {
                            fe.stopPropagation(), U()
                        }), N(V, j)
                    }

                    function N(F, V) {
                        var U, j, Y, fe;
                        return U = document.createElement("div"), U.classList.add(v), U.setAttribute(w.AFRAME_INJECTED, ""), j = document.createElement("div"), j.className = E, j.setAttribute(w.AFRAME_INJECTED, ""), U.appendChild(j), Y = document.createElement("div"), Y.classList.add(C), j.appendChild(Y), fe = document.createElement("div"), fe.classList.add(p), fe.innerHTML = F, Y.appendChild(fe), j.appendChild(V), U
                    }
                },
                "./src/components/scene/embedded.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("embedded", {
                        dependencies: ["xr-mode-ui"],
                        schema: {default: !0},
                        sceneOnly: !0,
                        update: function () {
                            var w = this.el, v = w.querySelector(".a-enter-vr");
                            this.data === !0 ? (v && v.classList.add("embedded"), w.removeFullScreenStyles()) : (v && v.classList.remove("embedded"), w.addFullScreenStyles())
                        }
                    })
                },
                "./src/components/scene/fog.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = h("./src/utils/debug.js");
                    v("components:fog:warn"), m.exports.Component = g("fog", {
                        schema: {
                            color: {
                                type: "color",
                                default: "#000"
                            },
                            density: {default: 25e-5},
                            far: {default: 1e3, min: 0},
                            near: {default: 1, min: 0},
                            type: {default: "linear", oneOf: ["linear", "exponential"]}
                        }, sceneOnly: !0, update: function () {
                            var p = this.data, C = this.el, M = this.el.object3D.fog;
                            if (!M || p.type !== M.name) {
                                C.object3D.fog = E(p);
                                return
                            }
                            Object.keys(this.schema).forEach(function (b) {
                                var B = p[b];
                                b === "color" && (B = new w.Color(B)), M[b] = B
                            })
                        }, remove: function () {
                            var p = this.el, C = this.el.object3D.fog;
                            C && (p.object3D.fog = null)
                        }
                    });

                    function E(p) {
                        var C;
                        return p.type === "exponential" ? C = new w.FogExp2(p.color, p.density) : C = new w.Fog(p.color, p.near, p.far), C.name = p.type, C
                    }
                },
                "./src/components/scene/inspector.js": (m, x, h) => {
                    var g = h("./src/constants/index.js").AFRAME_INJECTED, w = h("./package.json"),
                        v = h("./src/core/component.js").registerComponent, E = h("./src/utils/index.js");

                    function p(R) {
                        var I = R.split(".");
                        return I[2] = "x", I.join(".")
                    }

                    var C = "https://unpkg.com/aframe-inspector@" + p(w.version) + "/dist/aframe-inspector.min.js",
                        M = C, b = "Loading Inspector", B = "Error loading Inspector";
                    m.exports.Component = v("inspector", {
                        schema: {url: {default: M}}, sceneOnly: !0, init: function () {
                            this.firstPlay = !0, this.onKeydown = this.onKeydown.bind(this), this.onMessage = this.onMessage.bind(this), this.initOverlay(), window.addEventListener("keydown", this.onKeydown), window.addEventListener("message", this.onMessage)
                        }, play: function () {
                            var R;
                            this.firstPlay && (R = E.getUrlParameter("inspector"), R !== "false" && R && (this.openInspector(), this.firstPlay = !1))
                        }, initOverlay: function () {
                            var R = '<span class="dots"><span>.</span><span>.</span><span>.</span></span>';
                            this.loadingMessageEl = document.createElement("div"), this.loadingMessageEl.classList.add("a-inspector-loader"), this.loadingMessageEl.innerHTML = b + R
                        }, remove: function () {
                            this.removeEventListeners()
                        }, onKeydown: function (R) {
                            var I = R.keyCode === 73 && (R.ctrlKey && R.altKey || R.getModifierState("AltGraph"));
                            I && this.openInspector()
                        }, showLoader: function () {
                            document.body.appendChild(this.loadingMessageEl)
                        }, hideLoader: function () {
                            document.body.removeChild(this.loadingMessageEl)
                        }, onMessage: function (R) {
                            R.data === "INJECT_AFRAME_INSPECTOR" && this.openInspector()
                        }, openInspector: function (R) {
                            var I = this, L;
                            if (AFRAME.INSPECTOR || AFRAME.inspectorInjected) {
                                AFRAME.INSPECTOR.open(R);
                                return
                            }
                            this.showLoader(), L = document.createElement("script"), L.src = this.data.url, L.setAttribute("data-name", "aframe-inspector"), L.setAttribute(g, ""), L.onload = function () {
                                AFRAME.INSPECTOR.open(R), I.hideLoader(), I.removeEventListeners()
                            }, L.onerror = function () {
                                I.loadingMessageEl.innerHTML = B
                            }, document.head.appendChild(L), AFRAME.inspectorInjected = !0
                        }, removeEventListeners: function () {
                            window.removeEventListener("keydown", this.onKeydown), window.removeEventListener("message", this.onMessage)
                        }
                    })
                },
                "./src/components/scene/keyboard-shortcuts.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent,
                        w = h("./src/utils/index.js").shouldCaptureKeyEvent;
                    m.exports.Component = g("keyboard-shortcuts", {
                        schema: {
                            enterVR: {default: !0},
                            exitVR: {default: !0}
                        }, sceneOnly: !0, init: function () {
                            this.onKeyup = this.onKeyup.bind(this)
                        }, update: function (v) {
                            var E = this.data;
                            this.enterVREnabled = E.enterVR
                        }, play: function () {
                            window.addEventListener("keyup", this.onKeyup, !1)
                        }, pause: function () {
                            window.removeEventListener("keyup", this.onKeyup)
                        }, onKeyup: function (v) {
                            var E = this.el;
                            w(v) && (this.enterVREnabled && v.keyCode === 70 && E.enterVR(), this.enterVREnabled && v.keyCode === 27 && E.exitVR())
                        }
                    })
                },
                "./src/components/scene/pool.js": (m, x, h) => {
                    var g = h("./src/utils/debug.js"), w = h("./src/core/component.js").registerComponent,
                        v = g("components:pool:warn");
                    m.exports.Component = w("pool", {
                        schema: {
                            container: {default: ""},
                            mixin: {default: ""},
                            size: {default: 0},
                            dynamic: {default: !1}
                        }, sceneOnly: !0, multiple: !0, initPool: function () {
                            var E;
                            for (this.availableEls = [], this.usedEls = [], this.data.mixin || v("No mixin provided for pool component."), this.data.container && (this.container = document.querySelector(this.data.container), this.container || v("Container " + this.data.container + " not found.")), this.container = this.container || this.el, E = 0; E < this.data.size; ++E) this.createEntity()
                        }, update: function (E) {
                            var p = this.data;
                            (E.mixin !== p.mixin || E.size !== p.size) && this.initPool()
                        }, createEntity: function () {
                            var E;
                            E = document.createElement("a-entity"), E.play = this.wrapPlay(E.play), E.setAttribute("mixin", this.data.mixin), E.object3D.visible = !1, E.pause(), this.container.appendChild(E), this.availableEls.push(E);
                            var p = this.usedEls;
                            E.addEventListener("loaded", function () {
                                p.indexOf(E) === -1 && (E.object3DParent = E.object3D.parent, E.object3D.parent.remove(E.object3D))
                            })
                        }, wrapPlay: function (E) {
                            var p = this.usedEls;
                            return function () {
                                p.indexOf(this) !== -1 && E.call(this)
                            }
                        }, requestEntity: function () {
                            var E;
                            if (this.availableEls.length === 0) {
                                if (this.data.dynamic === !1) {
                                    v("Requested entity from empty pool: " + this.attrName);
                                    return
                                } else v("Requested entity from empty pool. This pool is dynamic and will resize automatically. You might want to increase its initial size: " + this.attrName);
                                this.createEntity()
                            }
                            return E = this.availableEls.shift(), this.usedEls.push(E), E.object3DParent && (E.object3DParent.add(E.object3D), this.updateRaycasters()), E.object3D.visible = !0, E
                        }, returnEntity: function (E) {
                            var p = this.usedEls.indexOf(E);
                            if (p === -1) {
                                v("The returned entity was not previously pooled from " + this.attrName);
                                return
                            }
                            return this.usedEls.splice(p, 1), this.availableEls.push(E), E.object3DParent = E.object3D.parent, E.object3D.parent.remove(E.object3D), this.updateRaycasters(), E.object3D.visible = !1, E.pause(), E
                        }, updateRaycasters: function () {
                            var E = document.querySelectorAll("[raycaster]");
                            E.forEach(function (p) {
                                p.components.raycaster.setDirty()
                            })
                        }
                    })
                },
                "./src/components/scene/real-world-meshing.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js");
                    m.exports.Component = g("real-world-meshing", {
                        schema: {
                            filterLabels: {type: "array"},
                            meshesEnabled: {default: !0},
                            meshMixin: {default: !0},
                            planesEnabled: {default: !0},
                            planeMixin: {default: ""}
                        }, sceneOnly: !0, init: function () {
                            var v = this.el.getAttribute("webxr"), E = v.requiredFeatures;
                            E.indexOf("mesh-detection") === -1 && (E.push("mesh-detection"), this.el.setAttribute("webxr", v)), E.indexOf("plane-detection") === -1 && (E.push("plane-detection"), this.el.setAttribute("webxr", v)), this.meshEntities = [], this.initWorldMeshEntity = this.initWorldMeshEntity.bind(this)
                        }, tick: function () {
                            this.el.is("ar-mode") && (this.detectMeshes(), this.updateMeshes())
                        }, detectMeshes: function () {
                            var v = this.data, E, p, C = this.el;
                            C.renderer.xr;
                            var M, b = this.meshEntities, B = !1, R = [], I = this.data.filterLabels;
                            M = C.frame, E = M.detectedMeshes, p = M.detectedPlanes;
                            for (var L = 0; L < b.length; L++) b[L].present = !1;
                            if (v.meshesEnabled) {
                                for (var O of E.values()) if (!(I.length && I.indexOf(O.semanticLabel) === -1)) {
                                    for (L = 0; L < b.length; L++) if (O === b[L].mesh) {
                                        B = !0, b[L].present = !0, b[L].lastChangedTime < O.lastChangedTime && this.updateMeshGeometry(b[L].el, O), b[L].lastChangedTime = O.lastChangedTime;
                                        break
                                    }
                                    B || R.push(O), B = !1
                                }
                            }
                            if (v.planesEnabled) {
                                for (O of p.values()) if (!(I.length && I.indexOf(O.semanticLabel) === -1)) {
                                    for (L = 0; L < b.length; L++) if (O === b[L].mesh) {
                                        B = !0, b[L].present = !0, b[L].lastChangedTime < O.lastChangedTime && this.updateMeshGeometry(b[L].el, O), b[L].lastChangedTime = O.lastChangedTime;
                                        break
                                    }
                                    B || R.push(O), B = !1
                                }
                            }
                            this.deleteMeshes(), this.createNewMeshes(R)
                        }, updateMeshes: function () {
                            var v = new w.Matrix4;
                            return function () {
                                for (var E, p = this.el, C, M = p.frame, b = this.meshEntities, B = p.renderer.xr.getReferenceSpace(), R, I = 0; I < b.length; I++) R = b[I].mesh.meshSpace || b[I].mesh.planeSpace, E = M.getPose(R, B), C = b[I].el, C.hasLoaded && (v.fromArray(E.transform.matrix), v.decompose(C.object3D.position, C.object3D.quaternion, C.object3D.scale))
                            }
                        }(), deleteMeshes: function () {
                            for (var v = this.meshEntities, E = [], p = 0; p < v.length; p++) v[p].present ? E.push(v[p]) : this.el.removeChild(v[p]);
                            this.meshEntities = E
                        }, createNewMeshes: function (v) {
                            for (var E, p = 0; p < v.length; p++) E = document.createElement("a-entity"), this.meshEntities.push({
                                mesh: v[p],
                                el: E
                            }), E.addEventListener("loaded", this.initWorldMeshEntity), this.el.appendChild(E)
                        }, initMeshGeometry: function (v) {
                            var E, p, C;
                            if (v instanceof XRPlane) {
                                p = new w.Shape, C = v.polygon;
                                for (var M = 0; M < C.length; ++M) M === 0 ? p.moveTo(C[M].x, C[M].z) : p.lineTo(C[M].x, C[M].z);
                                return E = new w.ShapeGeometry(p), E.rotateX(Math.PI / 2), E
                            }
                            return E = new w.BufferGeometry, E.setAttribute("position", new w.BufferAttribute(v.vertices, 3)), E.setIndex(new w.BufferAttribute(v.indices, 1)), E
                        }, initWorldMeshEntity: function (v) {
                            for (var E = v.target, p, C, M, b = this.meshEntities, B = 0; B < b.length; B++) if (b[B].el === E) {
                                M = b[B];
                                break
                            }
                            p = this.initMeshGeometry(M.mesh), C = new w.Mesh(p, new w.MeshBasicMaterial({
                                color: Math.random() * 16777215,
                                side: w.DoubleSide
                            })), E.setObject3D("mesh", C), M.mesh instanceof XRPlane && this.data.planeMixin ? E.setAttribute("mixin", this.data.planeMixin) : this.data.meshMixin && E.setAttribute("mixin", this.data.meshMixin), E.setAttribute("data-world-mesh", M.mesh.semanticLabel)
                        }, updateMeshGeometry: function (v, E) {
                            var p = v.getObject3D("mesh");
                            p.geometry.dispose(), p.geometry = this.initMeshGeometry(E)
                        }
                    })
                },
                "./src/components/scene/reflection.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;

                    function w(v, E, p, C) {
                        var M = Math.max(v.primaryLightIntensity.x, Math.max(v.primaryLightIntensity.y, v.primaryLightIntensity.z));
                        E.sh.fromArray(v.sphericalHarmonicsCoefficients), E.intensity = 1, p && (p.color.setRGB(v.primaryLightIntensity.x / M, v.primaryLightIntensity.y / M, v.primaryLightIntensity.z / M), p.intensity = M, C.copy(v.primaryLightDirection))
                    }

                    m.exports.Component = g("reflection", {
                        schema: {directionalLight: {type: "selector"}}, sceneOnly: !0, init: function () {
                            var v = this;
                            this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(16), this.cubeCamera = new THREE.CubeCamera(.1, 1e3, this.cubeRenderTarget), this.lightingEstimationTexture = new THREE.WebGLCubeRenderTarget(16).texture, this.needsVREnvironmentUpdate = !0;
                            var E = this.el.getAttribute("webxr"), p = E.optionalFeatures;
                            p.includes("light-estimation") || (p.push("light-estimation"), this.el.setAttribute("webxr", E)), this.el.addEventListener("enter-vr", function () {
                                if (v.el.is("ar-mode")) {
                                    var C = v.el.renderer, M = C.xr.getSession();
                                    M.requestLightProbe && v.startLightProbe()
                                }
                            }), this.el.addEventListener("exit-vr", function () {
                                v.xrLightProbe && v.stopLightProbe()
                            }), this.el.object3D.environment = this.cubeRenderTarget.texture
                        }, stopLightProbe: function () {
                            this.xrLightProbe = null, this.probeLight && (this.probeLight.components.light.light.intensity = 0), this.needsVREnvironmentUpdate = !0, this.el.object3D.environment = this.cubeRenderTarget.texture
                        }, startLightProbe: function () {
                            this.needsLightProbeUpdate = !0
                        }, setupLightProbe: function () {
                            var v = this.el.renderer, E = v.xr.getSession(), p = this, C = v.getContext();
                            if (!this.probeLight) {
                                var M = document.createElement("a-light");
                                M.setAttribute("type", "probe"), M.setAttribute("intensity", 0), this.el.appendChild(M), this.probeLight = M
                            }
                            switch (E.preferredReflectionFormat) {
                                case"srgba8":
                                    C.getExtension("EXT_sRGB");
                                    break;
                                case"rgba16f":
                                    C.getExtension("OES_texture_half_float");
                                    break
                            }
                            this.glBinding = new XRWebGLBinding(E, C), C.getExtension("EXT_sRGB"), C.getExtension("OES_texture_half_float"), E.requestLightProbe().then(function (b) {
                                p.xrLightProbe = b, b.addEventListener("reflectionchange", p.updateXRCubeMap.bind(p))
                            }).catch(function (b) {
                                console.warn("Lighting estimation not supported: " + b.message), console.warn('Are you missing: webxr="optionalFeatures: light-estimation;" from <a-scene>?')
                            })
                        }, updateXRCubeMap: function () {
                            var v = this.el.renderer, E = this.glBinding.getReflectionCubeMap(this.xrLightProbe);
                            if (E) {
                                var p = v.properties.get(this.lightingEstimationTexture);
                                p.__webglTexture = E, this.lightingEstimationTexture.needsPMREMUpdate = !0, this.el.object3D.environment = this.lightingEstimationTexture
                            }
                        }, tick: function () {
                            var v = this.el.object3D, E = this.el.renderer, p = this.el.frame;
                            if (p && this.xrLightProbe) {
                                var C = p.getLightEstimate(this.xrLightProbe);
                                C && w(C, this.probeLight.components.light.light, this.data.directionalLight && this.data.directionalLight.components.light.light, this.data.directionalLight && this.data.directionalLight.object3D.position)
                            }
                            this.needsVREnvironmentUpdate && (v.environment = null, this.needsVREnvironmentUpdate = !1, this.cubeCamera.position.set(0, 1.6, 0), this.cubeCamera.update(E, v), v.environment = this.cubeRenderTarget.texture), this.needsLightProbeUpdate && p && (this.setupLightProbe(), this.needsLightProbeUpdate = !1)
                        }, remove: function () {
                            this.el.object3D.environment = null, this.probeLight && this.el.removeChild(this.probeLight)
                        }
                    })
                },
                "./src/components/scene/screenshot.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = ["attribute vec3 position;", "attribute vec2 uv;", "uniform mat4 projectionMatrix;", "uniform mat4 modelViewMatrix;", "varying vec2 vUv;", "void main()  {", "  vUv = vec2( 1.- uv.x, uv.y );", "  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`),
                        E = ["precision mediump float;", "uniform samplerCube map;", "varying vec2 vUv;", "#define M_PI 3.141592653589793238462643383279", "void main() {", "  vec2 uv = vUv;", "  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;", "  float latitude = uv.y * M_PI;", "  vec3 dir = vec3(", "    - sin( longitude ) * sin( latitude ),", "    cos( latitude ),", "    - cos( longitude ) * sin( latitude )", "  );", "  normalize( dir );", "  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );", "}"].join(`
`);
                    m.exports.Component = g("screenshot", {
                        schema: {width: {default: 4096}, height: {default: 2048}, camera: {type: "selector"}},
                        sceneOnly: !0,
                        setup: function () {
                            var p = this.el;
                            if (!this.canvas) {
                                var C = p.renderer.getContext();
                                C && (this.cubeMapSize = C.getParameter(C.MAX_CUBE_MAP_TEXTURE_SIZE), this.material = new w.RawShaderMaterial({
                                    uniforms: {
                                        map: {
                                            type: "t",
                                            value: null
                                        }
                                    }, vertexShader: v, fragmentShader: E, side: w.DoubleSide
                                }), this.quad = new w.Mesh(new w.PlaneGeometry(1, 1), this.material), this.quad.visible = !1, this.camera = new w.OrthographicCamera(-.5, .5, .5, -.5, -1e4, 1e4), this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), p.object3D.add(this.quad), this.onKeyDown = this.onKeyDown.bind(this))
                            }
                        },
                        getRenderTarget: function (p, C) {
                            return new w.WebGLRenderTarget(p, C, {
                                colorSpace: this.el.sceneEl.renderer.outputColorSpace,
                                minFilter: w.LinearFilter,
                                magFilter: w.LinearFilter,
                                wrapS: w.ClampToEdgeWrapping,
                                wrapT: w.ClampToEdgeWrapping,
                                format: w.RGBAFormat,
                                type: w.UnsignedByteType
                            })
                        },
                        resize: function (p, C) {
                            this.quad.scale.set(p, C, 1), this.camera.left = -1 * p / 2, this.camera.right = p / 2, this.camera.top = C / 2, this.camera.bottom = -1 * C / 2, this.camera.updateProjectionMatrix(), this.canvas.width = p, this.canvas.height = C
                        },
                        play: function () {
                            window.addEventListener("keydown", this.onKeyDown)
                        },
                        onKeyDown: function (p) {
                            var C = p.keyCode === 83 && p.ctrlKey && p.altKey;
                            if (!(!this.data || !C)) {
                                var M = p.shiftKey ? "equirectangular" : "perspective";
                                this.capture(M)
                            }
                        },
                        setCapture: function (p) {
                            var C = this.el, M, b, B, R;
                            return p === "perspective" ? (this.quad.visible = !1, b = this.data.camera && this.data.camera.components.camera.camera || C.camera, M = {
                                width: this.data.width,
                                height: this.data.height
                            }) : (b = this.camera, R = new w.WebGLCubeRenderTarget(Math.min(this.cubeMapSize, 2048), {
                                format: w.RGBFormat,
                                generateMipmaps: !0,
                                minFilter: w.LinearMipmapLinearFilter,
                                colorSpace: w.SRGBColorSpace
                            }), B = new w.CubeCamera(C.camera.near, C.camera.far, R), C.camera.getWorldPosition(B.position), C.camera.getWorldQuaternion(B.quaternion), B.update(C.renderer, C.object3D), this.quad.material.uniforms.map.value = B.renderTarget.texture, M = {
                                width: this.data.width,
                                height: this.data.height
                            }, this.quad.visible = !0), {camera: b, size: M, projection: p}
                        },
                        capture: function (p) {
                            var C = this.el.renderer.xr.enabled, M = this.el.renderer, b;
                            this.setup(), M.xr.enabled = !1, b = this.setCapture(p), this.renderCapture(b.camera, b.size, b.projection), this.saveCapture(), M.xr.enabled = C
                        },
                        getCanvas: function (p) {
                            var C = this.el.renderer.xr.enabled, M = this.el.renderer;
                            this.setup();
                            var b = this.setCapture(p);
                            return M.xr.enabled = !1, this.renderCapture(b.camera, b.size, b.projection), M.xr.enabled = C, this.canvas
                        },
                        renderCapture: function (p, C, M) {
                            var b = this.el.renderer.autoClear, B = this.el, R, I, L, O = B.renderer;
                            I = this.getRenderTarget(C.width, C.height), L = new Uint8Array(4 * C.width * C.height), this.resize(C.width, C.height), O.autoClear = !0, O.clear(), O.setRenderTarget(I), O.render(B.object3D, p), O.autoClear = b, O.readRenderTargetPixels(I, 0, 0, C.width, C.height, L), O.setRenderTarget(null), M === "perspective" && (L = this.flipPixelsVertically(L, C.width, C.height)), R = new ImageData(new Uint8ClampedArray(L), C.width, C.height), this.quad.visible = !1, this.ctx.putImageData(R, 0, 0)
                        },
                        flipPixelsVertically: function (p, C, M) {
                            for (var b = p.slice(0), B = 0; B < C; ++B) for (var R = 0; R < M; ++R) b[B * 4 + R * C * 4] = p[B * 4 + (M - R) * C * 4], b[B * 4 + 1 + R * C * 4] = p[B * 4 + 1 + (M - R) * C * 4], b[B * 4 + 2 + R * C * 4] = p[B * 4 + 2 + (M - R) * C * 4], b[B * 4 + 3 + R * C * 4] = p[B * 4 + 3 + (M - R) * C * 4];
                            return b
                        },
                        saveCapture: function () {
                            this.canvas.toBlob(function (p) {
                                var C = "screenshot-" + document.title.toLowerCase() + "-" + Date.now() + ".png",
                                    M = document.createElement("a"), b = URL.createObjectURL(p);
                                M.href = b, M.setAttribute("download", C), M.innerHTML = "downloading...", M.style.display = "none", document.body.appendChild(M), setTimeout(function () {
                                    M.click(), document.body.removeChild(M)
                                }, 1)
                            }, "image/png")
                        }
                    })
                },
                "./src/components/scene/stats.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./vendor/rStats.js"),
                        v = h("./src/utils/index.js");
                    h("./vendor/rStats.extras.js"), h("./src/lib/rStatsAframe.js");
                    var E = window.aframeStats, p = "a-hidden", C = window.threeStats;
                    m.exports.Component = g("stats", {
                        schema: {default: !0}, sceneOnly: !0, init: function () {
                            var b = this.el;
                            v.getUrlParameter("stats") !== "false" && (this.stats = M(b), this.statsEl = document.querySelector(".rs-base"), this.hideBound = this.hide.bind(this), this.showBound = this.show.bind(this), b.addEventListener("enter-vr", this.hideBound), b.addEventListener("exit-vr", this.showBound))
                        }, update: function () {
                            if (this.stats) return this.data ? this.show() : this.hide()
                        }, remove: function () {
                            this.el.removeEventListener("enter-vr", this.hideBound), this.el.removeEventListener("exit-vr", this.showBound), this.statsEl && this.statsEl.parentNode.removeChild(this.statsEl)
                        }, tick: function () {
                            var b = this.stats;
                            b && (b("rAF").tick(), b("FPS").frame(), b().update())
                        }, hide: function () {
                            this.statsEl.classList.add(p)
                        }, show: function () {
                            this.statsEl.classList.remove(p)
                        }
                    });

                    function M(b) {
                        var B = new C(b.renderer), R = new E(b), I = b.isMobile ? [] : [B, R];
                        return new w({
                            css: [],
                            values: {fps: {caption: "fps", below: 30}},
                            groups: [{caption: "Framerate", values: ["fps", "raf"]}],
                            plugins: I
                        })
                    }
                },
                "./src/components/scene/xr-mode-ui.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/constants/index.js"),
                        v = h("./src/utils/index.js"), E = "a-enter-vr", p = "a-enter-ar", C = "a-enter-vr-button",
                        M = "a-enter-ar-button", b = "a-hidden", B = "a-orientation-modal";
                    m.exports.Component = g("xr-mode-ui", {
                        dependencies: ["canvas"],
                        schema: {
                            enabled: {default: !0},
                            cardboardModeEnabled: {default: !1},
                            enterVRButton: {default: ""},
                            enterVREnabled: {default: !0},
                            enterARButton: {default: ""},
                            enterAREnabled: {default: !0},
                            XRMode: {default: "vr", oneOf: ["vr", "ar", "xr"]}
                        },
                        sceneOnly: !0,
                        init: function () {
                            var N = this, F = this.el;
                            v.getUrlParameter("ui") !== "false" && (this.insideLoader = !1, this.enterVREl = null, this.enterAREl = null, this.orientationModalEl = null, this.bindMethods(), F.addEventListener("enter-vr", this.updateEnterInterfaces), F.addEventListener("exit-vr", this.updateEnterInterfaces), F.addEventListener("update-vr-devices", this.updateEnterInterfaces), window.addEventListener("message", function (V) {
                                V.data.type === "loaderReady" && (N.insideLoader = !0, N.remove())
                            }), window.addEventListener("orientationchange", this.toggleOrientationModalIfNeeded))
                        },
                        bindMethods: function () {
                            this.onEnterVRButtonClick = this.onEnterVRButtonClick.bind(this), this.onEnterARButtonClick = this.onEnterARButtonClick.bind(this), this.onModalClick = this.onModalClick.bind(this), this.toggleOrientationModalIfNeeded = this.toggleOrientationModalIfNeeded.bind(this), this.updateEnterInterfaces = this.updateEnterInterfaces.bind(this)
                        },
                        onModalClick: function () {
                            this.el.exitVR()
                        },
                        onEnterVRButtonClick: function () {
                            this.el.enterVR()
                        },
                        onEnterARButtonClick: function () {
                            this.el.enterAR()
                        },
                        update: function () {
                            var N = this.data, F = this.el;
                            if (!N.enabled || this.insideLoader || v.getUrlParameter("ui") === "false") return this.remove();
                            this.enterVREl || this.enterAREl || this.orientationModalEl || (!this.enterVREl && N.enterVREnabled && (N.XRMode === "xr" || N.XRMode === "vr") && (N.enterVRButton ? (this.enterVREl = document.querySelector(N.enterVRButton), this.enterVREl.addEventListener("click", this.onEnterVRButtonClick)) : (this.enterVREl = R(this.onEnterVRButtonClick), F.appendChild(this.enterVREl))), !this.enterAREl && N.enterAREnabled && (N.XRMode === "xr" || N.XRMode === "ar") && (N.enterARButton ? (this.enterAREl = document.querySelector(N.enterARButton), this.enterAREl.addEventListener("click", this.onEnterARButtonClick)) : (this.enterAREl = I(this.onEnterARButtonClick, N.XRMode === "xr"), F.appendChild(this.enterAREl))), this.orientationModalEl = L(this.onModalClick), F.appendChild(this.orientationModalEl), this.updateEnterInterfaces())
                        },
                        remove: function () {
                            [this.enterVREl, this.enterAREl, this.orientationModalEl].forEach(function (N) {
                                N && N.parentNode && N.parentNode.removeChild(N)
                            }), this.enterVREl = void 0, this.enterAREl = void 0, this.orientationModalEl = void 0
                        },
                        updateEnterInterfaces: function () {
                            this.toggleEnterVRButtonIfNeeded(), this.toggleEnterARButtonIfNeeded(), this.toggleOrientationModalIfNeeded()
                        },
                        toggleEnterVRButtonIfNeeded: function () {
                            var N = this.el;
                            this.enterVREl && (N.is("vr-mode") || (N.isMobile || v.device.isMobileDeviceRequestingDesktopSite()) && !this.data.cardboardModeEnabled && !v.device.checkVRSupport() ? this.enterVREl.classList.add(b) : (v.device.checkVRSupport() || this.enterVREl.classList.add("fullscreen"), this.enterVREl.classList.remove(b), N.enterVR(!1, !0)))
                        },
                        toggleEnterARButtonIfNeeded: function () {
                            var N = this.el;
                            this.enterAREl && (N.is("vr-mode") || !v.device.checkARSupport() ? this.enterAREl.classList.add(b) : (this.enterAREl.classList.remove(b), N.enterVR(!0, !0)))
                        },
                        toggleOrientationModalIfNeeded: function () {
                            var N = this.el, F = this.orientationModalEl;
                            !F || !N.isMobile || (!v.device.isLandscape() && N.is("vr-mode") ? F.classList.remove(b) : F.classList.add(b))
                        }
                    });

                    function R(N) {
                        var F, V;
                        return V = document.createElement("div"), V.classList.add(E), V.setAttribute(w.AFRAME_INJECTED, ""), F = document.createElement("button"), F.className = C, F.setAttribute("title", "Enter VR mode with a headset or fullscreen without"), F.setAttribute(w.AFRAME_INJECTED, ""), v.device.isMobile() && O(F), V.appendChild(F), F.addEventListener("click", function (U) {
                            N(), U.stopPropagation()
                        }), V
                    }

                    function I(N, F) {
                        var V, U;
                        return U = document.createElement("div"), U.classList.add(p), F && U.classList.add("xr"), U.setAttribute(w.AFRAME_INJECTED, ""), V = document.createElement("button"), V.className = M, V.setAttribute("title", "Enter AR mode with a headset or handheld device."), V.setAttribute(w.AFRAME_INJECTED, ""), v.device.isMobile() && O(V), U.appendChild(V), V.addEventListener("click", function (j) {
                            N(), j.stopPropagation()
                        }), U
                    }

                    function L(N) {
                        var F = document.createElement("div");
                        F.className = B, F.classList.add(b), F.setAttribute(w.AFRAME_INJECTED, "");
                        var V = document.createElement("button");
                        return V.setAttribute(w.AFRAME_INJECTED, ""), V.innerHTML = "Exit VR", V.addEventListener("click", N), F.appendChild(V), F
                    }

                    function O(N) {
                        N.addEventListener("touchstart", function () {
                            N.classList.remove("resethover")
                        }, {passive: !0}), N.addEventListener("touchend", function () {
                            N.classList.add("resethover")
                        }, {passive: !0})
                    }
                },
                "./src/components/shadow.js": (m, x, h) => {
                    var g = h("./src/core/component.js"), w = h("./src/lib/three.js"), v = g.registerComponent;
                    m.exports.Component = v("shadow", {
                        schema: {cast: {default: !0}, receive: {default: !0}},
                        init: function () {
                            this.onMeshChanged = this.update.bind(this), this.el.addEventListener("object3dset", this.onMeshChanged), this.system.setShadowMapEnabled(!0)
                        },
                        update: function () {
                            var E = this.data;
                            this.updateDescendants(E.cast, E.receive)
                        },
                        remove: function () {
                            var E = this.el;
                            E.removeEventListener("object3dset", this.onMeshChanged), this.updateDescendants(!1, !1)
                        },
                        updateDescendants: function (E, p) {
                            var C = this.el.sceneEl;
                            this.el.object3D.traverse(function (M) {
                                if (M instanceof w.Mesh && (M.castShadow = E, M.receiveShadow = p, C.hasLoaded && M.material)) for (var b = Array.isArray(M.material) ? M.material : [M.material], B = 0; B < b.length; B++) b[B].needsUpdate = !0
                            })
                        }
                    })
                },
                "./src/components/sound.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/debug.js"),
                        v = h("./src/lib/three.js"), E = w("components:sound:warn");
                    m.exports.Component = g("sound", {
                        schema: {
                            autoplay: {default: !1},
                            distanceModel: {default: "inverse", oneOf: ["linear", "inverse", "exponential"]},
                            loop: {default: !1},
                            loopStart: {default: 0},
                            loopEnd: {default: 0},
                            maxDistance: {default: 1e4},
                            on: {default: ""},
                            poolSize: {default: 1},
                            positional: {default: !0},
                            refDistance: {default: 1},
                            rolloffFactor: {default: 1},
                            src: {type: "audio"},
                            volume: {default: 1}
                        }, multiple: !0, init: function () {
                            var p = this;
                            this.listener = null, this.audioLoader = new v.AudioLoader, this.pool = new v.Group, this.loaded = !1, this.mustPlay = !1, this.playSoundBound = function () {
                                p.playSound()
                            }
                        }, update: function (p) {
                            var C = this.data, M, b, B = C.src !== p.src;
                            if (B) {
                                if (!C.src) return;
                                this.setupSound()
                            }
                            for (M = 0; M < this.pool.children.length; M++) b = this.pool.children[M], C.positional && (b.setDistanceModel(C.distanceModel), b.setMaxDistance(C.maxDistance), b.setRefDistance(C.refDistance), b.setRolloffFactor(C.rolloffFactor)), b.setLoop(C.loop), b.setLoopStart(C.loopStart), C.loopStart !== 0 && C.loopEnd === 0 ? b.setLoopEnd(b.buffer.duration) : b.setLoopEnd(C.loopEnd), b.setVolume(C.volume), b.isPaused = !1;
                            if (C.on !== p.on && this.updateEventListener(p.on), B) {
                                var R = this;
                                this.loaded = !1, this.audioLoader.load(C.src, function (I) {
                                    for (M = 0; M < R.pool.children.length; M++) b = R.pool.children[M], b.setBuffer(I);
                                    R.loaded = !0, v.Cache.remove(C.src), (R.data.autoplay || R.mustPlay) && R.playSound(R.processSound), R.el.emit("sound-loaded", R.evtDetail, !1)
                                })
                            }
                        }, pause: function () {
                            this.stopSound(), this.removeEventListener()
                        }, play: function () {
                            this.data.autoplay && this.playSound(), this.updateEventListener()
                        }, remove: function () {
                            var p, C;
                            this.removeEventListener(), this.el.getObject3D(this.attrName) && this.el.removeObject3D(this.attrName);
                            try {
                                for (p = 0; p < this.pool.children.length; p++) C = this.pool.children[p], C.disconnect()
                            } catch {
                                E("Audio source not properly disconnected")
                            }
                        }, updateEventListener: function (p) {
                            var C = this.el;
                            p && C.removeEventListener(p, this.playSoundBound), C.addEventListener(this.data.on, this.playSoundBound)
                        }, removeEventListener: function () {
                            this.el.removeEventListener(this.data.on, this.playSoundBound)
                        }, setupSound: function () {
                            var p = this.el, C, M = p.sceneEl, b = this, B;
                            this.pool.children.length > 0 && (this.stopSound(), p.removeObject3D("sound"));
                            var R = this.listener = M.audioListener || new v.AudioListener;
                            for (M.audioListener = R, M.camera && M.camera.add(R), M.addEventListener("camera-set-active", function (I) {
                                I.detail.cameraEl.getObject3D("camera").add(R)
                            }), this.pool = new v.Group, C = 0; C < this.data.poolSize; C++) B = this.data.positional ? new v.PositionalAudio(R) : new v.Audio(R), this.pool.add(B);
                            for (p.setObject3D(this.attrName, this.pool), C = 0; C < this.pool.children.length; C++) B = this.pool.children[C], B.onEnded = function () {
                                this.isPlaying = !1, b.el.emit("sound-ended", b.evtDetail, !1)
                            }
                        }, pauseSound: function () {
                            var p, C;
                            for (this.isPlaying = !1, p = 0; p < this.pool.children.length; p++) C = this.pool.children[p], !(!C.source || !C.source.buffer || !C.isPlaying || C.isPaused) && (C.isPaused = !0, C.pause())
                        }, playSound: function (p) {
                            var C, M, b;
                            if (!this.loaded) {
                                E("Sound not loaded yet. It will be played once it finished loading"), this.mustPlay = !0, this.processSound = p;
                                return
                            }
                            for (C = !1, this.isPlaying = !0, M = 0; M < this.pool.children.length; M++) if (b = this.pool.children[M], !b.isPlaying && b.buffer && !C) {
                                p && p(b), b.play(), b.isPaused = !1, C = !0;
                                continue
                            }
                            if (!C) {
                                E("All the sounds are playing. If you need to play more sounds simultaneously consider increasing the size of pool with the `poolSize` attribute.", this.el);
                                return
                            }
                            this.mustPlay = !1, this.processSound = void 0
                        }, stopSound: function () {
                            var p, C;
                            for (this.isPlaying = !1, p = 0; p < this.pool.children.length; p++) {
                                if (C = this.pool.children[p], !C.source || !C.source.buffer) return;
                                C.stop()
                            }
                        }
                    })
                },
                "./src/components/text.js": (m, x, h) => {
                    var g = h("./node_modules/three-bmfont-text/index.js"),
                        w = h("./node_modules/load-bmfont/browser.js"),
                        v = h("./src/core/component.js").registerComponent, E = h("./src/core/shader.js"),
                        p = h("./src/lib/three.js"), C = h("./src/utils/index.js"),
                        M = C.debug("components:text:error"), b = E.shaders, B = C.debug("components:text:warn"), R = 1,
                        I = 16, L = h("./src/constants/index.js").AFRAME_CDN_ROOT, O = L + "fonts/", N = {
                            aileronsemibold: O + "Aileron-Semibold.fnt",
                            dejavu: O + "DejaVu-sdf.fnt",
                            exo2bold: O + "Exo2Bold.fnt",
                            exo2semibold: O + "Exo2SemiBold.fnt",
                            kelsonsans: O + "KelsonSans.fnt",
                            monoid: O + "Monoid.fnt",
                            mozillavr: O + "mozillavr.fnt",
                            roboto: O + "Roboto-msdf.json",
                            sourcecodepro: O + "SourceCodePro.fnt"
                        }, F = ["roboto"], V = "roboto";
                    m.exports.FONTS = N;
                    var U = new ae, j = {}, Y = {}, fe = /^\w+:/;
                    m.exports.Component = v("text", {
                        multiple: !0,
                        schema: {
                            align: {type: "string", default: "left", oneOf: ["left", "right", "center"]},
                            alphaTest: {default: .5},
                            anchor: {default: "center", oneOf: ["left", "right", "center", "align"]},
                            baseline: {default: "center", oneOf: ["top", "center", "bottom"]},
                            color: {type: "color", default: "#FFF"},
                            font: {type: "string", default: V},
                            fontImage: {type: "string"},
                            height: {type: "number"},
                            letterSpacing: {type: "number", default: 0},
                            lineHeight: {type: "number"},
                            negate: {type: "boolean", default: !0},
                            opacity: {type: "number", default: 1},
                            shader: {default: "sdf", oneOf: b},
                            side: {default: "front", oneOf: ["front", "back", "double"]},
                            tabSize: {default: 4},
                            transparent: {default: !0},
                            value: {type: "string"},
                            whiteSpace: {default: "normal", oneOf: ["normal", "pre", "nowrap"]},
                            width: {type: "number"},
                            wrapCount: {type: "number", default: 40},
                            wrapPixels: {type: "number"},
                            xOffset: {type: "number", default: 0},
                            yOffset: {type: "number", default: 0},
                            zOffset: {type: "number", default: .001}
                        },
                        init: function () {
                            this.shaderData = {}, this.geometry = g(), this.createOrUpdateMaterial(), this.explicitGeoDimensionsChecked = !1
                        },
                        update: function (ee) {
                            var me = this.data, Re = this.currentFont;
                            if (Y[me.font] ? this.texture = Y[me.font] : (this.texture = Y[me.font] = new p.Texture, this.texture.anisotropy = I), this.createOrUpdateMaterial(), ee.font !== me.font) {
                                this.updateFont();
                                return
                            }
                            Re && (this.updateGeometry(this.geometry, Re), this.updateLayout())
                        },
                        remove: function () {
                            this.geometry.dispose(), this.geometry = null, this.el.removeObject3D(this.attrName), this.material.dispose(), this.material = null, this.texture.dispose(), this.texture = null, this.shaderObject && delete this.shaderObject
                        },
                        createOrUpdateMaterial: function () {
                            var ee = this.data, me, Re = this.material, ke, Ve = this.shaderData, He;
                            if (He = ee.shader, F.indexOf(ee.font) !== -1 || ee.font.indexOf("-msdf.") >= 0 ? He = "msdf" : ee.font in N && F.indexOf(ee.font) === -1 && (He = "sdf"), me = (this.shaderObject && this.shaderObject.name) !== He, Ve.alphaTest = ee.alphaTest, Ve.color = ee.color, Ve.map = this.texture, Ve.opacity = ee.opacity, Ve.side = se(ee.side), Ve.transparent = ee.transparent, Ve.negate = ee.negate, !me) {
                                this.shaderObject.update(Ve), Re.transparent = Ve.transparent, Re.side = Ve.side;
                                return
                            }
                            ke = he(this.el, He, Ve), this.material = ke.material, this.shaderObject = ke.shader, this.material.side = Ve.side, this.mesh && (this.mesh.material = this.material)
                        },
                        updateFont: function () {
                            var ee = this.data, me = this.el, Re, ke = this.geometry, Ve = this;
                            ee.font || B("No font specified. Using the default font."), this.mesh && (this.mesh.visible = !1), Re = this.lookupFont(ee.font || V) || ee.font, U.get(Re, function () {
                                return pe(Re, ee.yOffset)
                            }).then(function (ot) {
                                var gt;
                                if (ot.pages.length !== 1) throw new Error("Currently only single-page bitmap fonts are supported.");
                                j[Re] || (ot.widthFactor = j[ot] = H(ot)), Ve.currentFont = ot, gt = Ve.getFontImageSrc(), U.get(gt, function () {
                                    return ue(gt)
                                }).then(function (Bt) {
                                    var Rt = Ve.texture;
                                    Rt && (Rt.image = Bt, Rt.needsUpdate = !0, Y[ee.font] = Rt, Ve.texture = Rt, Ve.initMesh(), Ve.currentFont = ot, Ve.updateGeometry(ke, ot), Ve.updateLayout(), Ve.mesh.visible = !0, me.emit("textfontset", {
                                        font: ee.font,
                                        fontObj: ot
                                    }))
                                }).catch(function (Bt) {
                                    M(Bt.message), M(Bt.stack)
                                })
                            }).catch(function (He) {
                                M(He.message), M(He.stack)
                            })
                        },
                        initMesh: function () {
                            this.mesh || (this.mesh = new p.Mesh(this.geometry, this.material), this.el.setObject3D(this.attrName, this.mesh))
                        },
                        getFontImageSrc: function () {
                            if (this.data.fontImage) return this.data.fontImage;
                            var ee = this.lookupFont(this.data.font || V) || this.data.font,
                                me = this.currentFont.pages[0];
                            return me.match(fe) && me.indexOf("http") !== 0 ? ee.replace(/(\.fnt)|(\.json)/, ".png") : p.LoaderUtils.extractUrlBase(ee) + me
                        },
                        updateLayout: function () {
                            var ee, me, Re = this.el, ke = this.data, Ve = this.geometry, He, ot, gt, Bt = this.mesh,
                                Rt, an, En, Nn, oi;
                            if (!(!Bt || !Ve.layout)) {
                                if (He = Re.getAttribute("geometry"), En = ke.width || He && He.width || R, Rt = Z(ke.wrapPixels, ke.wrapCount, this.currentFont.widthFactor), an = En / Rt, gt = Ve.layout, ot = an * (gt.height + gt.descender), He && He.primitive === "plane" && (this.explicitGeoDimensionsChecked || (this.explicitGeoDimensionsChecked = !0, this.hasExplicitGeoWidth = !!He.width, this.hasExplicitGeoHeight = !!He.height), this.hasExplicitGeoWidth || Re.setAttribute("geometry", "width", En), this.hasExplicitGeoHeight || Re.setAttribute("geometry", "height", ot)), ee = ke.anchor === "align" ? ke.align : ke.anchor, ee === "left") Nn = 0; else if (ee === "right") Nn = -1 * gt.width; else if (ee === "center") Nn = -1 * gt.width / 2; else throw new TypeError("Invalid text.anchor property value", ee);
                                if (me = ke.baseline, me === "bottom") oi = 0; else if (me === "top") oi = -1 * gt.height + gt.ascender; else if (me === "center") oi = -1 * gt.height / 2; else throw new TypeError("Invalid text.baseline property value", me);
                                Bt.position.x = Nn * an + ke.xOffset, Bt.position.y = oi * an, Bt.position.z = ke.zOffset, Bt.scale.set(an, -1 * an, an)
                            }
                        },
                        lookupFont: function (ee) {
                            return N[ee]
                        },
                        updateGeometry: function () {
                            var ee = {}, me = {}, Re = /\\n/g, ke = /\\t/g;
                            return function (Ve, He) {
                                var ot = this.data;
                                me.font = He, me.lineHeight = ot.lineHeight && isFinite(ot.lineHeight) ? ot.lineHeight : He.common.lineHeight, me.text = ot.value.toString().replace(Re, `
`).replace(ke, "	"), me.width = Z(ot.wrapPixels, ot.wrapCount, He.widthFactor), Ve.update(C.extend(ee, ot, me))
                            }
                        }()
                    });

                    function se(ee) {
                        switch (ee) {
                            case"back":
                                return p.FrontSide;
                            case"double":
                                return p.DoubleSide;
                            default:
                                return p.BackSide
                        }
                    }

                    function pe(ee, me) {
                        return new Promise(function (Re, ke) {
                            w(ee, function (Ve, He) {
                                if (Ve) {
                                    M("Error loading font", ee), ke(Ve);
                                    return
                                }
                                ee.indexOf("/Roboto-msdf.json") >= 0 && (me = 30), me && He.chars.map(function (gt) {
                                    gt.yoffset += me
                                }), Re(He)
                            })
                        })
                    }

                    function ue(ee) {
                        return new Promise(function (me, Re) {
                            new p.ImageLoader().load(ee, function (ke) {
                                me(ke)
                            }, void 0, function () {
                                M("Error loading font image", ee), Re(null)
                            })
                        })
                    }

                    function he(ee, me, Re) {
                        var ke, Ve;
                        return Ve = new b[me].Shader, Ve.el = ee, Ve.init(Re), Ve.update(Re), ke = Ve.material, ke.transparent = Re.transparent, {
                            material: ke,
                            shader: Ve
                        }
                    }

                    function Z(ee, me, Re) {
                        return ee || (.5 + me) * Re
                    }

                    function H(ee) {
                        var me = 0, Re = 0, ke = 0;
                        return ee.chars.map(function (Ve) {
                            me += Ve.xadvance, Ve.id >= 48 && Ve.id <= 57 && (ke++, Re += Ve.xadvance)
                        }), ke ? Re / ke : me / ee.chars.length
                    }

                    function ae() {
                        var ee = this.cache = {};
                        this.get = function (me, Re) {
                            return me in ee || (ee[me] = Re()), ee[me]
                        }
                    }
                },
                "./src/components/tracked-controls-webvr.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/tracked-controls.js"),
                        v = h("./src/constants/index.js").DEFAULT_CAMERA_HEIGHT, E = h("./src/lib/three.js"),
                        p = h("./src/constants/index.js").DEFAULT_HANDEDNESS, C = {x: .175, y: -.3, z: -.03},
                        M = {x: 0, y: 0, z: -.175}, b = {touches: []}, B = {
                            AXISMOVE: "axismove",
                            BUTTONCHANGED: "buttonchanged",
                            BUTTONDOWN: "buttondown",
                            BUTTONUP: "buttonup",
                            TOUCHSTART: "touchstart",
                            TOUCHEND: "touchend"
                        };
                    m.exports.Component = g("tracked-controls-webvr", {
                        schema: {
                            autoHide: {default: !0},
                            controller: {default: 0},
                            id: {type: "string", default: ""},
                            hand: {type: "string", default: ""},
                            idPrefix: {type: "string", default: ""},
                            orientationOffset: {type: "vec3"},
                            armModel: {default: !1},
                            headElement: {type: "selector"}
                        }, init: function () {
                            this.axis = this.el.components["tracked-controls"].axis = [0, 0, 0], this.buttonStates = this.el.components["tracked-controls"].buttonStates = {}, this.changedAxes = [], this.targetControllerNumber = this.data.controller, this.axisMoveEventDetail = {
                                axis: this.axis,
                                changed: this.changedAxes
                            }, this.deltaControllerPosition = new E.Vector3, this.controllerQuaternion = new E.Quaternion, this.controllerEuler = new E.Euler, this.updateGamepad(), this.buttonEventDetails = {}
                        }, tick: function (R, I) {
                            var L = this.el.getObject3D("mesh");
                            L && L.update && L.update(I / 1e3), this.updateGamepad(), this.updatePose(), this.updateButtons()
                        }, defaultUserHeight: function () {
                            return v
                        }, getHeadElement: function () {
                            return this.data.headElement || this.el.sceneEl.camera.el
                        }, updateGamepad: function () {
                            var R = this.data,
                                I = w.findMatchingControllerWebVR(this.system.controllers, R.id, R.idPrefix, R.hand, R.controller);
                            this.controller = I, this.el.components["tracked-controls"].controller = I, this.data.autoHide && (this.el.object3D.visible = !!this.controller)
                        }, applyArmModel: function (R) {
                            var I = this.controller, L = this.controllerEuler, O = this.controllerQuaternion,
                                N = this.deltaControllerPosition, F, V, U, j, Y;
                            V = this.getHeadElement(), U = V.object3D, Y = this.defaultUserHeight(), j = I.pose, F = (I ? I.hand : void 0) || p, R.copy(U.position), N.set(C.x * (F === "left" ? -1 : F === "right" ? 1 : 0), C.y, C.z), N.multiplyScalar(Y), N.applyAxisAngle(U.up, U.rotation.y), R.add(N), N.set(M.x, M.y, M.z), N.multiplyScalar(Y), j.orientation ? O.fromArray(j.orientation) : O.copy(U.quaternion), L.setFromQuaternion(O), L.set(L.x, L.y, 0), N.applyEuler(L), R.add(N)
                        }, updatePose: function () {
                            var R = this.controller, I = this.data, L = this.el.object3D, O, N = this.system.vrDisplay,
                                F;
                            R && (O = R.pose, O.position ? L.position.fromArray(O.position) : I.armModel && this.applyArmModel(L.position), O.orientation && L.quaternion.fromArray(O.orientation), N && O.position && (F = this.el.sceneEl.renderer.xr.getStandingMatrix(), L.matrix.compose(L.position, L.quaternion, L.scale), L.matrix.multiplyMatrices(F, L.matrix), L.matrix.decompose(L.position, L.quaternion, L.scale)), L.rotateX(this.data.orientationOffset.x * E.MathUtils.DEG2RAD), L.rotateY(this.data.orientationOffset.y * E.MathUtils.DEG2RAD), L.rotateZ(this.data.orientationOffset.z * E.MathUtils.DEG2RAD))
                        }, updateButtons: function () {
                            var R, I = this.controller, L;
                            if (I) {
                                for (L = 0; L < I.buttons.length; ++L) this.buttonStates[L] || (this.buttonStates[L] = {
                                    pressed: !1,
                                    touched: !1,
                                    value: 0
                                }), this.buttonEventDetails[L] || (this.buttonEventDetails[L] = {
                                    id: L,
                                    state: this.buttonStates[L]
                                }), R = I.buttons[L], this.handleButton(L, R);
                                this.handleAxes()
                            }
                        }, handleButton: function (R, I) {
                            var L;
                            return L = this.handlePress(R, I) | this.handleTouch(R, I) | this.handleValue(R, I), L ? (this.el.emit(B.BUTTONCHANGED, this.buttonEventDetails[R], !1), !0) : !1
                        }, handleAxes: function () {
                            var R = !1, I = this.controller.axes, L, O = this.axis, N = this.changedAxes;
                            for (this.changedAxes.splice(0, this.changedAxes.length), L = 0; L < I.length; ++L) N.push(O[L] !== I[L]), N[L] && (R = !0);
                            if (!R) return !1;
                            for (this.axis.splice(0, this.axis.length), L = 0; L < I.length; L++) this.axis.push(I[L]);
                            return this.el.emit(B.AXISMOVE, this.axisMoveEventDetail, !1), !0
                        }, handlePress: function (R, I) {
                            var L, O = this.buttonStates[R];
                            return I.pressed === O.pressed ? !1 : (L = I.pressed ? B.BUTTONDOWN : B.BUTTONUP, this.el.emit(L, this.buttonEventDetails[R], !1), O.pressed = I.pressed, !0)
                        }, handleTouch: function (R, I) {
                            var L, O = this.buttonStates[R];
                            return I.touched === O.touched ? !1 : (L = I.touched ? B.TOUCHSTART : B.TOUCHEND, this.el.emit(L, this.buttonEventDetails[R], !1, b), O.touched = I.touched, !0)
                        }, handleValue: function (R, I) {
                            var L = this.buttonStates[R];
                            return I.value === L.value ? !1 : (L.value = I.value, !0)
                        }
                    })
                },
                "./src/components/tracked-controls-webxr.js": (m, x, h) => {
                    var g = h("./src/utils/tracked-controls.js"), w = h("./src/core/component.js").registerComponent,
                        v = {
                            AXISMOVE: "axismove",
                            BUTTONCHANGED: "buttonchanged",
                            BUTTONDOWN: "buttondown",
                            BUTTONUP: "buttonup",
                            TOUCHSTART: "touchstart",
                            TOUCHEND: "touchend"
                        };
                    m.exports.Component = w("tracked-controls-webxr", {
                        schema: {
                            id: {type: "string", default: ""},
                            hand: {type: "string", default: ""},
                            handTrackingEnabled: {default: !1},
                            index: {type: "int", default: -1},
                            iterateControllerProfiles: {default: !1},
                            space: {type: "string", oneOf: ["targetRaySpace", "gripSpace"], default: "gripSpace"}
                        }, init: function () {
                            this.updateController = this.updateController.bind(this), this.buttonEventDetails = {}, this.buttonStates = this.el.components["tracked-controls"].buttonStates = {}, this.axis = this.el.components["tracked-controls"].axis = [0, 0, 0], this.changedAxes = [], this.axisMoveEventDetail = {
                                axis: this.axis,
                                changed: this.changedAxes
                            }
                        }, update: function () {
                            this.updateController()
                        }, play: function () {
                            var E = this.el.sceneEl;
                            this.updateController(), E.addEventListener("controllersupdated", this.updateController)
                        }, pause: function () {
                            var E = this.el.sceneEl;
                            E.removeEventListener("controllersupdated", this.updateController)
                        }, isControllerPresent: function (E) {
                            return !(!this.controller || this.controller.gamepad || E.inputSource.handedness !== "none" && E.inputSource.handedness !== this.data.hand)
                        }, updateController: function () {
                            this.controller = g.findMatchingControllerWebXR(this.system.controllers, this.data.id, this.data.hand, this.data.index, this.data.iterateControllerProfiles, this.data.handTrackingEnabled), this.el.components["tracked-controls"].controller = this.controller, this.data.autoHide && (this.el.object3D.visible = !!this.controller)
                        }, tick: function () {
                            var E = this.el.sceneEl, p = this.controller, C = E.frame;
                            !p || !E.frame || !this.system.referenceSpace || p.hand || (this.pose = C.getPose(p[this.data.space], this.system.referenceSpace), this.updatePose(), this.updateButtons())
                        }, updatePose: function () {
                            var E = this.el.object3D, p = this.pose;
                            p && (E.matrix.elements = p.transform.matrix, E.matrix.decompose(E.position, E.rotation, E.scale))
                        }, updateButtons: function () {
                            var E, p, C = this.controller, M;
                            if (!(!C || !C.gamepad)) {
                                for (M = C.gamepad, p = 0; p < M.buttons.length; ++p) this.buttonStates[p] || (this.buttonStates[p] = {
                                    pressed: !1,
                                    touched: !1,
                                    value: 0
                                }), this.buttonEventDetails[p] || (this.buttonEventDetails[p] = {
                                    id: p,
                                    state: this.buttonStates[p]
                                }), E = M.buttons[p], this.handleButton(p, E);
                                this.handleAxes()
                            }
                        }, handleButton: function (E, p) {
                            var C;
                            return C = this.handlePress(E, p) | this.handleTouch(E, p) | this.handleValue(E, p), C ? (this.el.emit(v.BUTTONCHANGED, this.buttonEventDetails[E], !1), !0) : !1
                        }, handleAxes: function () {
                            var E = !1, p = this.controller.gamepad.axes, C, M = this.axis, b = this.changedAxes;
                            for (this.changedAxes.splice(0, this.changedAxes.length), C = 0; C < p.length; ++C) b.push(M[C] !== p[C]), b[C] && (E = !0);
                            if (!E) return !1;
                            for (this.axis.splice(0, this.axis.length), C = 0; C < p.length; C++) this.axis.push(p[C]);
                            return this.el.emit(v.AXISMOVE, this.axisMoveEventDetail, !1), !0
                        }, handlePress: function (E, p) {
                            var C, M = this.buttonStates[E];
                            return p.pressed === M.pressed ? !1 : (C = p.pressed ? v.BUTTONDOWN : v.BUTTONUP, this.el.emit(C, this.buttonEventDetails[E], !1), M.pressed = p.pressed, !0)
                        }, handleTouch: function (E, p) {
                            var C, M = this.buttonStates[E];
                            return p.touched === M.touched ? !1 : (C = p.touched ? v.TOUCHSTART : v.TOUCHEND, this.el.emit(C, this.buttonEventDetails[E], !1), M.touched = p.touched, !0)
                        }, handleValue: function (E, p) {
                            var C = this.buttonStates[E];
                            return p.value === C.value ? !1 : (C.value = p.value, !0)
                        }
                    })
                },
                "./src/components/tracked-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("tracked-controls", {
                        schema: {
                            autoHide: {default: !0},
                            controller: {default: -1},
                            id: {type: "string", default: ""},
                            hand: {type: "string", default: ""},
                            idPrefix: {type: "string", default: ""},
                            handTrackingEnabled: {default: !1},
                            orientationOffset: {type: "vec3"},
                            armModel: {default: !1},
                            headElement: {type: "selector"},
                            iterateControllerProfiles: {default: !1},
                            space: {type: "string", oneOf: ["targetRaySpace", "gripSpace"], default: "targetRaySpace"}
                        }, after: ["tracked-controls-webvr", "tracked-controls-webxr"], update: function () {
                            var w = this.data, v = this.el;
                            v.sceneEl.hasWebXR ? v.setAttribute("tracked-controls-webxr", {
                                id: w.id,
                                hand: w.hand,
                                index: w.controller,
                                iterateControllerProfiles: w.iterateControllerProfiles,
                                handTrackingEnabled: w.handTrackingEnabled,
                                space: w.space
                            }) : v.setAttribute("tracked-controls-webvr", w)
                        }
                    })
                },
                "./src/components/valve-index-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = h("./src/utils/tracked-controls.js"), E = v.checkControllerPresentAndSetup,
                        p = v.emitIfAxesChanged, C = v.onButtonEvent, M = h("./src/constants/index.js").AFRAME_CDN_ROOT,
                        b = M + "controllers/valve/index/valve-index-",
                        B = {left: b + "left.glb", right: b + "right.glb"}, R = "valve",
                        I = h("./src/utils/index.js").device.isWebXRAvailable, L = {
                            left: {x: -.00023692678902063457, y: .04724540367838371, z: -.061959880395271096},
                            right: {x: .002471558599671131, y: .055765208987076195, z: -.061068168708348844}
                        }, O = {left: {x: 0, y: -.05, z: .06}, right: {x: 0, y: -.05, z: .06}}, N = {
                            left: {
                                _x: .692295102620542,
                                _y: -.0627618864318427,
                                _z: -.06265893149611756,
                                _order: "XYZ"
                            },
                            right: {_x: .6484021229942998, _y: -.032563619881892894, _z: -.1327973171917482, _order: "XYZ"}
                        }, F = {
                            left: {_x: Math.PI / 3, _y: 0, _z: 0, _order: "XYZ"},
                            right: {_x: Math.PI / 3, _y: 0, _z: 0, _order: "XYZ"}
                        }, V = I ? F : N, U = I ? O : L;
                    m.exports.Component = g("valve-index-controls", {
                        schema: {
                            hand: {default: "left"},
                            buttonColor: {type: "color", default: "#FAFAFA"},
                            buttonHighlightColor: {type: "color", default: "#22D1EE"},
                            model: {default: !0},
                            orientationOffset: {type: "vec3"}
                        },
                        after: ["tracked-controls"],
                        mapping: {
                            axes: {trackpad: [0, 1], thumbstick: [2, 3]},
                            buttons: ["trigger", "grip", "trackpad", "thumbstick", "abutton"]
                        },
                        init: function () {
                            var j = this;
                            this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (Y) {
                                C(Y.detail.id, "down", j)
                            }, this.onButtonUp = function (Y) {
                                C(Y.detail.id, "up", j)
                            }, this.onButtonTouchEnd = function (Y) {
                                C(Y.detail.id, "touchend", j)
                            }, this.onButtonTouchStart = function (Y) {
                                C(Y.detail.id, "touchstart", j)
                            }, this.previousButtonValues = {}, this.bindMethods()
                        },
                        play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        },
                        pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        },
                        bindMethods: function () {
                            this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        },
                        addEventListeners: function () {
                            var j = this.el;
                            j.addEventListener("buttonchanged", this.onButtonChanged), j.addEventListener("buttondown", this.onButtonDown), j.addEventListener("buttonup", this.onButtonUp), j.addEventListener("touchend", this.onButtonTouchEnd), j.addEventListener("touchstart", this.onButtonTouchStart), j.addEventListener("model-loaded", this.onModelLoaded), j.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0
                        },
                        removeEventListeners: function () {
                            var j = this.el;
                            j.removeEventListener("buttonchanged", this.onButtonChanged), j.removeEventListener("buttondown", this.onButtonDown), j.removeEventListener("buttonup", this.onButtonUp), j.removeEventListener("touchend", this.onButtonTouchEnd), j.removeEventListener("touchstart", this.onButtonTouchStart), j.removeEventListener("model-loaded", this.onModelLoaded), j.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1
                        },
                        checkIfControllerPresent: function () {
                            var j = this.data, Y = j.hand === "right" ? 0 : j.hand === "left" ? 1 : 2;
                            E(this, R, {index: Y, iterateControllerProfiles: !0, hand: j.hand})
                        },
                        injectTrackedControls: function () {
                            var j = this.el, Y = this.data;
                            j.setAttribute("tracked-controls", {
                                idPrefix: R,
                                controller: Y.hand === "right" ? 1 : Y.hand === "left" ? 0 : 2,
                                hand: Y.hand,
                                orientationOffset: Y.orientationOffset
                            }), this.loadModel()
                        },
                        loadModel: function () {
                            var j = this.data;
                            j.model && this.el.setAttribute("gltf-model", "" + B[j.hand])
                        },
                        addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        },
                        removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        },
                        onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        },
                        onButtonChanged: function (j) {
                            var Y = this.mapping.buttons[j.detail.id], fe = this.buttonMeshes, se;
                            Y && (Y === "trigger" && (se = j.detail.state.value, fe && fe.trigger && (fe.trigger.rotation.x = this.triggerOriginalRotationX - se * (Math.PI / 40))), this.el.emit(Y + "changed", j.detail.state))
                        },
                        onModelLoaded: function (j) {
                            var Y, fe = j.detail.model, se = this;
                            j.target !== this.el || !this.data.model || (Y = this.buttonMeshes = {}, Y.grip = {
                                left: fe.getObjectByName("leftgrip"),
                                right: fe.getObjectByName("rightgrip")
                            }, Y.menu = fe.getObjectByName("menubutton"), Y.system = fe.getObjectByName("systembutton"), Y.trackpad = fe.getObjectByName("touchpad"), Y.trigger = fe.getObjectByName("trigger"), this.triggerOriginalRotationX = Y.trigger.rotation.x, Object.keys(Y).forEach(function (pe) {
                                se.setButtonColor(pe, se.data.buttonColor)
                            }), fe.position.copy(U[this.data.hand]), fe.rotation.copy(V[this.data.hand]), this.el.emit("controllermodelready", {
                                name: "valve-index-controls",
                                model: this.data.model,
                                rayOrigin: new w.Vector3(0, 0, 0)
                            }))
                        },
                        onAxisMoved: function (j) {
                            p(this, this.mapping.axes, j)
                        },
                        updateModel: function (j, Y) {
                            var fe, se;
                            this.data.model && (se = Y.indexOf("touch") !== -1, !se && (fe = Y === "up" ? this.data.buttonColor : this.data.buttonHighlightColor, this.setButtonColor(j, fe)))
                        },
                        setButtonColor: function (j, Y) {
                        }
                    })
                },
                "./src/components/visible.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent;
                    m.exports.Component = g("visible", {
                        schema: {default: !0}, update: function () {
                            this.el.object3D.visible = this.data
                        }
                    })
                },
                "./src/components/vive-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/tracked-controls.js"),
                        v = w.checkControllerPresentAndSetup, E = w.emitIfAxesChanged, p = w.onButtonEvent,
                        C = h("./src/constants/index.js").AFRAME_CDN_ROOT,
                        M = C + "controllers/vive/vr_controller_vive.obj",
                        b = C + "controllers/vive/vr_controller_vive.mtl",
                        B = h("./src/utils/index.js").device.isWebXRAvailable, R = "htc-vive", I = "OpenVR ",
                        L = B ? R : I,
                        O = {axes: {trackpad: [0, 1]}, buttons: ["trackpad", "trigger", "grip", "menu", "system"]},
                        N = {axes: {touchpad: [0, 1]}, buttons: ["trigger", "grip", "touchpad", "none"]}, F = B ? N : O;
                    m.exports.Component = g("vive-controls", {
                        schema: {
                            hand: {default: "left"},
                            buttonColor: {type: "color", default: "#FAFAFA"},
                            buttonHighlightColor: {type: "color", default: "#22D1EE"},
                            model: {default: !0},
                            orientationOffset: {type: "vec3"}
                        }, after: ["tracked-controls"], mapping: F, init: function () {
                            var V = this;
                            this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (U) {
                                p(U.detail.id, "down", V)
                            }, this.onButtonUp = function (U) {
                                p(U.detail.id, "up", V)
                            }, this.onButtonTouchEnd = function (U) {
                                p(U.detail.id, "touchend", V)
                            }, this.onButtonTouchStart = function (U) {
                                p(U.detail.id, "touchstart", V)
                            }, this.previousButtonValues = {}, this.bindMethods()
                        }, update: function () {
                            var V = this.data;
                            this.controllerIndex = V.hand === "right" ? 0 : V.hand === "left" ? 1 : 2
                        }, play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        }, pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        }, bindMethods: function () {
                            this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        }, addEventListeners: function () {
                            var V = this.el;
                            V.addEventListener("buttonchanged", this.onButtonChanged), V.addEventListener("buttondown", this.onButtonDown), V.addEventListener("buttonup", this.onButtonUp), V.addEventListener("touchend", this.onButtonTouchEnd), V.addEventListener("touchstart", this.onButtonTouchStart), V.addEventListener("model-loaded", this.onModelLoaded), V.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0
                        }, removeEventListeners: function () {
                            var V = this.el;
                            V.removeEventListener("buttonchanged", this.onButtonChanged), V.removeEventListener("buttondown", this.onButtonDown), V.removeEventListener("buttonup", this.onButtonUp), V.removeEventListener("touchend", this.onButtonTouchEnd), V.removeEventListener("touchstart", this.onButtonTouchStart), V.removeEventListener("model-loaded", this.onModelLoaded), V.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1
                        }, checkIfControllerPresent: function () {
                            var V = this.data;
                            v(this, L, {index: this.controllerIndex, hand: V.hand})
                        }, injectTrackedControls: function () {
                            var V = this.el, U = this.data;
                            V.setAttribute("tracked-controls", {
                                idPrefix: L,
                                hand: U.hand,
                                controller: this.controllerIndex,
                                orientationOffset: U.orientationOffset
                            }), this.data.model && this.el.setAttribute("obj-model", {obj: M, mtl: b})
                        }, addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        }, onButtonChanged: function (V) {
                            var U = this.mapping.buttons[V.detail.id], j = this.buttonMeshes, Y;
                            U && (U === "trigger" && (Y = V.detail.state.value, j && j.trigger && (j.trigger.rotation.x = -Y * (Math.PI / 12))), this.el.emit(U + "changed", V.detail.state))
                        }, onModelLoaded: function (V) {
                            var U, j = V.detail.model, Y = this;
                            V.target !== this.el || !this.data.model || (U = this.buttonMeshes = {}, U.grip = {
                                left: j.getObjectByName("leftgrip"),
                                right: j.getObjectByName("rightgrip")
                            }, U.menu = j.getObjectByName("menubutton"), U.system = j.getObjectByName("systembutton"), U.trackpad = j.getObjectByName("touchpad"), U.touchpad = j.getObjectByName("touchpad"), U.trigger = j.getObjectByName("trigger"), Object.keys(U).forEach(function (fe) {
                                Y.setButtonColor(fe, Y.data.buttonColor)
                            }), j.position.set(0, -.015, .04))
                        }, onAxisMoved: function (V) {
                            E(this, this.mapping.axes, V)
                        }, updateModel: function (V, U) {
                            var j, Y;
                            this.data.model && (Y = U.indexOf("touch") !== -1, !Y && (j = U === "up" ? this.data.buttonColor : this.data.buttonHighlightColor, this.setButtonColor(V, j)))
                        }, setButtonColor: function (V, U) {
                            var j = this.buttonMeshes;
                            if (j) {
                                if (V === "grip") {
                                    j.grip.left.material.color.set(U), j.grip.right.material.color.set(U);
                                    return
                                }
                                j[V].material.color.set(U)
                            }
                        }
                    })
                },
                "./src/components/vive-focus-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/tracked-controls.js"),
                        v = w.checkControllerPresentAndSetup, E = w.emitIfAxesChanged, p = w.onButtonEvent,
                        C = h("./src/constants/index.js").AFRAME_CDN_ROOT,
                        M = C + "controllers/vive/focus-controller/focus-controller.gltf",
                        b = h("./src/utils/index.js").device.isWebXRAvailable, B = "htc-vive-focus",
                        R = "HTC Vive Focus ", I = b ? B : R,
                        L = {axes: {trackpad: [0, 1]}, buttons: ["trackpad", "trigger"]},
                        O = {axes: {touchpad: [0, 1]}, buttons: ["trigger", "none", "touchpad", "none", "menu"]},
                        N = b ? O : L;
                    m.exports.Component = g("vive-focus-controls", {
                        schema: {
                            hand: {default: ""},
                            buttonTouchedColor: {type: "color", default: "#BBBBBB"},
                            buttonHighlightColor: {type: "color", default: "#7A7A7A"},
                            model: {default: !0},
                            orientationOffset: {type: "vec3"},
                            armModel: {default: !0}
                        }, after: ["tracked-controls"], mapping: N, bindMethods: function () {
                            this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        }, init: function () {
                            var F = this;
                            this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (V) {
                                p(V.detail.id, "down", F)
                            }, this.onButtonUp = function (V) {
                                p(V.detail.id, "up", F)
                            }, this.onButtonTouchStart = function (V) {
                                p(V.detail.id, "touchstart", F)
                            }, this.onButtonTouchEnd = function (V) {
                                p(V.detail.id, "touchend", F)
                            }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.bindMethods()
                        }, addEventListeners: function () {
                            var F = this.el;
                            F.addEventListener("buttonchanged", this.onButtonChanged), F.addEventListener("buttondown", this.onButtonDown), F.addEventListener("buttonup", this.onButtonUp), F.addEventListener("touchstart", this.onButtonTouchStart), F.addEventListener("touchend", this.onButtonTouchEnd), F.addEventListener("model-loaded", this.onModelLoaded), F.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0, this.addControllersUpdateListener()
                        }, removeEventListeners: function () {
                            var F = this.el;
                            F.removeEventListener("buttonchanged", this.onButtonChanged), F.removeEventListener("buttondown", this.onButtonDown), F.removeEventListener("buttonup", this.onButtonUp), F.removeEventListener("touchstart", this.onButtonTouchStart), F.removeEventListener("touchend", this.onButtonTouchEnd), F.removeEventListener("model-loaded", this.onModelLoaded), F.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1, this.removeControllersUpdateListener()
                        }, checkIfControllerPresent: function () {
                            v(this, I, this.data.hand ? {hand: this.data.hand} : {})
                        }, play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        }, pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        }, injectTrackedControls: function () {
                            var F = this.el, V = this.data;
                            F.setAttribute("tracked-controls", {
                                armModel: V.armModel,
                                idPrefix: I,
                                orientationOffset: V.orientationOffset
                            }), this.data.model && this.el.setAttribute("gltf-model", M)
                        }, addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        }, onModelLoaded: function (F) {
                            var V = F.detail.model, U;
                            F.target !== this.el || !this.data.model || (U = this.buttonMeshes = {}, U.trigger = V.getObjectByName("BumperKey"), U.triggerPressed = V.getObjectByName("BumperKey_Press"), U.triggerPressed && (U.triggerPressed.visible = !1), U.trackpad = V.getObjectByName("TouchPad"), U.trackpadPressed = V.getObjectByName("TouchPad_Press"), U.trackpadPressed && (U.trackpadPressed.visible = !1))
                        }, onButtonChanged: function (F) {
                            var V = this.mapping.buttons[F.detail.id];
                            V && this.el.emit(V + "changed", F.detail.state)
                        }, onAxisMoved: function (F) {
                            E(this, this.mapping.axes, F)
                        }, updateModel: function (F, V) {
                            this.data.model && this.updateButtonModel(F, V)
                        }, updateButtonModel: function (F, V) {
                            var U = this.buttonMeshes, j = F + "Pressed";
                            if (!(!U || !U[F] || !U[j])) {
                                var Y;
                                switch (V) {
                                    case"down":
                                        Y = this.data.buttonHighlightColor;
                                        break;
                                    case"touchstart":
                                        Y = this.data.buttonTouchedColor;
                                        break
                                }
                                Y && U[j].material.color.set(Y), U[j].visible = !!Y, U[F].visible = !Y
                            }
                        }
                    })
                },
                "./src/components/wasd-controls.js": (m, x, h) => {
                    var g = h("./src/constants/index.js").keyboardevent.KEYCODE_TO_CODE,
                        w = h("./src/core/component.js").registerComponent, v = h("./src/lib/three.js"),
                        E = h("./src/utils/index.js"), p = E.shouldCaptureKeyEvent, C = 1e-5, M = .2,
                        b = ["KeyW", "KeyA", "KeyS", "KeyD", "ArrowUp", "ArrowLeft", "ArrowRight", "ArrowDown"];
                    m.exports.Component = w("wasd-controls", {
                        schema: {
                            acceleration: {default: 65},
                            adAxis: {default: "x", oneOf: ["x", "y", "z"]},
                            adEnabled: {default: !0},
                            adInverted: {default: !1},
                            enabled: {default: !0},
                            fly: {default: !1},
                            wsAxis: {default: "z", oneOf: ["x", "y", "z"]},
                            wsEnabled: {default: !0},
                            wsInverted: {default: !1}
                        }, after: ["look-controls"], init: function () {
                            this.keys = {}, this.easing = 1.1, this.velocity = new v.Vector3, this.onBlur = this.onBlur.bind(this), this.onContextMenu = this.onContextMenu.bind(this), this.onFocus = this.onFocus.bind(this), this.onKeyDown = this.onKeyDown.bind(this), this.onKeyUp = this.onKeyUp.bind(this), this.onVisibilityChange = this.onVisibilityChange.bind(this), this.attachVisibilityEventListeners()
                        }, tick: function (R, I) {
                            var L = this.data, O = this.el, N = this.velocity;
                            !N[L.adAxis] && !N[L.wsAxis] && B(this.keys) || (I = I / 1e3, this.updateVelocity(I), !(!N[L.adAxis] && !N[L.wsAxis]) && O.object3D.position.add(this.getMovementVector(I)))
                        }, update: function (R) {
                            R.adAxis !== this.data.adAxis && (this.velocity[R.adAxis] = 0), R.wsAxis !== this.data.wsAxis && (this.velocity[R.wsAxis] = 0)
                        }, remove: function () {
                            this.removeKeyEventListeners(), this.removeVisibilityEventListeners()
                        }, play: function () {
                            this.attachKeyEventListeners()
                        }, pause: function () {
                            this.keys = {}, this.removeKeyEventListeners()
                        }, updateVelocity: function (R) {
                            var I, L, O, N = this.data, F = this.keys, V = this.velocity, U, j;
                            if (L = N.adAxis, U = N.wsAxis, R > M) {
                                V[L] = 0, V[U] = 0;
                                return
                            }
                            var Y = Math.pow(1 / this.easing, R * 60);
                            V[L] !== 0 && (V[L] = V[L] * Y), V[U] !== 0 && (V[U] = V[U] * Y), Math.abs(V[L]) < C && (V[L] = 0), Math.abs(V[U]) < C && (V[U] = 0), N.enabled && (I = N.acceleration, N.adEnabled && (O = N.adInverted ? -1 : 1, (F.KeyA || F.ArrowLeft) && (V[L] -= O * I * R), (F.KeyD || F.ArrowRight) && (V[L] += O * I * R)), N.wsEnabled && (j = N.wsInverted ? -1 : 1, (F.KeyW || F.ArrowUp) && (V[U] -= j * I * R), (F.KeyS || F.ArrowDown) && (V[U] += j * I * R)))
                        }, getMovementVector: function () {
                            var R = new v.Vector3(0, 0, 0), I = new v.Euler(0, 0, 0, "YXZ");
                            return function (L) {
                                var O = this.el.getAttribute("rotation"), N = this.velocity, F;
                                return R.copy(N), R.multiplyScalar(L), O && (F = this.data.fly ? O.x : 0, I.set(v.MathUtils.degToRad(F), v.MathUtils.degToRad(O.y), 0), R.applyEuler(I)), R
                            }
                        }(), attachVisibilityEventListeners: function () {
                            window.oncontextmenu = this.onContextMenu, window.addEventListener("blur", this.onBlur), window.addEventListener("focus", this.onFocus), document.addEventListener("visibilitychange", this.onVisibilityChange)
                        }, removeVisibilityEventListeners: function () {
                            window.removeEventListener("blur", this.onBlur), window.removeEventListener("focus", this.onFocus), document.removeEventListener("visibilitychange", this.onVisibilityChange)
                        }, attachKeyEventListeners: function () {
                            window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp)
                        }, removeKeyEventListeners: function () {
                            window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp)
                        }, onContextMenu: function () {
                            for (var R = Object.keys(this.keys), I = 0; I < R.length; I++) delete this.keys[R[I]]
                        }, onBlur: function () {
                            this.pause()
                        }, onFocus: function () {
                            this.play()
                        }, onVisibilityChange: function () {
                            document.hidden ? this.onBlur() : this.onFocus()
                        }, onKeyDown: function (R) {
                            var I;
                            p(R) && (I = R.code || g[R.keyCode], b.indexOf(I) !== -1 && (this.keys[I] = !0))
                        }, onKeyUp: function (R) {
                            var I;
                            I = R.code || g[R.keyCode], delete this.keys[I]
                        }
                    });

                    function B(R) {
                        var I;
                        for (I in R) return !1;
                        return !0
                    }
                },
                "./src/components/windows-motion-controls.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/utils/tracked-controls.js"),
                        v = w.checkControllerPresentAndSetup, E = w.emitIfAxesChanged, p = w.onButtonEvent,
                        C = h("./src/utils/index.js"), M = C.debug("components:windows-motion-controls:debug"),
                        b = C.debug("components:windows-motion-controls:warn"),
                        B = h("./src/constants/index.js").DEFAULT_HANDEDNESS,
                        R = h("./src/constants/index.js").AFRAME_CDN_ROOT, I = R + "controllers/microsoft/",
                        L = {left: "left.glb", right: "right.glb", default: "universal.glb"},
                        O = h("./src/utils/index.js").device.isWebXRAvailable, N = "windows-mixed-reality",
                        F = "Spatial Controller (Spatial Interaction Source) ", V = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/,
                        U = O ? N : F, j = {
                            axes: {thumbstick: [0, 1], trackpad: [2, 3]},
                            buttons: ["thumbstick", "trigger", "grip", "menu", "trackpad"],
                            axisMeshNames: ["THUMBSTICK_X", "THUMBSTICK_Y", "TOUCHPAD_TOUCH_X", "TOUCHPAD_TOUCH_Y"],
                            buttonMeshNames: {
                                trigger: "SELECT",
                                menu: "MENU",
                                grip: "GRASP",
                                thumbstick: "THUMBSTICK_PRESS",
                                trackpad: "TOUCHPAD_PRESS"
                            },
                            pointingPoseMeshName: "POINTING_POSE"
                        }, Y = {
                            axes: {touchpad: [0, 1], thumbstick: [2, 3]},
                            buttons: ["trigger", "squeeze", "touchpad", "thumbstick", "menu"],
                            axisMeshNames: ["TOUCHPAD_TOUCH_X", "TOUCHPAD_TOUCH_X", "THUMBSTICK_X", "THUMBSTICK_Y"],
                            buttonMeshNames: {
                                trigger: "SELECT",
                                menu: "MENU",
                                squeeze: "GRASP",
                                thumbstick: "THUMBSTICK_PRESS",
                                touchpad: "TOUCHPAD_PRESS"
                            },
                            pointingPoseMeshName: "POINTING_POSE"
                        }, fe = O ? Y : j;
                    m.exports.Component = g("windows-motion-controls", {
                        schema: {
                            hand: {default: B},
                            pair: {default: 0},
                            model: {default: !0},
                            hideDisconnected: {default: !0}
                        }, after: ["tracked-controls"], mapping: fe, bindMethods: function () {
                            this.onModelError = this.onModelError.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this)
                        }, init: function () {
                            var se = this, pe = this.el;
                            this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function (ue) {
                                p(ue.detail.id, "down", se)
                            }, this.onButtonUp = function (ue) {
                                p(ue.detail.id, "up", se)
                            }, this.onButtonTouchStart = function (ue) {
                                p(ue.detail.id, "touchstart", se)
                            }, this.onButtonTouchEnd = function (ue) {
                                p(ue.detail.id, "touchend", se)
                            }, this.onControllerConnected = function () {
                                se.setModelVisibility(!0)
                            }, this.onControllerDisconnected = function () {
                                se.setModelVisibility(!1)
                            }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.previousButtonValues = {}, this.bindMethods(), this.loadedMeshInfo = {
                                buttonMeshes: null,
                                axisMeshes: null
                            }, this.rayOrigin = {
                                origin: new THREE.Vector3,
                                direction: new THREE.Vector3(0, 0, -1),
                                createdFromMesh: !1
                            }, pe.addEventListener("controllerconnected", this.onControllerConnected), pe.addEventListener("controllerdisconnected", this.onControllerDisconnected)
                        }, addEventListeners: function () {
                            var se = this.el;
                            se.addEventListener("buttonchanged", this.onButtonChanged), se.addEventListener("buttondown", this.onButtonDown), se.addEventListener("buttonup", this.onButtonUp), se.addEventListener("touchstart", this.onButtonTouchStart), se.addEventListener("touchend", this.onButtonTouchEnd), se.addEventListener("axismove", this.onAxisMoved), se.addEventListener("model-error", this.onModelError), se.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0
                        }, removeEventListeners: function () {
                            var se = this.el;
                            se.removeEventListener("buttonchanged", this.onButtonChanged), se.removeEventListener("buttondown", this.onButtonDown), se.removeEventListener("buttonup", this.onButtonUp), se.removeEventListener("touchstart", this.onButtonTouchStart), se.removeEventListener("touchend", this.onButtonTouchEnd), se.removeEventListener("axismove", this.onAxisMoved), se.removeEventListener("model-error", this.onModelError), se.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1
                        }, checkIfControllerPresent: function () {
                            v(this, U, {hand: this.data.hand, index: this.data.pair, iterateControllerProfiles: !0})
                        }, play: function () {
                            this.checkIfControllerPresent(), this.addControllersUpdateListener()
                        }, pause: function () {
                            this.removeEventListeners(), this.removeControllersUpdateListener()
                        }, updateControllerModel: function () {
                            if (!this.data.model || this.rayOrigin.createdFromMesh) {
                                this.modelReady();
                                return
                            }
                            var se = this.createControllerModelUrl();
                            this.loadModel(se)
                        }, createControllerModelUrl: function (se) {
                            var pe = this.el.components["tracked-controls"], ue = pe ? pe.controller : null,
                                he = "default", Z = this.data.hand, H;
                            if (ue && !window.hasNativeWebXRImplementation && (Z = ue.hand, !se)) {
                                var ae = ue.id.match(V);
                                he = ae && ae[0] || he
                            }
                            return H = L[Z] || L.default, I + he + "/" + H
                        }, injectTrackedControls: function () {
                            var se = this.data;
                            this.el.setAttribute("tracked-controls", {
                                idPrefix: U,
                                controller: se.pair,
                                hand: se.hand,
                                armModel: !1
                            }), this.updateControllerModel()
                        }, addControllersUpdateListener: function () {
                            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, removeControllersUpdateListener: function () {
                            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1)
                        }, onControllersUpdate: function () {
                            this.checkIfControllerPresent()
                        }, onModelError: function (se) {
                            var pe = this.createControllerModelUrl(!0);
                            se.detail.src !== pe ? (b("Failed to load controller model for device, attempting to load default."), this.loadModel(pe)) : b("Failed to load default controller model.")
                        }, loadModel: function (se) {
                            this.el.setAttribute("gltf-model", "url(" + se + ")")
                        }, onModelLoaded: function (se) {
                            var pe = this.controllerModel = se.detail.model, ue = this.loadedMeshInfo, he, Z, H, ae;
                            if (se.target !== this.el) return;
                            if (M("Processing model"), ue.buttonMeshes = {}, ue.axisMeshes = {}, pe) {
                                for (he = 0; he < this.mapping.buttons.length; he++) {
                                    if (Z = this.mapping.buttonMeshNames[this.mapping.buttons[he]], !Z) {
                                        M("Skipping unknown button at index: " + he + " with mapped name: " + this.mapping.buttons[he]);
                                        continue
                                    }
                                    if (H = pe.getObjectByName(Z), !H) {
                                        b("Missing button mesh with name: " + Z);
                                        continue
                                    }
                                    ae = {
                                        index: he,
                                        value: ee(H, "VALUE"),
                                        pressed: ee(H, "PRESSED"),
                                        unpressed: ee(H, "UNPRESSED")
                                    }, ae.value && ae.pressed && ae.unpressed ? ue.buttonMeshes[this.mapping.buttons[he]] = ae : b("Missing button submesh under mesh with name: " + Z + "(VALUE: " + !!ae.value + ", PRESSED: " + !!ae.pressed + ", UNPRESSED:" + !!ae.unpressed + ")")
                                }
                                for (he = 0; he < this.mapping.axisMeshNames.length; he++) {
                                    if (Z = this.mapping.axisMeshNames[he], !Z) {
                                        M("Skipping unknown axis at index: " + he);
                                        continue
                                    }
                                    if (H = pe.getObjectByName(Z), !H) {
                                        b("Missing axis mesh with name: " + Z);
                                        continue
                                    }
                                    ae = {
                                        index: he,
                                        value: ee(H, "VALUE"),
                                        min: ee(H, "MIN"),
                                        max: ee(H, "MAX")
                                    }, ae.value && ae.min && ae.max ? ue.axisMeshes[he] = ae : b("Missing axis submesh under mesh with name: " + Z + "(VALUE: " + !!ae.value + ", MIN: " + !!ae.min + ", MAX:" + !!ae.max + ")")
                                }
                                this.calculateRayOriginFromMesh(pe), this.setModelVisibility()
                            }
                            M("Model load complete.");

                            function ee(me, Re) {
                                for (var ke = 0, Ve = me.children.length; ke < Ve; ke++) {
                                    var He = me.children[ke];
                                    if (He && He.name === Re) return He
                                }
                            }
                        }, calculateRayOriginFromMesh: function () {
                            var se = new THREE.Quaternion;
                            return function (pe) {
                                var ue;
                                if (this.rayOrigin.origin.set(0, 0, 0), this.rayOrigin.direction.set(0, 0, -1), this.rayOrigin.createdFromMesh = !0, ue = pe.getObjectByName(this.mapping.pointingPoseMeshName), ue) {
                                    var he = pe.parent;
                                    he && (pe.parent = null, pe.updateMatrixWorld(!0), pe.parent = he), ue.getWorldPosition(this.rayOrigin.origin), ue.getWorldQuaternion(se), this.rayOrigin.direction.applyQuaternion(se), he && pe.updateMatrixWorld(!0)
                                } else M("Mesh does not contain pointing origin data, defaulting to none.");
                                this.modelReady()
                            }
                        }(), lerpAxisTransform: function () {
                            var se = new THREE.Quaternion;
                            return function (pe, ue) {
                                var he = this.loadedMeshInfo.axisMeshes[pe];
                                if (he) {
                                    var Z = he.min, H = he.max, ae = he.value, ee = ue * .5 + .5;
                                    ae.setRotationFromQuaternion(se.copy(Z.quaternion).slerp(H.quaternion, ee)), ae.position.lerpVectors(Z.position, H.position, ee)
                                }
                            }
                        }(), lerpButtonTransform: function () {
                            var se = new THREE.Quaternion;
                            return function (pe, ue) {
                                var he = this.loadedMeshInfo.buttonMeshes[pe];
                                if (he) {
                                    var Z = he.unpressed, H = he.pressed, ae = he.value;
                                    ae.setRotationFromQuaternion(se.copy(Z.quaternion).slerp(H.quaternion, ue)), ae.position.lerpVectors(Z.position, H.position, ue)
                                }
                            }
                        }(), modelReady: function () {
                            this.el.emit("controllermodelready", {
                                name: "windows-motion-controls",
                                model: this.data.model,
                                rayOrigin: this.rayOrigin
                            })
                        }, onButtonChanged: function (se) {
                            var pe = this.mapping.buttons[se.detail.id];
                            pe && (this.loadedMeshInfo && this.loadedMeshInfo.buttonMeshes && this.lerpButtonTransform(pe, se.detail.state.value), this.el.emit(pe + "changed", se.detail.state))
                        }, onAxisMoved: function (se) {
                            var pe = this.mapping.axisMeshNames.length;
                            if (this.loadedMeshInfo && this.loadedMeshInfo.axisMeshes) for (var ue = 0; ue < pe; ue++) this.lerpAxisTransform(ue, se.detail.axis[ue] || 0);
                            E(this, this.mapping.axes, se)
                        }, setModelVisibility: function (se) {
                            var pe = this.el.getObject3D("mesh");
                            this.controllerPresent && (se = se !== void 0 ? se : this.modelVisible, this.modelVisible = se, pe && (pe.visible = se))
                        }
                    })
                },
                "./src/constants/index.js": (m, x, h) => {
                    m.exports = {
                        AFRAME_CDN_ROOT: window.AFRAME_CDN_ROOT || "https://cdn.aframe.io/",
                        AFRAME_INJECTED: "aframe-injected",
                        DEFAULT_CAMERA_HEIGHT: 1.6,
                        DEFAULT_HANDEDNESS: "right",
                        keyboardevent: h("./src/constants/keyboardevent.js")
                    }
                },
                "./src/constants/keyboardevent.js": m => {
                    m.exports = {
                        KEYCODE_TO_CODE: {
                            38: "ArrowUp",
                            37: "ArrowLeft",
                            40: "ArrowDown",
                            39: "ArrowRight",
                            87: "KeyW",
                            65: "KeyA",
                            83: "KeyS",
                            68: "KeyD"
                        }
                    }
                },
                "./src/core/a-assets.js": (m, x, h) => {
                    var g = h("./src/core/a-node.js").ANode, w = h("./src/utils/debug.js"), v = h("./src/lib/three.js"),
                        E = new v.FileLoader, p = w("core:a-assets:warn");

                    class C extends g {
                        constructor() {
                            super(), this.isAssets = !0, this.fileLoader = E, this.timeout = null
                        }

                        doConnectedCallback() {
                            var F = this, V, U = [], j, Y, fe, se, pe, ue;
                            if (super.doConnectedCallback(), !this.parentNode.isScene) throw new Error("<a-assets> must be a child of a <a-scene>.");
                            for (se = this.querySelectorAll("img"), V = 0; V < se.length; V++) fe = B(se[V]), U.push(new Promise(function (he, Z) {
                                if (v.Cache.add(se[V].getAttribute("src"), fe), fe.complete) {
                                    he();
                                    return
                                }
                                fe.onload = he, fe.onerror = Z
                            }));
                            for (Y = this.querySelectorAll("audio, video"), V = 0; V < Y.length; V++) j = B(Y[V]), !j.src && !j.srcObject && p("Audio/video asset has neither `src` nor `srcObject` attributes."), U.push(b(j));
                            ue = this.getChildren(), ue.forEach(function (he) {
                                !he.isAssetItem || !he.hasAttribute("src") || U.push(new Promise(function (H, ae) {
                                    if (he.hasLoaded) return H();
                                    he.addEventListener("loaded", H), he.addEventListener("error", ae)
                                }))
                            }), Promise.allSettled(U).then(function () {
                                F.timeout !== null && F.load()
                            }), pe = parseInt(this.getAttribute("timeout"), 10) || 3e3, this.timeout = setTimeout(function () {
                                F.hasLoaded || (p("Asset loading timed out in", pe, "ms"), F.timeout = null, F.emit("timeout"), F.load())
                            }, pe)
                        }

                        disconnectedCallback() {
                            super.disconnectedCallback(), this.timeout && clearTimeout(this.timeout)
                        }

                        load() {
                            super.load.call(this, null, function () {
                                return !1
                            })
                        }
                    }

                    customElements.define("a-assets", C);

                    class M extends g {
                        constructor() {
                            super(), this.data = null, this.isAssetItem = !0
                        }

                        connectedCallback() {
                            var F = this, V = this.getAttribute("src");
                            E.setResponseType(this.getAttribute("response-type") || L(V)), E.load(V, function (j) {
                                F.data = j, g.prototype.load.call(F)
                            }, function (j) {
                                F.emit("progress", {loadedBytes: j.loaded, totalBytes: j.total, xhr: j})
                            }, function (j) {
                                F.emit("error", {xhr: j})
                            })
                        }
                    }

                    customElements.define("a-asset-item", M);

                    function b(N) {
                        if (!(!N.hasAttribute("autoplay") && N.getAttribute("preload") !== "auto")) return new Promise(function (F, V) {
                            if (N.readyState === 4) return F();
                            if (N.error) return V();
                            N.addEventListener("loadeddata", U, !1), N.addEventListener("progress", U, !1), N.addEventListener("error", V, !1);

                            function U() {
                                for (var j = 0, Y = 0; Y < N.buffered.length; Y++) j += N.buffered.end(Y) - N.buffered.start(Y);
                                j >= N.duration && (N.tagName === "VIDEO" && v.Cache.add(N.getAttribute("src"), N), F())
                            }
                        })
                    }

                    function B(N) {
                        var F = R(N);
                        return F.tagName && F.tagName.toLowerCase() === "video" && (F.setAttribute("playsinline", ""), F.setAttribute("webkit-playsinline", "")), F !== N && (N.parentNode.appendChild(F), N.parentNode.removeChild(N)), F
                    }

                    function R(N) {
                        var F, V;
                        return N.hasAttribute("crossorigin") || (V = N.getAttribute("src"), V !== null && (V.indexOf("://") === -1 || I(V) === window.location.host)) ? N : (p('Cross-origin element (e.g., <img>) was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set. Please set `crossorigin` on the element (e.g., <img crossorigin="anonymous">)', V), N.crossOrigin = "anonymous", F = N.cloneNode(!0), F)
                    }

                    function I(N) {
                        var F = N.indexOf("://") > -1 ? N.split("/")[2] : N.split("/")[0];
                        return F.substring(0, F.indexOf(":"))
                    }

                    function L(N) {
                        var F = O(N), V = F.lastIndexOf(".");
                        if (V >= 0) {
                            var U = F.slice(V, N.search(/\?|#|$/));
                            if (U === ".glb") return "arraybuffer"
                        }
                        return "text"
                    }

                    m.exports.inferResponseType = L;

                    function O(N) {
                        var F = document.createElement("a");
                        F.href = N;
                        var V = F.search.replace(/^\?/, ""), U = N.replace(V, "").replace("?", "");
                        return U.substring(U.lastIndexOf("/") + 1)
                    }

                    m.exports.getFileNameFromURL = O
                },
                "./src/core/a-cubemap.js": (m, x, h) => {
                    var g = h("./src/utils/debug.js"), w = g("core:cubemap:warn");

                    class v extends HTMLElement {
                        constructor(p) {
                            return p = super(p), p
                        }

                        onReadyStateChange() {
                            document.readyState === "complete" && this.doConnectedCallback()
                        }

                        connectedCallback() {
                            if (document.readyState !== "complete") {
                                document.addEventListener("readystatechange", this.onReadyStateChange.bind(this));
                                return
                            }
                            v.prototype.doConnectedCallback.call(this)
                        }

                        doConnectedCallback() {
                            this.srcs = this.validate()
                        }

                        validate() {
                            var p = this.querySelectorAll("[src]"), C, M = [];
                            if (p.length === 6) {
                                for (C = 0; C < p.length; C++) p[C].tagName === "IMG" ? M.push(p[C]) : M.push(p[C].getAttribute("src"));
                                return M
                            }
                            w("<a-cubemap> did not contain exactly six elements each with a `src` attribute.")
                        }
                    }

                    customElements.define("a-cubemap", v)
                },
                "./src/core/a-entity.js": (m, x, h) => {
                    var g = h("./src/core/a-node.js").ANode, w = h("./src/core/component.js").components,
                        v = h("./src/lib/three.js"), E = h("./src/utils/index.js"), p = E.debug("core:a-entity:debug"),
                        C = E.debug("core:a-entity:warn"), M = "__", b = ["position", "rotation", "scale", "visible"],
                        B = {once: !0};

                    class R extends g {
                        constructor() {
                            super(), this.components = {}, this.initializingComponents = {}, this.componentsToUpdate = {}, this.isEntity = !0, this.isPlaying = !1, this.object3D = new v.Group, this.object3D.rotation.order = "YXZ", this.object3D.el = this, this.object3DMap = {}, this.parentEl = null, this.rotationObj = {}, this.states = []
                        }

                        attributeChangedCallback(U, j, Y) {
                            var fe = this.components[U];
                            if (super.attributeChangedCallback(), fe && fe.justInitialized && Y === "") {
                                delete fe.justInitialized;
                                return
                            }
                            !fe && Y === null || this.setEntityAttribute(U, j, Y)
                        }

                        doConnectedCallback() {
                            var U = this, j, Y;
                            if (super.doConnectedCallback(), Y = this.sceneEl, this.addToParent(), !this.isScene) {
                                if (!Y) {
                                    this.load();
                                    return
                                }
                                if (j = Y.querySelector("a-assets"), j && !j.hasLoaded) {
                                    j.addEventListener("loaded", function () {
                                        U.load()
                                    });
                                    return
                                }
                                this.load()
                            }
                        }

                        disconnectedCallback() {
                            var U;
                            if (this.parentEl) {
                                for (U in this.components) this.removeComponent(U, !1);
                                this.isScene || (this.removeFromParent(), super.disconnectedCallback(), this.object3D.el = null)
                            }
                        }

                        getObject3D(U) {
                            return this.object3DMap[U]
                        }

                        setObject3D(U, j) {
                            var Y, fe = this;
                            if (!(j instanceof v.Object3D)) throw new Error("`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D.");
                            Y = this.getObject3D(U), Y && this.object3D.remove(Y), j.el = this, j.children.length && j.traverse(function (pe) {
                                pe.el = fe
                            }), this.object3D.add(j), this.object3DMap[U] = j, this.emit("object3dset", {
                                object: j,
                                type: U
                            })
                        }

                        removeObject3D(U) {
                            var j = this.getObject3D(U);
                            if (!j) {
                                C("Tried to remove `Object3D` of type:", U, "which was not defined.");
                                return
                            }
                            this.object3D.remove(j), delete this.object3DMap[U], this.emit("object3dremove", {type: U})
                        }

                        getOrCreateObject3D(U, j) {
                            var Y = this.getObject3D(U);
                            return !Y && j && (Y = new j, this.setObject3D(U, Y)), C("`getOrCreateObject3D` has been deprecated. Use `setObject3D()` and `object3dset` event instead."), Y
                        }

                        add(U) {
                            if (!U.object3D) throw new Error("Trying to add an element that doesn't have an `object3D`");
                            this.object3D.add(U.object3D), this.emit("child-attached", {el: U})
                        }

                        addToParent() {
                            var U = this.parentEl = this.parentNode;
                            !U || !U.add || this.attachedToParent || (U.add(this), this.attachedToParent = !0)
                        }

                        removeFromParent() {
                            var U = this.parentEl;
                            this.parentEl.remove(this), this.attachedToParent = !1, this.parentEl = null, U.emit("child-detached", {el: this})
                        }

                        load() {
                            var U = this;
                            this.hasLoaded || !this.parentEl || super.load.call(this, function () {
                                U.parentEl && (U.updateComponents(), (U.isScene || U.parentEl.isPlaying) && U.play())
                            })
                        }

                        remove(U) {
                            U ? this.object3D.remove(U.object3D) : this.parentNode.removeChild(this)
                        }

                        getChildEntities() {
                            for (var U = this.children, j = [], Y = 0; Y < U.length; Y++) {
                                var fe = U[Y];
                                fe instanceof R && j.push(fe)
                            }
                            return j
                        }

                        initComponent(U, j, Y) {
                            var fe, se, pe, ue, he;
                            pe = E.split(U, M), ue = pe[0], se = pe.length > 2 ? pe.slice(1).join("__") : pe[1], w[ue] && (he = I(this, U) || j !== void 0, !(!he && !Y) && (U in this.components || (this.initComponentDependencies(ue), fe = new w[ue].Component(this, j, se), this.isPlaying && fe.play(), this.hasAttribute(U) || (fe.justInitialized = !0, window.HTMLElement.prototype.setAttribute.call(this, U, "")), p("Component initialized: %s", U))))
                        }

                        initComponentDependencies(U) {
                            var j = this, Y = w[U], fe, se;
                            if (Y && (fe = w[U].dependencies, !!fe)) for (se = 0; se < fe.length; se++) j.initComponent(fe[se], window.HTMLElement.prototype.getAttribute.call(j, fe[se]) || void 0, !0)
                        }

                        removeComponent(U, j) {
                            var Y;
                            if (Y = this.components[U], !!Y) {
                                if (!Y.initialized) {
                                    this.addEventListener("componentinitialized", function fe(se) {
                                        se.detail.name === U && (this.removeComponent(U, j), this.removeEventListener("componentinitialized", fe))
                                    });
                                    return
                                }
                                Y.pause(), Y.remove(), j && (Y.destroy(), delete this.components[U], this.hasAttribute(U) && window.HTMLElement.prototype.removeAttribute.call(this, U)), this.emit("componentremoved", Y.evtDetail, !1)
                            }
                        }

                        updateComponents() {
                            var U, j, Y, fe, se = this.componentsToUpdate;
                            if (!(!this.hasLoaded && !this.isLoading)) {
                                for (Y = 0; Y < this.mixinEls.length; Y++) for (fe in this.mixinEls[Y].componentCache) N(fe) && (se[fe] = !0);
                                if (this.getExtraComponents) {
                                    j = this.getExtraComponents();
                                    for (fe in j) N(fe) && (se[fe] = !0)
                                }
                                for (Y = 0; Y < this.attributes.length; ++Y) fe = this.attributes[Y].name, b.indexOf(fe) === -1 && N(fe) && (se[fe] = !0);
                                for (Y = 0; Y < b.length; Y++) fe = b[Y], this.hasAttribute(fe) && this.updateComponent(fe, this.getDOMAttribute(fe));
                                for (fe in se) U = O(this.getDOMAttribute(fe), j && j[fe]), this.updateComponent(fe, U), delete se[fe]
                            }
                        }

                        updateComponent(U, j, Y) {
                            var fe = this.components[U];
                            if (fe) {
                                if (j === null && !I(this, U)) {
                                    this.removeComponent(U, !0);
                                    return
                                }
                                fe.updateProperties(j, Y);
                                return
                            }
                            this.initComponent(U, j, !1)
                        }

                        removeAttribute(U, j) {
                            var Y = this.components[U];
                            if (Y && j === void 0 && this.removeComponent(U, !0), Y && j !== void 0) {
                                Y.resetProperty(j);
                                return
                            }
                            U === "mixin" && this.mixinUpdate(""), window.HTMLElement.prototype.removeAttribute.call(this, U)
                        }

                        play() {
                            var U, j, Y;
                            if (!(this.isPlaying || !this.hasLoaded && !this.isLoading)) {
                                this.isPlaying = !0;
                                for (Y in this.components) this.components[Y].play();
                                for (U = this.getChildEntities(), j = 0; j < U.length; j++) U[j].play();
                                this.emit("play")
                            }
                        }

                        pause() {
                            var U, j, Y;
                            if (this.isPlaying) {
                                this.isPlaying = !1;
                                for (Y in this.components) this.components[Y].pause();
                                for (U = this.getChildEntities(), j = 0; j < U.length; j++) U[j].pause();
                                this.emit("pause")
                            }
                        }

                        setEntityAttribute(U, j, Y) {
                            if (w[U] || this.components[U]) {
                                this.updateComponent(U, Y);
                                return
                            }
                            if (U === "mixin") {
                                if (Y === this.computedMixinStr) return;
                                this.mixinUpdate(Y, j)
                            }
                        }

                        mixinUpdate(U, j, Y) {
                            var fe = R.componentsUpdated, se, pe, ue, he, Z = this;
                            if (Y || (j = j || this.getAttribute("mixin")), !this.hasLoaded) {
                                this.addEventListener("loaded-private", function () {
                                    Z.mixinUpdate(U, j, !0)
                                }, B);
                                return
                            }
                            for (ue = this.updateMixins(U, j), fe.length = 0, he = 0; he < this.mixinEls.length; he++) for (se in this.mixinEls[he].componentCache) fe.indexOf(se) === -1 && (this.components[se] ? this.components[se].handleMixinUpdate() : this.initComponent(se, null), fe.push(se));
                            for (he = 0; he < ue.oldMixinIds.length; he++) if (pe = document.getElementById(ue.oldMixinIds[he]), !!pe) for (se in pe.componentCache) fe.indexOf(se) === -1 && this.components[se] && (this.getDOMAttribute(se) ? this.components[se].handleMixinUpdate() : this.removeComponent(se, !0))
                        }

                        setAttribute(U, j, Y) {
                            var fe = R.singlePropUpdate, se, pe, ue, he, Z, H;
                            if (he = U.indexOf(M), ue = he > 0 ? U.substring(0, he) : U, !w[ue]) {
                                U === "mixin" && this.mixinUpdate(j), super.setAttribute.call(this, U, j);
                                return
                            }
                            if (!this.components[U] && this.hasAttribute(U) && this.updateComponent(U, window.HTMLElement.prototype.getAttribute.call(this, U)), typeof Y < "u" && typeof j == "string" && j.length > 0 && typeof E.styleParser.parse(j) == "string") {
                                for (H in fe) delete fe[H];
                                se = fe, se[j] = Y, pe = !1
                            } else se = j, pe = Y === !0;
                            this.updateComponent(U, se, pe), Z = this.sceneEl && this.sceneEl.getAttribute("debug"), Z && this.components[U].flushToDOM()
                        }

                        flushToDOM(U) {
                            var j = this.components, Y, fe = this.children, se, pe;
                            for (pe in j) j[pe].flushToDOM();
                            if (U) for (se = 0; se < fe.length; ++se) Y = fe[se], Y.flushToDOM && Y.flushToDOM(U)
                        }

                        getAttribute(U) {
                            var j;
                            return U === "position" ? this.object3D.position : U === "rotation" ? F(this) : U === "scale" ? this.object3D.scale : U === "visible" ? this.object3D.visible : (j = this.components[U], j ? j.data : window.HTMLElement.prototype.getAttribute.call(this, U))
                        }

                        getDOMAttribute(U) {
                            var j = this.components[U];
                            return j ? j.attrValue : window.HTMLElement.prototype.getAttribute.call(this, U)
                        }

                        addState(U) {
                            this.is(U) || (this.states.push(U), this.emit("stateadded", U))
                        }

                        removeState(U) {
                            var j = this.states.indexOf(U);
                            j !== -1 && (this.states.splice(j, 1), this.emit("stateremoved", U))
                        }

                        is(U) {
                            return this.states.indexOf(U) !== -1
                        }

                        inspect() {
                            this.sceneEl.components.inspector.openInspector(this)
                        }

                        destroy() {
                            var U;
                            if (this.parentNode) {
                                C("Entity can only be destroyed if detached from scenegraph.");
                                return
                            }
                            for (U in this.components) this.components[U].destroy()
                        }
                    }

                    function I(V, U) {
                        return V.components[U] && V.components[U].attrValue ? !0 : L(U, V.mixinEls)
                    }

                    function L(V, U) {
                        var j, Y = !1;
                        for (j = 0; j < U.length && (Y = U[j].hasAttribute(V), !Y); ++j) ;
                        return Y
                    }

                    function O(V, U) {
                        return U ? U.constructor === Object ? E.extend(U, E.styleParser.parse(V || {})) : V || U : V
                    }

                    function N(V) {
                        return V.indexOf(M) !== -1 && (V = E.split(V, M)[0]), !!w[V]
                    }

                    function F(V) {
                        var U = v.MathUtils.radToDeg, j = V.object3D.rotation, Y = V.rotationObj;
                        return Y.x = U(j.x), Y.y = U(j.y), Y.z = U(j.z), Y
                    }

                    R.componentsUpdated = [], R.singlePropUpdate = {}, customElements.define("a-entity", R), m.exports.AEntity = R
                },
                "./src/core/a-mixin.js": (m, x, h) => {
                    var g = h("./src/core/a-node.js").ANode, w = h("./src/core/component.js").components,
                        v = h("./src/utils/index.js"), E = v.styleParser, p = "__";

                    class C extends g {
                        constructor() {
                            super(), this.componentCache = {}, this.rawAttributeCache = {}, this.isMixin = !0
                        }

                        doConnectedCallback() {
                            super.doConnectedCallback(), this.sceneEl = this.closestScene(), this.id = this.getAttribute("id"), this.cacheAttributes(), this.updateEntities(), this.load()
                        }

                        attributeChangedCallback(b, B, R) {
                            super.attributeChangedCallback(), this.cacheAttribute(b, R), this.updateEntities()
                        }

                        setAttribute(b, B) {
                            window.HTMLElement.prototype.setAttribute.call(this, b, B), this.cacheAttribute(b, B)
                        }

                        cacheAttribute(b, B) {
                            var R, I;
                            I = v.split(b, p)[0], R = w[I], B === void 0 && (B = window.HTMLElement.prototype.getAttribute.call(this, b)), this.rawAttributeCache[b] = B, R && (this.componentCache[b] = this.parseComponentAttrValue(R, B))
                        }

                        parseComponentAttrValue(b, B) {
                            var R;
                            return typeof B != "string" ? B : (b.isSingleProperty ? (R = b.schema.parse(B), typeof R == "string" && (R = B)) : R = E.parse(B), R)
                        }

                        getAttribute(b) {
                            return this.componentCache[b] || window.HTMLElement.prototype.getAttribute.call(this, b)
                        }

                        cacheAttributes() {
                            var b = this.attributes, B, R;
                            for (R = 0; R < b.length; R++) B = b[R].name, this.cacheAttribute(B)
                        }

                        updateEntities() {
                            var b, B, R;
                            if (this.sceneEl) for (B = this.sceneEl.querySelectorAll("[mixin~=" + this.id + "]"), R = 0; R < B.length; R++) b = B[R], !(!b.hasLoaded || b.isMixin) && b.mixinUpdate(this.id)
                        }
                    }

                    customElements.define("a-mixin", C)
                },
                "./src/core/a-node.js": (m, x, h) => {
                    var g = h("./src/utils/index.js"), w = h("./src/core/readyState.js"),
                        v = g.debug("core:a-node:warn"), E = {
                            "a-scene": !0,
                            "a-assets": !0,
                            "a-assets-items": !0,
                            "a-cubemap": !0,
                            "a-mixin": !0,
                            "a-node": !0,
                            "a-entity": !0
                        };

                    function p(M) {
                        return M.tagName.toLowerCase() in E || M.isNode
                    }

                    class C extends HTMLElement {
                        constructor() {
                            super(), this.computedMixinStr = "", this.hasLoaded = !1, this.isNode = !0, this.mixinEls = []
                        }

                        connectedCallback() {
                            if (!w.canInitializeElements) {
                                document.addEventListener("aframeready", this.connectedCallback.bind(this));
                                return
                            }
                            this.doConnectedCallback()
                        }

                        doConnectedCallback() {
                            var b;
                            this.sceneEl = this.closestScene(), this.sceneEl || v("You are attempting to attach <" + this.tagName + "> outside of an A-Frame scene. Append this element to `<a-scene>` instead."), this.hasLoaded = !1, this.emit("nodeready", void 0, !1), this.isMixin || (b = this.getAttribute("mixin"), b && this.updateMixins(b))
                        }

                        attributeChangedCallback(b, B, R) {
                            R !== this.computedMixinStr && b === "mixin" && !this.isMixin && this.updateMixins(R, B)
                        }

                        closestScene() {
                            for (var b = this; b && !b.isScene;) b = b.parentElement;
                            return b
                        }

                        closest(b) {
                            for (var B = this.matches || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector, R = this; R && !B.call(R, b);) R = R.parentElement;
                            return R
                        }

                        disconnectedCallback() {
                            this.hasLoaded = !1
                        }

                        load(b, B) {
                            var R, I, L = this;
                            this.hasLoaded || (B = B || p, R = this.getChildren(), I = R.filter(B).map(function (O) {
                                return new Promise(function (F, V) {
                                    if (O.hasLoaded) return F();
                                    O.addEventListener("loaded", F), O.addEventListener("error", V)
                                })
                            }), Promise.allSettled(I).then(function (N) {
                                N.forEach(function (V) {
                                    V.status === "rejected" && v("Rendering scene with errors on node: ", V.reason.target)
                                }), L.isLoading = !0, L.setupMutationObserver(), b && b(), L.isLoading = !1, L.hasLoaded = !0, L.emit("loaded-private", void 0, !1), L.emit("loaded", void 0, !1)
                            }))
                        }

                        setupMutationObserver() {
                            var b = this, B = {attributes: !0, attributeOldValue: !0},
                                R = new MutationObserver(function (L) {
                                    var O;
                                    for (O = 0; O < L.length; O++) if (L[O].type === "attributes") {
                                        var N = L[O].attributeName,
                                            F = window.HTMLElement.prototype.getAttribute.call(b, N), V = L[O].oldValue;
                                        b.attributeChangedCallback(N, V, F)
                                    }
                                });
                            R.observe(this, B)
                        }

                        getChildren() {
                            return Array.prototype.slice.call(this.children, 0)
                        }

                        updateMixins(b, B) {
                            var R = C.newMixinIdArray, I = C.oldMixinIdArray, L = C.mixinIds, O, N, F;
                            for (R.length = 0, I.length = 0, N = b ? g.split(b.trim(), /\s+/) : R, F = B ? g.split(B.trim(), /\s+/) : I, L.newMixinIds = N, L.oldMixinIds = F, O = 0; O < F.length; O++) N.indexOf(F[O]) === -1 && this.unregisterMixin(F[O]);
                            for (this.computedMixinStr = "", this.mixinEls.length = 0, O = 0; O < N.length; O++) this.registerMixin(N[O]);
                            return this.computedMixinStr && (this.computedMixinStr = this.computedMixinStr.trim(), window.HTMLElement.prototype.setAttribute.call(this, "mixin", this.computedMixinStr)), N.length === 0 && window.HTMLElement.prototype.removeAttribute.call(this, "mixin"), L
                        }

                        registerMixin(b) {
                            var B, R, I, L = document.getElementById(b);
                            if (!L) {
                                v("No mixin was found with id `%s`", b);
                                return
                            }
                            if (I = L.getAttribute("mixin"), I) for (B = g.split(I.trim(), /\s+/), R = 0; R < B.length; R++) this.registerMixin(B[R]);
                            this.computedMixinStr = this.computedMixinStr + " " + L.id, this.mixinEls.push(L)
                        }

                        setAttribute(b, B) {
                            b === "mixin" && this.updateMixins(B), window.HTMLElement.prototype.setAttribute.call(this, b, B)
                        }

                        unregisterMixin(b) {
                            var B, R = this.mixinEls, I;
                            for (B = 0; B < R.length; ++B) if (I = R[B], b === I.id) {
                                R.splice(B, 1);
                                break
                            }
                        }

                        emit(b, B, R, I) {
                            var L = C.evtData;
                            R === void 0 && (R = !0), L.bubbles = !!R, L.detail = B, I && (L = g.extend({}, I, L)), this.dispatchEvent(new CustomEvent(b, L))
                        }
                    }

                    C.evtData = {}, C.newMixinIdArray = [], C.oldMixinIdArray = [], C.mixinIds = {}, customElements.define("a-node", C), m.exports.ANode = C, m.exports.knownTags = E
                },
                "./src/core/component.js": (m, x, h) => {
                    var g = h("./src/core/schema.js"), w = h("./src/core/scene/scenes.js"),
                        v = h("./src/core/system.js"), E = h("./src/utils/index.js"), p = m.exports.components = {},
                        C = g.parseProperty, M = g.process, b = g.isSingleProperty, B = g.stringifyProperties,
                        R = g.stringifyProperty, I = E.styleParser, L = E.debug("core:component:warn"),
                        O = document.currentScript, N = new RegExp("[A-Z]+"), F = {}, V = Object.freeze({}), U = [],
                        j = {
                            get: function (H, ae) {
                                return H.getComputedPropertyValue(ae)
                            }, set: function (H, ae, ee) {
                                return ae in H.schema ? H.recomputeProperty(ae, ee) : ee !== void 0 && H.handleUnknownProperty(ae, ee), !0
                            }
                        }, Y = m.exports.Component = function (H, ae, ee) {
                            var me = this;
                            if (this.sceneOnly && !H.isScene) throw new Error("Component `" + this.name + "` can only be applied to <a-scene>");
                            if (ee && !this.multiple) throw new Error("Trying to initialize multiple components of type `" + this.name + "`. There can only be one component of this type per entity.");
                            this.el = H, this.id = ee, this.attrName = this.name + (ee ? "__" + ee : ""), this.evtDetail = {
                                id: this.id,
                                name: this.name
                            }, this.initialized = !1, this.el.components[this.attrName] = this, this.objectPool = F[this.name];
                            var Re = this.events;
                            this.events = {}, fe(this, Re), this.attrValue = void 0, this.isObjectBased ? (this.data = this.objectPool.use(), E.objectPool.removeUnusedKeys(this.data, this.schema), this.oldData = this.objectPool.use(), E.objectPool.removeUnusedKeys(this.oldData, this.schema), this.attrValueProxy = new Proxy(this, j)) : (this.data = void 0, this.oldData = void 0, this.attrValueProxy = void 0), this.deferUnknownPropertyWarnings = !!this.updateSchema, this.silenceUnknownPropertyWarnings = !1, this.throttledEmitComponentChanged = E.throttleLeadingAndTrailing(function () {
                                H.emit("componentchanged", me.evtDetail, !1)
                            }, 200), this.updateProperties(ae, !0)
                        };
                    Y.prototype = {
                        schema: {}, init: function () {
                        }, events: {}, update: function (H) {
                        }, updateSchema: void 0, tick: void 0, tock: void 0, play: function () {
                        }, pause: function () {
                        }, remove: function () {
                        }, stringify: function (H) {
                            var ae = this.schema;
                            return typeof H == "string" ? H : this.isSingleProperty ? R(H, ae) : (H = B(H, ae), I.stringify(H))
                        }, flushToDOM: function (H) {
                            var ae = H ? this.data : this.attrValue;
                            ae != null && window.HTMLElement.prototype.setAttribute.call(this.el, this.attrName, this.stringify(ae))
                        }, updateProperties: function (H, ae) {
                            var ee = this.el;
                            this.updateData(H, ae), !(!ee.hasLoaded && !ee.isLoading) && (this.initialized ? this.callUpdateHandler() : this.initComponent())
                        }, initComponent: function () {
                            var H = this.el, ae;
                            H.initializingComponents[this.name] || (H.initializingComponents[this.name] = !0, this.init(), this.initialized = !0, delete H.initializingComponents[this.name], ae = this.isObjectBased ? V : void 0, this.dataChanged = !1, this.storeOldData(), this.update(ae), H.isPlaying && this.play(), H.emit("componentinitialized", this.evtDetail, !1))
                        }, updateData: function (H, ae) {
                            if (this.isSingleProperty) {
                                this.recomputeProperty(void 0, H);
                                return
                            }
                            ae ? (E.objectPool.clearObject(this.attrValue), this.recomputeData(H), this.schemaChangeRequired = !!this.updateSchema) : typeof H == "string" ? I.parse(H, this.attrValueProxy) : E.extend(this.attrValueProxy, H), this.updateSchemaIfNeeded(H)
                        }, updateSchemaIfNeeded: function (H) {
                            if (!this.schemaChangeRequired || !this.updateSchema) {
                                for (var ae = 0; ae < U.length; ae++) L("Unknown property `" + U[ae] + "` for component `" + this.name + "`.");
                                U.length = 0;
                                return
                            }
                            U.length = 0, this.updateSchema(this.data), E.objectPool.removeUnusedKeys(this.data, this.schema), this.silenceUnknownPropertyWarnings = !0, this.recomputeData(H), this.silenceUnknownPropertyWarnings = !1, this.schemaChangeRequired = !1
                        }, callUpdateHandler: function () {
                            if (!(!this.isPositionRotationScale && !this.dataChanged)) {
                                this.dataChanged = !1;
                                var H = this.oldData;
                                this.oldDataInUse = !0, this.update(H), H !== this.oldData && this.objectPool.recycle(H), this.oldDataInUse = !1, this.storeOldData(), this.throttledEmitComponentChanged()
                            }
                        }, handleMixinUpdate: function () {
                            this.recomputeData(), this.updateSchemaIfNeeded(), this.callUpdateHandler()
                        }, resetProperty: function (H) {
                            !this.isSingleProperty && !(H in this.schema) || (H ? this.attrValue[H] = void 0 : (this.isObjectBased && this.objectPool.recycle(this.attrValue), this.attrValue = void 0), this.recomputeProperty(H, void 0), this.updateSchemaIfNeeded(), this.callUpdateHandler())
                        }, extendSchema: function (H) {
                            var ae;
                            ae = E.extend({}, p[this.name].schema), E.extend(ae, H), this.schema = M(ae), this.el.emit("schemachanged", this.evtDetail)
                        }, getComputedPropertyValue: function (H) {
                            var ae = this.el.mixinEls, ee = this.attrValue && H ? this.attrValue[H] : this.attrValue;
                            if (ee !== void 0) return ee;
                            for (var me = ae.length - 1; me >= 0; me--) {
                                var Re = ae[me].getAttribute(this.attrName);
                                if (!(Re === null || H && !(H in Re))) return H ? Re[H] : Re
                            }
                            var ke = H ? this.schema[H].default : this.schema.default;
                            return ke
                        }, recomputeProperty: function (H, ae) {
                            var ee = H ? this.schema[H] : this.schema;
                            if (ae != null) {
                                this.attrValue === void 0 && this.isObjectBased && (this.attrValue = this.objectPool.use());
                                var me = H ? this.attrValue[H] : this.attrValue;
                                me = ee.isCacheable ? C(ae, ee, me) : ae, typeof me == "string" && (me = ae === "" ? void 0 : ae), H ? this.attrValue[H] = me : this.attrValue = me
                            }
                            this.oldDataInUse && (this.oldData = this.objectPool.use(), E.objectPool.removeUnusedKeys(this.oldData, this.schema), this.storeOldData(), this.oldDataInUse = !1);
                            var Re = H ? this.oldData[H] : this.oldData, ke = H ? this.data[H] : this.data,
                                Ve = C(this.getComputedPropertyValue(H), ee, ke);
                            return ee.type === "array" && !H && (Ve = E.clone(Ve)), ee.equals(Ve, Re) || (this.dataChanged = !0, ee.schemaChange && (this.schemaChangeRequired = !0)), H ? this.data[H] = Ve : this.data = Ve, Ve
                        }, handleUnknownProperty: function (H, ae) {
                            this.attrValue === void 0 && (this.attrValue = this.objectPool.use()), this.attrValue[H] = ae, this.silenceUnknownPropertyWarnings || (this.deferUnknownPropertyWarnings ? U.push(H) : this.silenceUnknownPropertyWarnings || L("Unknown property `" + H + "` for component `" + this.name + "`."))
                        }, storeOldData: function () {
                            if (!this.isObjectBased) {
                                this.oldData = this.data;
                                return
                            }
                            if (this.isSingleProperty) {
                                this.oldData = C(this.data, this.schema, this.oldData);
                                return
                            }
                            var H;
                            for (H in this.schema) this.data[H] !== void 0 && (this.data[H] && typeof this.data[H] == "object" ? this.oldData[H] = C(this.data[H], this.schema[H], this.oldData[H]) : this.oldData[H] = this.data[H])
                        }, recomputeData: function (H) {
                            var ae;
                            if (this.isSingleProperty) {
                                this.recomputeProperty(void 0, H);
                                return
                            }
                            if (H && typeof H == "object") for (ae in this.schema) this.attrValueProxy[ae] = H[ae]; else for (ae in this.schema) this.attrValueProxy[ae] = void 0;
                            typeof H == "string" && I.parse(H, this.attrValueProxy);
                            for (ae in this.attrValue) this.attrValue[ae] !== void 0 && U.indexOf(ae) !== -1 && (ae in this.schema || L("Unknown property `" + ae + "` for component `" + this.name + "`."))
                        }, eventsAttach: function () {
                            var H;
                            this.eventsDetach();
                            for (H in this.events) this.el.addEventListener(H, this.events[H])
                        }, eventsDetach: function () {
                            var H;
                            for (H in this.events) this.el.removeEventListener(H, this.events[H])
                        }, destroy: function () {
                            this.objectPool.recycle(this.attrValue), this.objectPool.recycle(this.data), this.objectPool.recycle(this.oldData), this.attrValue = this.data = this.oldData = this.attrValueProxy = void 0
                        }
                    };

                    function fe(H, ae) {
                        var ee;
                        for (ee in ae) H.events[ee] = ae[ee].bind(H)
                    }

                    if (window.debug) var se = m.exports.registrationOrderWarnings = {};
                    m.exports.registerComponent = function (H, ae) {
                        var ee, me = {}, Re, ke;
                        if (document.currentScript && document.currentScript !== O && w.forEach(function (ot) {
                            ot.hasLoaded || document.currentScript.compareDocumentPosition(ot) !== Node.DOCUMENT_POSITION_FOLLOWING && (L("The component `" + H + "` was registered in a <script> tag after the scene. Component <script> tags in an HTML file should be declared *before* the scene such that the component is available to entities during scene initialization."), window.debug && (se[H] = !0))
                        }), N.test(H) === !0 && L("The component name `" + H + "` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `" + H.toLowerCase() + "`"), H.indexOf("__") !== -1) throw new Error("The component name `" + H + "` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type");
                        if (Object.keys(ae).forEach(function (He) {
                            me[He] = {value: ae[He], writable: !0}
                        }), p[H]) throw new Error("The component `" + H + "` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name.");
                        ee = function (He, ot, gt) {
                            Y.call(this, He, ot, gt)
                        }, ee.prototype = Object.create(Y.prototype, me), ee.prototype.name = H, ee.prototype.isPositionRotationScale = H === "position" || H === "rotation" || H === "scale", ee.prototype.constructor = ee, ee.prototype.system = v && v.systems[H], ee.prototype.play = he(ee.prototype.play), ee.prototype.pause = ue(ee.prototype.pause), Re = E.extend(M(ee.prototype.schema, ee.prototype.name)), ee.prototype.isSingleProperty = ke = b(ee.prototype.schema), ee.prototype.isObjectBased = !ke || ke && (Z(Re.default) || Z(C(void 0, Re))), F[H] = E.objectPool.createPool(), p[H] = {
                            Component: ee,
                            dependencies: ee.prototype.dependencies,
                            before: ee.prototype.before,
                            after: ee.prototype.after,
                            isSingleProperty: ee.prototype.isSingleProperty,
                            isObjectBased: ee.prototype.isObjectBased,
                            multiple: ee.prototype.multiple,
                            sceneOnly: ee.prototype.sceneOnly,
                            name: H,
                            schema: Re,
                            stringify: ee.prototype.stringify
                        };
                        for (var Ve = 0; Ve < w.length; Ve++) w[Ve].emit("componentregistered", {name: H}, !1);
                        return ee
                    };

                    function pe(H) {
                        return H.tick || H.tock
                    }

                    function ue(H) {
                        return function () {
                            var ee = this.el.sceneEl;
                            this.isPlaying && (H.call(this), this.isPlaying = !1, this.eventsDetach(), pe(this) && ee.removeBehavior(this))
                        }
                    }

                    function he(H) {
                        return function () {
                            var ee = this.el.sceneEl, me = this.el.isPlaying && !this.isPlaying;
                            !this.initialized || !me || (H.call(this), this.isPlaying = !0, this.eventsAttach(), pe(this) && ee.addBehavior(this))
                        }
                    }

                    function Z(H) {
                        return H && H.constructor === Object && !(H instanceof window.HTMLElement)
                    }
                },
                "./src/core/geometry.js": (m, x, h) => {
                    var g = h("./src/core/schema.js"), w = g.process, v = m.exports.geometries = {},
                        E = m.exports.geometryNames = [], p = h("./src/lib/three.js"),
                        C = m.exports.Geometry = function () {
                        };
                    C.prototype = {
                        schema: {}, init: function (M) {
                            return this.geometry = new p.BufferGeometry, this.geometry
                        }, update: function (M) {
                        }
                    }, m.exports.registerGeometry = function (M, b) {
                        var B, R = {};
                        if (Object.keys(b).forEach(function (L) {
                            R[L] = {value: b[L], writable: !0}
                        }), v[M]) throw new Error("The geometry `" + M + "` has been already registered");
                        return B = function () {
                            C.call(this)
                        }, B.prototype = Object.create(C.prototype, R), B.prototype.name = M, B.prototype.constructor = B, v[M] = {
                            Geometry: B,
                            schema: w(B.prototype.schema)
                        }, E.push(M), B
                    }
                },
                "./src/core/propertyTypes.js": (m, x, h) => {
                    var g = h("./src/utils/coordinates.js"), w = h("./node_modules/debug/src/browser.js"),
                        v = w("core:propertyTypes:warn"), E = m.exports.propertyTypes = {}, p = /[,> .[\]:]/,
                        C = /url\((.+)\)/;
                    M("audio", "", I), M("array", [], b, B, R), M("asset", "", I), M("boolean", !1, F), M("color", "#FFF"), M("int", 0, V), M("number", 0, U), M("map", "", I), M("model", "", I), M("selector", null, j, fe, N, !1), M("selectorAll", null, Y, se, R, !1), M("src", "", pe), M("string", ""), M("time", 0, V), M("vec2", {
                        x: 0,
                        y: 0
                    }, ue, g.stringify, g.equals), M("vec3", {
                        x: 0,
                        y: 0,
                        z: 0
                    }, ue, g.stringify, g.equals), M("vec4", {x: 0, y: 0, z: 0, w: 1}, ue, g.stringify, g.equals);

                    function M(H, ae, ee, me, Re, ke) {
                        if (H in E) throw new Error("Property type " + H + " is already registered.");
                        E[H] = {
                            default: ae,
                            parse: ee || L,
                            stringify: me || O,
                            equals: Re || N,
                            isCacheable: ke !== !1
                        }
                    }

                    m.exports.registerPropertyType = M;

                    function b(H) {
                        if (Array.isArray(H)) return H;
                        if (!H || typeof H != "string") return [];
                        return H.split(",").map(ae);

                        function ae(ee) {
                            return ee.trim()
                        }
                    }

                    function B(H) {
                        return H.join(", ")
                    }

                    function R(H, ae) {
                        if (!Array.isArray(H) || !Array.isArray(ae)) return H === ae;
                        if (H.length !== ae.length) return !1;
                        for (var ee = 0; ee < H.length; ee++) if (H[ee] !== ae[ee]) return !1;
                        return !0
                    }

                    function I(H) {
                        var ae, ee;
                        if (typeof H != "string") return H;
                        if (ee = H.match(C), ee) return ee[1];
                        if (H.charAt(0) === "#") {
                            if (ae = document.getElementById(H.substring(1)), ae) return ae.tagName === "CANVAS" || ae.tagName === "VIDEO" || ae.tagName === "IMG" ? ae : ae.getAttribute("src");
                            v('"' + H + '" asset not found.');
                            return
                        }
                        return H
                    }

                    function L(H) {
                        return H
                    }

                    function O(H) {
                        return H === null ? "null" : H.toString()
                    }

                    function N(H, ae) {
                        return H === ae
                    }

                    function F(H) {
                        return H !== "false" && H !== !1
                    }

                    function V(H) {
                        return parseInt(H, 10)
                    }

                    function U(H) {
                        return parseFloat(H, 10)
                    }

                    function j(H) {
                        return H ? typeof H != "string" ? H : H[0] === "#" && !p.test(H) ? document.getElementById(H.substring(1)) : document.querySelector(H) : null
                    }

                    function Y(H) {
                        return H ? typeof H != "string" ? H : Array.prototype.slice.call(document.querySelectorAll(H), 0) : null
                    }

                    function fe(H) {
                        return H.getAttribute ? "#" + H.getAttribute("id") : O(H)
                    }

                    function se(H) {
                        return H instanceof Array ? H.map(function (ae) {
                            return "#" + ae.getAttribute("id")
                        }).join(", ") : O(H)
                    }

                    function pe(H) {
                        return v("`src` property type is deprecated. Use `asset` instead."), I(H)
                    }

                    function ue(H, ae, ee) {
                        return g.parse(H, ae, ee)
                    }

                    function he(H, ae) {
                        return H === "audio" && typeof ae != "string" || H === "array" && !Array.isArray(ae) || H === "asset" && typeof ae != "string" || H === "boolean" && typeof ae != "boolean" || H === "color" && typeof ae != "string" || H === "int" && typeof ae != "number" || H === "number" && typeof ae != "number" || H === "map" && typeof ae != "string" || H === "model" && typeof ae != "string" || H === "selector" && typeof ae != "string" && ae !== null || H === "selectorAll" && typeof ae != "string" && ae !== null || H === "src" && typeof ae != "string" || H === "string" && typeof ae != "string" || H === "time" && typeof ae != "number" ? !1 : H === "vec2" ? Z(ae, 2) : H === "vec3" ? Z(ae, 3) : H === "vec4" ? Z(ae, 4) : !0
                    }

                    m.exports.isValidDefaultValue = he;

                    function Z(H, ae) {
                        if (H === null) return !0;
                        if (typeof H != "object" || Object.keys(H).length !== ae) return !1;
                        var ee = H.x, me = H.y, Re = H.z, ke = H.w;
                        return !(typeof ee != "number" || typeof me != "number" || ae > 2 && typeof Re != "number" || ae > 3 && typeof ke != "number")
                    }

                    m.exports.isValidDefaultCoordinate = Z
                },
                "./src/core/readyState.js": m => {
                    m.exports.canInitializeElements = !1;

                    function x() {
                        if (document.readyState === "complete") {
                            h();
                            return
                        }
                        document.addEventListener("readystatechange", function g() {
                            document.readyState === "complete" && (document.removeEventListener("readystatechange", g), h())
                        })
                    }

                    m.exports.waitForDocumentReadyState = x;

                    function h() {
                        m.exports.canInitializeElements || (m.exports.canInitializeElements = !0, setTimeout(function () {
                            document.dispatchEvent(new CustomEvent("aframeready"))
                        }))
                    }

                    m.exports.emitReady = h
                },
                "./src/core/scene/a-scene.js": (m, x, h) => {
                    var g = h("./src/core/scene/metaTags.js").inject, w = h("./src/core/scene/wakelock.js"),
                        v = h("./src/core/scene/loadingScreen.js"), E = h("./src/core/scene/scenes.js"),
                        p = h("./src/core/system.js").systems, C = h("./src/core/component.js").components,
                        M = h("./src/lib/three.js"), b = h("./src/utils/index.js"), B = b.debug("core:a-scene:warn"),
                        R = h("./src/core/a-entity.js").AEntity, I = h("./src/core/a-node.js").ANode,
                        L = h("./src/core/scene/postMessage.js"), O = b.device.isIOS(), N = b.device.isMobile(),
                        F = b.device.isWebXRAvailable;
                    O && h("./src/utils/ios-orientationchange-blank-bug.js");

                    class V extends R {
                        constructor() {
                            var Z;
                            super(), Z = this, Z.clock = new M.Clock, Z.isIOS = O, Z.isMobile = N, Z.hasWebXR = F, Z.isAR = !1, Z.isScene = !0, Z.object3D = new M.Scene, Z.object3D.onAfterRender = function (H, ae, ee) {
                                Z.isPlaying && Z.tock(Z.time, Z.delta, ee)
                            }, Z.resize = Z.resize.bind(Z), Z.render = Z.render.bind(Z), Z.systems = {}, Z.systemNames = [], Z.time = Z.delta = 0, Z.usedOfferSession = !1, Z.componentOrder = [], Z.behaviors = {}, Z.hasLoaded = !1, Z.isPlaying = !1, Z.originalHTML = Z.innerHTML
                        }

                        addFullScreenStyles() {
                            document.documentElement.classList.add("a-fullscreen")
                        }

                        removeFullScreenStyles() {
                            document.documentElement.classList.remove("a-fullscreen")
                        }

                        doConnectedCallback() {
                            var Z = this, H = this.hasAttribute("embedded");
                            this.setAttribute("inspector", ""), this.setAttribute("keyboard-shortcuts", ""), this.setAttribute("screenshot", ""), this.setAttribute("xr-mode-ui", ""), this.setAttribute("device-orientation-permission-ui", ""), super.doConnectedCallback(), ue(this), this.setupRenderer(), v.setup(this, Y), this.resize(), H || this.addFullScreenStyles(), L(this), g(this), w(this), this.onVRPresentChangeBound = this.onVRPresentChange.bind(this), window.addEventListener("vrdisplaypresentchange", this.onVRPresentChangeBound), this.enterVRBound = function () {
                                Z.enterVR()
                            }, this.exitVRBound = function () {
                                Z.exitVR()
                            }, this.exitVRTrueBound = function () {
                                Z.exitVR(!0)
                            }, this.pointerRestrictedBound = function () {
                                Z.pointerRestricted()
                            }, this.pointerUnrestrictedBound = function () {
                                Z.pointerUnrestricted()
                            }, Z.hasWebXR || (window.addEventListener("vrdisplaydeactivate", this.exitVRBound), window.addEventListener("vrdisplaydisconnect", this.exitVRTrueBound), window.addEventListener("vrdisplaypointerrestricted", this.pointerRestrictedBound), window.addEventListener("vrdisplaypointerunrestricted", this.pointerUnrestrictedBound)), window.addEventListener("sessionend", this.resize), this.addEventListener("cameraready", function () {
                                Z.attachedCallbackPostCamera()
                            }), this.initSystems(), this.componentOrder = U(C, this.componentOrder), this.addEventListener("componentregistered", function () {
                                Z.componentOrder = U(C, Z.componentOrder)
                            }), this.hasWebXR && navigator.xr && navigator.xr.addEventListener && navigator.xr.addEventListener("sessiongranted", function () {
                                Z.enterVR()
                            })
                        }

                        attachedCallbackPostCamera() {
                            var Z, H = this;
                            window.addEventListener("load", Z), window.addEventListener("resize", function () {
                                H.isIOS ? setTimeout(H.resize, 100) : H.resize()
                            }), this.play(), E.push(this)
                        }

                        initSystems() {
                            var Z;
                            this.initSystem("camera");
                            for (Z in p) Z !== "camera" && this.initSystem(Z)
                        }

                        initSystem(Z) {
                            this.systems[Z] || (this.systems[Z] = new p[Z](this), this.systemNames.push(Z))
                        }

                        disconnectedCallback() {
                            var Z = E.indexOf(this);
                            super.disconnectedCallback(), E.splice(Z, 1), window.removeEventListener("vrdisplaypresentchange", this.onVRPresentChangeBound), window.removeEventListener("vrdisplayactivate", this.enterVRBound), window.removeEventListener("vrdisplaydeactivate", this.exitVRBound), window.removeEventListener("vrdisplayconnect", this.enterVRBound), window.removeEventListener("vrdisplaydisconnect", this.exitVRTrueBound), window.removeEventListener("vrdisplaypointerrestricted", this.pointerRestrictedBound), window.removeEventListener("vrdisplaypointerunrestricted", this.pointerUnrestrictedBound), window.removeEventListener("sessionend", this.resize), this.renderer.dispose()
                        }

                        addBehavior(Z) {
                            var H, ae = this.behaviors[Z.name], ee;
                            ae || (ae = this.behaviors[Z.name] = {
                                tick: {inUse: !1, array: [], markedForRemoval: []},
                                tock: {inUse: !1, array: [], markedForRemoval: []}
                            });
                            for (ee in ae) if (Z[ee]) {
                                if (H = ae[ee], H.inUse) {
                                    var me = H.markedForRemoval.indexOf(Z);
                                    me !== -1 && H.markedForRemoval.splice(me, 1)
                                }
                                H.array.indexOf(Z) === -1 && H.array.push(Z)
                            }
                        }

                        getPointerLockElement() {
                            return document.pointerLockElement
                        }

                        checkHeadsetConnected() {
                            return b.device.checkHeadsetConnected()
                        }

                        enterAR() {
                            var Z;
                            if (!this.hasWebXR) throw Z = "Failed to enter AR mode, WebXR not supported.", new Error(Z);
                            if (!b.device.checkARSupport()) throw Z = "Failed to enter AR, WebXR immersive-ar mode not supported in your browser or device.", new Error(Z);
                            return this.enterVR(!0)
                        }

                        enterVR(Z, H) {
                            var ae = this, ee, me = ae.renderer.xr, Re;
                            if (H && (!navigator.xr || !navigator.xr.offerSession)) return Promise.resolve("OfferSession is not supported.");
                            if (ae.usedOfferSession && H) return Promise.resolve("OfferSession was already called.");
                            if (this.is("vr-mode")) return Promise.resolve("Already in VR.");
                            if (this.checkHeadsetConnected() || this.isMobile) {
                                var ke = ae.getAttribute("renderer");
                                if (me.enabled = !0, this.hasWebXR) {
                                    this.xrSession && this.xrSession.removeEventListener("end", this.exitVRBound);
                                    var Ve = this.sceneEl.systems.webxr.sessionReferenceSpaceType;
                                    me.setReferenceSpaceType(Ve);
                                    var He = Z ? "immersive-ar" : "immersive-vr";
                                    return Re = this.sceneEl.systems.webxr.sessionConfiguration, new Promise(function (Rt, an) {
                                        var En = H ? navigator.xr.offerSession.bind(navigator.xr) : navigator.xr.requestSession.bind(navigator.xr);
                                        ae.usedOfferSession |= H, En(He, Re).then(function (oi) {
                                            H && (ae.usedOfferSession = !1), me.layersEnabled = Re.requiredFeatures.indexOf("layers") !== -1, me.setSession(oi).then(function () {
                                                me.setFoveation(ke.foveationLevel), ae.xrSession = oi, ae.systems.renderer.setWebXRFrameRate(oi), oi.addEventListener("end", ae.exitVRBound), gt(Rt)
                                            })
                                        }, function (oi) {
                                            var pi = He === "immersive-ar", hi = pi ? "AR" : "VR";
                                            an(new Error("Failed to enter " + hi + " mode (`requestSession`)", {cause: oi}))
                                        })
                                    })
                                } else {
                                    if (ee = b.device.getVRDisplay(), me.setDevice(ee), ee.isPresenting && !window.hasNativeWebVRImplementation) return gt(), Promise.resolve();
                                    var ot = {highRefreshRate: ke.highRefreshRate};
                                    return ee.requestPresent([{source: this.canvas, attributes: ot}]).then(gt, Bt)
                                }
                            }
                            return gt(), Promise.resolve();

                            function gt(Rt) {
                                var an;
                                window.hasNativeWebVRImplementation && !window.hasNativeWebXRImplementation && (an = new CustomEvent("vrdisplaypresentchange", {detail: {display: b.device.getVRDisplay()}}), window.dispatchEvent(an)), Z ? ae.addState("ar-mode") : ae.addState("vr-mode"), ae.emit("enter-vr", {target: ae}), !ae.hasWebXR && ae.isMobile && screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape"), ae.addFullScreenStyles(), !ae.isMobile && !ae.checkHeadsetConnected() && se(ae.canvas), ae.resize(), Rt && Rt()
                            }

                            function Bt(Rt) {
                                throw ae.removeState("vr-mode"), Rt && Rt.message ? new Error("Failed to enter VR mode (`requestPresent`): " + Rt.message) : new Error("Failed to enter VR mode (`requestPresent`).")
                            }
                        }

                        exitVR() {
                            var Z = this, H, ae = this.renderer.xr;
                            if (!this.is("vr-mode") && !this.is("ar-mode")) return Promise.resolve("Not in immersive mode.");
                            if (this.checkHeadsetConnected() || this.isMobile) {
                                if (ae.enabled = !1, H = b.device.getVRDisplay(), this.hasWebXR) this.xrSession.removeEventListener("end", this.exitVRBound), this.xrSession.end().then(function () {
                                }, function () {
                                }), this.xrSession = void 0; else if (H.isPresenting) return H.exitPresent().then(ee, me)
                            } else pe();
                            return ee(), Promise.resolve();

                            function ee() {
                                Z.removeState("vr-mode"), Z.removeState("ar-mode"), Z.isMobile && screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), Z.hasAttribute("embedded") && Z.removeFullScreenStyles(), Z.resize(), Z.isIOS && b.forceCanvasResizeSafariMobile(Z.canvas), Z.renderer.setPixelRatio(window.devicePixelRatio), Z.emit("exit-vr", {target: Z})
                            }

                            function me(Re) {
                                throw Re && Re.message ? new Error("Failed to exit VR mode (`exitPresent`): " + Re.message) : new Error("Failed to exit VR mode (`exitPresent`).")
                            }
                        }

                        pointerRestricted() {
                            if (this.canvas) {
                                var Z = this.getPointerLockElement();
                                Z && Z !== this.canvas && document.exitPointerLock && document.exitPointerLock(), this.canvas.requestPointerLock && this.canvas.requestPointerLock()
                            }
                        }

                        pointerUnrestricted() {
                            var Z = this.getPointerLockElement();
                            Z && Z === this.canvas && document.exitPointerLock && document.exitPointerLock()
                        }

                        onVRPresentChange(Z) {
                            var H = Z.display || Z.detail.display;
                            if (H && H.isPresenting) {
                                this.enterVR();
                                return
                            }
                            this.exitVR()
                        }

                        getAttribute(Z) {
                            var H = this.systems[Z];
                            return H ? H.data : R.prototype.getAttribute.call(this, Z)
                        }

                        getDOMAttribute(Z) {
                            var H = this.systems[Z];
                            return H ? H.data : R.prototype.getDOMAttribute.call(this, Z)
                        }

                        setAttribute(Z, H, ae) {
                            if (p[Z]) {
                                I.prototype.setAttribute.call(this, Z, H);
                                var ee = this.systems[Z];
                                ee && ee.updateProperties(H);
                                return
                            }
                            R.prototype.setAttribute.call(this, Z, H, ae)
                        }

                        removeBehavior(Z) {
                            var H, ae, ee = this.behaviors[Z.name], me;
                            for (ae in ee) Z[ae] && (H = ee[ae], me = H.array.indexOf(Z), me !== -1 && (H.inUse ? H.markedForRemoval.indexOf(Z) === -1 && H.markedForRemoval.push(Z) : (H.array[me] = H.array[H.array.length - 1], H.array.pop())))
                        }

                        resize() {
                            var Z = this.camera, H = this.canvas, ae, ee, me, Re = this.renderer.xr.isPresenting;
                            ee = this.renderer.xr.enabled && Re, !(!Z || !H || this.is("vr-mode") && (this.isMobile || ee)) && (ae = this.getAttribute("embedded") && !this.is("vr-mode"), me = Y(H, ae, this.maxCanvasSize, this.is("vr-mode")), Z.aspect = me.width / me.height, Z.updateProjectionMatrix(), this.renderer.setSize(me.width, me.height, !1), this.emit("rendererresize", null, !1))
                        }

                        setupRenderer() {
                            var Z = this, H, ae, ee, me;
                            me = {
                                alpha: !0,
                                antialias: !N,
                                canvas: this.canvas,
                                logarithmicDepthBuffer: !1,
                                powerPreference: "high-performance"
                            }, this.maxCanvasSize = {
                                height: -1,
                                width: -1
                            }, this.hasAttribute("renderer") && (ee = this.getAttribute("renderer"), ae = b.styleParser.parse(ee), ae.precision && (me.precision = ae.precision + "p"), ae.antialias && ae.antialias !== "auto" && (me.antialias = ae.antialias === "true"), ae.logarithmicDepthBuffer && ae.logarithmicDepthBuffer !== "auto" && (me.logarithmicDepthBuffer = ae.logarithmicDepthBuffer === "true"), ae.alpha && (me.alpha = ae.alpha === "true"), ae.stencil && (me.stencil = ae.stencil === "true"), ae.multiviewStereo && (me.multiviewStereo = ae.multiviewStereo === "true"), this.maxCanvasSize = {
                                width: ae.maxCanvasWidth ? parseInt(ae.maxCanvasWidth) : this.maxCanvasSize.width,
                                height: ae.maxCanvasHeight ? parseInt(ae.maxCanvasHeight) : this.maxCanvasSize.height
                            }), H = this.renderer = new M.WebGLRenderer(me), H.setPixelRatio(window.devicePixelRatio), this.camera && H.xr.setPoseTarget(this.camera.el.object3D), this.addEventListener("camera-set-active", function () {
                                H.xr.setPoseTarget(Z.camera.el.object3D)
                            })
                        }

                        play() {
                            var Z = this, H = this;
                            if (this.renderStarted) {
                                R.prototype.play.call(this);
                                return
                            }
                            this.addEventListener("loaded", function () {
                                var ae = this.renderer, ee, me = this.renderer.xr;
                                R.prototype.play.call(this), !H.renderStarted && (H.resize(), H.renderer && (window.performance && window.performance.mark("render-started"), v.remove(), ee = b.device.getVRDisplay(), ee && ee.isPresenting && (me.setDevice(ee), me.enabled = !0, H.enterVR()), ae.setAnimationLoop(this.render), H.renderStarted = !0, H.emit("renderstart")))
                            }), setTimeout(function () {
                                R.prototype.load.call(Z)
                            })
                        }

                        updateComponent(Z) {
                            Z in p || R.prototype.updateComponent.apply(this, arguments)
                        }

                        tick(Z, H) {
                            var ae, ee = this.systems;
                            for (this.callComponentBehaviors("tick", Z, H), ae = 0; ae < this.systemNames.length; ae++) ee[this.systemNames[ae]].tick && ee[this.systemNames[ae]].tick(Z, H)
                        }

                        tock(Z, H, ae) {
                            var ee, me = this.systems;
                            for (this.callComponentBehaviors("tock", Z, H), ee = 0; ee < this.systemNames.length; ee++) me[this.systemNames[ee]].tock && me[this.systemNames[ee]].tock(Z, H, ae)
                        }

                        render(Z, H) {
                            var ae = this.renderer;
                            this.frame = H, this.delta = this.clock.getDelta() * 1e3, this.time = this.clock.elapsedTime * 1e3, this.isPlaying && this.tick(this.time, this.delta);
                            var ee = null;
                            this.is("ar-mode") && (ee = this.object3D.background, this.object3D.background = null), ae.render(this.object3D, this.camera), ee && (this.object3D.background = ee)
                        }

                        callComponentBehaviors(Z, H, ae) {
                            for (var ee, me = 0; me < this.componentOrder.length; me++) {
                                var Re = this.behaviors[this.componentOrder[me]];
                                if (Re) {
                                    var ke = Re[Z];
                                    for (ke.inUse = !0, ee = 0; ee < ke.array.length; ee++) ke.array[ee].isPlaying && ke.array[ee][Z](H, ae);
                                    for (ke.inUse = !1, ee = 0; ee < ke.markedForRemoval.length; ee++) this.removeBehavior(ke.markedForRemoval[ee]);
                                    ke.markedForRemoval.length = 0
                                }
                            }
                        }
                    }

                    function U(he, Z) {
                        var H = {}, ae, ee, me = Z || [];
                        me.length = 0;
                        for (ee in he) {
                            var Re = he[ee];
                            if (Re !== void 0) {
                                var ke = Re.before ? Re.before.slice(0) : [], Ve = Re.after ? Re.after.slice(0) : [];
                                H[ee] = {before: ke, after: Ve, visited: !1, done: !1}
                            }
                        }
                        for (ee in H) for (ae = 0; ae < H[ee].before.length; ae++) {
                            var He = H[ee].before[ae];
                            if (!(He in H)) {
                                B("Invalid ordering constraint, no component named `" + He + "` referenced by `" + ee + "`");
                                continue
                            }
                            H[He].after.push(ee)
                        }

                        function ot(gt) {
                            if (!(!(gt in H) || H[gt].done)) {
                                if (H[gt].visited) {
                                    B("Cycle detected, ignoring one or more before/after constraints. The resulting order might be incorrect");
                                    return
                                }
                                H[gt].visited = !0;
                                for (var Bt = 0; Bt < H[gt].after.length; Bt++) {
                                    var Rt = H[gt].after[Bt];
                                    Rt in H || B("Invalid before/after constraint, no component named `" + Rt + "` referenced in `" + gt + "`"), ot(Rt)
                                }
                                H[gt].done = !0, me.push(gt)
                            }
                        }

                        for (ee in H) H[ee].done || ot(ee);
                        return me
                    }

                    m.exports.determineComponentBehaviorOrder = U;

                    function j(he, Z) {
                        var H, ae = window.devicePixelRatio;
                        return !Z || Z.width === -1 && Z.height === -1 || he.width * ae < Z.width && he.height * ae < Z.height || (H = he.width / he.height, he.width * ae > Z.width && Z.width !== -1 && (he.width = Math.round(Z.width / ae), he.height = Math.round(Z.width / H / ae)), he.height * ae > Z.height && Z.height !== -1 && (he.height = Math.round(Z.height / ae), he.width = Math.round(Z.height * H / ae))), he
                    }

                    customElements.define("a-scene", V);

                    function Y(he, Z, H, ae) {
                        if (!he.parentElement) return {height: 0, width: 0};
                        if (Z) {
                            var ee;
                            return ee = {
                                height: he.parentElement.offsetHeight,
                                width: he.parentElement.offsetWidth
                            }, j(ee, H)
                        }
                        return fe(H, ae)
                    }

                    function fe(he, Z) {
                        var H;
                        return H = {
                            height: document.body.offsetHeight,
                            width: document.body.offsetWidth
                        }, Z ? H : j(H, he)
                    }

                    function se(he) {
                        var Z = he.requestFullscreen || he.webkitRequestFullscreen || he.mozRequestFullScreen || he.msRequestFullscreen;
                        Z.apply(he, [{navigationUI: "hide"}])
                    }

                    function pe() {
                        var he = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement;
                        he && (document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen())
                    }

                    function ue(he) {
                        var Z;
                        Z = document.createElement("canvas"), Z.classList.add("a-canvas"), Z.dataset.aframeCanvas = !0, he.appendChild(Z), document.addEventListener("fullscreenchange", H), document.addEventListener("mozfullscreenchange", H), document.addEventListener("webkitfullscreenchange", H), document.addEventListener("MSFullscreenChange", H), Z.addEventListener("touchmove", function (ae) {
                            ae.preventDefault()
                        }, {passive: !1}), he.canvas = Z, he.emit("render-target-loaded", {target: Z}), setTimeout(he.resize.bind(he), 0);

                        function H() {
                            var ae = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
                            ae || he.exitVR(), document.activeElement.blur(), document.body.focus()
                        }
                    }

                    m.exports.setupCanvas = ue, m.exports.AScene = V
                },
                "./src/core/scene/loadingScreen.js": (m, x, h) => {
                    var g = h("./src/utils/index.js"), w = g.styleParser, v, E, p, C = "loading-screen",
                        M = "a-loader-title";
                    m.exports.setup = function (I, L) {
                        v = I, p = L;
                        var O = v.hasAttribute(C) ? w.parse(v.getAttribute(C)) : void 0,
                            N = O && O.dotsColor || "white", F = O && O.backgroundColor || "#24CAFF",
                            V = O === void 0 || O.enabled === "true" || O.enabled === void 0, U, j, Y, fe, se, pe, ue,
                            he, Z, H;
                        V && (U = new THREE.Scene, j = new THREE.SphereGeometry(.2, 36, 18, 0, 2 * Math.PI, 0, Math.PI), Y = new THREE.MeshBasicMaterial({color: N}), fe = new THREE.Mesh(j, Y), se = fe.clone(), pe = fe.clone(), ue = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 5e-4, 1e4), he = new THREE.Clock, Z = 0, H = function () {
                            v.renderer.render(U, ue), Z = he.getElapsedTime() % 4, fe.visible = Z >= 1, se.visible = Z >= 2, pe.visible = Z >= 3
                        }, U.background = new THREE.Color(F), U.add(ue), fe.position.set(-1, 0, -15), se.position.set(0, 0, -15), pe.position.set(1, 0, -15), ue.add(fe), ue.add(se), ue.add(pe), B(), setTimeout(function () {
                            v.hasLoaded || (b(ue), E.style.display = "block", window.addEventListener("resize", function () {
                                b(ue)
                            }), v.renderer.setAnimationLoop(H))
                        }, 200))
                    }, m.exports.remove = function () {
                        window.removeEventListener("resize", b), E && (E.style.display = "none")
                    };

                    function b(R) {
                        var I = v.hasAttribute("embedded"), L = p(v.canvas, I, v.maxCanvasSize, v.is("vr-mode"));
                        R.aspect = L.width / L.height, R.updateProjectionMatrix(), v.renderer.setSize(L.width, L.height, !1)
                    }

                    function B() {
                        E = document.createElement("div"), E.className = M, E.innerHTML = document.title, E.style.display = "none", v.appendChild(E)
                    }
                },
                "./src/core/scene/metaTags.js": (m, x, h) => {
                    var g = h("./src/constants/index.js"), w = h("./src/utils/index.js").extend,
                        v = m.exports.MOBILE_HEAD_TAGS = [p({
                            name: "viewport",
                            content: "width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui,viewport-fit=cover"
                        }), p({name: "mobile-web-app-capable", content: "yes"}), p({
                            name: "theme-color",
                            content: "black"
                        })], E = [p({
                            name: "apple-mobile-web-app-capable",
                            content: "yes"
                        }), p({
                            name: "apple-mobile-web-app-status-bar-style",
                            content: "black"
                        }), C({rel: "apple-touch-icon", href: "https://aframe.io/images/aframe-logo-152.png"})];

                    function p(b) {
                        return {
                            tagName: "meta", attributes: b, exists: function () {
                                return document.querySelector('meta[name="' + b.name + '"]')
                            }
                        }
                    }

                    function C(b) {
                        return {
                            tagName: "link", attributes: b, exists: function () {
                                return document.querySelector('link[rel="' + b.rel + '"]')
                            }
                        }
                    }

                    m.exports.inject = function (B) {
                        var R = document.head, I = R.querySelector("script"), L, O = [];
                        return v.forEach(N), B.isIOS && E.forEach(N), O;

                        function N(F) {
                            !F || F.exists() || (L = M(F), L && (I ? I.parentNode.insertBefore(L, I) : R.appendChild(L), O.push(L)))
                        }
                    };

                    function M(b) {
                        if (!(!b || !b.tagName)) {
                            var B = document.createElement(b.tagName);
                            return B.setAttribute(g.AFRAME_INJECTED, ""), w(B, b.attributes)
                        }
                    }
                },
                "./src/core/scene/postMessage.js": (m, x, h) => {
                    var g = h("./src/utils/index.js").isIframed;
                    m.exports = function (E) {
                        g() && window.addEventListener("message", w.bind(E))
                    };

                    function w(v) {
                        var E = this;
                        if (v.data) switch (v.data.type) {
                            case"vr":
                                switch (v.data.data) {
                                    case"enter":
                                        E.enterVR();
                                        break;
                                    case"exit":
                                        E.exitVR();
                                        break
                                }
                        }
                    }
                },
                "./src/core/scene/scenes.js": m => {
                    m.exports = []
                },
                "./src/core/scene/wakelock.js": (m, x, h) => {
                    var g = h("./vendor/wakelock/wakelock.js");
                    m.exports = function (v) {
                        if (v.isMobile) {
                            var E = v.wakelock = new g;
                            v.addEventListener("enter-vr", function () {
                                E.request()
                            }), v.addEventListener("exit-vr", function () {
                                E.release()
                            })
                        }
                    }
                },
                "./src/core/schema.js": (m, x, h) => {
                    var g = h("./src/utils/index.js"), w = h("./src/core/propertyTypes.js"), v = g.debug,
                        E = w.isValidDefaultValue, p = w.propertyTypes, C = v("core:schema:warn");

                    function M(I) {
                        return "type" in I ? typeof I.type == "string" : "default" in I
                    }

                    m.exports.isSingleProperty = M, m.exports.process = function (I, L) {
                        var O;
                        if (M(I)) return b(I, L);
                        for (O in I) I[O] = b(I[O], L);
                        return I
                    };

                    function b(I, L) {
                        var O = I.default, N, F, V = I.type;
                        return I.type ? I.type === "bool" ? V = "boolean" : I.type === "float" && (V = "number") : O !== void 0 && (typeof O == "boolean" || typeof O == "number") ? V = typeof O : Array.isArray(O) ? V = "array" : V = "string", F = p[V], F || C("Unknown property type for component `" + L + "`: " + V), N = !!I.parse, I.parse = I.parse || F.parse, I.stringify = I.stringify || F.stringify, I.equals = I.equals || F.equals, I.isCacheable = I.isCacheable === !0 || F.isCacheable, I.type = V, "default" in I ? !N && !E(V, O) && C("Default value `" + O + "` does not match type `" + V + "` in component `" + L + "`") : I.default = F.default, I
                    }

                    m.exports.processPropertyDefinition = b, m.exports.parseProperties = function () {
                        var I = [];
                        return function (L, O, N, F, V) {
                            var U, j, Y, fe;
                            I.length = 0;
                            for (j in N ? L : O) N && L[j] === void 0 || I.push(j);
                            if (L === null || typeof L != "object") return L;
                            for (j in L) L[j] !== void 0 && !O[j] && !V && C("Unknown property `" + j + "` for component/system `" + F + "`.");
                            for (U = 0; U < I.length; U++) {
                                if (j = I[U], Y = O[j], fe = L[j], !O[j]) return;
                                L[j] = B(fe, Y)
                            }
                            return L
                        }
                    }();

                    function B(I, L, O) {
                        return (I == null || I === "") && (I = L.default, Array.isArray(I) && (I = I.slice())), L.parse(I, L.default, O)
                    }

                    m.exports.parseProperty = B, m.exports.stringifyProperties = function (I, L) {
                        var O, N, F, V = {}, U;
                        for (O in I) N = L[O], F = I[O], U = F, typeof U == "object" && (U = R(F, N), N || C("Unknown component property: " + O)), V[O] = U;
                        return V
                    };

                    function R(I, L) {
                        return typeof I != "object" ? I : !L || I === null ? JSON.stringify(I) : L.stringify(I)
                    }

                    m.exports.stringifyProperty = R
                },
                "./src/core/shader.js": (m, x, h) => {
                    var g = h("./src/core/schema.js"), w = g.process, v = m.exports.shaders = {},
                        E = m.exports.shaderNames = [], p = h("./src/lib/three.js"), C = h("./src/utils/index.js"),
                        M = {
                            array: "v3",
                            color: "v3",
                            int: "i",
                            number: "f",
                            map: "t",
                            time: "f",
                            vec2: "v2",
                            vec3: "v3",
                            vec4: "v4"
                        }, b = m.exports.Shader = function () {
                        };
                    b.prototype = {
                        schema: {},
                        vertexShader: "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",
                        fragmentShader: "void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",
                        init: function (B) {
                            return this.uniforms = this.initUniforms(), this.material = new (this.raw ? p.RawShaderMaterial : p.ShaderMaterial)({
                                uniforms: this.uniforms,
                                glslVersion: this.raw || this.glsl3 ? p.GLSL3 : null,
                                vertexShader: this.vertexShader,
                                fragmentShader: this.fragmentShader
                            }), this.material
                        },
                        initUniforms: function () {
                            var B, R = this.schema, I = {}, L;
                            for (B in R) R[B].is === "uniform" && (L = M[R[B].type], I[B] = {type: L, value: void 0});
                            return I
                        },
                        update: function (B) {
                            var R, I, L = this.schema, O = this.uniforms;
                            for (R in B) if (!(!L[R] || L[R].is !== "uniform")) {
                                if (L[R].type === "map") {
                                    if (!O[R] || O[R].value === B[R]) continue;
                                    I = "_texture_" + R, this.setMapOnTextureLoad(O, R, I), C.material.updateMapMaterialFromData(I, R, this, B);
                                    continue
                                }
                                O[R].value = this.parseValue(L[R].type, B[R]), O[R].needsUpdate = !0
                            }
                        },
                        parseValue: function (B, R) {
                            var I;
                            switch (B) {
                                case"vec2":
                                    return new p.Vector2(R.x, R.y);
                                case"vec3":
                                    return new p.Vector3(R.x, R.y, R.z);
                                case"vec4":
                                    return new p.Vector4(R.x, R.y, R.z, R.w);
                                case"color":
                                    return I = new p.Color(R), new p.Vector3(I.r, I.g, I.b);
                                default:
                                    return R
                            }
                        },
                        setMapOnTextureLoad: function (B, R, I) {
                            var L = this;
                            this.el.addEventListener("materialtextureloaded", function () {
                                B[R].value = L.material[I], B[R].needsUpdate = !0
                            })
                        }
                    }, m.exports.registerShader = function (B, R) {
                        var I, L = {};
                        if (Object.keys(R).forEach(function (O) {
                            L[O] = {value: R[O], writable: !0}
                        }), v[B]) throw new Error("The shader " + B + " has already been registered");
                        return I = function () {
                            b.call(this)
                        }, I.prototype = Object.create(b.prototype, L), I.prototype.name = B, I.prototype.constructor = I, v[B] = {
                            Shader: I,
                            schema: w(I.prototype.schema)
                        }, E.push(B), I
                    }
                },
                "./src/core/system.js": (m, x, h) => {
                    var g = h("./src/core/component.js"), w = h("./src/core/schema.js"), v = h("./src/utils/index.js"),
                        E = h("./src/core/readyState.js"), p = w.parseProperties, C = w.parseProperty, M = w.process,
                        b = w.isSingleProperty, B = v.styleParser, R = m.exports.systems = {},
                        I = m.exports.System = function (L) {
                            var O = g && g.components[this.name];
                            this.el = L, this.sceneEl = L, O && (O.Component.prototype.system = this), this.buildData(), this.init(), this.update({})
                        };
                    I.prototype = {
                        schema: {}, init: function () {
                        }, update: function (L) {
                        }, updateProperties: function (L) {
                            var O = this.data;
                            Object.keys(w).length && (this.buildData(L), this.update(O))
                        }, buildData: function (L) {
                            var O = this.schema;
                            Object.keys(O).length && (L = L || window.HTMLElement.prototype.getAttribute.call(this.sceneEl, this.name), b(O) ? this.data = C(L, O) : this.data = p(B.parse(L) || {}, O, !1, this.name))
                        }, tick: void 0, tock: void 0, play: function () {
                        }, pause: function () {
                        }
                    }, m.exports.registerSystem = function (L, O) {
                        var N, F, V = {}, U = v.findAllScenes(document);
                        if (Object.keys(O).forEach(function (j) {
                            V[j] = {value: O[j], writable: !0}
                        }), R[L]) throw new Error("The system `" + L + "` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");
                        if (F = function (j) {
                            I.call(this, j)
                        }, F.prototype = Object.create(I.prototype, V), F.prototype.name = L, F.prototype.constructor = F, F.prototype.schema = v.extend(M(F.prototype.schema)), R[L] = F, E.canInitializeElements) for (N = 0; N < U.length; N++) U[N].initSystem(L)
                    }
                },
                "./src/extras/components/index.js": (m, x, h) => {
                    h("./src/extras/components/pivot.js")
                },
                "./src/extras/components/pivot.js": (m, x, h) => {
                    var g = h("./src/core/component.js").registerComponent, w = h("./src/lib/three.js"),
                        v = new w.Vector3, E = new w.Vector3;
                    g("pivot", {
                        dependencies: ["position"], schema: {type: "vec3"}, init: function () {
                            var p = this.data, C = this.el, M = C.object3D.parent, b = C.object3D, B = new w.Group;
                            v.copy(b.position), E.copy(b.rotation), M.remove(b), B.add(b), M.add(B), C.object3D = B, b.position.set(-1 * p.x, -1 * p.y, -1 * p.z), B.position.set(p.x + v.x, p.y + v.y, p.z + v.z), B.rotation.copy(b.rotation), b.rotation.set(0, 0, 0)
                        }
                    })
                },
                "./src/extras/primitives/getMeshMixin.js": (m, x, h) => {
                    var g = h("./src/core/component.js").components, w = h("./src/core/shader.js").shaders,
                        v = h("./src/utils/index.js"), E = {};
                    Object.keys(g.material.schema).forEach(p), Object.keys(w.standard.schema).forEach(p);

                    function p(C) {
                        var M = C.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                        C === "fog" && (M = "material-fog"), C === "visible" && (M = "material-visible"), E[M] = "material." + C
                    }

                    m.exports = function () {
                        return {defaultComponents: {material: {}}, mappings: v.extend({}, E)}
                    }
                },
                "./src/extras/primitives/index.js": (m, x, h) => {
                    h("./src/extras/primitives/primitives/a-camera.js"), h("./src/extras/primitives/primitives/a-cursor.js"), h("./src/extras/primitives/primitives/a-curvedimage.js"), h("./src/extras/primitives/primitives/a-gltf-model.js"), h("./src/extras/primitives/primitives/a-image.js"), h("./src/extras/primitives/primitives/a-light.js"), h("./src/extras/primitives/primitives/a-link.js"), h("./src/extras/primitives/primitives/a-obj-model.js"), h("./src/extras/primitives/primitives/a-sky.js"), h("./src/extras/primitives/primitives/a-sound.js"), h("./src/extras/primitives/primitives/a-text.js"), h("./src/extras/primitives/primitives/a-video.js"), h("./src/extras/primitives/primitives/a-videosphere.js"), h("./src/extras/primitives/primitives/meshPrimitives.js")
                },
                "./src/extras/primitives/primitives.js": (m, x, h) => {
                    var g = h("./src/core/a-node.js").knownTags, w = h("./src/core/a-entity.js").AEntity,
                        v = h("./src/core/component.js").components, E = h("./src/utils/index.js"), p = E.debug,
                        C = E.entity.setComponentProperty, M = p("extras:primitives:debug"),
                        b = p("extras:primitives:warn"), B = p("extras:primitives:error"),
                        R = m.exports.primitives = {};
                    m.exports.registerPrimitive = function (F, V) {
                        if (F = F.toLowerCase(), g[F]) {
                            B("Trying to register primitive " + F + " that has been already previously registered");
                            return
                        }
                        g[F] = !0, M("Registering <%s>", F), V.defaultAttributes && b("The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead.");
                        var U = V.mappings || {}, j = class extends w {
                            constructor() {
                                super(), this.defaultComponentsFromPrimitive = V.defaultComponents || V.defaultAttributes || {}, this.deprecated = V.deprecated || null, this.deprecatedMappings = V.deprecatedMappings || {}, this.mappings = U, V.deprecated && console.warn(V.deprecated), this.resolveMappingCollisions()
                            }

                            resolveMappingCollisions() {
                                var Y = this.mappings, fe = this;
                                Object.keys(Y).forEach(function (pe) {
                                    var ue;
                                    pe !== pe.toLowerCase() && b("Mapping keys should be specified in lower case. The mapping key " + pe + " may not be recognized"), v[pe] && (ue = Y[pe].replace(".", "-"), Y[ue] = Y[pe], delete Y[pe], console.warn("The primitive " + fe.tagName.toLowerCase() + " has a mapping collision. The attribute " + pe + " has the same name as a registered component and has been renamed to " + ue))
                                })
                            }

                            getExtraComponents() {
                                var Y, fe, se, pe, ue, he = this;
                                for (fe = E.clone(this.defaultComponentsFromPrimitive), ue = this.getAttribute("mixin"), ue && (ue = E.split(ue.trim(), /\s+/), ue.forEach(function (Re) {
                                    var ke = document.getElementById(Re);
                                    if (ke) {
                                        var Ve = ke.rawAttributeCache, He = ke.componentCache;
                                        for (var ot in Ve) {
                                            if (pe = he.mappings[ot], pe) {
                                                I(pe, Ve[ot], fe);
                                                return
                                            }
                                            ot in He && (fe[ot] = Z(fe[ot], He[ot]))
                                        }
                                    }
                                })), se = 0; se < this.attributes.length; se++) Y = this.attributes[se], pe = this.mappings[Y.name], pe && I(pe, Y.value, fe);
                                return fe;

                                function Z(me, Re) {
                                    return H(me) ? ae(Re) : H(Re) ? ae(me) : ee(me) && ee(Re) ? E.extendDeep(me, Re) : ae(Re)
                                }

                                function H(me) {
                                    return typeof me > "u"
                                }

                                function ae(me) {
                                    return ee(me) ? E.extendDeep({}, me) : me
                                }

                                function ee(me) {
                                    return me !== null && me.constructor === Object
                                }
                            }

                            attributeChangedCallback(Y, fe, se) {
                                var pe = this.mappings[Y];
                                if (Y in this.deprecatedMappings && console.warn(this.deprecatedMappings[Y]), !Y || !pe) {
                                    super.attributeChangedCallback(Y, fe, se);
                                    return
                                }
                                C(this, pe, se)
                            }
                        };
                        return customElements.define(F, j), j.mappings = U, R[F] = j, j
                    };

                    function I(N, F, V) {
                        var U = E.entity.getComponentPropertyPath(N);
                        U.constructor === Array ? (V[U[0]] = V[U[0]] || {}, V[U[0]][U[1]] = F.trim()) : V[U] = F.trim()
                    }

                    function L(N, F) {
                        var V = v[N].schema;
                        Object.keys(V).map(function (U) {
                            var j = U.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                            F[j] !== void 0 && (j = N + "-" + U), F[j] = N + "." + U
                        })
                    }

                    function O(N, F, V) {
                        V = V || {}, Object.keys(F).map(function (j) {
                            L(j, V)
                        }), m.exports.registerPrimitive(N, E.extendDeep({}, null, {defaultComponents: F, mappings: V}))
                    }

                    m.exports.definePrimitive = O
                },
                "./src/extras/primitives/primitives/a-camera.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/primitives.js").registerPrimitive;
                    g("a-camera", {
                        defaultComponents: {
                            camera: {},
                            "look-controls": {},
                            "wasd-controls": {},
                            position: {x: 0, y: 1.6, z: 0}
                        },
                        mappings: {
                            active: "camera.active",
                            far: "camera.far",
                            fov: "camera.fov",
                            "look-controls-enabled": "look-controls.enabled",
                            near: "camera.near",
                            "pointer-lock-enabled": "look-controls.pointerLockEnabled",
                            "wasd-controls-enabled": "wasd-controls.enabled",
                            "reverse-mouse-drag": "look-controls.reverseMouseDrag",
                            zoom: "camera.zoom"
                        }
                    })
                },
                "./src/extras/primitives/primitives/a-cursor.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/getMeshMixin.js"),
                        w = h("./src/extras/primitives/primitives.js").registerPrimitive, v = h("./src/utils/index.js");
                    w("a-cursor", v.extendDeep({}, g(), {
                        defaultComponents: {
                            cursor: {},
                            geometry: {primitive: "ring", radiusOuter: .016, radiusInner: .01, segmentsTheta: 32},
                            material: {color: "#000", shader: "flat", opacity: .8},
                            position: {x: 0, y: 0, z: -1}
                        },
                        mappings: {
                            far: "raycaster.far",
                            fuse: "cursor.fuse",
                            "fuse-timeout": "cursor.fuseTimeout",
                            interval: "raycaster.interval",
                            objects: "raycaster.objects"
                        }
                    }))
                },
                "./src/extras/primitives/primitives/a-curvedimage.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/getMeshMixin.js"),
                        w = h("./src/extras/primitives/primitives.js").registerPrimitive, v = h("./src/utils/index.js");
                    w("a-curvedimage", v.extendDeep({}, g(), {
                        defaultComponents: {
                            geometry: {
                                height: 1,
                                primitive: "cylinder",
                                radius: 2,
                                segmentsRadial: 48,
                                thetaLength: 270,
                                openEnded: !0,
                                thetaStart: 0
                            },
                            material: {color: "#FFF", shader: "flat", side: "double", transparent: !0, repeat: "-1 1"}
                        },
                        mappings: {
                            height: "geometry.height",
                            "open-ended": "geometry.openEnded",
                            radius: "geometry.radius",
                            segments: "geometry.segmentsRadial",
                            start: "geometry.thetaStart",
                            "theta-length": "geometry.thetaLength",
                            "theta-start": "geometry.thetaStart",
                            width: "geometry.thetaLength"
                        }
                    }))
                },
                "./src/extras/primitives/primitives/a-gltf-model.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/primitives.js").registerPrimitive;
                    g("a-gltf-model", {mappings: {src: "gltf-model"}})
                },
                "./src/extras/primitives/primitives/a-image.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/getMeshMixin.js"),
                        w = h("./src/extras/primitives/primitives.js").registerPrimitive, v = h("./src/utils/index.js");
                    w("a-image", v.extendDeep({}, g(), {
                        defaultComponents: {
                            geometry: {primitive: "plane"},
                            material: {color: "#FFF", shader: "flat", side: "double", transparent: !0}
                        }, mappings: {height: "geometry.height", width: "geometry.width"}
                    }))
                },
                "./src/extras/primitives/primitives/a-light.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/primitives.js").registerPrimitive;
                    g("a-light", {
                        defaultComponents: {light: {}},
                        mappings: {
                            angle: "light.angle",
                            color: "light.color",
                            "ground-color": "light.groundColor",
                            decay: "light.decay",
                            distance: "light.distance",
                            intensity: "light.intensity",
                            penumbra: "light.penumbra",
                            type: "light.type",
                            target: "light.target",
                            envmap: "light.envMap",
                            "shadow-camera-automatic": "light.shadowCameraAutomatic"
                        }
                    })
                },
                "./src/extras/primitives/primitives/a-link.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/primitives.js").registerPrimitive;
                    g("a-link", {
                        defaultComponents: {link: {visualAspectEnabled: !0}},
                        mappings: {href: "link.href", image: "link.image", title: "link.title"}
                    })
                },
                "./src/extras/primitives/primitives/a-obj-model.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/getMeshMixin.js")(),
                        w = h("./src/extras/primitives/primitives.js").registerPrimitive, v = h("./src/utils/index.js");
                    w("a-obj-model", v.extendDeep({}, g, {
                        defaultComponents: {"obj-model": {}},
                        mappings: {src: "obj-model.obj", mtl: "obj-model.mtl"}
                    }))
                },
                "./src/extras/primitives/primitives/a-sky.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/getMeshMixin.js"),
                        w = h("./src/extras/primitives/primitives.js").registerPrimitive, v = h("./src/utils/index.js"),
                        E = h("./src/extras/primitives/primitives/meshPrimitives.js");
                    w("a-sky", v.extendDeep({}, g(), {
                        defaultComponents: {
                            geometry: {
                                primitive: "sphere",
                                radius: 500,
                                segmentsWidth: 64,
                                segmentsHeight: 32
                            }, material: {color: "#FFF", side: "back", shader: "flat", npot: !0}, scale: "-1 1 1"
                        }, mappings: v.extendDeep({}, E["a-sphere"].mappings)
                    }))
                },
                "./src/extras/primitives/primitives/a-sound.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/primitives.js").registerPrimitive;
                    g("a-sound", {
                        defaultComponents: {sound: {}},
                        mappings: {
                            src: "sound.src",
                            on: "sound.on",
                            autoplay: "sound.autoplay",
                            loop: "sound.loop",
                            volume: "sound.volume"
                        }
                    })
                },
                "./src/extras/primitives/primitives/a-text.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/primitives.js").definePrimitive;
                    g("a-text", {text: {anchor: "align", width: 5}})
                },
                "./src/extras/primitives/primitives/a-video.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/getMeshMixin.js"),
                        w = h("./src/extras/primitives/primitives.js").registerPrimitive, v = h("./src/utils/index.js");
                    w("a-video", v.extendDeep({}, g(), {
                        defaultComponents: {
                            geometry: {primitive: "plane"},
                            material: {color: "#FFF", shader: "flat", side: "double", transparent: !0}
                        }, mappings: {height: "geometry.height", width: "geometry.width"}
                    }))
                },
                "./src/extras/primitives/primitives/a-videosphere.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/getMeshMixin.js"),
                        w = h("./src/extras/primitives/primitives.js").registerPrimitive, v = h("./src/utils/index.js");
                    w("a-videosphere", v.extendDeep({}, g(), {
                        defaultComponents: {
                            geometry: {
                                primitive: "sphere",
                                radius: 500,
                                segmentsWidth: 64,
                                segmentsHeight: 32
                            }, material: {color: "#FFF", shader: "flat", side: "back", npot: !0}, scale: "-1 1 1"
                        },
                        mappings: {
                            radius: "geometry.radius",
                            "segments-height": "geometry.segmentsHeight",
                            "segments-width": "geometry.segmentsWidth"
                        }
                    }))
                },
                "./src/extras/primitives/primitives/meshPrimitives.js": (m, x, h) => {
                    var g = h("./src/extras/primitives/getMeshMixin.js"), w = h("./src/core/geometry.js").geometries,
                        v = h("./src/core/geometry.js").geometryNames,
                        E = h("./src/extras/primitives/primitives.js").registerPrimitive, p = h("./src/utils/index.js"),
                        C = m.exports = {};
                    v.forEach(function (B) {
                        var R = w[B], I = M(B), L = {};
                        Object.keys(R.schema).forEach(function (V) {
                            L[M(V)] = "geometry." + V
                        });
                        var O = "a-" + I, N = E(O, p.extendDeep({}, g(), {
                            defaultComponents: {geometry: {primitive: B}},
                            mappings: L
                        }));
                        C[O] = N
                    });

                    function M(b) {
                        return b.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
                    }
                },
                "./src/geometries/box.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js");
                    g("box", {
                        schema: {
                            depth: {default: 1, min: 0},
                            height: {default: 1, min: 0},
                            width: {default: 1, min: 0},
                            segmentsHeight: {default: 1, min: 1, max: 20, type: "int"},
                            segmentsWidth: {default: 1, min: 1, max: 20, type: "int"},
                            segmentsDepth: {default: 1, min: 1, max: 20, type: "int"}
                        }, init: function (v) {
                            this.geometry = new w.BoxGeometry(v.width, v.height, v.depth, v.segmentsWidth, v.segmentsHeight, v.segmentsDepth)
                        }
                    })
                },
                "./src/geometries/circle.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js"),
                        v = w.MathUtils.degToRad;
                    g("circle", {
                        schema: {
                            radius: {default: 1, min: 0},
                            segments: {default: 32, min: 3, type: "int"},
                            thetaLength: {default: 360, min: 0},
                            thetaStart: {default: 0}
                        }, init: function (E) {
                            this.geometry = new w.CircleGeometry(E.radius, E.segments, v(E.thetaStart), v(E.thetaLength))
                        }
                    })
                },
                "./src/geometries/cone.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js"),
                        v = w.MathUtils.degToRad;
                    g("cone", {
                        schema: {
                            height: {default: 1, min: 0},
                            openEnded: {default: !1},
                            radiusBottom: {default: 1, min: 0},
                            radiusTop: {default: .01, min: 0},
                            segmentsHeight: {default: 18, min: 1, type: "int"},
                            segmentsRadial: {default: 36, min: 3, type: "int"},
                            thetaLength: {default: 360, min: 0},
                            thetaStart: {default: 0}
                        }, init: function (E) {
                            this.geometry = new w.CylinderGeometry(E.radiusTop, E.radiusBottom, E.height, E.segmentsRadial, E.segmentsHeight, E.openEnded, v(E.thetaStart), v(E.thetaLength))
                        }
                    })
                },
                "./src/geometries/cylinder.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js"),
                        v = w.MathUtils.degToRad;
                    g("cylinder", {
                        schema: {
                            height: {default: 1, min: 0},
                            openEnded: {default: !1},
                            radius: {default: 1, min: 0},
                            segmentsHeight: {default: 18, min: 1, type: "int"},
                            segmentsRadial: {default: 36, min: 3, type: "int"},
                            thetaLength: {default: 360, min: 0},
                            thetaStart: {default: 0}
                        }, init: function (E) {
                            this.geometry = new w.CylinderGeometry(E.radius, E.radius, E.height, E.segmentsRadial, E.segmentsHeight, E.openEnded, v(E.thetaStart), v(E.thetaLength))
                        }
                    })
                },
                "./src/geometries/dodecahedron.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js");
                    g("dodecahedron", {
                        schema: {
                            detail: {default: 0, min: 0, max: 5, type: "int"},
                            radius: {default: 1, min: 0}
                        }, init: function (v) {
                            this.geometry = new w.DodecahedronGeometry(v.radius, v.detail)
                        }
                    })
                },
                "./src/geometries/icosahedron.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js");
                    g("icosahedron", {
                        schema: {
                            detail: {default: 0, min: 0, max: 5, type: "int"},
                            radius: {default: 1, min: 0}
                        }, init: function (v) {
                            this.geometry = new w.IcosahedronGeometry(v.radius, v.detail)
                        }
                    })
                },
                "./src/geometries/index.js": (m, x, h) => {
                    h("./src/geometries/box.js"), h("./src/geometries/circle.js"), h("./src/geometries/cone.js"), h("./src/geometries/cylinder.js"), h("./src/geometries/dodecahedron.js"), h("./src/geometries/icosahedron.js"), h("./src/geometries/octahedron.js"), h("./src/geometries/plane.js"), h("./src/geometries/ring.js"), h("./src/geometries/sphere.js"), h("./src/geometries/tetrahedron.js"), h("./src/geometries/torus.js"), h("./src/geometries/torusKnot.js"), h("./src/geometries/triangle.js")
                },
                "./src/geometries/octahedron.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js");
                    g("octahedron", {
                        schema: {
                            detail: {default: 0, min: 0, max: 5, type: "int"},
                            radius: {default: 1, min: 0}
                        }, init: function (v) {
                            this.geometry = new w.OctahedronGeometry(v.radius, v.detail)
                        }
                    })
                },
                "./src/geometries/plane.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js");
                    g("plane", {
                        schema: {
                            height: {default: 1, min: 0},
                            width: {default: 1, min: 0},
                            segmentsHeight: {default: 1, min: 1, max: 20, type: "int"},
                            segmentsWidth: {default: 1, min: 1, max: 20, type: "int"}
                        }, init: function (v) {
                            this.geometry = new w.PlaneGeometry(v.width, v.height, v.segmentsWidth, v.segmentsHeight)
                        }
                    })
                },
                "./src/geometries/ring.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js"),
                        v = w.MathUtils.degToRad;
                    g("ring", {
                        schema: {
                            radiusInner: {default: .8, min: 0},
                            radiusOuter: {default: 1.2, min: 0},
                            segmentsPhi: {default: 10, min: 1, type: "int"},
                            segmentsTheta: {default: 32, min: 3, type: "int"},
                            thetaLength: {default: 360, min: 0},
                            thetaStart: {default: 0}
                        }, init: function (E) {
                            this.geometry = new w.RingGeometry(E.radiusInner, E.radiusOuter, E.segmentsTheta, E.segmentsPhi, v(E.thetaStart), v(E.thetaLength))
                        }
                    })
                },
                "./src/geometries/sphere.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js"),
                        v = w.MathUtils.degToRad;
                    g("sphere", {
                        schema: {
                            radius: {default: 1, min: 0},
                            phiLength: {default: 360},
                            phiStart: {default: 0, min: 0},
                            thetaLength: {default: 180, min: 0},
                            thetaStart: {default: 0},
                            segmentsHeight: {default: 18, min: 2, type: "int"},
                            segmentsWidth: {default: 36, min: 3, type: "int"}
                        }, init: function (E) {
                            this.geometry = new w.SphereGeometry(E.radius, E.segmentsWidth, E.segmentsHeight, v(E.phiStart), v(E.phiLength), v(E.thetaStart), v(E.thetaLength))
                        }
                    })
                },
                "./src/geometries/tetrahedron.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js");
                    g("tetrahedron", {
                        schema: {
                            detail: {default: 0, min: 0, max: 5, type: "int"},
                            radius: {default: 1, min: 0}
                        }, init: function (v) {
                            this.geometry = new w.TetrahedronGeometry(v.radius, v.detail)
                        }
                    })
                },
                "./src/geometries/torus.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js"),
                        v = w.MathUtils.degToRad;
                    g("torus", {
                        schema: {
                            arc: {default: 360},
                            radius: {default: 1, min: 0},
                            radiusTubular: {default: .2, min: 0},
                            segmentsRadial: {default: 36, min: 2, type: "int"},
                            segmentsTubular: {default: 32, min: 3, type: "int"}
                        }, init: function (E) {
                            this.geometry = new w.TorusGeometry(E.radius, E.radiusTubular * 2, E.segmentsRadial, E.segmentsTubular, v(E.arc))
                        }
                    })
                },
                "./src/geometries/torusKnot.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js");
                    g("torusKnot", {
                        schema: {
                            p: {default: 2, min: 1},
                            q: {default: 3, min: 1},
                            radius: {default: 1, min: 0},
                            radiusTubular: {default: .2, min: 0},
                            segmentsRadial: {default: 8, min: 3, type: "int"},
                            segmentsTubular: {default: 100, min: 3, type: "int"}
                        }, init: function (v) {
                            this.geometry = new w.TorusKnotGeometry(v.radius, v.radiusTubular * 2, v.segmentsTubular, v.segmentsRadial, v.p, v.q)
                        }
                    })
                },
                "./src/geometries/triangle.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").registerGeometry, w = h("./src/lib/three.js"),
                        v = new w.Quaternion, E = new w.Vector3(0, 0, 1), p = new w.Vector2, C = new w.Vector2,
                        M = new w.Vector2;
                    g("triangle", {
                        schema: {
                            vertexA: {type: "vec3", default: {x: 0, y: .5, z: 0}},
                            vertexB: {type: "vec3", default: {x: -.5, y: -.5, z: 0}},
                            vertexC: {type: "vec3", default: {x: .5, y: -.5, z: 0}}
                        }, init: function (b) {
                            var B, R, I, L, O, N, F, V, U;
                            I = new w.Triangle, I.a.set(b.vertexA.x, b.vertexA.y, b.vertexA.z), I.b.set(b.vertexB.x, b.vertexB.y, b.vertexB.z), I.c.set(b.vertexC.x, b.vertexC.y, b.vertexC.z), R = I.getNormal(new w.Vector3), v.setFromUnitVectors(R, E), L = I.a.clone().applyQuaternion(v), O = I.b.clone().applyQuaternion(v), N = I.c.clone().applyQuaternion(v), p.set(Math.min(L.x, O.x, N.x), Math.min(L.y, O.y, N.y)), C.set(Math.max(L.x, O.x, N.x), Math.max(L.y, O.y, N.y)), M.set(0, 0).subVectors(C, p), L = new w.Vector2().subVectors(L, p).divide(M), O = new w.Vector2().subVectors(O, p).divide(M), N = new w.Vector2().subVectors(N, p).divide(M), B = this.geometry = new w.BufferGeometry, F = [I.a.x, I.a.y, I.a.z, I.b.x, I.b.y, I.b.z, I.c.x, I.c.y, I.c.z], V = [R.x, R.y, R.z, R.x, R.y, R.z, R.x, R.y, R.z], U = [L.x, L.y, O.x, O.y, N.x, N.y], B.setAttribute("position", new w.Float32BufferAttribute(F, 3)), B.setAttribute("normal", new w.Float32BufferAttribute(V, 3)), B.setAttribute("uv", new w.Float32BufferAttribute(U, 2))
                        }
                    })
                },
                "./src/index.js": (m, x, h) => {
                    if (window.hasNativeWebVRImplementation = !!window.navigator.getVRDisplays || !!window.navigator.getVRDevices, window.hasNativeWebXRImplementation = navigator.xr !== void 0, !window.hasNativeWebXRImplementation && !window.hasNativeWebVRImplementation) {
                        var g = h("./src/utils/isIOSOlderThan10.js"),
                            w = g(window.navigator.userAgent) ? 1 / window.devicePixelRatio : 1,
                            v = h("./node_modules/webvr-polyfill/build/webvr-polyfill.js"), E = {
                                BUFFER_SCALE: w,
                                CARDBOARD_UI_DISABLED: !0,
                                ROTATE_INSTRUCTIONS_DISABLED: !0,
                                MOBILE_WAKE_LOCK: !!window.cordova
                            };
                        window.webvrpolyfill = new v(E)
                    }
                    var p = h("./src/utils/index.js"), C = p.debug, M = C("A-Frame:error"), b = C("A-Frame:warn");
                    window.document.currentScript && window.document.currentScript.parentNode !== window.document.head && !window.debug && b("Put the A-Frame <script> tag in the <head> of the HTML *before* the scene to ensure everything for A-Frame is properly registered before they are used from HTML."), !window.cordova && window.location.protocol === "file:" && M("This HTML file is currently being served via the file:// protocol. Assets, textures, and models WILL NOT WORK due to cross-origin policy! Please use a local or hosted server: https://aframe.io/docs/1.4.0/introduction/installation.html#use-a-local-server."), p.device.isBrowserEnvironment && (h("./src/style/aframe.css"), h("./src/style/rStats.css"));
                    var B = h("./src/core/scene/a-scene.js").AScene, R = h("./src/core/component.js").components,
                        I = h("./src/core/component.js").registerComponent,
                        L = h("./src/core/geometry.js").registerGeometry,
                        O = h("./src/extras/primitives/primitives.js").registerPrimitive,
                        N = h("./src/core/shader.js").registerShader, F = h("./src/core/system.js").registerSystem,
                        V = h("./src/core/shader.js").shaders, U = h("./src/core/system.js").systems,
                        j = window.THREE = h("./src/lib/three.js"), Y = h("./src/core/readyState.js"),
                        fe = h("./package.json");
                    h("./src/components/index.js"), h("./src/geometries/index.js"), h("./src/shaders/index.js"), h("./src/systems/index.js");
                    var se = h("./src/core/a-node.js").ANode, pe = h("./src/core/a-entity.js").AEntity;
                    h("./src/core/a-assets.js"), h("./src/core/a-cubemap.js"), h("./src/core/a-mixin.js"), h("./src/extras/components/index.js"), h("./src/extras/primitives/index.js"), console.log("A-Frame Version: 1.6.0 (Date 2024-05-23, Commit #e6c47761)"), console.log("THREE Version (https://github.com/supermedium/three.js):", j.REVISION), console.log("WebVR Polyfill Version:", fe.dependencies["webvr-polyfill"]), window.AFRAME_ASYNC || Y.waitForDocumentReadyState(), m.exports = window.AFRAME = {
                        AComponent: h("./src/core/component.js").Component,
                        AEntity: pe,
                        ANode: se,
                        ANIME: h("./node_modules/super-animejs/lib/anime.es.js").default,
                        AScene: B,
                        components: R,
                        coreComponents: Object.keys(R),
                        geometries: h("./src/core/geometry.js").geometries,
                        registerComponent: I,
                        registerGeometry: L,
                        registerPrimitive: O,
                        registerShader: N,
                        registerSystem: F,
                        primitives: {
                            getMeshMixin: h("./src/extras/primitives/getMeshMixin.js"),
                            primitives: h("./src/extras/primitives/primitives.js").primitives
                        },
                        scenes: h("./src/core/scene/scenes.js"),
                        schema: h("./src/core/schema.js"),
                        shaders: V,
                        systems: U,
                        emitReady: Y.emitReady,
                        THREE: j,
                        utils: p,
                        version: fe.version
                    }
                },
                "./src/lib/rStatsAframe.js": m => {
                    window.aframeStats = function (x) {
                        var h = null, g = x, w = {te: {caption: "Entities"}, lt: {caption: "Load Time"}},
                            v = [{caption: "A-Frame", values: ["te", "lt"]}];

                        function E() {
                            h("te").set(p()), window.performance.getEntriesByName && h("lt").set(window.performance.getEntriesByName("render-started")[0].startTime.toFixed(0))
                        }

                        function p() {
                            var B = g.querySelectorAll("*");
                            return Array.prototype.slice.call(B).filter(function (R) {
                                return R.isEntity
                            }), B.length
                        }

                        function C() {
                        }

                        function M() {
                        }

                        function b(B) {
                            h = B
                        }

                        return {update: E, start: C, end: M, attach: b, values: w, groups: v, fractions: []}
                    }, m.exports = {aframeStats: window.aframeStats}
                },
                "./src/lib/three.js": (m, x, h) => {
                    var g = h("./src/lib/three.mjs").default;
                    h.g.THREE = g, h("./vendor/DeviceOrientationControls.js"), g.Cache && (g.Cache.enabled = !0), m.exports = g
                },
                "./src/shaders/flat.js": (m, x, h) => {
                    var g = h("./src/core/shader.js").registerShader, w = h("./src/lib/three.js"),
                        v = h("./src/utils/index.js");
                    m.exports.Shader = g("flat", {
                        schema: {
                            color: {type: "color"},
                            fog: {default: !0},
                            height: {default: 256},
                            offset: {type: "vec2", default: {x: 0, y: 0}},
                            repeat: {type: "vec2", default: {x: 1, y: 1}},
                            src: {type: "map"},
                            width: {default: 512},
                            wireframe: {default: !1},
                            wireframeLinewidth: {default: 2},
                            toneMapped: {default: !0}
                        }, init: function (p) {
                            this.materialData = {color: new w.Color}, E(p, this.materialData), this.material = new w.MeshBasicMaterial(this.materialData)
                        }, update: function (p) {
                            this.updateMaterial(p), v.material.updateMap(this, p)
                        }, updateMaterial: function (p) {
                            var C;
                            E(p, this.materialData);
                            for (C in this.materialData) this.material[C] = this.materialData[C]
                        }
                    });

                    function E(p, C) {
                        return C.color.set(p.color), C.fog = p.fog, C.wireframe = p.wireframe, C.toneMapped = p.toneMapped, C.wireframeLinewidth = p.wireframeLinewidth, C
                    }
                },
                "./src/shaders/index.js": (m, x, h) => {
                    h("./src/shaders/flat.js"), h("./src/shaders/standard.js"), h("./src/shaders/phong.js"), h("./src/shaders/sdf.js"), h("./src/shaders/msdf.js"), h("./src/shaders/shadow.js")
                },
                "./src/shaders/msdf.js": (m, x, h) => {
                    var g = h("./src/core/shader.js").registerShader, w = h("./src/lib/three.js"),
                        v = ["#include <common>", "#include <fog_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "out vec2 vUV;", "void main(void) {", "  vUV = uv;", "  #include <begin_vertex>", "  #include <project_vertex>", "  #include <logdepthbuf_vertex>", "  #include <fog_vertex>", "}"].join(`
`),
                        E = ["#include <common>", "#include <fog_pars_fragment>", "#include <logdepthbuf_pars_fragment>", "uniform bool negate;", "uniform float alphaTest;", "uniform float opacity;", "uniform sampler2D map;", "uniform vec3 color;", "in vec2 vUV;", "float median(float r, float g, float b) {", "  return max(min(r, g), min(max(r, g), b));", "}", "#define BIG_ENOUGH 0.001", "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)", "void main() {", "  vec3 sampleColor = texture(map, vUV).rgb;", "  if (negate) { sampleColor = 1.0 - sampleColor; }", "  float sigDist = median(sampleColor.r, sampleColor.g, sampleColor.b) - 0.5;", "  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);", "  float dscale = 0.353505;", "  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));", "  float isBigEnough = max(abs(duv.x), abs(duv.y));", "  // Do modified alpha test.", "  if (isBigEnough > BIG_ENOUGH) {", "    float ratio = BIG_ENOUGH / isBigEnough;", "    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);", "  }", "  // Do modified alpha test.", "  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }", "  gl_FragColor = vec4(color.xyz, alpha * opacity);", "  #include <logdepthbuf_fragment>", "  #include <tonemapping_fragment>", "  #include <colorspace_fragment>", "  #include <fog_fragment>", "}"].join(`
`);
                    m.exports.Shader = g("msdf", {
                        schema: {
                            alphaTest: {type: "number", is: "uniform", default: .5},
                            color: {type: "color", is: "uniform", default: "white"},
                            map: {type: "map", is: "uniform"},
                            negate: {type: "boolean", is: "uniform", default: !0},
                            opacity: {type: "number", is: "uniform", default: 1}
                        }, vertexShader: v, fragmentShader: E, init: function () {
                            return this.uniforms = w.UniformsUtils.merge([w.UniformsLib.fog, this.initUniforms()]), this.material = new w.ShaderMaterial({
                                uniforms: this.uniforms,
                                vertexShader: this.vertexShader,
                                fragmentShader: this.fragmentShader,
                                fog: !0
                            }), this.material
                        }
                    })
                },
                "./src/shaders/phong.js": (m, x, h) => {
                    var g = h("./src/core/shader.js").registerShader, w = h("./src/lib/three.js"),
                        v = h("./src/utils/index.js");
                    m.exports.Shader = g("phong", {
                        schema: {
                            color: {type: "color"},
                            emissive: {type: "color", default: "black"},
                            emissiveIntensity: {default: 1},
                            specular: {type: "color", default: "#111111"},
                            transparent: {default: !1},
                            fog: {default: !0},
                            offset: {type: "vec2", default: {x: 0, y: 0}},
                            repeat: {type: "vec2", default: {x: 1, y: 1}},
                            src: {type: "map"},
                            envMap: {default: ""},
                            sphericalEnvMap: {type: "map"},
                            shininess: {default: 30},
                            flatShading: {default: !1},
                            wireframe: {default: !1},
                            wireframeLinewidth: {default: 2},
                            combine: {oneOF: ["multiply", "mix", "add"], default: "mix"},
                            reflectivity: {default: .9},
                            refractionRatio: {default: .98},
                            refract: {default: !1},
                            normalMap: {type: "map"},
                            normalScale: {type: "vec2", default: {x: 1, y: 1}},
                            normalTextureOffset: {type: "vec2"},
                            normalTextureRepeat: {type: "vec2", default: {x: 1, y: 1}},
                            ambientOcclusionMap: {type: "map"},
                            ambientOcclusionMapIntensity: {default: 1},
                            displacementMap: {type: "map"},
                            displacementScale: {default: 1},
                            displacementBias: {default: .5},
                            displacementTextureOffset: {type: "vec2"},
                            displacementTextureRepeat: {type: "vec2", default: {x: 1, y: 1}},
                            bumpMap: {type: "map"},
                            bumpMapScale: {default: 1},
                            bumpTextureOffset: {type: "vec2"},
                            bumpTextureRepeat: {type: "vec2", default: {x: 1, y: 1}}
                        }, init: function (p) {
                            this.materialData = {
                                color: new w.Color,
                                specular: new w.Color,
                                emissive: new w.Color
                            }, E(p, this.materialData), this.material = new w.MeshPhongMaterial(this.materialData);
                            var C = this.el.sceneEl;
                            Object.defineProperty(this.material, "envMap", {
                                get: function () {
                                    return this._envMap || C.object3D.environment
                                }, set: function (M) {
                                    this._envMap = M
                                }
                            })
                        }, update: function (p) {
                            this.updateMaterial(p), v.material.updateMap(this, p), v.material.updateDistortionMap("normal", this, p), v.material.updateDistortionMap("displacement", this, p), v.material.updateDistortionMap("ambientOcclusion", this, p), v.material.updateDistortionMap("bump", this, p), v.material.updateEnvMap(this, p)
                        }, updateMaterial: function (p) {
                            var C;
                            E(p, this.materialData);
                            for (C in this.materialData) this.material[C] = this.materialData[C]
                        }
                    });

                    function E(p, C) {
                        switch (C.color.set(p.color), C.specular.set(p.specular), C.emissive.set(p.emissive), C.emissiveIntensity = p.emissiveIntensity, C.fog = p.fog, C.transparent = p.transparent, C.wireframe = p.wireframe, C.wireframeLinewidth = p.wireframeLinewidth, C.shininess = p.shininess, C.flatShading = p.flatShading, C.wireframe = p.wireframe, C.wireframeLinewidth = p.wireframeLinewidth, C.reflectivity = p.reflectivity, C.refractionRatio = p.refractionRatio, p.combine) {
                            case"mix":
                                C.combine = w.MixOperation;
                                break;
                            case"multiply":
                                C.combine = w.MultiplyOperation;
                                break;
                            case"add":
                                C.combine = w.AddOperation;
                                break
                        }
                        return p.normalMap && (C.normalScale = p.normalScale), p.ambientOcclusionMap && (C.aoMapIntensity = p.ambientOcclusionMapIntensity), p.bumpMap && (C.bumpScale = p.bumpMapScale), p.displacementMap && (C.displacementScale = p.displacementScale, C.displacementBias = p.displacementBias), C
                    }
                },
                "./src/shaders/sdf.js": (m, x, h) => {
                    var g = h("./src/core/shader.js").registerShader, w = h("./src/lib/three.js"),
                        v = ["#include <common>", "#include <fog_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "out vec2 vUV;", "void main(void) {", "  vUV = uv;", "  #include <begin_vertex>", "  #include <project_vertex>", "  #include <logdepthbuf_vertex>", "  #include <fog_vertex>", "}"].join(`
`),
                        E = ["#include <common>", "#include <fog_pars_fragment>", "#include <logdepthbuf_pars_fragment>", "uniform float alphaTest;", "uniform float opacity;", "uniform sampler2D map;", "uniform vec3 color;", "in vec2 vUV;", "float contour(float width, float value) {", "  return smoothstep(0.5 - value, 0.5 + value, width);", "}", "#define BIG_ENOUGH 0.001", "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)", "void main() {", "  vec2 uv = vUV;", "  vec4 texColor = texture(map, uv);", "  float dist = texColor.a;", "  float width = fwidth(dist);", "  float alpha = contour(dist, width);", "  float dscale = 0.353505;", "  vec2 duv = dscale * (dFdx(uv) + dFdy(uv));", "  float isBigEnough = max(abs(duv.x), abs(duv.y));", "  if (isBigEnough > BIG_ENOUGH) {", "    float ratio = BIG_ENOUGH / isBigEnough;", "    alpha = ratio * alpha + (1.0 - ratio) * dist;", "  }", "  if (isBigEnough <= BIG_ENOUGH) {", "    vec4 box = vec4 (uv - duv, uv + duv);", "    alpha = (alpha + 0.5 * (", "      contour(texture(map, box.xy).a, width)", "      + contour(texture(map, box.zw).a, width)", "      + contour(texture(map, box.xw).a, width)", "      + contour(texture(map, box.zy).a, width)", "    )) / 3.0;", "  }", "  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }", "  gl_FragColor = vec4(color, opacity * alpha);", "  #include <logdepthbuf_fragment>", "  #include <tonemapping_fragment>", "  #include <colorspace_fragment>", "  #include <fog_fragment>", "}"].join(`
`);
                    m.exports.Shader = g("sdf", {
                        schema: {
                            alphaTest: {type: "number", is: "uniform", default: .5},
                            color: {type: "color", is: "uniform", default: "white"},
                            map: {type: "map", is: "uniform"},
                            opacity: {type: "number", is: "uniform", default: 1}
                        }, vertexShader: v, fragmentShader: E, init: function () {
                            return this.uniforms = w.UniformsUtils.merge([w.UniformsLib.fog, this.initUniforms()]), this.material = new w.ShaderMaterial({
                                uniforms: this.uniforms,
                                vertexShader: this.vertexShader,
                                fragmentShader: this.fragmentShader,
                                fog: !0
                            }), this.material
                        }
                    })
                },
                "./src/shaders/shadow.js": (m, x, h) => {
                    var g = h("./src/core/shader.js").registerShader, w = h("./src/lib/three.js");
                    m.exports.Shader = g("shadow", {
                        schema: {
                            opacity: {default: .5},
                            transparent: {default: !0},
                            alphaToCoverage: {default: !0}
                        }, init: function (v) {
                            this.material = new w.ShadowMaterial
                        }, update: function (v) {
                            this.material.opacity = v.opacity, this.material.alphaToCoverage = v.alphaToCoverage, this.material.transparent = v.transparent
                        }
                    })
                },
                "./src/shaders/standard.js": (m, x, h) => {
                    var g = h("./src/core/shader.js").registerShader, w = h("./src/lib/three.js"),
                        v = h("./src/utils/index.js");
                    m.exports.Shader = g("standard", {
                        schema: {
                            ambientOcclusionMap: {type: "map"},
                            ambientOcclusionMapIntensity: {default: 1},
                            ambientOcclusionTextureOffset: {type: "vec2"},
                            ambientOcclusionTextureRepeat: {type: "vec2", default: {x: 1, y: 1}},
                            color: {type: "color"},
                            displacementMap: {type: "map"},
                            displacementScale: {default: 1},
                            displacementBias: {default: .5},
                            displacementTextureOffset: {type: "vec2"},
                            displacementTextureRepeat: {type: "vec2", default: {x: 1, y: 1}},
                            emissive: {type: "color", default: "#000"},
                            emissiveIntensity: {default: 1},
                            envMap: {default: ""},
                            fog: {default: !0},
                            height: {default: 256},
                            metalness: {default: 0, min: 0, max: 1},
                            metalnessMap: {type: "map"},
                            metalnessTextureOffset: {type: "vec2"},
                            metalnessTextureRepeat: {type: "vec2", default: {x: 1, y: 1}},
                            normalMap: {type: "map"},
                            normalScale: {type: "vec2", default: {x: 1, y: 1}},
                            normalTextureOffset: {type: "vec2"},
                            normalTextureRepeat: {type: "vec2", default: {x: 1, y: 1}},
                            offset: {type: "vec2", default: {x: 0, y: 0}},
                            repeat: {type: "vec2", default: {x: 1, y: 1}},
                            roughness: {default: .5, min: 0, max: 1},
                            roughnessMap: {type: "map"},
                            roughnessTextureOffset: {type: "vec2"},
                            roughnessTextureRepeat: {type: "vec2", default: {x: 1, y: 1}},
                            sphericalEnvMap: {type: "map"},
                            src: {type: "map"},
                            width: {default: 512},
                            wireframe: {default: !1},
                            wireframeLinewidth: {default: 2}
                        }, init: function (p) {
                            this.materialData = {
                                color: new w.Color,
                                emissive: new w.Color
                            }, E(p, this.materialData), this.material = new w.MeshStandardMaterial(this.materialData)
                        }, update: function (p) {
                            this.updateMaterial(p), v.material.updateMap(this, p), v.material.updateDistortionMap("normal", this, p), v.material.updateDistortionMap("displacement", this, p), v.material.updateDistortionMap("ambientOcclusion", this, p), v.material.updateDistortionMap("metalness", this, p), v.material.updateDistortionMap("roughness", this, p), v.material.updateEnvMap(this, p)
                        }, updateMaterial: function (p) {
                            var C, M = this.material;
                            E(p, this.materialData);
                            for (C in this.materialData) M[C] = this.materialData[C]
                        }
                    });

                    function E(p, C) {
                        return C.color.set(p.color), C.emissive.set(p.emissive), C.emissiveIntensity = p.emissiveIntensity, C.fog = p.fog, C.metalness = p.metalness, C.roughness = p.roughness, C.wireframe = p.wireframe, C.wireframeLinewidth = p.wireframeLinewidth, p.normalMap && (C.normalScale = p.normalScale), p.ambientOcclusionMap && (C.aoMapIntensity = p.ambientOcclusionMapIntensity), p.displacementMap && (C.displacementScale = p.displacementScale, C.displacementBias = p.displacementBias), C
                    }
                },
                "./src/systems/camera.js": (m, x, h) => {
                    var g = h("./src/constants/index.js"), w = h("./src/core/system.js").registerSystem,
                        v = "data-aframe-default-camera";
                    m.exports.System = w("camera", {
                        init: function () {
                            this.activeCameraEl = null, this.render = this.render.bind(this), this.unwrapRender = this.unwrapRender.bind(this), this.wrapRender = this.wrapRender.bind(this), this.initialCameraFound = !1, this.numUserCameras = 0, this.numUserCamerasChecked = 0, this.setupInitialCamera()
                        }, setupInitialCamera: function () {
                            var p, C, M = this.sceneEl, b = this;
                            if (M.camera && !M.camera.el.getAttribute("camera").spectator) {
                                M.emit("cameraready", {cameraEl: M.camera.el});
                                return
                            }
                            if (p = M.querySelectorAll("a-camera, :not(a-mixin)[camera]"), !p.length) {
                                this.createDefaultCamera();
                                return
                            }
                            for (this.numUserCameras = p.length, C = 0; C < p.length; C++) p[C].addEventListener("object3dset", function (B) {
                                B.detail.type === "camera" && b.checkUserCamera(this)
                            }), p[C].isNode ? p[C].load() : p[C].addEventListener("nodeready", function () {
                                this.load()
                            })
                        }, checkUserCamera: function (p) {
                            var C, M = this.el.sceneEl;
                            if (this.numUserCamerasChecked++, !this.initialCameraFound) {
                                if (C = p.getAttribute("camera"), !C.active || C.spectator) {
                                    this.numUserCamerasChecked === this.numUserCameras && this.createDefaultCamera();
                                    return
                                }
                                this.initialCameraFound = !0, M.camera = p.getObject3D("camera"), M.emit("cameraready", {cameraEl: p})
                            }
                        }, createDefaultCamera: function () {
                            var p, C = this.sceneEl;
                            p = document.createElement("a-entity"), p.setAttribute("camera", {active: !0}), p.setAttribute("position", {
                                x: 0,
                                y: g.DEFAULT_CAMERA_HEIGHT,
                                z: 0
                            }), p.setAttribute("wasd-controls", ""), p.setAttribute("look-controls", ""), p.setAttribute(g.AFRAME_INJECTED, ""), p.addEventListener("object3dset", function (M) {
                                M.detail.type === "camera" && (C.camera = M.detail.object, C.emit("cameraready", {cameraEl: p}))
                            }), C.appendChild(p)
                        }, disableActiveCamera: function () {
                            var p, C;
                            p = this.sceneEl.querySelectorAll(":not(a-mixin)[camera]"), C = p[p.length - 1], C.setAttribute("camera", "active", !0)
                        }, setActiveCamera: function (p) {
                            var C, M, b, B, R = this.activeCameraEl, I = this.sceneEl;
                            if (B = p.getObject3D("camera"), !(!B || p === this.activeCameraEl)) {
                                var L = I.querySelector("[" + v + "]"),
                                    O = L && L.querySelector(":not(a-mixin)[camera]");
                                for (p !== O && E(I), this.activeCameraEl = p, this.activeCameraEl.play(), I.camera = B, R && R.setAttribute("camera", "active", !1), M = I.querySelectorAll(":not(a-mixin)[camera]"), b = 0; b < M.length; b++) C = M[b], !(!C.isEntity || p === C) && (C.setAttribute("camera", "active", !1), C.pause());
                                I.emit("camera-set-active", {cameraEl: p})
                            }
                        }, setSpectatorCamera: function (p) {
                            var C, M = this.spectatorCameraEl, b = this.sceneEl, B;
                            C = p.getObject3D("camera"), !(!C || p === this.spectatorCameraEl) && (M && M.setAttribute("camera", "spectator", !1), B = this.spectatorCameraEl = p, b.addEventListener("enter-vr", this.wrapRender), b.addEventListener("exit-vr", this.unwrapRender), B.setAttribute("camera", "active", !1), B.play(), b.emit("camera-set-spectator", {cameraEl: p}))
                        }, disableSpectatorCamera: function () {
                            this.spectatorCameraEl = void 0
                        }, wrapRender: function () {
                            !this.spectatorCameraEl || this.originalRender || (this.originalRender = this.sceneEl.renderer.render, this.sceneEl.renderer.render = this.render)
                        }, unwrapRender: function () {
                            this.originalRender && (this.sceneEl.renderer.render = this.originalRender, this.originalRender = void 0)
                        }, render: function (p, C) {
                            var M, b = this.sceneEl, B;
                            M = b.renderer.xr.enabled, this.originalRender.call(b.renderer, p, C), !(!this.spectatorCameraEl || b.isMobile || !M) && (B = this.spectatorCameraEl.components.camera.camera, b.renderer.xr.enabled = !1, this.originalRender.call(b.renderer, p, B), b.renderer.xr.enabled = M)
                        }
                    });

                    function E(p) {
                        var C, M = p.camera;
                        M && (C = p.querySelector("[" + v + "]"), C && p.removeChild(C))
                    }
                },
                "./src/systems/geometry.js": (m, x, h) => {
                    var g = h("./src/core/geometry.js").geometries, w = h("./src/core/system.js").registerSystem;
                    m.exports.System = w("geometry", {
                        init: function () {
                            this.cache = {}, this.cacheCount = {}
                        }, clearCache: function () {
                            this.cache = {}, this.cacheCount = {}
                        }, getOrCreateGeometry: function (C) {
                            var M = this.cache, b, B;
                            return C.skipCache ? v(C) : (B = this.hash(C), b = M[B], p(this.cacheCount, B), b || (b = v(C), M[B] = b, b))
                        }, unuseGeometry: function (C) {
                            var M = this.cache, b = this.cacheCount, B, R;
                            C.skipCache || (R = this.hash(C), M[R] && (E(b, R), !(b[R] > 0) && (B = M[R], B.dispose(), delete M[R], delete b[R])))
                        }, hash: function (C) {
                            return JSON.stringify(C)
                        }
                    });

                    function v(C) {
                        var M = C.primitive, b = g[M] && g[M].Geometry, B = new b;
                        if (!b) throw new Error("Unknown geometry `" + M + "`");
                        return B.init(C), B.geometry
                    }

                    function E(C, M) {
                        C[M]--
                    }

                    function p(C, M) {
                        C[M] = C[M] === void 0 ? 1 : C[M] + 1
                    }
                },
                "./src/systems/gltf-model.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem, w = h("./src/lib/three.js");

                    function v(E) {
                        return new Promise(function (p, C) {
                            var M = document.createElement("script");
                            document.body.appendChild(M), M.onload = p, M.onerror = C, M.async = !0, M.src = E
                        })
                    }

                    m.exports.System = g("gltf-model", {
                        schema: {
                            dracoDecoderPath: {default: "https://www.gstatic.com/draco/versioned/decoders/1.5.6/"},
                            basisTranscoderPath: {default: ""},
                            meshoptDecoderPath: {default: ""}
                        }, init: function () {
                            this.update()
                        }, update: function () {
                            var E = this.data.dracoDecoderPath, p = this.data.basisTranscoderPath,
                                C = this.data.meshoptDecoderPath;
                            !this.dracoLoader && E && (this.dracoLoader = new w.DRACOLoader, this.dracoLoader.setDecoderPath(E)), !this.ktx2Loader && p && (this.ktx2Loader = new w.KTX2Loader, this.ktx2Loader.setTranscoderPath(p).detectSupport(this.el.renderer)), !this.meshoptDecoder && C && (this.meshoptDecoder = v(C).then(function () {
                                return window.MeshoptDecoder.ready
                            }).then(function () {
                                return window.MeshoptDecoder
                            }))
                        }, getDRACOLoader: function () {
                            return this.dracoLoader
                        }, getKTX2Loader: function () {
                            return this.ktx2Loader
                        }, getMeshoptDecoder: function () {
                            return this.meshoptDecoder
                        }
                    })
                },
                "./src/systems/index.js": (m, x, h) => {
                    h("./src/systems/camera.js"), h("./src/systems/geometry.js"), h("./src/systems/gltf-model.js"), h("./src/systems/light.js"), h("./src/systems/material.js"), h("./src/systems/obb-collider.js"), h("./src/systems/renderer.js"), h("./src/systems/shadow.js"), h("./src/systems/tracked-controls-webvr.js"), h("./src/systems/tracked-controls-webxr.js"), h("./src/systems/webxr.js")
                },
                "./src/systems/light.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem, w = h("./src/constants/index.js"),
                        v = "data-aframe-default-light";
                    m.exports.System = g("light", {
                        schema: {defaultLightsEnabled: {default: !0}}, init: function () {
                            this.defaultLights = !1, this.userDefinedLights = !1, this.sceneEl.addEventListener("loaded", this.setupDefaultLights.bind(this))
                        }, registerLight: function (E) {
                            E.hasAttribute(v) || (this.removeDefaultLights(), this.userDefinedLights = !0)
                        }, removeDefaultLights: function () {
                            var E, p = this.sceneEl;
                            if (this.defaultLights) {
                                E = document.querySelectorAll("[" + v + "]");
                                for (var C = 0; C < E.length; C++) p.removeChild(E[C]);
                                this.defaultLights = !1
                            }
                        }, setupDefaultLights: function () {
                            var E = this.sceneEl, p, C;
                            this.userDefinedLights || this.defaultLights || !this.data.defaultLightsEnabled || (p = document.createElement("a-entity"), p.setAttribute("light", {
                                color: "#BBB",
                                type: "ambient"
                            }), p.setAttribute(v, ""), p.setAttribute(w.AFRAME_INJECTED, ""), E.appendChild(p), C = document.createElement("a-entity"), C.setAttribute("light", {
                                color: "#FFF",
                                intensity: .6,
                                castShadow: !0
                            }), C.setAttribute("position", {
                                x: -.5,
                                y: 1,
                                z: 1
                            }), C.setAttribute(v, ""), C.setAttribute(w.AFRAME_INJECTED, ""), E.appendChild(C), this.defaultLights = !0)
                        }
                    })
                },
                "./src/systems/material.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem, w = h("./src/lib/three.js"),
                        v = h("./src/utils/index.js"), E = h("./src/utils/material.js").setTextureProperties,
                        p = h("./src/utils/material.js").createCompatibleTexture, C = v.debug,
                        M = C("components:texture:error"), b = C("components:texture:warn"), B = new w.ImageLoader;
                    m.exports.System = g("material", {
                        init: function () {
                            this.materials = {}, this.sourceCache = {}
                        }, clearTextureSourceCache: function () {
                            this.sourceCache = {}
                        }, loadTexture: function (O, N, F) {
                            this.loadTextureSource(O, function (U) {
                                var j = p(U);
                                E(j, N), F(j)
                            })
                        }, loadTextureSource: function (O, N) {
                            var F = this, V = this.sourceCache, U = this.hash(O);
                            if (V[U]) {
                                V[U].then(N);
                                return
                            }
                            if (O.tagName === "CANVAS") {
                                Y(new w.Source(O));
                                return
                            }
                            Y(new Promise(j));

                            function j(fe, se) {
                                v.srcLoader.validateSrc(O, pe, ue);

                                function pe(he) {
                                    F.loadImage(he, fe)
                                }

                                function ue(he) {
                                    F.loadVideo(he, fe)
                                }
                            }

                            function Y(fe) {
                                V[U] = Promise.resolve(fe), V[U].then(N)
                            }
                        }, loadCubeMapTexture: function (O, N) {
                            var F = this, V = 0, U = new w.CubeTexture;
                            U.colorSpace = w.SRGBColorSpace;

                            function j(fe) {
                                F.loadTextureSource(O[fe], function (se) {
                                    U.images[fe] = se, V++, V === 6 && (U.needsUpdate = !0, N(U))
                                })
                            }

                            if (O.length !== 6) {
                                b("Cube map texture requires exactly 6 sources, got only %s sources", O.length);
                                return
                            }
                            for (var Y = 0; Y < O.length; Y++) j(Y)
                        }, loadImage: function (O, N) {
                            if (typeof O != "string") {
                                N(new w.Source(O));
                                return
                            }
                            N(R(O))
                        }, loadVideo: function (O, N) {
                            var F;
                            typeof O != "string" && (F = O, L(F)), F = F || I(O), N(new w.Source(F))
                        }, hash: function (O) {
                            return O.tagName && (O.id || O.src) || O
                        }, registerMaterial: function (O) {
                            this.materials[O.uuid] = O
                        }, unregisterMaterial: function (O) {
                            delete this.materials[O.uuid]
                        }
                    });

                    function R(O) {
                        return new Promise(N);

                        function N(F, V) {
                            B.load(O, U, function () {
                            }, function (j) {
                                M("`$s` could not be fetched (Error code: %s; Response: %s)", j.status, j.statusText)
                            });

                            function U(j) {
                                F(new w.Source(j))
                            }
                        }
                    }

                    function I(O) {
                        var N = document.createElement("video");
                        return N.setAttribute("playsinline", ""), N.setAttribute("webkit-playsinline", ""), N.autoplay = !0, N.loop = !0, N.crossOrigin = "anonymous", N.addEventListener("error", function () {
                            b("`%s` is not a valid video", O)
                        }, !0), N.src = O, N
                    }

                    function L(O) {
                        return O.autoplay = O.hasAttribute("autoplay") && O.getAttribute("autoplay") !== "false", O.controls = O.hasAttribute("controls") && O.getAttribute("controls") !== "false", O.getAttribute("loop") === "false" && O.removeAttribute("loop"), O.getAttribute("preload") === "false" && (O.preload = "none"), O.crossOrigin = O.crossOrigin || "anonymous", O.setAttribute("playsinline", ""), O.setAttribute("webkit-playsinline", ""), O
                    }
                },
                "./src/systems/obb-collider.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem;
                    g("obb-collider", {
                        schema: {showColliders: {default: !1}}, init: function () {
                            this.collisions = [], this.colliderEls = []
                        }, addCollider: function (w) {
                            this.colliderEls.push(w), this.data.showColliders ? w.components["obb-collider"].showCollider() : w.components["obb-collider"].hideCollider(), this.tick = this.detectCollisions
                        }, removeCollider: function (w) {
                            var v = this.colliderEls, E = v.indexOf(w);
                            w.components["obb-collider"].hideCollider(), E > -1 && v.splice(E, 1), v.length === 0 && (this.tick = void 0)
                        }, registerCollision: function (w, v) {
                            var E = this.collisions, p = !1, C = w.obb, M = v.obb, b = w.renderColliderMesh,
                                B = v.renderColliderMesh;
                            b && b.material.color.set(16711680), B && B.material.color.set(16711680);
                            for (var R = 0; R < E.length; R++) if (E[R].componentA.obb === C && E[R].componentB.obb === M || E[R].componentA.obb === M && E[R].componentB.obb === C) {
                                p = !0, E[R].detected = !0;
                                break
                            }
                            p || (E.push({
                                componentA: w,
                                componentB: v,
                                detected: !0
                            }), w.el.emit("obbcollisionstarted", {
                                trackedObject3D: w.trackedObject3D,
                                withEl: v.el
                            }), v.el.emit("obbcollisionstarted", {trackedObject3D: v.trackedObject3D, withEl: w.el}))
                        }, resetCollisions: function () {
                            for (var w = this.collisions, v = 0; v < w.length; v++) w[v].detected = !1
                        }, clearCollisions: function () {
                            for (var w = this.collisions, v = [], E, p, C, M, b = 0; b < w.length; b++) w[b].detected ? v.push(w[b]) : (E = w[b].componentA, p = w[b].componentB, C = E.renderColliderMesh, M = p.renderColliderMesh, C && C.material.color.set(65280), E.el.emit("obbcollisionended", {
                                trackedObject3D: this.trackedObject3D,
                                withEl: p.el
                            }), M && M.material.color.set(65280), p.el.emit("obbcollisionended", {
                                trackedObject3D: this.trackedObject3D,
                                withEl: E.el
                            }));
                            this.collisions = v
                        }, detectCollisions: function () {
                            var w, v, E, p, C = this.colliderEls;
                            if (!(C.length < 2)) {
                                this.resetCollisions();
                                for (var M = 0; M < C.length; M++) if (E = C[M].components["obb-collider"], w = C[M].components["obb-collider"].obb, !(w.halfSize.x === 0 || w.halfSize.y === 0 || w.halfSize.z === 0)) for (var b = M + 1; b < C.length; b++) p = C[b].components["obb-collider"], v = p.obb, !(v.halfSize.x === 0 || v.halfSize.y === 0 || v.halfSize.z === 0) && w.intersectsOBB(v) && this.registerCollision(E, p);
                                this.clearCollisions()
                            }
                        }
                    })
                },
                "./src/systems/renderer.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem, w = h("./src/utils/index.js"),
                        v = h("./src/lib/three.js"), E = w.debug, p = E("components:renderer:warn");
                    m.exports.System = g("renderer", {
                        schema: {
                            antialias: {default: "auto", oneOf: ["true", "false", "auto"]},
                            highRefreshRate: {default: w.device.isOculusBrowser()},
                            logarithmicDepthBuffer: {default: "auto", oneOf: ["true", "false", "auto"]},
                            maxCanvasWidth: {default: -1},
                            maxCanvasHeight: {default: -1},
                            multiviewStereo: {default: !1},
                            physicallyCorrectLights: {default: !1},
                            exposure: {default: 1, if: {toneMapping: ["ACESFilmic", "linear", "reinhard", "cineon"]}},
                            toneMapping: {default: "no", oneOf: ["no", "ACESFilmic", "linear", "reinhard", "cineon"]},
                            precision: {default: "high", oneOf: ["high", "medium", "low"]},
                            anisotropy: {default: 1},
                            sortTransparentObjects: {default: !1},
                            colorManagement: {default: !0},
                            alpha: {default: !0},
                            stencil: {default: !1},
                            foveationLevel: {default: 1}
                        }, init: function () {
                            var B = this.data, R = this.el,
                                I = this.data.toneMapping.charAt(0).toUpperCase() + this.data.toneMapping.slice(1),
                                L = R.renderer;
                            B.physicallyCorrectLights || (L.useLegacyLights = !B.physicallyCorrectLights), L.toneMapping = v[I + "ToneMapping"], v.Texture.DEFAULT_ANISOTROPY = B.anisotropy, v.ColorManagement.enabled = B.colorManagement, L.outputColorSpace = B.colorManagement ? v.SRGBColorSpace : v.LinearSRGBColorSpace, R.hasAttribute("antialias") && p('Component `antialias` is deprecated. Use `renderer="antialias: true"` instead.'), R.hasAttribute("logarithmicDepthBuffer") && p('Component `logarithmicDepthBuffer` is deprecated. Use `renderer="logarithmicDepthBuffer: true"` instead.'), L.sortObjects = !0, L.setOpaqueSort(C)
                        }, update: function () {
                            var B = this.data, R = this.el, I = R.renderer,
                                L = this.data.toneMapping.charAt(0).toUpperCase() + this.data.toneMapping.slice(1);
                            I.toneMapping = v[L + "ToneMapping"], I.toneMappingExposure = B.exposure, I.xr.setFoveation(B.foveationLevel), B.sortObjects && p('`sortObjects` property is deprecated. Use `renderer="sortTransparentObjects: true"` instead.'), B.sortTransparentObjects ? I.setTransparentSort(b) : I.setTransparentSort(M)
                        }, applyColorCorrection: function (B) {
                            !this.data.colorManagement || !B || B.isTexture && B.colorSpace !== v.SRGBColorSpace && (B.colorSpace = v.SRGBColorSpace, B.needsUpdate = !0)
                        }, setWebXRFrameRate: function (B) {
                            var R = this.data, I = B.supportedFrameRates;
                            if (I && B.updateTargetFrameRate) {
                                var L;
                                I.includes(90) ? L = R.highRefreshRate ? 90 : 72 : L = R.highRefreshRate ? 72 : 60, B.updateTargetFrameRate(L).catch(function (O) {
                                    console.warn("failed to set target frame rate of " + L + ". Error info: " + O)
                                })
                            }
                        }
                    });

                    function C(B, R) {
                        return B.groupOrder !== R.groupOrder ? B.groupOrder - R.groupOrder : B.renderOrder !== R.renderOrder ? B.renderOrder - R.renderOrder : B.z - R.z
                    }

                    function M(B, R) {
                        return B.groupOrder !== R.groupOrder ? B.groupOrder - R.groupOrder : B.renderOrder - R.renderOrder
                    }

                    function b(B, R) {
                        return B.groupOrder !== R.groupOrder ? B.groupOrder - R.groupOrder : B.renderOrder !== R.renderOrder ? B.renderOrder - R.renderOrder : R.z - B.z
                    }

                    m.exports.sortFrontToBack = C, m.exports.sortRenderOrderOnly = M, m.exports.sortBackToFront = b
                },
                "./src/systems/shadow.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem, w = h("./src/lib/three.js"),
                        v = {basic: w.BasicShadowMap, pcf: w.PCFShadowMap, pcfsoft: w.PCFSoftShadowMap};
                    m.exports.System = g("shadow", {
                        schema: {
                            enabled: {default: !0},
                            autoUpdate: {default: !0},
                            type: {default: "pcf", oneOf: ["basic", "pcf", "pcfsoft"]}
                        }, init: function () {
                            var p = this.sceneEl, C = this.data;
                            this.shadowMapEnabled = !1, p.renderer.shadowMap.type = v[C.type], p.renderer.shadowMap.autoUpdate = C.autoUpdate
                        }, update: function (p) {
                            p.enabled !== this.data.enabled && this.setShadowMapEnabled(this.shadowMapEnabled)
                        }, setShadowMapEnabled: function (p) {
                            var C = this.sceneEl, M = this.sceneEl.renderer;
                            this.shadowMapEnabled = p;
                            var b = this.data.enabled && this.shadowMapEnabled;
                            M && b !== M.shadowMap.enabled && (M.shadowMap.enabled = b, E(C))
                        }
                    });

                    function E(p) {
                        p.hasLoaded && p.object3D.traverse(function (C) {
                            if (C.material) for (var M = Array.isArray(C.material) ? C.material : [C.material], b = 0; b < M.length; b++) M[b].needsUpdate = !0
                        })
                    }
                },
                "./src/systems/tracked-controls-webvr.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem, w = h("./src/utils/index.js"),
                        v = w.device.isWebXRAvailable;
                    m.exports.System = g("tracked-controls-webvr", {
                        init: function () {
                            var E = this;
                            this.controllers = [], this.isChrome = navigator.userAgent.indexOf("Chrome") !== -1, this.updateControllerList(), this.throttledUpdateControllerList = w.throttle(this.updateControllerList, 500, this), !v && navigator.getVRDisplays && this.sceneEl.addEventListener("enter-vr", function () {
                                navigator.getVRDisplays().then(function (p) {
                                    p.length && (E.vrDisplay = p[0])
                                })
                            })
                        }, tick: function () {
                            this.isChrome ? this.updateControllerList() : this.throttledUpdateControllerList()
                        }, updateControllerList: function () {
                            var E = this.controllers, p, C, M, b;
                            if (C = navigator.getGamepads && navigator.getGamepads(), !!C) {
                                for (b = E.length, E.length = 0, M = 0; M < C.length; ++M) p = C[M], p && p.pose && E.push(p);
                                E.length !== b && this.el.emit("controllersupdated", void 0, !1)
                            }
                        }
                    })
                },
                "./src/systems/tracked-controls-webxr.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem, w = h("./src/utils/index.js");
                    m.exports.System = g("tracked-controls-webxr", {
                        init: function () {
                            this.controllers = [], this.oldControllers = [], this.oldControllersLength = 0, this.throttledUpdateControllerList = w.throttle(this.updateControllerList, 500, this), this.updateReferenceSpace = this.updateReferenceSpace.bind(this), this.el.addEventListener("enter-vr", this.updateReferenceSpace), this.el.addEventListener("exit-vr", this.updateReferenceSpace)
                        }, tick: function () {
                            this.throttledUpdateControllerList()
                        }, updateReferenceSpace: function () {
                            var v = this, E = this.el.xrSession;
                            if (!E) {
                                this.referenceSpace = void 0, this.controllers = [], this.oldControllersLength > 0 && (this.oldControllersLength = 0, this.el.emit("controllersupdated", void 0, !1));
                                return
                            }
                            var p = v.el.sceneEl.systems.webxr.sessionReferenceSpaceType;
                            E.requestReferenceSpace(p).then(function (C) {
                                v.referenceSpace = C
                            }).catch(function (C) {
                                throw v.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(p, 'tracked-controls-webxr uses reference space "' + p + '".'), C
                            })
                        }, updateControllerList: function () {
                            var v = this.el.xrSession, E = this.oldControllers, p;
                            if (!v) {
                                if (this.oldControllersLength === 0) return;
                                this.oldControllersLength = 0, this.controllers = [], this.el.emit("controllersupdated", void 0, !1);
                                return
                            }
                            if (v.inputSources) {
                                if (this.controllers = v.inputSources, this.oldControllersLength === this.controllers.length) {
                                    var C = !0;
                                    for (p = 0; p < this.controllers.length; ++p) if (!(this.controllers[p] === E[p] && this.controllers[p].gamepad === E[p].gamepad)) {
                                        C = !1;
                                        break
                                    }
                                    if (C) return
                                }
                                for (E.length = 0, p = 0; p < this.controllers.length; p++) E.push(this.controllers[p]);
                                this.oldControllersLength = this.controllers.length, this.el.emit("controllersupdated", void 0, !1)
                            }
                        }
                    })
                },
                "./src/systems/webxr.js": (m, x, h) => {
                    var g = h("./src/core/system.js").registerSystem, w = h("./src/utils/index.js"),
                        v = w.debug("systems:webxr:warn");
                    m.exports.System = g("webxr", {
                        schema: {
                            referenceSpaceType: {type: "string", default: "local-floor"},
                            requiredFeatures: {type: "array", default: ["local-floor"]},
                            optionalFeatures: {type: "array", default: ["bounded-floor"]},
                            overlayElement: {type: "selector"}
                        }, update: function () {
                            var E = this.data;
                            this.sessionConfiguration = {
                                requiredFeatures: E.requiredFeatures,
                                optionalFeatures: E.optionalFeatures
                            }, this.sessionReferenceSpaceType = E.referenceSpaceType, E.overlayElement && (E.overlayElement.classList.remove("a-dom-overlay"), E.optionalFeatures.includes("dom-overlay") || (E.optionalFeatures.push("dom-overlay"), this.el.setAttribute("webxr", E)), this.warnIfFeatureNotRequested("dom-overlay"), this.sessionConfiguration.domOverlay = {root: E.overlayElement}, E.overlayElement.classList.add("a-dom-overlay"))
                        }, wasFeatureRequested: function (E) {
                            return !!(E === "viewer" || E === "local" || this.sessionConfiguration.requiredFeatures.includes(E) || this.sessionConfiguration.optionalFeatures.includes(E))
                        }, warnIfFeatureNotRequested: function (E, p) {
                            if (!this.wasFeatureRequested(E)) {
                                var C = 'Please add the feature "' + E + `" to a-scene's webxr system options in requiredFeatures/optionalFeatures.`;
                                v((p ? p + " " : "") + C)
                            }
                        }
                    })
                },
                "./src/utils/coordinates.js": (m, x, h) => {
                    var g = h("./src/utils/debug.js"), w = g("utils:coordinates:warn"), v = ["x", "y", "z", "w"],
                        E = /^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/;
                    m.exports.regex = E;
                    var p = /\s+/g;

                    function C(I, L, O) {
                        var N, F, V, U, j = O && typeof O == "object" ? O : {}, Y, fe, se, pe;
                        if (I && I instanceof Object) return Y = I.x === void 0 ? L && L.x : I.x, fe = I.y === void 0 ? L && L.y : I.y, se = I.z === void 0 ? L && L.z : I.z, pe = I.w === void 0 ? L && L.w : I.w, Y != null && (j.x = R(Y)), fe != null && (j.y = R(fe)), se != null && (j.z = R(se)), pe != null && (j.w = R(pe)), j;
                        if (I == null) return typeof L == "object" ? Object.assign(j, L) : L;
                        for (N = I.trim().split(p), U = 0; U < v.length; U++) if (V = v[U], N[U]) j[V] = parseFloat(N[U], 10); else {
                            if (F = L && L[V], F === void 0) continue;
                            j[V] = R(F)
                        }
                        return j
                    }

                    m.exports.parse = C;

                    function M(I) {
                        var L;
                        return typeof I != "object" ? I : (L = I.x + " " + I.y, I.z != null && (L += " " + I.z), I.w != null && (L += " " + I.w), L)
                    }

                    m.exports.stringify = M;

                    function b(I, L) {
                        return typeof I != "object" || typeof L != "object" ? I === L : I.x === L.x && I.y === L.y && I.z === L.z && I.w === L.w
                    }

                    m.exports.equals = b;

                    function B(I) {
                        return E.test(I)
                    }

                    m.exports.isCoordinates = B, m.exports.isCoordinate = function (I) {
                        return w("`AFRAME.utils.isCoordinate` has been renamed to `AFRAME.utils.isCoordinates`"), B(I)
                    };

                    function R(I) {
                        return I != null && I.constructor === String ? parseFloat(I, 10) : I
                    }

                    m.exports.toVector3 = function (I) {
                        return new THREE.Vector3(I.x, I.y, I.z)
                    }
                },
                "./src/utils/debug.js": (m, x, h) => {
                    var g = h("./node_modules/debug/src/browser.js"),
                        w = h("./src/utils/device.js").isBrowserEnvironment,
                        v = {colors: {debug: "gray", error: "red", info: "gray", warn: "orange"}};
                    g.formatArgs = E;

                    function E(B) {
                        if (B[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + B[0] + (this.useColors ? "%c " : " "), !!this.useColors) {
                            this.color = C(this.namespace);
                            var R = "color: " + this.color;
                            B.splice(1, 0, R, "color: inherit");
                            var I = 0, L = 0;
                            B[0].replace(/%[a-zA-Z%]/g, function (O) {
                                O !== "%%" && (I++, O === "%c" && (L = I))
                            }), B.splice(L, 0, R)
                        }
                    }

                    function p(B) {
                        var R = B.split(":");
                        return R[R.length - 1]
                    }

                    function C(B) {
                        var R = p(B), I = v.colors && v.colors[R];
                        return I || null
                    }

                    function M() {
                        try {
                            return window.localStorage
                        } catch {
                        }
                    }

                    var b = M();
                    b && (parseInt(b.logs, 10) || b.logs === "true") ? g.enable("*") : g.enable("*:error,*:info,*:warn"), w && (window.logs = g), m.exports = g
                },
                "./src/utils/device.js": (m, x, h) => {
                    var g = h("./node_modules/debug/src/browser.js")("device:error"), w, v = !1, E = !1,
                        p = m.exports.isWebXRAvailable = navigator.xr !== void 0;
                    if (window.addEventListener("vrdisplayactivate", function (se) {
                        var pe;
                        p || (pe = document.createElement("canvas"), w = se.display, pe.getContext("webgl", {}), w.requestPresent([{source: pe}]).then(function () {
                        }, function () {
                        }))
                    }), p) {
                        var C = function () {
                            var se = document.querySelector("a-scene");
                            if (!se) {
                                window.addEventListener("DOMContentLoaded", C);
                                return
                            }
                            se.hasLoaded ? se.components["xr-mode-ui"].updateEnterInterfaces() : se.addEventListener("loaded", C)
                        }, M = function (se) {
                            g("WebXR session support error: " + se.message)
                        };
                        navigator.xr.isSessionSupported ? (navigator.xr.isSessionSupported("immersive-vr").then(function (se) {
                            v = se, C()
                        }).catch(M), navigator.xr.isSessionSupported("immersive-ar").then(function (se) {
                            E = se, C()
                        }).catch(function () {
                        })) : navigator.xr.supportsSession ? (navigator.xr.supportsSession("immersive-vr").then(function () {
                            v = !0, C()
                        }).catch(M), navigator.xr.supportsSession("immersive-ar").then(function () {
                            E = !0, C()
                        }).catch(function () {
                        })) : g("WebXR has neither isSessionSupported or supportsSession?!")
                    } else navigator.getVRDisplays && navigator.getVRDisplays().then(function (se) {
                        var pe = document.querySelector("a-scene");
                        w = se.length && se[0], pe && pe.emit("displayconnected", {vrDisplay: w})
                    });

                    function b() {
                        return w
                    }

                    m.exports.getVRDisplay = b;

                    function B() {
                        return v || E || !!b()
                    }

                    m.exports.checkHeadsetConnected = B;

                    function R() {
                        return E
                    }

                    m.exports.checkARSupport = R;

                    function I() {
                        return v
                    }

                    m.exports.checkVRSupport = I;
                    var L = function () {
                        var se = !1;
                        return function (pe) {
                            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(pe) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(pe.substr(0, 4))) && (se = !0), (F() || O() || fe()) && (se = !0), Y() && (se = !1)
                        }(window.navigator.userAgent || window.navigator.vendor || window.opera), function () {
                            return se
                        }
                    }();
                    m.exports.isMobile = L;

                    function O(se) {
                        var pe = se || window.navigator.userAgent,
                            ue = /Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(pe);
                        return ue || N()
                    }

                    m.exports.isTablet = O;

                    function N(se, pe, ue) {
                        var he = se || window.navigator.userAgent, Z = pe || window.navigator.platform,
                            H = ue || window.navigator.maxTouchPoints || 0;
                        return (Z === "iPad" || Z === "MacIntel") && H > 0 && /Macintosh|Intel|iPad|ipad/i.test(he) && !window.MSStream
                    }

                    m.exports.isIpad = N;

                    function F() {
                        return /iPad|iPhone|iPod/.test(window.navigator.platform)
                    }

                    m.exports.isIOS = F;

                    function V() {
                        return !L() && !Y() && window.orientation !== void 0
                    }

                    m.exports.isMobileDeviceRequestingDesktopSite = V;

                    function U() {
                        return /(OculusBrowser)/i.test(window.navigator.userAgent)
                    }

                    m.exports.isOculusBrowser = U;

                    function j() {
                        return /(Mobile VR)/i.test(window.navigator.userAgent)
                    }

                    m.exports.isFirefoxReality = j;

                    function Y() {
                        return U() || j()
                    }

                    m.exports.isMobileVR = Y;

                    function fe() {
                        return /R7 Build/.test(window.navigator.userAgent)
                    }

                    m.exports.isR7 = fe, m.exports.isLandscape = function () {
                        var se = window.orientation;
                        return fe() && (se += 90), se === 90 || se === -90
                    }, m.exports.isBrowserEnvironment = typeof process > "u" || process.browser === !0, m.exports.isNodeEnvironment = !m.exports.isBrowserEnvironment
                },
                "./src/utils/entity.js": (m, x, h) => {
                    var g = h("./src/utils/split.js").split;

                    function w(v, E) {
                        E = E || ".";
                        var p = g(v, E);
                        return p.length === 1 ? p[0] : p
                    }

                    m.exports.getComponentPropertyPath = w, m.exports.getComponentProperty = function (v, E, p) {
                        var C;
                        return p = p || ".", E.indexOf(p) !== -1 ? (C = w(E, p), C.constructor === String ? v.getAttribute(C) : v.getAttribute(C[0])[C[1]]) : v.getAttribute(E)
                    }, m.exports.setComponentProperty = function (v, E, p, C) {
                        var M;
                        if (C = C || ".", E.indexOf(C) !== -1) {
                            M = w(E, C), M.constructor === String ? v.setAttribute(M, p) : v.setAttribute(M[0], M[1], p);
                            return
                        }
                        v.setAttribute(E, p)
                    }
                },
                "./src/utils/forceCanvasResizeSafariMobile.js": m => {
                    m.exports = function (h) {
                        var g = h.style.width, w = h.style.height;
                        h.style.width = parseInt(g, 10) + 1 + "px", h.style.height = parseInt(w, 10) + 1 + "px", setTimeout(function () {
                            h.style.width = g, h.style.height = w
                        }, 200)
                    }
                },
                "./src/utils/index.js": (m, x, h) => {
                    var g = h("./src/utils/debug.js"), w = h("./node_modules/deep-assign/index.js"),
                        v = h("./src/utils/device.js"), E = h("./src/utils/object-pool.js"), p = g("utils:warn");
                    m.exports.bind = function (M) {
                        return M.bind.apply(M, Array.prototype.slice.call(arguments, 1))
                    }, m.exports.coordinates = h("./src/utils/coordinates.js"), m.exports.debug = g, m.exports.device = v, m.exports.entity = h("./src/utils/entity.js"), m.exports.forceCanvasResizeSafariMobile = h("./src/utils/forceCanvasResizeSafariMobile.js"), m.exports.material = h("./src/utils/material.js"), m.exports.objectPool = E, m.exports.split = h("./src/utils/split.js").split, m.exports.styleParser = h("./src/utils/styleParser.js"), m.exports.trackedControls = h("./src/utils/tracked-controls.js"), m.exports.checkHeadsetConnected = function () {
                        return p("`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`"), v.checkHeadsetConnected(arguments)
                    }, m.exports.isGearVR = m.exports.device.isGearVR = function () {
                        p("`utils.isGearVR` has been deprecated, use `utils.device.isMobileVR`")
                    }, m.exports.isIOS = function () {
                        return p("`utils.isIOS` has moved to `utils.device.isIOS`"), v.isIOS(arguments)
                    }, m.exports.isOculusGo = m.exports.device.isOculusGo = function () {
                        p("`utils.isOculusGo` has been deprecated, use `utils.device.isMobileVR`")
                    }, m.exports.isMobile = function () {
                        return p("`utils.isMobile has moved to `utils.device.isMobile`"), v.isMobile(arguments)
                    }, m.exports.throttle = function (M, b, B) {
                        var R;
                        return B && (M = M.bind(B)), function () {
                            var I = Date.now(), L = typeof R > "u" ? b : I - R;
                            (typeof R > "u" || L >= b) && (R = I, M.apply(null, arguments))
                        }
                    }, m.exports.throttleLeadingAndTrailing = function (M, b, B) {
                        var R, I;
                        B && (M = M.bind(B));
                        var L, O = function () {
                            R = Date.now(), M.apply(this, L), I = void 0
                        };
                        return function () {
                            var N = Date.now(), F = typeof R > "u" ? b : N - R;
                            F >= b ? (clearTimeout(I), I = void 0, R = N, M.apply(null, arguments)) : (I = I || setTimeout(O, b - F), L = arguments)
                        }
                    }, m.exports.throttleTick = function (M, b, B) {
                        var R;
                        return B && (M = M.bind(B)), function (I, L) {
                            var O = typeof R > "u" ? L : I - R;
                            (typeof R > "u" || O >= b) && (R = I, M(I, O))
                        }
                    }, m.exports.debounce = function (M, b, B) {
                        var R;
                        return function () {
                            var I = this, L = arguments, O = function () {
                                R = null, B || M.apply(I, L)
                            }, N = B && !R;
                            clearTimeout(R), R = setTimeout(O, b), N && M.apply(I, L)
                        }
                    }, m.exports.extend = Object.assign, m.exports.extendDeep = w, m.exports.clone = function (M) {
                        return JSON.parse(JSON.stringify(M))
                    };
                    var C = function () {
                        var M = E.createPool(function () {
                            return []
                        });
                        return function (b, B) {
                            var R, I, L, O, N, F;
                            if (b === void 0 || B === void 0 || b === null || B === null || !(b && B && b.constructor === Object && B.constructor === Object || b.constructor === Array && B.constructor === Array)) return b === B;
                            I = M.use(), L = M.use(), I.length = 0, L.length = 0;
                            for (R in b) I.push(R);
                            for (R in B) L.push(R);
                            if (I.length !== L.length) return M.recycle(I), M.recycle(L), !1;
                            for (O = 0; O < I.length; ++O) if (N = b[I[O]], F = B[I[O]], typeof N == "object" || typeof F == "object" || Array.isArray(N) && Array.isArray(F)) {
                                if (N === F) continue;
                                if (!C(N, F)) return M.recycle(I), M.recycle(L), !1
                            } else if (N !== F) return M.recycle(I), M.recycle(L), !1;
                            return M.recycle(I), M.recycle(L), !0
                        }
                    }();
                    m.exports.deepEqual = C, m.exports.diff = function () {
                        var M = [];
                        return function (b, B, R) {
                            var I, L, O, N, F, V, U;
                            N = R || {}, M.length = 0;
                            for (F in b) M.push(F);
                            if (!B) return N;
                            for (O in B) M.indexOf(O) === -1 && M.push(O);
                            for (V = 0; V < M.length; V++) F = M[V], I = b[F], L = B[F], U = I && L && I.constructor === Object && L.constructor === Object, (U && !C(I, L) || !U && I !== L) && (N[F] = L);
                            return N
                        }
                    }(), m.exports.shouldCaptureKeyEvent = function (M) {
                        return M.metaKey ? !1 : document.activeElement === document.body
                    }, m.exports.splitString = function (M, b) {
                        typeof b > "u" && (b = " ");
                        var B = new RegExp(b, "g");
                        return M = (M || "").replace(B, b), M.split(b)
                    }, m.exports.getElData = function (M, b) {
                        b = b || {};
                        var B = {};
                        Object.keys(b).forEach(R);

                        function R(I) {
                            M.hasAttribute(I) && (B[I] = M.getAttribute(I))
                        }

                        return B
                    }, m.exports.getUrlParameter = function (M) {
                        M = M.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
                        var b = new RegExp("[\\?&]" + M + "=([^&#]*)"), B = b.exec(location.search);
                        return B === null ? "" : decodeURIComponent(B[1].replace(/\+/g, " "))
                    }, m.exports.isIframed = function () {
                        return window.top !== window.self
                    }, m.exports.findAllScenes = function (M) {
                        for (var b = [], B = M.getElementsByTagName("*"), R = 0, I = B.length; R < I; R++) B[R].isScene && b.push(B[R]);
                        return b
                    }, m.exports.srcLoader = h("./src/utils/src-loader.js")
                },
                "./src/utils/ios-orientationchange-blank-bug.js": () => {
                    window.addEventListener("orientationchange", function () {
                        document.documentElement.style.height = "initial", setTimeout(function () {
                            document.documentElement.style.height = "100%", setTimeout(function () {
                                window.scrollTo(0, 1)
                            }, 500)
                        }, 500)
                    })
                },
                "./src/utils/isIOSOlderThan10.js": m => {
                    m.exports = function (h) {
                        return /(iphone|ipod|ipad).*os.(7_|8_|9_)/i.test(h)
                    }
                },
                "./src/utils/material.js": (m, x, h) => {
                    var g = h("./src/lib/three.js"), w = h("./src/utils/src-loader.js"), v = h("./src/utils/debug.js"),
                        E = v("utils:material:warn"), p = new Set(["emissiveMap", "envMap", "map", "specularMap"]);

                    function C(I, L) {
                        var O = L.offset || {x: 0, y: 0}, N = L.repeat || {x: 1, y: 1}, F = L.npot || !1,
                            V = L.anisotropy || g.Texture.DEFAULT_ANISOTROPY, U = I.wrapS, j = I.wrapT, Y = I.magFilter,
                            fe = I.minFilter;
                        F && (U = g.ClampToEdgeWrapping, j = g.ClampToEdgeWrapping, Y = g.LinearFilter, fe = g.LinearFilter), (N.x !== 1 || N.y !== 1) && (U = g.RepeatWrapping, j = g.RepeatWrapping), I.offset.set(O.x, O.y), I.repeat.set(N.x, N.y), (I.wrapS !== U || I.wrapT !== j || I.magFilter !== Y || I.minFilter !== fe || I.anisotropy !== V) && (I.wrapS = U, I.wrapT = j, I.magFilter = Y, I.minFilter = fe, I.anisotropy = V, I.needsUpdate = !0)
                    }

                    m.exports.setTextureProperties = C, m.exports.updateMapMaterialFromData = function (I, L, O, N) {
                        var F = O.el, V = O.material, U = F.sceneEl.systems.renderer, j = N[L];
                        if (O.materialSrcs || (O.materialSrcs = {}), !j) {
                            delete O.materialSrcs[I], fe(null);
                            return
                        }
                        if (j === O.materialSrcs[I] && V[I]) {
                            C(V[I], N);
                            return
                        }
                        O.materialSrcs[I] = j, j instanceof g.Texture ? fe(j) : F.sceneEl.systems.material.loadTextureSource(j, Y);

                        function Y(se) {
                            if (O.materialSrcs[I] === j) {
                                var pe = V[I];
                                pe && (se === null || !B(pe, se)) && (pe = null), !pe && se && (pe = R(se)), pe && (pe.source !== se && (pe.source = se, pe.needsUpdate = !0), p.has(I) && U.applyColorCorrection(pe), C(pe, N)), fe(pe)
                            }
                        }

                        function fe(se) {
                            V[I] !== se && (V[I] && V[I].dispose(), V[I] = se, V.needsUpdate = !0, b(F, se))
                        }
                    }, m.exports.updateMap = function (I, L) {
                        return m.exports.updateMapMaterialFromData("map", "src", I, L)
                    }, m.exports.updateDistortionMap = function (I, L, O) {
                        var N = I;
                        I === "ambientOcclusion" && (N = "ao");
                        var F = {};
                        return F.src = O[I + "Map"], F.offset = O[I + "TextureOffset"], F.repeat = O[I + "TextureRepeat"], F.wrap = O[I + "TextureWrap"], m.exports.updateMapMaterialFromData(N + "Map", "src", L, F)
                    };
                    var M = {};
                    m.exports.updateEnvMap = function (I, L) {
                        var O = I.material, N = I.el, F = "envMap", V = L.envMap, U = L.sphericalEnvMap, j = L.refract;
                        if (U && (V = U, E("`sphericalEnvMap` property is deprecated, using spherical map as equirectangular map instead. Use `envMap` property with a CubeMap or Equirectangular image instead.")), I.materialSrcs || (I.materialSrcs = {}), !V) {
                            delete I.materialSrcs[F], O.envMap = null, O.needsUpdate = !0;
                            return
                        }
                        if (I.materialSrcs[F] = V, M[V]) {
                            M[V].then(Y);
                            return
                        }
                        M[V] = new Promise(function (fe) {
                            w.validateEnvMapSrc(V, function (pe) {
                                N.sceneEl.systems.material.loadCubeMapTexture(pe, function (ue) {
                                    ue.mapping = j ? g.CubeRefractionMapping : g.CubeReflectionMapping, Y(ue), fe(ue)
                                })
                            }, function (pe) {
                                N.sceneEl.systems.material.loadTexture(pe, {src: pe}, function (ue) {
                                    ue.mapping = j ? g.EquirectangularRefractionMapping : g.EquirectangularReflectionMapping, Y(ue), fe(ue)
                                })
                            })
                        });

                        function Y(fe) {
                            I.materialSrcs[F] === V && (O.envMap = fe, O.needsUpdate = !0, b(N, fe))
                        }
                    };

                    function b(I, L) {
                        if (!L || (I.emit("materialtextureloaded", {
                            src: L.image,
                            texture: L
                        }), !L.image || L.image.tagName !== "VIDEO")) return;
                        L.image.addEventListener("loadeddata", O), L.image.addEventListener("ended", N);

                        function O() {
                            I.emit("materialvideoloadeddata", {src: L.image, texture: L})
                        }

                        function N() {
                            I.emit("materialvideoended", {src: L.image, texture: L})
                        }

                        L.addEventListener("dispose", function () {
                            L.image.removeEventListener("loadeddata", O), L.image.removeEventListener("ended", N)
                        })
                    }

                    m.exports.handleTextureEvents = b;

                    function B(I, L) {
                        return L.data instanceof HTMLCanvasElement ? I.isCanvasTexture : L.data instanceof HTMLVideoElement ? I.isVideoTexture && I.source === L : I.isTexture && !I.isCanvasTexture && !I.isVideoTexture
                    }

                    m.exports.isCompatibleTexture = B;

                    function R(I) {
                        var L;
                        return I.data instanceof HTMLCanvasElement ? L = new g.CanvasTexture : I.data instanceof HTMLVideoElement ? L = new g.VideoTexture(I.data) : L = new g.Texture, L.source = I, L.needsUpdate = !0, L
                    }

                    m.exports.createCompatibleTexture = R
                },
                "./src/utils/math.js": m => {
                    function x(g, w, v) {
                        var E = w.dot(g);
                        return (E - w.dot(v)) / w.length()
                    }

                    function h(g, w, v, E) {
                        var p = x(g, w, v);
                        return E.copy(w), E.multiplyScalar(p), E.add(v), E
                    }

                    m.exports.distanceOfPointFromPlane = x, m.exports.nearestPointInPlane = h
                },
                "./src/utils/object-pool.js": m => {
                    var x = Object.freeze(Object.create(null));

                    function h() {
                        return {}
                    }

                    m.exports.createPool = function (E) {
                        var p = [], C = null;
                        E = E || h;

                        function M() {
                            var I;
                            return (C === null || C === p.length) && B(p.length || 5), I = p[C], p[C++] = x, g(I), I
                        }

                        function b(I) {
                            if (I instanceof Object) {
                                if (C === null || C === -1) {
                                    p[p.length] = I;
                                    return
                                }
                                p[--C] = I
                            }
                        }

                        function B(I) {
                            var L, O;
                            if (I = I === void 0 ? p.length : I, I > 0 && C == null && (C = 0), I > 0) for (L = p.length, p.length += Number(I), O = L; O < p.length; O++) p[O] = E();
                            return p.length
                        }

                        function R() {
                            return p.length
                        }

                        return {grow: B, pool: p, recycle: b, size: R, use: M}
                    };

                    function g(v) {
                        var E;
                        if (!(!v || v.constructor !== Object)) for (E in v) v[E] = void 0
                    }

                    m.exports.clearObject = g;

                    function w(v, E) {
                        var p;
                        if (!(!v || v.constructor !== Object)) for (p in v) p in E || delete v[p]
                    }

                    m.exports.removeUnusedKeys = w
                },
                "./src/utils/split.js": m => {
                    m.exports.split = function () {
                        var x = {};
                        return function (h, g) {
                            return g in x || (x[g] = {}), h in x[g] || (x[g][h] = h.split(g)), x[g][h]
                        }
                    }()
                },
                "./src/utils/src-loader.js": (m, x, h) => {
                    var g = h("./src/utils/debug.js"), w = g("utils:src-loader:warn");

                    function v(R, I, L) {
                        M(R, function (N) {
                            if (N) {
                                I(R);
                                return
                            }
                            L(R)
                        })
                    }

                    function E(R, I, L) {
                        var O, N = "", F, V, U = [];
                        if (typeof R == "string") {
                            let Y = function (fe) {
                                U.push(fe), U.length === 6 && I(U)
                            };
                            for (F = 0; F < 5; F++) N += "(url\\((?:[^\\)]+)\\),\\s*)";
                            if (N += "(url\\((?:[^\\)]+)\\)\\s*)", V = R.match(new RegExp(N)), V) {
                                for (F = 1; F < 7; F++) v(C(V[F]), Y);
                                return
                            }
                            if (!R.startsWith("#")) {
                                var j = C(R);
                                v(j || R, L);
                                return
                            }
                        }
                        if (R.tagName ? O = R : O = B(R), !!O) {
                            if (O.tagName === "A-CUBEMAP" && O.srcs) return I(O.srcs);
                            if (O.tagName === "IMG") return L(O);
                            w('Selector "%s" does not point to <a-cubemap> or <img>', R)
                        }
                    }

                    function p(R, I) {
                        return E(R, I, function () {
                            w("Expected cubemap but got image")
                        })
                    }

                    function C(R) {
                        var I = R.match(/url\((.+)\)/);
                        if (I) return I[1]
                    }

                    function M(R, I) {
                        var L;
                        if (R.tagName) {
                            I(R.tagName === "IMG");
                            return
                        }
                        L = new XMLHttpRequest, L.open("HEAD", R), L.addEventListener("load", function (O) {
                            var N;
                            L.status >= 200 && L.status < 300 ? (N = L.getResponseHeader("Content-Type"), N == null ? b(R, I) : N.startsWith("image") ? I(!0) : I(!1)) : b(R, I), L.abort()
                        }), L.send()
                    }

                    function b(R, I) {
                        var L = new Image;
                        L.addEventListener("load", O);

                        function O() {
                            I(!0)
                        }

                        L.addEventListener("error", N);

                        function N() {
                            I(!1)
                        }

                        L.src = R
                    }

                    function B(R) {
                        try {
                            var I = document.querySelector(R);
                            return I || w('No element was found matching the selector: "%s"', R), I
                        } catch {
                            w('"%s" is not a valid selector', R);
                            return
                        }
                    }

                    m.exports = {parseUrl: C, validateSrc: v, validateCubemapSrc: p, validateEnvMapSrc: E}
                },
                "./src/utils/styleParser.js": m => {
                    var x = /-([a-z])/g;
                    m.exports.parse = function (p, C) {
                        var M;
                        return typeof p != "string" || (M = w(p, C), M[""]) ? p : M
                    }, m.exports.stringify = function (p) {
                        return typeof p == "string" ? p : v(p)
                    };

                    function h(p) {
                        return p.replace(x, E)
                    }

                    m.exports.toCamelCase = h;
                    var g = function () {
                        var p = [], C = /url\([^)]+$/;
                        return function (b) {
                            var B = "", R, I = 0, L = ";";
                            for (p.length = 0; I < b.length;) {
                                if (R = b.indexOf(L, I), R === -1 && (R = b.length), B += b.substring(I, R), C.test(B)) {
                                    B += ";", I = R + 1;
                                    continue
                                }
                                p.push(B.trim()), B = "", I = R + 1
                            }
                            return p
                        }
                    }();

                    function w(p, C) {
                        var M, b, B, R, I, L;
                        for (C = C || {}, M = g(p), b = 0; b < M.length; b++) B = M[b], B && (R = B.indexOf(":"), I = B.substr(0, R).trim(), L = B.substr(R + 1).trim(), C[h(I)] = L);
                        return C
                    }

                    function v(p) {
                        var C, M = 0, b = 0, B = "";
                        for (C in p) M++;
                        for (C in p) B += C + ": " + p[C], b < M - 1 && (B += "; "), b++;
                        return B
                    }

                    function E(p) {
                        return p[1].toUpperCase()
                    }
                },
                "./src/utils/tracked-controls.js": (m, x, h) => {
                    var g = h("./src/constants/index.js").DEFAULT_HANDEDNESS, w = ["x", "y", "z", "w"], v = 2;
                    m.exports.checkControllerPresentAndSetup = function (b, B, R) {
                        var I = b.el, L, O = I.sceneEl.hasWebXR, N = O ? p : E, F;
                        if (L = N(b, B, R), F = !!L, b.controllerPresent && !b.controllerEventsActive && !O && b.addEventListeners(), F === b.controllerPresent) return F;
                        b.controllerPresent = F, F ? (b.addEventListeners(), b.injectTrackedControls(L), I.emit("controllerconnected", {
                            name: b.name,
                            component: b
                        })) : (b.removeEventListeners(), I.emit("controllerdisconnected", {name: b.name, component: b}))
                    };

                    function E(b, B, R) {
                        var I, L = b.el.sceneEl, O, N = R.index || 0;
                        return !B || (O = L && L.systems["tracked-controls-webvr"], !O) || (I = O.controllers, !I.length) ? !1 : !!C(I, null, B, R.hand, N)
                    }

                    function p(b, B, R) {
                        var I, L = b.el.sceneEl, O = L && L.systems["tracked-controls-webxr"];
                        return !O || (I = O.controllers, !I || !I.length) ? !1 : M(I, B, R.hand, R.index, R.iterateControllerProfiles, R.handTracking)
                    }

                    m.exports.isControllerPresentWebVR = E, m.exports.isControllerPresentWebXR = p;

                    function C(b, B, R, I, L) {
                        var O, N, F = 0, V = L >= 0 ? L : 0;
                        for (N = 0; N < b.length; N++) if (O = b[N], !(R && !O.id.startsWith(R)) && !(!R && O.id !== B) && !(I && O.hand && I !== O.hand)) {
                            if (I && !O.hand) V = v * L + (I === g ? 0 : 1); else return O;
                            if (F === V) return O;
                            ++F
                        }
                    }

                    function M(b, B, R, I, L, O) {
                        var N, F, V, U = !1, j, Y;
                        for (N = 0; N < b.length; N++) {
                            if (V = b[N], Y = V.profiles, O) U = V.hand; else if (L) for (F = 0; F < Y.length && (U = Y[F].startsWith(B), !U); F++) ; else U = Y.length > 0 && Y[0].startsWith(B);
                            if (U) {
                                if (j = V.handedness === "right" || V.handedness === "left", j) {
                                    if (V.handedness === R) return b[N]
                                } else if (N === I) return b[N]
                            }
                        }
                    }

                    m.exports.findMatchingControllerWebVR = C, m.exports.findMatchingControllerWebXR = M, m.exports.emitIfAxesChanged = function (b, B, R) {
                        var I, L, O, N, F;
                        for (L in B) {
                            for (I = B[L], O = !1, F = 0; F < I.length; F++) R.detail.changed[I[F]] && (O = !0);
                            if (O) {
                                for (N = {}, F = 0; F < I.length; F++) N[w[F]] = R.detail.axis[I[F]];
                                b.el.emit(L + "moved", N)
                            }
                        }
                    }, m.exports.onButtonEvent = function (b, B, R, I) {
                        var L = I ? R.mapping[I] : R.mapping, O = L.buttons[b];
                        R.el.emit(O + B), R.updateModel && R.updateModel(O, B)
                    }
                },
                "./vendor/DeviceOrientationControls.js": () => {
                    THREE.DeviceOrientationControls = function (m) {
                        var x = this;
                        this.object = m, this.object.rotation.reorder("YXZ"), this.enabled = !0, this.deviceOrientation = {}, this.screenOrientation = 0, this.alphaOffset = 0;
                        var h = function (v) {
                            x.deviceOrientation = v
                        }, g = function () {
                            x.screenOrientation = window.orientation || 0
                        }, w = function () {
                            var v = new THREE.Vector3(0, 0, 1), E = new THREE.Euler, p = new THREE.Quaternion,
                                C = new THREE.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5));
                            return function (M, b, B, R, I) {
                                E.set(B, b, -R, "YXZ"), M.setFromEuler(E), M.multiply(C), M.multiply(p.setFromAxisAngle(v, -I))
                            }
                        }();
                        this.connect = function () {
                            g(), window.addEventListener("orientationchange", g, !1), window.addEventListener("deviceorientation", h, !1), x.enabled = !0
                        }, this.disconnect = function () {
                            window.removeEventListener("orientationchange", g, !1), window.removeEventListener("deviceorientation", h, !1), x.enabled = !1
                        }, this.update = function () {
                            if (x.enabled !== !1) {
                                var v = x.deviceOrientation;
                                if (v) {
                                    var E = v.alpha ? THREE.MathUtils.degToRad(v.alpha) + x.alphaOffset : 0,
                                        p = v.beta ? THREE.MathUtils.degToRad(v.beta) : 0,
                                        C = v.gamma ? THREE.MathUtils.degToRad(v.gamma) : 0,
                                        M = x.screenOrientation ? THREE.MathUtils.degToRad(x.screenOrientation) : 0;
                                    w(x.object.quaternion, E, p, C, M)
                                }
                            }
                        }, this.dispose = function () {
                            x.disconnect()
                        }, this.connect()
                    }
                },
                "./vendor/rStats.extras.js": m => {
                    window.glStats = function () {
                        var x = null, h = 0, g = 0, w = 0, v = 0, E = 0, p = 0, C = 0;

                        function M(F, V) {
                            return function () {
                                V.apply(this, arguments), F.apply(this, arguments)
                            }
                        }

                        WebGLRenderingContext.prototype.drawArrays = M(WebGLRenderingContext.prototype.drawArrays, function () {
                            h++, arguments[0] == this.POINTS ? p += arguments[2] : E += arguments[2]
                        }), WebGLRenderingContext.prototype.drawElements = M(WebGLRenderingContext.prototype.drawElements, function () {
                            g++, v += arguments[1] / 3, E += arguments[1]
                        }), WebGLRenderingContext.prototype.useProgram = M(WebGLRenderingContext.prototype.useProgram, function () {
                            w++
                        }), WebGLRenderingContext.prototype.bindTexture = M(WebGLRenderingContext.prototype.bindTexture, function () {
                            C++
                        });
                        var b = {
                            allcalls: {over: 3e3, caption: "Calls (hook)"},
                            drawelements: {caption: "drawElements (hook)"},
                            drawarrays: {caption: "drawArrays (hook)"}
                        }, B = [{
                            caption: "WebGL",
                            values: ["allcalls", "drawelements", "drawarrays", "useprogram", "bindtexture", "glfaces", "glvertices", "glpoints"]
                        }], R = [{base: "allcalls", steps: ["drawelements", "drawarrays"]}];

                        function I() {
                            x("allcalls").set(h + g), x("drawElements").set(g), x("drawArrays").set(h), x("bindTexture").set(C), x("useProgram").set(w), x("glfaces").set(v), x("glvertices").set(E), x("glpoints").set(p)
                        }

                        function L() {
                            h = 0, g = 0, w = 0, v = 0, E = 0, p = 0, C = 0
                        }

                        function O() {
                        }

                        function N(F) {
                            x = F
                        }

                        return {update: I, start: L, end: O, attach: N, values: b, groups: B, fractions: R}
                    }, window.threeStats = function (x) {
                        var h = null, g = {
                            "renderer.info.memory.geometries": {caption: "Geometries"},
                            "renderer.info.memory.textures": {caption: "Textures"},
                            "renderer.info.programs": {caption: "Programs"},
                            "renderer.info.render.calls": {caption: "Calls"},
                            "renderer.info.render.triangles": {caption: "Triangles", over: 1e3},
                            "renderer.info.render.points": {caption: "Points"}
                        }, w = [{
                            caption: "Three.js - Memory",
                            values: ["renderer.info.memory.geometries", "renderer.info.programs", "renderer.info.memory.textures"]
                        }, {
                            caption: "Three.js - Render",
                            values: ["renderer.info.render.calls", "renderer.info.render.triangles", "renderer.info.render.points"]
                        }], v = [];

                        function E() {
                            h("renderer.info.memory.geometries").set(x.info.memory.geometries), h("renderer.info.programs").set(x.info.programs.length), h("renderer.info.memory.textures").set(x.info.memory.textures), h("renderer.info.render.calls").set(x.info.render.calls), h("renderer.info.render.triangles").set(x.info.render.triangles), h("renderer.info.render.points").set(x.info.render.points)
                        }

                        function p() {
                        }

                        function C() {
                        }

                        function M(b) {
                            h = b
                        }

                        return {update: E, start: p, end: C, attach: M, values: g, groups: w, fractions: v}
                    }, window.BrowserStats = function () {
                        var x = null, h = 0, g = 0;
                        window.performance && !performance.memory && (performance.memory = {
                            usedJSHeapSize: 0,
                            totalJSHeapSize: 0
                        }), performance.memory.totalJSHeapSize === 0 && console.warn("totalJSHeapSize === 0... performance.memory is only available in Chrome .");
                        var w = {
                                memory: {caption: "Used Memory", average: !0, avgMs: 1e3, over: 22},
                                total: {caption: "Total Memory"}
                            }, v = [{caption: "Browser", values: ["memory", "total"]}],
                            E = [{base: "total", steps: ["memory"]}], p = Math.log(1024);

                        function C(I) {
                            var L = 100, O = Math.floor(Math.log(I) / p);
                            return Math.round(I * L / Math.pow(1024, O)) / L
                        }

                        function M() {
                            h = C(performance.memory.usedJSHeapSize), g = C(performance.memory.totalJSHeapSize), x("memory").set(h), x("total").set(g)
                        }

                        function b() {
                            h = 0
                        }

                        function B() {
                        }

                        function R(I) {
                            x = I
                        }

                        return {update: M, start: b, end: B, attach: R, values: w, groups: v, fractions: E}
                    }, m.exports = {
                        glStats: window.glStats,
                        threeStats: window.threeStats,
                        BrowserStats: window.BrowserStats
                    }
                },
                "./vendor/rStats.js": m => {
                    (function () {
                        "performance" in window || (window.performance = {});
                        var x = window.performance;
                        if (!("now" in x)) {
                            var h = Date.now();
                            x.timing && x.timing.navigationStart && (h = x.timing.navigationStart), x.now = function () {
                                return Date.now() - h
                            }
                        }
                        x.mark || (x.mark = function () {
                        }), x.measure || (x.measure = function () {
                        })
                    })(), window.rStats = function (h) {
                        function g(Y, fe) {
                            for (var se = Object.keys(Y), pe = 0, ue = se.length; pe < ue; pe++) fe(se[pe])
                        }

                        function w(Y) {
                            var fe = document.createElement("link");
                            fe.href = Y, fe.rel = "stylesheet", fe.type = "text/css", document.getElementsByTagName("head")[0].appendChild(fe)
                        }

                        var v = h || {}, E = v.colours || ["#850700", "#c74900", "#fcb300", "#284280", "#4c7c0c"],
                            p = "https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300",
                            C = (v.CSSPath ? v.CSSPath : "") + "rStats.css", M = v.css || [p, C];
                        M.forEach(function (Y) {
                            w(Y)
                        }), v.values || (v.values = {});
                        var b, B, R = 10, I = 200, L = {};

                        function O(Y, fe, se) {
                            var pe = se || {}, ue = document.createElement("canvas"), he = ue.getContext("2d"), Z = 0,
                                H = 0, ae = pe.color ? pe.color : "#666666", ee = document.createElement("canvas"),
                                me = ee.getContext("2d");
                            ee.width = 1, ee.height = 2 * R, me.fillStyle = "#444444", me.fillRect(0, 0, 1, 2 * R), me.fillStyle = ae, me.fillRect(0, R, 1, R), me.fillStyle = "#ffffff", me.globalAlpha = .5, me.fillRect(0, R, 1, 1), me.globalAlpha = 1;
                            var Re = document.createElement("canvas"), ke = Re.getContext("2d");
                            Re.width = 1, Re.height = 2 * R, ke.fillStyle = "#444444", ke.fillRect(0, 0, 1, 2 * R), ke.fillStyle = "#b70000", ke.fillRect(0, R, 1, R), ke.globalAlpha = .5, ke.fillStyle = "#ffffff", ke.fillRect(0, R, 1, 1), ke.globalAlpha = 1;

                            function Ve() {
                                ue.width = I, ue.height = R, ue.style.width = ue.width + "px", ue.style.height = ue.height + "px", ue.className = "rs-canvas", Y.appendChild(ue), he.fillStyle = "#444444", he.fillRect(0, 0, ue.width, ue.height)
                            }

                            function He(ot, gt) {
                                H += (ot - H) * .1, Z *= .99, H > Z && (Z = H), he.drawImage(ue, 1, 0, ue.width - 1, ue.height, 0, 0, ue.width - 1, ue.height), gt ? he.drawImage(Re, ue.width - 1, ue.height - H * ue.height / Z - R) : he.drawImage(ee, ue.width - 1, ue.height - H * ue.height / Z - R)
                            }

                            return Ve(), {draw: He}
                        }

                        function N(Y, fe) {
                            var se = document.createElement("canvas"), pe = se.getContext("2d");

                            function ue() {
                                se.width = I, se.height = R * fe, se.style.width = se.width + "px", se.style.height = se.height + "px", se.className = "rs-canvas", Y.appendChild(se), pe.fillStyle = "#444444", pe.fillRect(0, 0, se.width, se.height)
                            }

                            function he(Z) {
                                pe.drawImage(se, 1, 0, se.width - 1, se.height, 0, 0, se.width - 1, se.height);
                                var H = 0;
                                g(Z, function (ae) {
                                    var ee = Z[ae] * se.height;
                                    pe.fillStyle = E[ae], pe.fillRect(se.width - 1, H, 1, ee), H += ee
                                })
                            }

                            return ue(), {draw: he}
                        }

                        function F(Y, fe) {
                            var se = Y, pe, ue = 0, he = 0, Z = 0, H = 0, ae = performance.now(), ee = 0,
                                me = document.createElement("div"), Re = document.createElement("span"),
                                ke = document.createElement("div"), Ve = document.createTextNode(""),
                                He = v ? v.values[se.toLowerCase()] : null, ot = new O(me, se, He), gt = !1;
                            Re.className = "rs-counter-id", Re.textContent = He && He.caption ? He.caption : se, ke.className = "rs-counter-value", ke.appendChild(Ve), me.appendChild(Re), me.appendChild(ke), fe ? fe.div.appendChild(me) : B.appendChild(me), pe = performance.now();

                            function Bt(hi) {
                                if (He && He.average) {
                                    H += hi, ee++;
                                    var Vn = performance.now();
                                    Vn - ae >= (He.avgMs || 1e3) && (Z = H / ee, H = 0, ae = Vn, ee = 0)
                                }
                            }

                            function Rt() {
                                pe = performance.now(), v.userTimingAPI && performance.mark(se + "-start"), gt = !0
                            }

                            function an() {
                                ue = performance.now() - pe, v.userTimingAPI && (performance.mark(se + "-end"), gt && performance.measure(se, se + "-start", se + "-end")), Bt(ue)
                            }

                            function En() {
                                an(), Rt()
                            }

                            function Nn() {
                                var hi = He && He.average ? Z : ue;
                                Ve.nodeValue = Math.round(hi * 100) / 100;
                                var Vn = He && (He.below && ue < He.below || He.over && ue > He.over);
                                ot.draw(ue, Vn), me.className = Vn ? "rs-counter-base alarm" : "rs-counter-base"
                            }

                            function oi() {
                                var hi = performance.now(), Vn = hi - pe;
                                he++, Vn > 1e3 && (He && He.interpolate === !1 ? ue = he : ue = he * 1e3 / Vn, he = 0, pe = hi, Bt(ue))
                            }

                            function pi(hi) {
                                ue = hi, Bt(ue)
                            }

                            return {
                                set: pi, start: Rt, tick: En, end: an, frame: oi, value: function () {
                                    return ue
                                }, draw: Nn
                            }
                        }

                        function V(Y) {
                            var fe = Y.toLowerCase();
                            if (fe === void 0 && (fe = "default"), L[fe]) return L[fe];
                            var se = null;
                            v && v.groups && g(v.groups, function (ue) {
                                var he = v.groups[parseInt(ue, 10)];
                                !se && he.values.indexOf(fe.toLowerCase()) !== -1 && (se = he)
                            });
                            var pe = new F(fe, se);
                            return L[fe] = pe, pe
                        }

                        function U() {
                            if (v.plugins) {
                                v.values || (v.values = {}), v.groups || (v.groups = []), v.fractions || (v.fractions = []);
                                for (var Y = 0; Y < v.plugins.length; Y++) v.plugins[Y].attach(V), g(v.plugins[Y].values, function (fe) {
                                    v.values[fe] = v.plugins[Y].values[fe]
                                }), v.groups = v.groups.concat(v.plugins[Y].groups), v.fractions = v.fractions.concat(v.plugins[Y].fractions)
                            } else v.plugins = {};
                            b = document.createElement("div"), b.className = "rs-base", B = document.createElement("div"), B.className = "rs-container", B.style.height = "auto", b.appendChild(B), document.body.appendChild(b), v && (v.groups && g(v.groups, function (fe) {
                                var se = v.groups[parseInt(fe, 10)], pe = document.createElement("div");
                                pe.className = "rs-group", se.div = pe;
                                var ue = document.createElement("h1");
                                ue.textContent = se.caption, ue.addEventListener("click", (function (he) {
                                    this.classList.toggle("hidden"), he.preventDefault()
                                }).bind(pe)), B.appendChild(ue), B.appendChild(pe)
                            }), v.fractions && g(v.fractions, function (fe) {
                                var se = v.fractions[parseInt(fe, 10)], pe = document.createElement("div");
                                pe.className = "rs-fraction";
                                var ue = document.createElement("div");
                                ue.className = "rs-legend";
                                var he = 0;
                                g(v.fractions[fe].steps, function (H) {
                                    var ae = document.createElement("p");
                                    ae.textContent = v.fractions[fe].steps[H], ae.style.color = E[he], ue.appendChild(ae), he++
                                }), pe.appendChild(ue), pe.style.height = he * R + "px", se.div = pe;
                                var Z = new N(pe, he);
                                se.graph = Z, B.appendChild(pe)
                            }))
                        }

                        function j() {
                            g(v.plugins, function (Y) {
                                v.plugins[Y].update()
                            }), g(L, function (Y) {
                                L[Y].draw()
                            }), v && v.fractions && g(v.fractions, function (Y) {
                                var fe = v.fractions[parseInt(Y, 10)], se = [], pe = L[fe.base.toLowerCase()];
                                pe && (pe = pe.value(), g(v.fractions[Y].steps, function (ue) {
                                    var he = v.fractions[Y].steps[parseInt(ue, 10)].toLowerCase(), Z = L[he];
                                    Z && se.push(Z.value() / pe)
                                })), fe.graph.draw(se)
                            })
                        }

                        return U(), function (Y) {
                            return Y ? V(Y) : {element: b, update: j}
                        }
                    }, m.exports = window.rStats
                },
                "./vendor/wakelock/util.js": m => {
                    var x = {};
                    x.base64 = function (h, g) {
                        return "data:" + h + ";base64," + g
                    }, x.isMobile = function () {
                        var h = !1;
                        return function (g) {
                            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(g) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(g.substr(0, 4))) && (h = !0)
                        }(navigator.userAgent || navigator.vendor || window.opera), h
                    }, x.isIOS = function () {
                        return /(iPad|iPhone|iPod)/g.test(navigator.userAgent)
                    }, x.isIFrame = function () {
                        try {
                            return window.self !== window.top
                        } catch {
                            return !0
                        }
                    }, x.appendQueryParameter = function (h, g, w) {
                        var v = h.indexOf("?") < 0 ? "?" : "&";
                        return h += v + g + "=" + w, h
                    }, x.getQueryParameter = function (h) {
                        h = h.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
                        var g = new RegExp("[\\?&]" + h + "=([^&#]*)"), w = g.exec(location.search);
                        return w === null ? "" : decodeURIComponent(w[1].replace(/\+/g, " "))
                    }, x.isLandscapeMode = function () {
                        return window.orientation == 90 || window.orientation == -90
                    }, m.exports = x
                },
                "./vendor/wakelock/wakelock.js": (m, x, h) => {
                    var g = h("./vendor/wakelock/util.js");

                    function w() {
                        var p = document.createElement("video");
                        p.addEventListener("ended", function () {
                            p.play()
                        }), this.request = function () {
                            p.paused && (p.src = g.base64("video/webm", "GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw=="), p.play())
                        }, this.release = function () {
                            p.pause(), p.src = ""
                        }
                    }

                    function v() {
                        var p = null;
                        this.request = function () {
                            p || (p = setInterval(function () {
                                window.location.href = "/", setTimeout(window.stop, 0)
                            }, 15e3))
                        }, this.release = function () {
                            p && (clearInterval(p), p = null)
                        }
                    }

                    function E() {
                        var p = navigator.userAgent || navigator.vendor || window.opera;
                        return p.match(/iPhone/i) || p.match(/iPod/i) ? v : w
                    }

                    m.exports = E()
                },
                "./node_modules/css-loader/dist/cjs.js!./src/style/aframe.css": (m, x, h) => {
                    h.r(x), h.d(x, {default: () => j});
                    var g = h("./node_modules/css-loader/dist/runtime/sourceMaps.js"), w = h.n(g),
                        v = h("./node_modules/css-loader/dist/runtime/api.js"), E = h.n(v),
                        p = h("./node_modules/css-loader/dist/runtime/getUrl.js"), C = h.n(p),
                        M = new URL(h("data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"), h.b),
                        b = new URL(h("data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"), h.b),
                        B = new URL(h("data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E"), h.b),
                        R = new URL(h("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E"), h.b),
                        I = new URL(h("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E"), h.b),
                        L = E()(w()), O = C()(M), N = C()(b), F = C()(B), V = C()(R), U = C()(I);
                    L.push([m.id, `/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url(` + O + `) 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url(` + N + `) 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url(` + F + `);
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(` + V + `) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(` + U + `) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`, "", {
                        version: 3,
                        sources: ["webpack://./src/style/aframe.css"],
                        names: [],
                        mappings: "AAAA,sCAAsC;AACtC;EACE,SAAS;EACT,OAAO;EACP,eAAe;EACf,QAAQ;EACR,MAAM;AACR;;AAEA;EACE,YAAY;EACZ,SAAS;EACT,gBAAgB;EAChB,UAAU;EACV,WAAW;AACb;;AAEA,oDAAoD;AACpD;EACE,sBAAsB;EACtB,uBAAuB;EACvB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;AAC5B;;AAEA;;EAEE,UAAU;EACV,WAAW;AACb;;AAEA;EACE,WAAW;AACb;;AAEA,gEAAgE;AAChE;EACE,6BAA6B;AAC/B;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,YAAY;EACZ,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,WAAW;AACb;;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;AACtB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,yBAAyB;EACzB,eAAe;EACf,SAAS;EACT,QAAQ;EACR,iBAAiB;EACjB,WAAW;EACX,qBAAqB;EACrB,eAAe;EACf,8BAA8B;EAC9B,kBAAkB;EAClB,cAAc;EACd,YAAY;AACd;;AAEA,+BAA+B;AAC/B,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;;AAErE;EACE,sCAAsC;EACtC,8CAA8C;AAChD;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,YAAY;EACZ,WAAW;AACb;;AAEA;;;;EAIE,aAAa;AACf;;AAEA;;EAEE,0DAA0D;AAC5D;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,qBAAqB;EACrB,6BAA6B;AAC/B;;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE,kCAAkC;EAClC,eAAe;EACf,WAAW;EACX,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;AACb;;AAEA;;;EAGE,WAAW;EACX,iBAAiB;EACjB,aAAa;AACf;;AAEA;EACE,yFAA4qB;AAC9qB;;AAEA;EACE,yFAAkzB;AACpzB;;AAEA;EACE,yDAA2qK;AAC7qK;;AAEA;;EAEE,wBAAwB;EACxB,SAAS;EACT,SAAS;EACT,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB;;;;GAIC;EACD,gBAAgB;EAChB,cAAc;EACd,kBAAkB;EAClB,QAAQ;EACR,sCAAsC;EACtC,8CAA8C;EAC9C,aAAa;EACb,kBAAkB;EAClB,0BAA0B,EAAE,8CAA8C;AAC5E;;AAEA;EACE,yBAAyB;EACzB,kBAAkB;AACpB;;AAEA;;;;EAIE,yBAAyB;AAC3B;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,sBAAsB;EACtB,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,qCAAqC;EACrC,4BAA4B;EAC5B,kCAAkC;EAClC,qBAAqB;EACrB,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,QAAQ;EACR,SAAS;AACX;;AAEA;;EAEE,eAAe;AACjB;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,2FAAivF;EACjvF,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,8CAA8C;EAC9C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,QAAQ;EACR,2BAA2B;EAC3B,WAAW;AACb;;AAEA;EACE,6DAA25B;EAC35B,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,WAAW;AACb;;AAEA;EACE,oCAAoC;EACpC,kCAAkC;EAClC,kBAAkB;EAClB,eAAe;EACf,YAAY;EACZ,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,SAAS;EACT,QAAQ;EACR,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,+BAA+B;EAC/B,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gCAAgC;EAChC,eAAe;EACf,YAAY;EACZ,aAAa;EACb,wBAAwB;EACxB,uBAAuB;EACvB,kCAAkC;EAClC,eAAe;EACf,kBAAkB;EAClB,YAAY;AACd;;AAEA;EACE,WAAW;EACX,WAAW;EACX,sBAAsB;EACtB,aAAa;EACb,uBAAuB;EACvB,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;EACnB,eAAe;EACf,WAAW;AACb;;AAEA;EACE,oBAAoB;EACpB,oBAAoB;EACpB,WAAW;EACX,WAAW;AACb;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,UAAU;EACV,eAAe;EACf,WAAW;EACX,kBAAkB;EAClB,iBAAiB;EACjB,YAAY;EACZ,qBAAqB;EACrB,yCAAyC;EACzC,iCAAiC;EACjC,wEAAwE;EACxE,iBAAiB;AACnB;;AAEA;EACE,mEAAmE;AACrE;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;EACzB,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,oBAAoB;EACpB,sBAAsB;EACtB,SAAS;EACT,OAAO;EACP,QAAQ;EACR,MAAM;EACN,YAAY;AACd;;AAEA;EACE,oBAAoB;AACtB",
                        sourcesContent: [`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z' fill='%23fff'/%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z' fill='%23fff'/%3E%3Cpath d='M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z' fill='%23fff'/%3E%3Cpath d='M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg width='108' height='62' viewBox='0 0 108 62' version='1.1' id='svg320' sodipodi:docname='fullscreen-aframe.svg' xml:space='preserve' inkscape:version='1.2.1 (9c6d41e  2022-07-14)' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:cc='http://creativecommons.org/ns%23' xmlns:dc='http://purl.org/dc/elements/1.1/'%3E%3Cdefs id='defs324' /%3E%3Csodipodi:namedview id='namedview322' pagecolor='%23ffffff' bordercolor='%23000000' borderopacity='0.25' inkscape:showpageshadow='2' inkscape:pageopacity='0.0' inkscape:pagecheckerboard='0' inkscape:deskcolor='%23d1d1d1' showgrid='false' inkscape:zoom='3.8064516' inkscape:cx='91.423729' inkscape:cy='-1.4449153' inkscape:window-width='1440' inkscape:window-height='847' inkscape:window-x='32' inkscape:window-y='25' inkscape:window-maximized='0' inkscape:current-layer='svg320' /%3E%3Ctitle id='title312'%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z' fill='%23fff' id='path314' style='fill:%23ffffff' /%3E%3Cg id='g356' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g358' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g360' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g362' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g364' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g366' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g368' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g370' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g372' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g374' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g376' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g378' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g380' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g382' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g384' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cmetadata id='metadata561'%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=''%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d='m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4' id='path596' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4' id='path598' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4' id='path600' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616' id='path602' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3C/svg%3E");
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`],
                        sourceRoot: ""
                    }]);
                    const j = L
                },
                "./node_modules/css-loader/dist/cjs.js!./src/style/rStats.css": (m, x, h) => {
                    h.r(x), h.d(x, {default: () => C});
                    var g = h("./node_modules/css-loader/dist/runtime/sourceMaps.js"), w = h.n(g),
                        v = h("./node_modules/css-loader/dist/runtime/api.js"), E = h.n(v), p = E()(w());
                    p.push([m.id, `.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`, "", {
                        version: 3,
                        sources: ["webpack://./src/style/rStats.css"],
                        names: [],
                        mappings: "AAAA;EACE,sBAAsB;EACtB,cAAc;EACd,gBAAgB;EAChB,oBAAoB;EACpB,SAAS;EACT,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,eAAe;EACf,QAAQ;EACR,YAAY;EACZ,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;EACX,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,sCAAsC;EACtC,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,YAAY;EACZ,sCAAsC;EACtC,8BAA8B;EAC9B,aAAa;AACf;;AAEA;EACE,cAAc;EACd;;;;;;;;2BAQyB;AAC3B;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,iBAAiB;EACjB,WAAW;AACb;;AAEA;EACE,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;AACV;;AAEA;EACE;IACE,UAAU;IACV,SAAS;EACX;AACF",
                        sourcesContent: [`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`],
                        sourceRoot: ""
                    }]);
                    const C = p
                },
                "./src/style/aframe.css": (m, x, h) => {
                    h.r(x), h.d(x, {default: () => F});
                    var g = h("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"), w = h.n(g),
                        v = h("./node_modules/style-loader/dist/runtime/styleDomAPI.js"), E = h.n(v),
                        p = h("./node_modules/style-loader/dist/runtime/insertBySelector.js"), C = h.n(p),
                        M = h("./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"), b = h.n(M),
                        B = h("./node_modules/style-loader/dist/runtime/insertStyleElement.js"), R = h.n(B),
                        I = h("./node_modules/style-loader/dist/runtime/styleTagTransform.js"), L = h.n(I),
                        O = h("./node_modules/css-loader/dist/cjs.js!./src/style/aframe.css"), N = {};
                    N.styleTagTransform = L(), N.setAttributes = b(), N.insert = C().bind(null, "head"), N.domAPI = E(), N.insertStyleElement = R(), w()(O.default, N);
                    const F = O.default && O.default.locals ? O.default.locals : void 0
                },
                "./src/style/rStats.css": (m, x, h) => {
                    h.r(x), h.d(x, {default: () => F});
                    var g = h("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"), w = h.n(g),
                        v = h("./node_modules/style-loader/dist/runtime/styleDomAPI.js"), E = h.n(v),
                        p = h("./node_modules/style-loader/dist/runtime/insertBySelector.js"), C = h.n(p),
                        M = h("./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"), b = h.n(M),
                        B = h("./node_modules/style-loader/dist/runtime/insertStyleElement.js"), R = h.n(B),
                        I = h("./node_modules/style-loader/dist/runtime/styleTagTransform.js"), L = h.n(I),
                        O = h("./node_modules/css-loader/dist/cjs.js!./src/style/rStats.css"), N = {};
                    N.styleTagTransform = L(), N.setAttributes = b(), N.insert = C().bind(null, "head"), N.domAPI = E(), N.insertStyleElement = R(), w()(O.default, N);
                    const F = O.default && O.default.locals ? O.default.locals : void 0
                },
                "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js": m => {
                    var x = [];

                    function h(v) {
                        for (var E = -1, p = 0; p < x.length; p++) if (x[p].identifier === v) {
                            E = p;
                            break
                        }
                        return E
                    }

                    function g(v, E) {
                        for (var p = {}, C = [], M = 0; M < v.length; M++) {
                            var b = v[M], B = E.base ? b[0] + E.base : b[0], R = p[B] || 0,
                                I = "".concat(B, " ").concat(R);
                            p[B] = R + 1;
                            var L = h(I), O = {css: b[1], media: b[2], sourceMap: b[3], supports: b[4], layer: b[5]};
                            if (L !== -1) x[L].references++, x[L].updater(O); else {
                                var N = w(O, E);
                                E.byIndex = M, x.splice(M, 0, {identifier: I, updater: N, references: 1})
                            }
                            C.push(I)
                        }
                        return C
                    }

                    function w(v, E) {
                        var p = E.domAPI(E);
                        p.update(v);
                        var C = function (b) {
                            if (b) {
                                if (b.css === v.css && b.media === v.media && b.sourceMap === v.sourceMap && b.supports === v.supports && b.layer === v.layer) return;
                                p.update(v = b)
                            } else p.remove()
                        };
                        return C
                    }

                    m.exports = function (v, E) {
                        E = E || {}, v = v || [];
                        var p = g(v, E);
                        return function (M) {
                            M = M || [];
                            for (var b = 0; b < p.length; b++) {
                                var B = p[b], R = h(B);
                                x[R].references--
                            }
                            for (var I = g(M, E), L = 0; L < p.length; L++) {
                                var O = p[L], N = h(O);
                                x[N].references === 0 && (x[N].updater(), x.splice(N, 1))
                            }
                            p = I
                        }
                    }
                },
                "./node_modules/style-loader/dist/runtime/insertBySelector.js": m => {
                    var x = {};

                    function h(w) {
                        if (typeof x[w] > "u") {
                            var v = document.querySelector(w);
                            if (window.HTMLIFrameElement && v instanceof window.HTMLIFrameElement) try {
                                v = v.contentDocument.head
                            } catch {
                                v = null
                            }
                            x[w] = v
                        }
                        return x[w]
                    }

                    function g(w, v) {
                        var E = h(w);
                        if (!E) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                        E.appendChild(v)
                    }

                    m.exports = g
                },
                "./node_modules/style-loader/dist/runtime/insertStyleElement.js": m => {
                    function x(h) {
                        var g = document.createElement("style");
                        return h.setAttributes(g, h.attributes), h.insert(g, h.options), g
                    }

                    m.exports = x
                },
                "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js": (m, x, h) => {
                    function g(w) {
                        var v = h.nc;
                        v && w.setAttribute("nonce", v)
                    }

                    m.exports = g
                },
                "./node_modules/style-loader/dist/runtime/styleDomAPI.js": m => {
                    function x(w, v, E) {
                        var p = "";
                        E.supports && (p += "@supports (".concat(E.supports, ") {")), E.media && (p += "@media ".concat(E.media, " {"));
                        var C = typeof E.layer < "u";
                        C && (p += "@layer".concat(E.layer.length > 0 ? " ".concat(E.layer) : "", " {")), p += E.css, C && (p += "}"), E.media && (p += "}"), E.supports && (p += "}");
                        var M = E.sourceMap;
                        M && typeof btoa < "u" && (p += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(M)))), " */")), v.styleTagTransform(p, w, v.options)
                    }

                    function h(w) {
                        if (w.parentNode === null) return !1;
                        w.parentNode.removeChild(w)
                    }

                    function g(w) {
                        if (typeof document > "u") return {
                            update: function () {
                            }, remove: function () {
                            }
                        };
                        var v = w.insertStyleElement(w);
                        return {
                            update: function (p) {
                                x(v, w, p)
                            }, remove: function () {
                                h(v)
                            }
                        }
                    }

                    m.exports = g
                },
                "./node_modules/style-loader/dist/runtime/styleTagTransform.js": m => {
                    function x(h, g) {
                        if (g.styleSheet) g.styleSheet.cssText = h; else {
                            for (; g.firstChild;) g.removeChild(g.firstChild);
                            g.appendChild(document.createTextNode(h))
                        }
                    }

                    m.exports = x
                },
                "data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E": m => {
                    m.exports = "data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E"
                },
                "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E": m => {
                    m.exports = "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"
                },
                "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E": m => {
                    m.exports = "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"
                },
                "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E": m => {
                    m.exports = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E"
                },
                "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E": m => {
                    m.exports = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E"
                },
                "./node_modules/three/build/three.module.js": (m, x, h) => {
                    h.r(x), h.d(x, {
                        ACESFilmicToneMapping: () => jt,
                        AddEquation: () => se,
                        AddOperation: () => Br,
                        AdditiveAnimationBlendMode: () => gi,
                        AdditiveBlending: () => U,
                        AgXToneMapping: () => _e,
                        AlphaFormat: () => Qo,
                        AlwaysCompare: () => Wh,
                        AlwaysDepth: () => pi,
                        AlwaysStencilFunc: () => Uu,
                        AmbientLight: () => Ax,
                        AnimationAction: () => Lx,
                        AnimationClip: () => Qp,
                        AnimationLoader: () => dM,
                        AnimationMixer: () => GM,
                        AnimationObjectGroup: () => UM,
                        AnimationUtils: () => lM,
                        ArcCurve: () => LE,
                        ArrayCamera: () => pv,
                        ArrowHelper: () => c3,
                        AttachedBindMode: () => Le,
                        Audio: () => Ix,
                        AudioAnalyser: () => IM,
                        AudioContext: () => Xv,
                        AudioListener: () => MM,
                        AudioLoader: () => wM,
                        AxesHelper: () => u3,
                        BackSide: () => O,
                        BasicDepthPacking: () => ha,
                        BasicShadowMap: () => b,
                        BatchedMesh: () => wE,
                        Bone: () => Ev,
                        BooleanKeyframeTrack: () => Ch,
                        Box2: () => YM,
                        Box3: () => Ei,
                        Box3Helper: () => a3,
                        BoxGeometry: () => ma,
                        BoxHelper: () => o3,
                        BufferAttribute: () => Er,
                        BufferGeometry: () => Ti,
                        BufferGeometryLoader: () => xx,
                        ByteType: () => $s,
                        Cache: () => Rc,
                        Camera: () => Xa,
                        CameraHelper: () => s3,
                        CanvasTexture: () => L_,
                        CapsuleGeometry: () => og,
                        CatmullRomCurve3: () => DE,
                        CineonToneMapping: () => ir,
                        CircleGeometry: () => ag,
                        ClampToEdgeWrapping: () => tt,
                        Clock: () => Mx,
                        Color: () => Bn,
                        ColorKeyframeTrack: () => Vv,
                        ColorManagement: () => ur,
                        CompressedArrayTexture: () => R_,
                        CompressedCubeTexture: () => B_,
                        CompressedTexture: () => ng,
                        CompressedTextureLoader: () => fM,
                        ConeGeometry: () => lg,
                        ConstantAlphaFactor: () => En,
                        ConstantColorFactor: () => Rt,
                        CubeCamera: () => Mm,
                        CubeReflectionMapping: () => oe,
                        CubeRefractionMapping: () => G,
                        CubeTexture: () => ys,
                        CubeTextureLoader: () => pM,
                        CubeUVReflectionMapping: () => Be,
                        CubicBezierCurve: () => Rv,
                        CubicBezierCurve3: () => OE,
                        CubicInterpolant: () => sx,
                        CullFaceBack: () => p,
                        CullFaceFront: () => C,
                        CullFaceFrontBack: () => M,
                        CullFaceNone: () => E,
                        Curve: () => ml,
                        CurvePath: () => FE,
                        CustomBlending: () => fe,
                        CustomToneMapping: () => Se,
                        CylinderGeometry: () => Nd,
                        Cylindrical: () => XM,
                        Data3DTexture: () => Mi,
                        DataArrayTexture: () => Tl,
                        DataTexture: () => uu,
                        DataTextureLoader: () => mM,
                        DataUtils: () => Ff,
                        DecrementStencilOp: () => pf,
                        DecrementWrapStencilOp: () => Fu,
                        DefaultLoadingManager: () => lx,
                        DepthFormat: () => dt,
                        DepthStencilFormat: () => Lt,
                        DepthTexture: () => uh,
                        DetachedBindMode: () => Ue,
                        DirectionalLight: () => mx,
                        DirectionalLightHelper: () => r3,
                        DiscreteInterpolant: () => ox,
                        DisplayP3ColorSpace: () => bl,
                        DodecahedronGeometry: () => cg,
                        DoubleSide: () => N,
                        DstAlphaFactor: () => Ve,
                        DstColorFactor: () => ot,
                        DynamicCopyUsage: () => bf,
                        DynamicDrawUsage: () => yf,
                        DynamicReadUsage: () => Kh,
                        EdgesGeometry: () => NE,
                        EllipseCurve: () => ig,
                        EqualCompare: () => Vh,
                        EqualDepth: () => yi,
                        EqualStencilFunc: () => mf,
                        EquirectangularReflectionMapping: () => X,
                        EquirectangularRefractionMapping: () => ve,
                        Euler: () => bo,
                        EventDispatcher: () => Ss,
                        ExtrudeGeometry: () => Ag,
                        FileLoader: () => Lc,
                        Float16BufferAttribute: () => tu,
                        Float32BufferAttribute: () => Xn,
                        FloatType: () => kr,
                        Fog: () => UA,
                        FogExp2: () => NA,
                        FramebufferTexture: () => I_,
                        FrontSide: () => L,
                        Frustum: () => Ec,
                        GLBufferAttribute: () => jM,
                        GLSL1: () => Mf,
                        GLSL3: () => zu,
                        GreaterCompare: () => Hh,
                        GreaterDepth: () => Oi,
                        GreaterEqualCompare: () => jh,
                        GreaterEqualDepth: () => nr,
                        GreaterEqualStencilFunc: () => vf,
                        GreaterStencilFunc: () => gf,
                        GridHelper: () => n3,
                        Group: () => mh,
                        HalfFloatType: () => Hi,
                        HemisphereLight: () => cx,
                        HemisphereLightHelper: () => t3,
                        IcosahedronGeometry: () => gg,
                        ImageBitmapLoader: () => CM,
                        ImageLoader: () => jp,
                        ImageUtils: () => ul,
                        IncrementStencilOp: () => tc,
                        IncrementWrapStencilOp: () => ku,
                        InstancedBufferAttribute: () => Od,
                        InstancedBufferGeometry: () => Ex,
                        InstancedInterleavedBuffer: () => QM,
                        InstancedMesh: () => EE,
                        Int16BufferAttribute: () => qu,
                        Int32BufferAttribute: () => _m,
                        Int8BufferAttribute: () => $c,
                        IntType: () => Eo,
                        InterleavedBuffer: () => zA,
                        InterleavedBufferAttribute: () => gh,
                        Interpolant: () => Gp,
                        InterpolateDiscrete: () => gn,
                        InterpolateLinear: () => un,
                        InterpolateSmooth: () => _n,
                        InvertStencilOp: () => nc,
                        KeepStencilOp: () => Bo,
                        KeyframeTrack: () => Al,
                        LOD: () => uE,
                        LatheGeometry: () => Op,
                        Layers: () => hl,
                        LessCompare: () => Gh,
                        LessDepth: () => hi,
                        LessEqualCompare: () => jc,
                        LessEqualDepth: () => Vn,
                        LessEqualStencilFunc: () => Af,
                        LessStencilFunc: () => Uh,
                        Light: () => pu,
                        LightProbe: () => yx,
                        Line: () => du,
                        Line3: () => qM,
                        LineBasicMaterial: () => oa,
                        LineCurve: () => Bv,
                        LineCurve3: () => kE,
                        LineDashedMaterial: () => nx,
                        LineLoop: () => TE,
                        LineSegments: () => Ql,
                        LinearDisplayP3ColorSpace: () => ka,
                        LinearFilter: () => qn,
                        LinearInterpolant: () => Gv,
                        LinearMipMapLinearFilter: () => co,
                        LinearMipMapNearestFilter: () => Vi,
                        LinearMipmapLinearFilter: () => Zi,
                        LinearMipmapNearestFilter: () => fr,
                        LinearSRGBColorSpace: () => Gs,
                        LinearToneMapping: () => ss,
                        LinearTransfer: () => _l,
                        Loader: () => ga,
                        LoaderUtils: () => Kv,
                        LoadingManager: () => Hv,
                        LoopOnce: () => Jt,
                        LoopPingPong: () => Pt,
                        LoopRepeat: () => sn,
                        LuminanceAlphaFormat: () => Ct,
                        LuminanceFormat: () => rt,
                        MOUSE: () => w,
                        Material: () => Dr,
                        MaterialLoader: () => bg,
                        MathUtils: () => Lf,
                        Matrix3: () => ai,
                        Matrix4: () => Mn,
                        MaxEquation: () => Z,
                        Mesh: () => Wr,
                        MeshBasicMaterial: () => gr,
                        MeshDepthMaterial: () => dv,
                        MeshDistanceMaterial: () => fv,
                        MeshLambertMaterial: () => ex,
                        MeshMatcapMaterial: () => tx,
                        MeshNormalMaterial: () => $E,
                        MeshPhongMaterial: () => JE,
                        MeshPhysicalMaterial: () => qE,
                        MeshStandardMaterial: () => Nv,
                        MeshToonMaterial: () => ZE,
                        MinEquation: () => he,
                        MirroredRepeatWrapping: () => Yt,
                        MixOperation: () => Pi,
                        MultiplyBlending: () => Y,
                        MultiplyOperation: () => Ji,
                        NearestFilter: () => cn,
                        NearestMipMapLinearFilter: () => Gi,
                        NearestMipMapNearestFilter: () => en,
                        NearestMipmapLinearFilter: () => Sn,
                        NearestMipmapNearestFilter: () => $t,
                        NeutralToneMapping: () => Ge,
                        NeverCompare: () => zh,
                        NeverDepth: () => oi,
                        NeverStencilFunc: () => Qc,
                        NoBlending: () => F,
                        NoColorSpace: () => Ms,
                        NoToneMapping: () => cr,
                        NormalAnimationBlendMode: () => _i,
                        NormalBlending: () => V,
                        NotEqualCompare: () => Qh,
                        NotEqualDepth: () => Rr,
                        NotEqualStencilFunc: () => Nu,
                        NumberKeyframeTrack: () => Vp,
                        Object3D: () => or,
                        ObjectLoader: () => EM,
                        ObjectSpaceNormalMap: () => Wo,
                        OctahedronGeometry: () => Up,
                        OneFactor: () => ae,
                        OneMinusConstantAlphaFactor: () => Nn,
                        OneMinusConstantColorFactor: () => an,
                        OneMinusDstAlphaFactor: () => He,
                        OneMinusDstColorFactor: () => gt,
                        OneMinusSrcAlphaFactor: () => ke,
                        OneMinusSrcColorFactor: () => me,
                        OrthographicCamera: () => oh,
                        P3Primaries: () => Ml,
                        PCFShadowMap: () => B,
                        PCFSoftShadowMap: () => R,
                        PMREMGenerator: () => bd,
                        Path: () => Pp,
                        PerspectiveCamera: () => ns,
                        Plane: () => Ps,
                        PlaneGeometry: () => xc,
                        PlaneHelper: () => l3,
                        PointLight: () => px,
                        PointLightHelper: () => $M,
                        Points: () => RE,
                        PointsMaterial: () => bv,
                        PolarGridHelper: () => i3,
                        PolyhedronGeometry: () => fu,
                        PositionalAudio: () => TM,
                        PropertyBinding: () => vr,
                        PropertyMixer: () => Bx,
                        QuadraticBezierCurve: () => Lv,
                        QuadraticBezierCurve3: () => Dv,
                        Quaternion: () => $i,
                        QuaternionKeyframeTrack: () => zd,
                        QuaternionLinearInterpolant: () => ax,
                        RED_GREEN_RGTC2_Format: () => Vt,
                        RED_RGTC1_Format: () => st,
                        REVISION: () => g,
                        RGBADepthPacking: () => jo,
                        RGBAFormat: () => Ke,
                        RGBAIntegerFormat: () => Hn,
                        RGBA_ASTC_10x10_Format: () => _t,
                        RGBA_ASTC_10x5_Format: () => wt,
                        RGBA_ASTC_10x6_Format: () => kt,
                        RGBA_ASTC_10x8_Format: () => et,
                        RGBA_ASTC_12x10_Format: () => ce,
                        RGBA_ASTC_12x12_Format: () => de,
                        RGBA_ASTC_4x4_Format: () => ri,
                        RGBA_ASTC_5x4_Format: () => $,
                        RGBA_ASTC_5x5_Format: () => re,
                        RGBA_ASTC_6x5_Format: () => Ae,
                        RGBA_ASTC_6x6_Format: () => xe,
                        RGBA_ASTC_8x5_Format: () => Oe,
                        RGBA_ASTC_8x6_Format: () => Ze,
                        RGBA_ASTC_8x8_Format: () => at,
                        RGBA_BPTC_Format: () => we,
                        RGBA_ETC2_EAC_Format: () => _r,
                        RGBA_PVRTC_2BPPV1_Format: () => Ur,
                        RGBA_PVRTC_4BPPV1_Format: () => yr,
                        RGBA_S3TC_DXT1_Format: () => Wn,
                        RGBA_S3TC_DXT3_Format: () => Wi,
                        RGBA_S3TC_DXT5_Format: () => li,
                        RGBFormat: () => De,
                        RGB_BPTC_SIGNED_Format: () => Ee,
                        RGB_BPTC_UNSIGNED_Format: () => Me,
                        RGB_ETC1_Format: () => Cn,
                        RGB_ETC2_Format: () => Ai,
                        RGB_PVRTC_2BPPV1_Format: () => ki,
                        RGB_PVRTC_4BPPV1_Format: () => mi,
                        RGB_S3TC_DXT1_Format: () => jn,
                        RGFormat: () => xn,
                        RGIntegerFormat: () => Dt,
                        RawShaderMaterial: () => YE,
                        Ray: () => jr,
                        Raycaster: () => WM,
                        Rec709Primaries: () => Fa,
                        RectAreaLight: () => gx,
                        RedFormat: () => Kt,
                        RedIntegerFormat: () => Rn,
                        ReinhardToneMapping: () => Nr,
                        RenderTarget: () => lc,
                        RepeatWrapping: () => je,
                        ReplaceStencilOp: () => Ou,
                        ReverseSubtractEquation: () => ue,
                        RingGeometry: () => vg,
                        SIGNED_RED_GREEN_RGTC2_Format: () => Ft,
                        SIGNED_RED_RGTC1_Format: () => ut,
                        SRGBColorSpace: () => rr,
                        SRGBTransfer: () => mr,
                        Scene: () => rE,
                        ShaderChunk: () => ci,
                        ShaderLib: () => ia,
                        ShaderMaterial: () => ta,
                        ShadowMaterial: () => XE,
                        Shape: () => yh,
                        ShapeGeometry: () => yg,
                        ShapePath: () => h3,
                        ShapeUtils: () => jl,
                        ShortType: () => Or,
                        Skeleton: () => WA,
                        SkeletonHelper: () => ZM,
                        SkinnedMesh: () => AE,
                        Source: () => zr,
                        Sphere: () => as,
                        SphereGeometry: () => zp,
                        Spherical: () => KM,
                        SphericalHarmonics3: () => vx,
                        SplineCurve: () => Pv,
                        SpotLight: () => dx,
                        SpotLightHelper: () => JM,
                        Sprite: () => lE,
                        SpriteMaterial: () => Av,
                        SrcAlphaFactor: () => Re,
                        SrcAlphaSaturateFactor: () => Bt,
                        SrcColorFactor: () => ee,
                        StaticCopyUsage: () => wf,
                        StaticDrawUsage: () => rl,
                        StaticReadUsage: () => xf,
                        StereoCamera: () => bM,
                        StreamCopyUsage: () => _f,
                        StreamDrawUsage: () => Ef,
                        StreamReadUsage: () => Cf,
                        StringKeyframeTrack: () => wh,
                        SubtractEquation: () => pe,
                        SubtractiveBlending: () => j,
                        TOUCH: () => v,
                        TangentSpaceNormalMap: () => zs,
                        TetrahedronGeometry: () => Eg,
                        Texture: () => Lr,
                        TextureLoader: () => AM,
                        TorusGeometry: () => xg,
                        TorusKnotGeometry: () => Cg,
                        Triangle: () => Bs,
                        TriangleFanDrawMode: () => _s,
                        TriangleStripDrawMode: () => Mr,
                        TrianglesDrawMode: () => Yr,
                        TubeGeometry: () => wg,
                        UVMapping: () => Qe,
                        Uint16BufferAttribute: () => eu,
                        Uint32BufferAttribute: () => sd,
                        Uint8BufferAttribute: () => Nf,
                        Uint8ClampedBufferAttribute: () => z0,
                        Uniform: () => Jv,
                        UniformsGroup: () => HM,
                        UniformsLib: () => wn,
                        UniformsUtils: () => ld,
                        UnsignedByteType: () => pr,
                        UnsignedInt248Type: () => xo,
                        UnsignedInt5999Type: () => Ea,
                        UnsignedIntType: () => bs,
                        UnsignedShort4444Type: () => Qr,
                        UnsignedShort5551Type: () => ua,
                        UnsignedShortType: () => ws,
                        VSMShadowMap: () => I,
                        Vector2: () => zt,
                        Vector3: () => Ne,
                        Vector4: () => ar,
                        VectorKeyframeTrack: () => Hp,
                        VideoTexture: () => T_,
                        WebGL3DRenderTarget: () => sr,
                        WebGLArrayRenderTarget: () => Pn,
                        WebGLCoordinateSystem: () => da,
                        WebGLCubeRenderTarget: () => ud,
                        WebGLMultipleRenderTargets: () => d3,
                        WebGLRenderTarget: () => os,
                        WebGLRenderer: () => y_,
                        WebGLUtils: () => $1,
                        WebGPUCoordinateSystem: () => sl,
                        WireframeGeometry: () => jE,
                        WrapAroundEnding: () => Ii,
                        ZeroCurvatureEnding: () => yn,
                        ZeroFactor: () => H,
                        ZeroSlopeEnding: () => bi,
                        ZeroStencilOp: () => Co,
                        createCanvasElement: () => Kc
                    });
                    /**
                     * @license
                     * Copyright 2010-2024 Three.js Authors
                     * SPDX-License-Identifier: MIT
                     */const g = "164", w = {LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2},
                        v = {ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3}, E = 0, p = 1, C = 2, M = 3, b = 0,
                        B = 1, R = 2, I = 3, L = 0, O = 1, N = 2, F = 0, V = 1, U = 2, j = 3, Y = 4, fe = 5, se = 100,
                        pe = 101, ue = 102, he = 103, Z = 104, H = 200, ae = 201, ee = 202, me = 203, Re = 204,
                        ke = 205, Ve = 206, He = 207, ot = 208, gt = 209, Bt = 210, Rt = 211, an = 212, En = 213,
                        Nn = 214, oi = 0, pi = 1, hi = 2, Vn = 3, yi = 4, nr = 5, Oi = 6, Rr = 7, Ji = 0, Pi = 1,
                        Br = 2, cr = 0, ss = 1, Nr = 2, ir = 3, jt = 4, Se = 5, _e = 6, Ge = 7, Le = "attached",
                        Ue = "detached", Qe = 300, oe = 301, G = 302, X = 303, ve = 304, Be = 306, je = 1e3, tt = 1001,
                        Yt = 1002, cn = 1003, $t = 1004, en = 1004, Sn = 1005, Gi = 1005, qn = 1006, fr = 1007,
                        Vi = 1007, Zi = 1008, co = 1008, pr = 1009, $s = 1010, Or = 1011, ws = 1012, Eo = 1013,
                        bs = 1014, kr = 1015, Hi = 1016, Qr = 1017, ua = 1018, xo = 1020, Ea = 35902, Qo = 1021,
                        De = 1022, Ke = 1023, rt = 1024, Ct = 1025, dt = 1026, Lt = 1027, Kt = 1028, Rn = 1029,
                        xn = 1030, Dt = 1031, Hn = 1033, jn = 33776, Wn = 33777, Wi = 33778, li = 33779, mi = 35840,
                        ki = 35841, yr = 35842, Ur = 35843, Cn = 36196, Ai = 37492, _r = 37496, ri = 37808, $ = 37809,
                        re = 37810, Ae = 37811, xe = 37812, Oe = 37813, Ze = 37814, at = 37815, wt = 37816, kt = 37817,
                        et = 37818, _t = 37819, ce = 37820, de = 37821, we = 36492, Ee = 36494, Me = 36495, st = 36283,
                        ut = 36284, Vt = 36285, Ft = 36286, Jt = 2200, sn = 2201, Pt = 2202, gn = 2300, un = 2301,
                        _n = 2302, yn = 2400, bi = 2401, Ii = 2402, _i = 2500, gi = 2501, Yr = 0, Mr = 1, _s = 2,
                        ha = 3200, jo = 3201, zs = 0, Wo = 1, Ms = "", rr = "srgb", Gs = "srgb-linear",
                        bl = "display-p3", ka = "display-p3-linear", _l = "linear", mr = "srgb", Fa = "rec709",
                        Ml = "p3", Co = 0, Bo = 7680, Ou = 7681, tc = 7682, pf = 7683, ku = 34055, Fu = 34056,
                        nc = 5386, Qc = 512, Uh = 513, mf = 514, Af = 515, gf = 516, Nu = 517, vf = 518, Uu = 519,
                        zh = 512, Gh = 513, Vh = 514, jc = 515, Hh = 516, Qh = 517, jh = 518, Wh = 519, rl = 35044,
                        yf = 35048, Ef = 35040, xf = 35045, Kh = 35049, Cf = 35041, wf = 35046, bf = 35050, _f = 35042,
                        Mf = "100", zu = "300 es", da = 2e3, sl = 2001;

                    class Ss {
                        addEventListener(e, n) {
                            this._listeners === void 0 && (this._listeners = {});
                            const r = this._listeners;
                            r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n)
                        }

                        hasEventListener(e, n) {
                            if (this._listeners === void 0) return !1;
                            const r = this._listeners;
                            return r[e] !== void 0 && r[e].indexOf(n) !== -1
                        }

                        removeEventListener(e, n) {
                            if (this._listeners === void 0) return;
                            const a = this._listeners[e];
                            if (a !== void 0) {
                                const u = a.indexOf(n);
                                u !== -1 && a.splice(u, 1)
                            }
                        }

                        dispatchEvent(e) {
                            if (this._listeners === void 0) return;
                            const r = this._listeners[e.type];
                            if (r !== void 0) {
                                e.target = this;
                                const a = r.slice(0);
                                for (let u = 0, y = a.length; u < y; u++) a[u].call(this, e);
                                e.target = null
                            }
                        }
                    }

                    const Vs = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
                    let Gu = 1234567;
                    const Na = Math.PI / 180, ol = 180 / Math.PI;

                    function uo() {
                        const d = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0,
                            n = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
                        return (Vs[d & 255] + Vs[d >> 8 & 255] + Vs[d >> 16 & 255] + Vs[d >> 24 & 255] + "-" + Vs[e & 255] + Vs[e >> 8 & 255] + "-" + Vs[e >> 16 & 15 | 64] + Vs[e >> 24 & 255] + "-" + Vs[n & 63 | 128] + Vs[n >> 8 & 255] + "-" + Vs[n >> 16 & 255] + Vs[n >> 24 & 255] + Vs[r & 255] + Vs[r >> 8 & 255] + Vs[r >> 16 & 255] + Vs[r >> 24 & 255]).toLowerCase()
                    }

                    function Hr(d, e, n) {
                        return Math.max(e, Math.min(n, d))
                    }

                    function Ua(d, e) {
                        return (d % e + e) % e
                    }

                    function Sf(d, e, n, r, a) {
                        return r + (d - e) * (a - r) / (n - e)
                    }

                    function Tf(d, e, n) {
                        return d !== e ? (n - d) / (e - d) : 0
                    }

                    function ic(d, e, n) {
                        return (1 - n) * d + n * e
                    }

                    function Xh(d, e, n, r) {
                        return ic(d, e, 1 - Math.exp(-n * r))
                    }

                    function Yh(d, e = 1) {
                        return e - Math.abs(Ua(d, e * 2) - e)
                    }

                    function rc(d, e, n) {
                        return d <= e ? 0 : d >= n ? 1 : (d = (d - e) / (n - e), d * d * (3 - 2 * d))
                    }

                    function sc(d, e, n) {
                        return d <= e ? 0 : d >= n ? 1 : (d = (d - e) / (n - e), d * d * d * (d * (d * 6 - 15) + 10))
                    }

                    function If(d, e) {
                        return d + Math.floor(Math.random() * (e - d + 1))
                    }

                    function Wc(d, e) {
                        return d + Math.random() * (e - d)
                    }

                    function Rf(d) {
                        return d * (.5 - Math.random())
                    }

                    function qh(d) {
                        d !== void 0 && (Gu = d);
                        let e = Gu += 1831565813;
                        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
                    }

                    function Vu(d) {
                        return d * Na
                    }

                    function Hu(d) {
                        return d * ol
                    }

                    function Jh(d) {
                        return (d & d - 1) === 0 && d !== 0
                    }

                    function Zh(d) {
                        return Math.pow(2, Math.ceil(Math.log(d) / Math.LN2))
                    }

                    function $h(d) {
                        return Math.pow(2, Math.floor(Math.log(d) / Math.LN2))
                    }

                    function Bf(d, e, n, r, a) {
                        const u = Math.cos, y = Math.sin, S = u(n / 2), D = y(n / 2), P = u((e + r) / 2),
                            z = y((e + r) / 2), Q = u((e - r) / 2), K = y((e - r) / 2), q = u((r - e) / 2),
                            te = y((r - e) / 2);
                        switch (a) {
                            case"XYX":
                                d.set(S * z, D * Q, D * K, S * P);
                                break;
                            case"YZY":
                                d.set(D * K, S * z, D * Q, S * P);
                                break;
                            case"ZXZ":
                                d.set(D * Q, D * K, S * z, S * P);
                                break;
                            case"XZX":
                                d.set(S * z, D * te, D * q, S * P);
                                break;
                            case"YXY":
                                d.set(D * q, S * z, D * te, S * P);
                                break;
                            case"ZYZ":
                                d.set(D * te, D * q, S * z, S * P);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + a)
                        }
                    }

                    function eo(d, e) {
                        switch (e.constructor) {
                            case Float32Array:
                                return d;
                            case Uint32Array:
                                return d / 4294967295;
                            case Uint16Array:
                                return d / 65535;
                            case Uint8Array:
                                return d / 255;
                            case Int32Array:
                                return Math.max(d / 2147483647, -1);
                            case Int16Array:
                                return Math.max(d / 32767, -1);
                            case Int8Array:
                                return Math.max(d / 127, -1);
                            default:
                                throw new Error("Invalid component type.")
                        }
                    }

                    function Ri(d, e) {
                        switch (e.constructor) {
                            case Float32Array:
                                return d;
                            case Uint32Array:
                                return Math.round(d * 4294967295);
                            case Uint16Array:
                                return Math.round(d * 65535);
                            case Uint8Array:
                                return Math.round(d * 255);
                            case Int32Array:
                                return Math.round(d * 2147483647);
                            case Int16Array:
                                return Math.round(d * 32767);
                            case Int8Array:
                                return Math.round(d * 127);
                            default:
                                throw new Error("Invalid component type.")
                        }
                    }

                    const Lf = {
                        DEG2RAD: Na,
                        RAD2DEG: ol,
                        generateUUID: uo,
                        clamp: Hr,
                        euclideanModulo: Ua,
                        mapLinear: Sf,
                        inverseLerp: Tf,
                        lerp: ic,
                        damp: Xh,
                        pingpong: Yh,
                        smoothstep: rc,
                        smootherstep: sc,
                        randInt: If,
                        randFloat: Wc,
                        randFloatSpread: Rf,
                        seededRandom: qh,
                        degToRad: Vu,
                        radToDeg: Hu,
                        isPowerOfTwo: Jh,
                        ceilPowerOfTwo: Zh,
                        floorPowerOfTwo: $h,
                        setQuaternionFromProperEuler: Bf,
                        normalize: Ri,
                        denormalize: eo
                    };

                    class zt {
                        constructor(e = 0, n = 0) {
                            zt.prototype.isVector2 = !0, this.x = e, this.y = n
                        }

                        get width() {
                            return this.x
                        }

                        set width(e) {
                            this.x = e
                        }

                        get height() {
                            return this.y
                        }

                        set height(e) {
                            this.y = e
                        }

                        set(e, n) {
                            return this.x = e, this.y = n, this
                        }

                        setScalar(e) {
                            return this.x = e, this.y = e, this
                        }

                        setX(e) {
                            return this.x = e, this
                        }

                        setY(e) {
                            return this.y = e, this
                        }

                        setComponent(e, n) {
                            switch (e) {
                                case 0:
                                    this.x = n;
                                    break;
                                case 1:
                                    this.y = n;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }

                        getComponent(e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }

                        clone() {
                            return new this.constructor(this.x, this.y)
                        }

                        copy(e) {
                            return this.x = e.x, this.y = e.y, this
                        }

                        add(e) {
                            return this.x += e.x, this.y += e.y, this
                        }

                        addScalar(e) {
                            return this.x += e, this.y += e, this
                        }

                        addVectors(e, n) {
                            return this.x = e.x + n.x, this.y = e.y + n.y, this
                        }

                        addScaledVector(e, n) {
                            return this.x += e.x * n, this.y += e.y * n, this
                        }

                        sub(e) {
                            return this.x -= e.x, this.y -= e.y, this
                        }

                        subScalar(e) {
                            return this.x -= e, this.y -= e, this
                        }

                        subVectors(e, n) {
                            return this.x = e.x - n.x, this.y = e.y - n.y, this
                        }

                        multiply(e) {
                            return this.x *= e.x, this.y *= e.y, this
                        }

                        multiplyScalar(e) {
                            return this.x *= e, this.y *= e, this
                        }

                        divide(e) {
                            return this.x /= e.x, this.y /= e.y, this
                        }

                        divideScalar(e) {
                            return this.multiplyScalar(1 / e)
                        }

                        applyMatrix3(e) {
                            const n = this.x, r = this.y, a = e.elements;
                            return this.x = a[0] * n + a[3] * r + a[6], this.y = a[1] * n + a[4] * r + a[7], this
                        }

                        min(e) {
                            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                        }

                        max(e) {
                            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                        }

                        clamp(e, n) {
                            return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this
                        }

                        clampScalar(e, n) {
                            return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this
                        }

                        clampLength(e, n) {
                            const r = this.length();
                            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
                        }

                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                        }

                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                        }

                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                        }

                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
                        }

                        negate() {
                            return this.x = -this.x, this.y = -this.y, this
                        }

                        dot(e) {
                            return this.x * e.x + this.y * e.y
                        }

                        cross(e) {
                            return this.x * e.y - this.y * e.x
                        }

                        lengthSq() {
                            return this.x * this.x + this.y * this.y
                        }

                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        }

                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y)
                        }

                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }

                        angle() {
                            return Math.atan2(-this.y, -this.x) + Math.PI
                        }

                        angleTo(e) {
                            const n = Math.sqrt(this.lengthSq() * e.lengthSq());
                            if (n === 0) return Math.PI / 2;
                            const r = this.dot(e) / n;
                            return Math.acos(Hr(r, -1, 1))
                        }

                        distanceTo(e) {
                            return Math.sqrt(this.distanceToSquared(e))
                        }

                        distanceToSquared(e) {
                            const n = this.x - e.x, r = this.y - e.y;
                            return n * n + r * r
                        }

                        manhattanDistanceTo(e) {
                            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                        }

                        setLength(e) {
                            return this.normalize().multiplyScalar(e)
                        }

                        lerp(e, n) {
                            return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this
                        }

                        lerpVectors(e, n, r) {
                            return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this
                        }

                        equals(e) {
                            return e.x === this.x && e.y === this.y
                        }

                        fromArray(e, n = 0) {
                            return this.x = e[n], this.y = e[n + 1], this
                        }

                        toArray(e = [], n = 0) {
                            return e[n] = this.x, e[n + 1] = this.y, e
                        }

                        fromBufferAttribute(e, n) {
                            return this.x = e.getX(n), this.y = e.getY(n), this
                        }

                        rotateAround(e, n) {
                            const r = Math.cos(n), a = Math.sin(n), u = this.x - e.x, y = this.y - e.y;
                            return this.x = u * r - y * a + e.x, this.y = u * a + y * r + e.y, this
                        }

                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this
                        }

                        * [Symbol.iterator]() {
                            yield this.x, yield this.y
                        }
                    }

                    class ai {
                        constructor(e, n, r, a, u, y, S, D, P) {
                            ai.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, n, r, a, u, y, S, D, P)
                        }

                        set(e, n, r, a, u, y, S, D, P) {
                            const z = this.elements;
                            return z[0] = e, z[1] = a, z[2] = S, z[3] = n, z[4] = u, z[5] = D, z[6] = r, z[7] = y, z[8] = P, this
                        }

                        identity() {
                            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                        }

                        copy(e) {
                            const n = this.elements, r = e.elements;
                            return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], this
                        }

                        extractBasis(e, n, r) {
                            return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this
                        }

                        setFromMatrix4(e) {
                            const n = e.elements;
                            return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
                        }

                        multiply(e) {
                            return this.multiplyMatrices(this, e)
                        }

                        premultiply(e) {
                            return this.multiplyMatrices(e, this)
                        }

                        multiplyMatrices(e, n) {
                            const r = e.elements, a = n.elements, u = this.elements, y = r[0], S = r[3], D = r[6],
                                P = r[1], z = r[4], Q = r[7], K = r[2], q = r[5], te = r[8], le = a[0], ne = a[3],
                                J = a[6], Ce = a[1], ye = a[4], ge = a[7], $e = a[2], ze = a[5], We = a[8];
                            return u[0] = y * le + S * Ce + D * $e, u[3] = y * ne + S * ye + D * ze, u[6] = y * J + S * ge + D * We, u[1] = P * le + z * Ce + Q * $e, u[4] = P * ne + z * ye + Q * ze, u[7] = P * J + z * ge + Q * We, u[2] = K * le + q * Ce + te * $e, u[5] = K * ne + q * ye + te * ze, u[8] = K * J + q * ge + te * We, this
                        }

                        multiplyScalar(e) {
                            const n = this.elements;
                            return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this
                        }

                        determinant() {
                            const e = this.elements, n = e[0], r = e[1], a = e[2], u = e[3], y = e[4], S = e[5],
                                D = e[6], P = e[7], z = e[8];
                            return n * y * z - n * S * P - r * u * z + r * S * D + a * u * P - a * y * D
                        }

                        invert() {
                            const e = this.elements, n = e[0], r = e[1], a = e[2], u = e[3], y = e[4], S = e[5],
                                D = e[6], P = e[7], z = e[8], Q = z * y - S * P, K = S * D - z * u, q = P * u - y * D,
                                te = n * Q + r * K + a * q;
                            if (te === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                            const le = 1 / te;
                            return e[0] = Q * le, e[1] = (a * P - z * r) * le, e[2] = (S * r - a * y) * le, e[3] = K * le, e[4] = (z * n - a * D) * le, e[5] = (a * u - S * n) * le, e[6] = q * le, e[7] = (r * D - P * n) * le, e[8] = (y * n - r * u) * le, this
                        }

                        transpose() {
                            let e;
                            const n = this.elements;
                            return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this
                        }

                        getNormalMatrix(e) {
                            return this.setFromMatrix4(e).invert().transpose()
                        }

                        transposeIntoArray(e) {
                            const n = this.elements;
                            return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this
                        }

                        setUvTransform(e, n, r, a, u, y, S) {
                            const D = Math.cos(u), P = Math.sin(u);
                            return this.set(r * D, r * P, -r * (D * y + P * S) + y + e, -a * P, a * D, -a * (-P * y + D * S) + S + n, 0, 0, 1), this
                        }

                        scale(e, n) {
                            return this.premultiply(al.makeScale(e, n)), this
                        }

                        rotate(e) {
                            return this.premultiply(al.makeRotation(-e)), this
                        }

                        translate(e, n) {
                            return this.premultiply(al.makeTranslation(e, n)), this
                        }

                        makeTranslation(e, n) {
                            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, n, 0, 0, 1), this
                        }

                        makeRotation(e) {
                            const n = Math.cos(e), r = Math.sin(e);
                            return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this
                        }

                        makeScale(e, n) {
                            return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this
                        }

                        equals(e) {
                            const n = this.elements, r = e.elements;
                            for (let a = 0; a < 9; a++) if (n[a] !== r[a]) return !1;
                            return !0
                        }

                        fromArray(e, n = 0) {
                            for (let r = 0; r < 9; r++) this.elements[r] = e[r + n];
                            return this
                        }

                        toArray(e = [], n = 0) {
                            const r = this.elements;
                            return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e
                        }

                        clone() {
                            return new this.constructor().fromArray(this.elements)
                        }
                    }

                    const al = new ai;

                    function Qu(d) {
                        for (let e = d.length - 1; e >= 0; --e) if (d[e] >= 65535) return !0;
                        return !1
                    }

                    const ed = {
                        Int8Array,
                        Uint8Array,
                        Uint8ClampedArray,
                        Int16Array,
                        Uint16Array,
                        Int32Array,
                        Uint32Array,
                        Float32Array,
                        Float64Array
                    };

                    function ll(d, e) {
                        return new ed[d](e)
                    }

                    function Sl(d) {
                        return document.createElementNS("http://www.w3.org/1999/xhtml", d)
                    }

                    function Kc() {
                        const d = Sl("canvas");
                        return d.style.display = "block", d
                    }

                    const td = {};

                    function nd(d) {
                        d in td || (td[d] = !0, console.warn(d))
                    }

                    const cl = new ai().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
                        Xc = new ai().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
                        za = {
                            [Gs]: {transfer: _l, primaries: Fa, toReference: d => d, fromReference: d => d},
                            [rr]: {
                                transfer: mr,
                                primaries: Fa,
                                toReference: d => d.convertSRGBToLinear(),
                                fromReference: d => d.convertLinearToSRGB()
                            },
                            [ka]: {
                                transfer: _l,
                                primaries: Ml,
                                toReference: d => d.applyMatrix3(Xc),
                                fromReference: d => d.applyMatrix3(cl)
                            },
                            [bl]: {
                                transfer: mr,
                                primaries: Ml,
                                toReference: d => d.convertSRGBToLinear().applyMatrix3(Xc),
                                fromReference: d => d.applyMatrix3(cl).convertLinearToSRGB()
                            }
                        }, ju = new Set([Gs, ka]), ur = {
                            enabled: !0, _workingColorSpace: Gs, get workingColorSpace() {
                                return this._workingColorSpace
                            }, set workingColorSpace(d) {
                                if (!ju.has(d)) throw new Error(`Unsupported working color space, "${d}".`);
                                this._workingColorSpace = d
                            }, convert: function (d, e, n) {
                                if (this.enabled === !1 || e === n || !e || !n) return d;
                                const r = za[e].toReference, a = za[n].fromReference;
                                return a(r(d))
                            }, fromWorkingColorSpace: function (d, e) {
                                return this.convert(d, this._workingColorSpace, e)
                            }, toWorkingColorSpace: function (d, e) {
                                return this.convert(d, e, this._workingColorSpace)
                            }, getPrimaries: function (d) {
                                return za[d].primaries
                            }, getTransfer: function (d) {
                                return d === Ms ? _l : za[d].transfer
                            }
                        };

                    function xa(d) {
                        return d < .04045 ? d * .0773993808 : Math.pow(d * .9478672986 + .0521327014, 2.4)
                    }

                    function Ga(d) {
                        return d < .0031308 ? d * 12.92 : 1.055 * Math.pow(d, .41666) - .055
                    }

                    let Ca;

                    class ul {
                        static getDataURL(e) {
                            if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
                            let n;
                            if (e instanceof HTMLCanvasElement) n = e; else {
                                Ca === void 0 && (Ca = Sl("canvas")), Ca.width = e.width, Ca.height = e.height;
                                const r = Ca.getContext("2d");
                                e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), n = Ca
                            }
                            return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", .6)) : n.toDataURL("image/png")
                        }

                        static sRGBToLinear(e) {
                            if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                                const n = Sl("canvas");
                                n.width = e.width, n.height = e.height;
                                const r = n.getContext("2d");
                                r.drawImage(e, 0, 0, e.width, e.height);
                                const a = r.getImageData(0, 0, e.width, e.height), u = a.data;
                                for (let y = 0; y < u.length; y++) u[y] = xa(u[y] / 255) * 255;
                                return r.putImageData(a, 0, 0), n
                            } else if (e.data) {
                                const n = e.data.slice(0);
                                for (let r = 0; r < n.length; r++) n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[r] = Math.floor(xa(n[r] / 255) * 255) : n[r] = xa(n[r]);
                                return {data: n, width: e.width, height: e.height}
                            } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
                        }
                    }

                    let oc = 0;

                    class zr {
                        constructor(e = null) {
                            this.isSource = !0, Object.defineProperty(this, "id", {value: oc++}), this.uuid = uo(), this.data = e, this.dataReady = !0, this.version = 0
                        }

                        set needsUpdate(e) {
                            e === !0 && this.version++
                        }

                        toJSON(e) {
                            const n = e === void 0 || typeof e == "string";
                            if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
                            const r = {uuid: this.uuid, url: ""}, a = this.data;
                            if (a !== null) {
                                let u;
                                if (Array.isArray(a)) {
                                    u = [];
                                    for (let y = 0, S = a.length; y < S; y++) a[y].isDataTexture ? u.push(ac(a[y].image)) : u.push(ac(a[y]))
                                } else u = ac(a);
                                r.url = u
                            }
                            return n || (e.images[this.uuid] = r), r
                        }
                    }

                    function ac(d) {
                        return typeof HTMLImageElement < "u" && d instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && d instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && d instanceof ImageBitmap ? ul.getDataURL(d) : d.data ? {
                            data: Array.from(d.data),
                            width: d.width,
                            height: d.height,
                            type: d.data.constructor.name
                        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                    }

                    let Wu = 0;

                    class Lr extends Ss {
                        constructor(e = Lr.DEFAULT_IMAGE, n = Lr.DEFAULT_MAPPING, r = tt, a = tt, u = qn, y = Zi, S = Ke, D = pr, P = Lr.DEFAULT_ANISOTROPY, z = Ms) {
                            super(), this.isTexture = !0, Object.defineProperty(this, "id", {value: Wu++}), this.uuid = uo(), this.name = "", this.source = new zr(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = r, this.wrapT = a, this.magFilter = u, this.minFilter = y, this.anisotropy = P, this.format = S, this.internalFormat = null, this.type = D, this.offset = new zt(0, 0), this.repeat = new zt(1, 1), this.center = new zt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ai, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = z, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
                        }

                        get image() {
                            return this.source.data
                        }

                        set image(e = null) {
                            this.source.data = e
                        }

                        updateMatrix() {
                            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        copy(e) {
                            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
                        }

                        toJSON(e) {
                            const n = e === void 0 || typeof e == "string";
                            if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
                            const r = {
                                metadata: {version: 4.6, type: "Texture", generator: "Texture.toJSON"},
                                uuid: this.uuid,
                                name: this.name,
                                image: this.source.toJSON(e).uuid,
                                mapping: this.mapping,
                                channel: this.channel,
                                repeat: [this.repeat.x, this.repeat.y],
                                offset: [this.offset.x, this.offset.y],
                                center: [this.center.x, this.center.y],
                                rotation: this.rotation,
                                wrap: [this.wrapS, this.wrapT],
                                format: this.format,
                                internalFormat: this.internalFormat,
                                type: this.type,
                                colorSpace: this.colorSpace,
                                minFilter: this.minFilter,
                                magFilter: this.magFilter,
                                anisotropy: this.anisotropy,
                                flipY: this.flipY,
                                generateMipmaps: this.generateMipmaps,
                                premultiplyAlpha: this.premultiplyAlpha,
                                unpackAlignment: this.unpackAlignment
                            };
                            return Object.keys(this.userData).length > 0 && (r.userData = this.userData), n || (e.textures[this.uuid] = r), r
                        }

                        dispose() {
                            this.dispatchEvent({type: "dispose"})
                        }

                        transformUv(e) {
                            if (this.mapping !== Qe) return e;
                            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                                case je:
                                    e.x = e.x - Math.floor(e.x);
                                    break;
                                case tt:
                                    e.x = e.x < 0 ? 0 : 1;
                                    break;
                                case Yt:
                                    Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                                    break
                            }
                            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                                case je:
                                    e.y = e.y - Math.floor(e.y);
                                    break;
                                case tt:
                                    e.y = e.y < 0 ? 0 : 1;
                                    break;
                                case Yt:
                                    Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                                    break
                            }
                            return this.flipY && (e.y = 1 - e.y), e
                        }

                        set needsUpdate(e) {
                            e === !0 && (this.version++, this.source.needsUpdate = !0)
                        }

                        set needsPMREMUpdate(e) {
                            e === !0 && this.pmremVersion++
                        }
                    }

                    Lr.DEFAULT_IMAGE = null, Lr.DEFAULT_MAPPING = Qe, Lr.DEFAULT_ANISOTROPY = 1;

                    class ar {
                        constructor(e = 0, n = 0, r = 0, a = 1) {
                            ar.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = r, this.w = a
                        }

                        get width() {
                            return this.z
                        }

                        set width(e) {
                            this.z = e
                        }

                        get height() {
                            return this.w
                        }

                        set height(e) {
                            this.w = e
                        }

                        set(e, n, r, a) {
                            return this.x = e, this.y = n, this.z = r, this.w = a, this
                        }

                        setScalar(e) {
                            return this.x = e, this.y = e, this.z = e, this.w = e, this
                        }

                        setX(e) {
                            return this.x = e, this
                        }

                        setY(e) {
                            return this.y = e, this
                        }

                        setZ(e) {
                            return this.z = e, this
                        }

                        setW(e) {
                            return this.w = e, this
                        }

                        setComponent(e, n) {
                            switch (e) {
                                case 0:
                                    this.x = n;
                                    break;
                                case 1:
                                    this.y = n;
                                    break;
                                case 2:
                                    this.z = n;
                                    break;
                                case 3:
                                    this.w = n;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }

                        getComponent(e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                case 3:
                                    return this.w;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }

                        clone() {
                            return new this.constructor(this.x, this.y, this.z, this.w)
                        }

                        copy(e) {
                            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
                        }

                        add(e) {
                            return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
                        }

                        addScalar(e) {
                            return this.x += e, this.y += e, this.z += e, this.w += e, this
                        }

                        addVectors(e, n) {
                            return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this
                        }

                        addScaledVector(e, n) {
                            return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this
                        }

                        sub(e) {
                            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
                        }

                        subScalar(e) {
                            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                        }

                        subVectors(e, n) {
                            return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this
                        }

                        multiply(e) {
                            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                        }

                        multiplyScalar(e) {
                            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                        }

                        applyMatrix4(e) {
                            const n = this.x, r = this.y, a = this.z, u = this.w, y = e.elements;
                            return this.x = y[0] * n + y[4] * r + y[8] * a + y[12] * u, this.y = y[1] * n + y[5] * r + y[9] * a + y[13] * u, this.z = y[2] * n + y[6] * r + y[10] * a + y[14] * u, this.w = y[3] * n + y[7] * r + y[11] * a + y[15] * u, this
                        }

                        divideScalar(e) {
                            return this.multiplyScalar(1 / e)
                        }

                        setAxisAngleFromQuaternion(e) {
                            this.w = 2 * Math.acos(e.w);
                            const n = Math.sqrt(1 - e.w * e.w);
                            return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this
                        }

                        setAxisAngleFromRotationMatrix(e) {
                            let n, r, a, u;
                            const D = e.elements, P = D[0], z = D[4], Q = D[8], K = D[1], q = D[5], te = D[9],
                                le = D[2], ne = D[6], J = D[10];
                            if (Math.abs(z - K) < .01 && Math.abs(Q - le) < .01 && Math.abs(te - ne) < .01) {
                                if (Math.abs(z + K) < .1 && Math.abs(Q + le) < .1 && Math.abs(te + ne) < .1 && Math.abs(P + q + J - 3) < .1) return this.set(1, 0, 0, 0), this;
                                n = Math.PI;
                                const ye = (P + 1) / 2, ge = (q + 1) / 2, $e = (J + 1) / 2, ze = (z + K) / 4,
                                    We = (Q + le) / 4, qe = (te + ne) / 4;
                                return ye > ge && ye > $e ? ye < .01 ? (r = 0, a = .707106781, u = .707106781) : (r = Math.sqrt(ye), a = ze / r, u = We / r) : ge > $e ? ge < .01 ? (r = .707106781, a = 0, u = .707106781) : (a = Math.sqrt(ge), r = ze / a, u = qe / a) : $e < .01 ? (r = .707106781, a = .707106781, u = 0) : (u = Math.sqrt($e), r = We / u, a = qe / u), this.set(r, a, u, n), this
                            }
                            let Ce = Math.sqrt((ne - te) * (ne - te) + (Q - le) * (Q - le) + (K - z) * (K - z));
                            return Math.abs(Ce) < .001 && (Ce = 1), this.x = (ne - te) / Ce, this.y = (Q - le) / Ce, this.z = (K - z) / Ce, this.w = Math.acos((P + q + J - 1) / 2), this
                        }

                        min(e) {
                            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                        }

                        max(e) {
                            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                        }

                        clamp(e, n) {
                            return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this
                        }

                        clampScalar(e, n) {
                            return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this
                        }

                        clampLength(e, n) {
                            const r = this.length();
                            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
                        }

                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                        }

                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                        }

                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                        }

                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
                        }

                        negate() {
                            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                        }

                        dot(e) {
                            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                        }

                        lengthSq() {
                            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                        }

                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                        }

                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                        }

                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }

                        setLength(e) {
                            return this.normalize().multiplyScalar(e)
                        }

                        lerp(e, n) {
                            return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this
                        }

                        lerpVectors(e, n, r) {
                            return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this.w = e.w + (n.w - e.w) * r, this
                        }

                        equals(e) {
                            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                        }

                        fromArray(e, n = 0) {
                            return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this
                        }

                        toArray(e = [], n = 0) {
                            return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e
                        }

                        fromBufferAttribute(e, n) {
                            return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this
                        }

                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                        }

                        * [Symbol.iterator]() {
                            yield this.x, yield this.y, yield this.z, yield this.w
                        }
                    }

                    class lc extends Ss {
                        constructor(e = 1, n = 1, r = {}) {
                            super(), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new ar(0, 0, e, n), this.scissorTest = !1, this.viewport = new ar(0, 0, e, n);
                            const a = {width: e, height: n, depth: 1};
                            r = Object.assign({
                                generateMipmaps: !1,
                                internalFormat: null,
                                minFilter: qn,
                                depthBuffer: !0,
                                stencilBuffer: !1,
                                resolveDepthBuffer: !0,
                                resolveStencilBuffer: !0,
                                depthTexture: null,
                                samples: 0,
                                count: 1
                            }, r);
                            const u = new Lr(a, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.colorSpace);
                            u.flipY = !1, u.generateMipmaps = r.generateMipmaps, u.internalFormat = r.internalFormat, this.textures = [];
                            const y = r.count;
                            for (let S = 0; S < y; S++) this.textures[S] = u.clone(), this.textures[S].isRenderTargetTexture = !0;
                            this.depthBuffer = r.depthBuffer, this.stencilBuffer = r.stencilBuffer, this.resolveDepthBuffer = r.resolveDepthBuffer, this.resolveStencilBuffer = r.resolveStencilBuffer, this.depthTexture = r.depthTexture, this.samples = r.samples
                        }

                        get texture() {
                            return this.textures[0]
                        }

                        set texture(e) {
                            this.textures[0] = e
                        }

                        setSize(e, n, r = 1) {
                            if (this.width !== e || this.height !== n || this.depth !== r) {
                                this.width = e, this.height = n, this.depth = r;
                                for (let a = 0, u = this.textures.length; a < u; a++) this.textures[a].image.width = e, this.textures[a].image.height = n, this.textures[a].image.depth = r;
                                this.dispose()
                            }
                            this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n)
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        copy(e) {
                            this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
                            for (let r = 0, a = e.textures.length; r < a; r++) this.textures[r] = e.textures[r].clone(), this.textures[r].isRenderTargetTexture = !0;
                            const n = Object.assign({}, e.texture.image);
                            return this.texture.source = new zr(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
                        }

                        dispose() {
                            this.dispatchEvent({type: "dispose"})
                        }
                    }

                    class os extends lc {
                        constructor(e = 1, n = 1, r = {}) {
                            super(e, n, r), this.isWebGLRenderTarget = !0
                        }
                    }

                    class Tl extends Lr {
                        constructor(e = null, n = 1, r = 1, a = 1) {
                            super(null), this.isDataArrayTexture = !0, this.image = {
                                data: e,
                                width: n,
                                height: r,
                                depth: a
                            }, this.magFilter = cn, this.minFilter = cn, this.wrapR = tt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                        }
                    }

                    class Pn extends os {
                        constructor(e = 1, n = 1, r = 1, a = {}) {
                            super(e, n, a), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new Tl(null, e, n, r), this.texture.isRenderTargetTexture = !0
                        }
                    }

                    class Mi extends Lr {
                        constructor(e = null, n = 1, r = 1, a = 1) {
                            super(null), this.isData3DTexture = !0, this.image = {
                                data: e,
                                width: n,
                                height: r,
                                depth: a
                            }, this.magFilter = cn, this.minFilter = cn, this.wrapR = tt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                        }
                    }

                    class sr extends os {
                        constructor(e = 1, n = 1, r = 1, a = {}) {
                            super(e, n, a), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new Mi(null, e, n, r), this.texture.isRenderTargetTexture = !0
                        }
                    }

                    class $i {
                        constructor(e = 0, n = 0, r = 0, a = 1) {
                            this.isQuaternion = !0, this._x = e, this._y = n, this._z = r, this._w = a
                        }

                        static slerpFlat(e, n, r, a, u, y, S) {
                            let D = r[a + 0], P = r[a + 1], z = r[a + 2], Q = r[a + 3];
                            const K = u[y + 0], q = u[y + 1], te = u[y + 2], le = u[y + 3];
                            if (S === 0) {
                                e[n + 0] = D, e[n + 1] = P, e[n + 2] = z, e[n + 3] = Q;
                                return
                            }
                            if (S === 1) {
                                e[n + 0] = K, e[n + 1] = q, e[n + 2] = te, e[n + 3] = le;
                                return
                            }
                            if (Q !== le || D !== K || P !== q || z !== te) {
                                let ne = 1 - S;
                                const J = D * K + P * q + z * te + Q * le, Ce = J >= 0 ? 1 : -1, ye = 1 - J * J;
                                if (ye > Number.EPSILON) {
                                    const $e = Math.sqrt(ye), ze = Math.atan2($e, J * Ce);
                                    ne = Math.sin(ne * ze) / $e, S = Math.sin(S * ze) / $e
                                }
                                const ge = S * Ce;
                                if (D = D * ne + K * ge, P = P * ne + q * ge, z = z * ne + te * ge, Q = Q * ne + le * ge, ne === 1 - S) {
                                    const $e = 1 / Math.sqrt(D * D + P * P + z * z + Q * Q);
                                    D *= $e, P *= $e, z *= $e, Q *= $e
                                }
                            }
                            e[n] = D, e[n + 1] = P, e[n + 2] = z, e[n + 3] = Q
                        }

                        static multiplyQuaternionsFlat(e, n, r, a, u, y) {
                            const S = r[a], D = r[a + 1], P = r[a + 2], z = r[a + 3], Q = u[y], K = u[y + 1],
                                q = u[y + 2], te = u[y + 3];
                            return e[n] = S * te + z * Q + D * q - P * K, e[n + 1] = D * te + z * K + P * Q - S * q, e[n + 2] = P * te + z * q + S * K - D * Q, e[n + 3] = z * te - S * Q - D * K - P * q, e
                        }

                        get x() {
                            return this._x
                        }

                        set x(e) {
                            this._x = e, this._onChangeCallback()
                        }

                        get y() {
                            return this._y
                        }

                        set y(e) {
                            this._y = e, this._onChangeCallback()
                        }

                        get z() {
                            return this._z
                        }

                        set z(e) {
                            this._z = e, this._onChangeCallback()
                        }

                        get w() {
                            return this._w
                        }

                        set w(e) {
                            this._w = e, this._onChangeCallback()
                        }

                        set(e, n, r, a) {
                            return this._x = e, this._y = n, this._z = r, this._w = a, this._onChangeCallback(), this
                        }

                        clone() {
                            return new this.constructor(this._x, this._y, this._z, this._w)
                        }

                        copy(e) {
                            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                        }

                        setFromEuler(e, n = !0) {
                            const r = e._x, a = e._y, u = e._z, y = e._order, S = Math.cos, D = Math.sin, P = S(r / 2),
                                z = S(a / 2), Q = S(u / 2), K = D(r / 2), q = D(a / 2), te = D(u / 2);
                            switch (y) {
                                case"XYZ":
                                    this._x = K * z * Q + P * q * te, this._y = P * q * Q - K * z * te, this._z = P * z * te + K * q * Q, this._w = P * z * Q - K * q * te;
                                    break;
                                case"YXZ":
                                    this._x = K * z * Q + P * q * te, this._y = P * q * Q - K * z * te, this._z = P * z * te - K * q * Q, this._w = P * z * Q + K * q * te;
                                    break;
                                case"ZXY":
                                    this._x = K * z * Q - P * q * te, this._y = P * q * Q + K * z * te, this._z = P * z * te + K * q * Q, this._w = P * z * Q - K * q * te;
                                    break;
                                case"ZYX":
                                    this._x = K * z * Q - P * q * te, this._y = P * q * Q + K * z * te, this._z = P * z * te - K * q * Q, this._w = P * z * Q + K * q * te;
                                    break;
                                case"YZX":
                                    this._x = K * z * Q + P * q * te, this._y = P * q * Q + K * z * te, this._z = P * z * te - K * q * Q, this._w = P * z * Q - K * q * te;
                                    break;
                                case"XZY":
                                    this._x = K * z * Q - P * q * te, this._y = P * q * Q - K * z * te, this._z = P * z * te + K * q * Q, this._w = P * z * Q + K * q * te;
                                    break;
                                default:
                                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + y)
                            }
                            return n === !0 && this._onChangeCallback(), this
                        }

                        setFromAxisAngle(e, n) {
                            const r = n / 2, a = Math.sin(r);
                            return this._x = e.x * a, this._y = e.y * a, this._z = e.z * a, this._w = Math.cos(r), this._onChangeCallback(), this
                        }

                        setFromRotationMatrix(e) {
                            const n = e.elements, r = n[0], a = n[4], u = n[8], y = n[1], S = n[5], D = n[9], P = n[2],
                                z = n[6], Q = n[10], K = r + S + Q;
                            if (K > 0) {
                                const q = .5 / Math.sqrt(K + 1);
                                this._w = .25 / q, this._x = (z - D) * q, this._y = (u - P) * q, this._z = (y - a) * q
                            } else if (r > S && r > Q) {
                                const q = 2 * Math.sqrt(1 + r - S - Q);
                                this._w = (z - D) / q, this._x = .25 * q, this._y = (a + y) / q, this._z = (u + P) / q
                            } else if (S > Q) {
                                const q = 2 * Math.sqrt(1 + S - r - Q);
                                this._w = (u - P) / q, this._x = (a + y) / q, this._y = .25 * q, this._z = (D + z) / q
                            } else {
                                const q = 2 * Math.sqrt(1 + Q - r - S);
                                this._w = (y - a) / q, this._x = (u + P) / q, this._y = (D + z) / q, this._z = .25 * q
                            }
                            return this._onChangeCallback(), this
                        }

                        setFromUnitVectors(e, n) {
                            let r = e.dot(n) + 1;
                            return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = r), this.normalize()
                        }

                        angleTo(e) {
                            return 2 * Math.acos(Math.abs(Hr(this.dot(e), -1, 1)))
                        }

                        rotateTowards(e, n) {
                            const r = this.angleTo(e);
                            if (r === 0) return this;
                            const a = Math.min(1, n / r);
                            return this.slerp(e, a), this
                        }

                        identity() {
                            return this.set(0, 0, 0, 1)
                        }

                        invert() {
                            return this.conjugate()
                        }

                        conjugate() {
                            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                        }

                        dot(e) {
                            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                        }

                        lengthSq() {
                            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                        }

                        length() {
                            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                        }

                        normalize() {
                            let e = this.length();
                            return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                        }

                        multiply(e) {
                            return this.multiplyQuaternions(this, e)
                        }

                        premultiply(e) {
                            return this.multiplyQuaternions(e, this)
                        }

                        multiplyQuaternions(e, n) {
                            const r = e._x, a = e._y, u = e._z, y = e._w, S = n._x, D = n._y, P = n._z, z = n._w;
                            return this._x = r * z + y * S + a * P - u * D, this._y = a * z + y * D + u * S - r * P, this._z = u * z + y * P + r * D - a * S, this._w = y * z - r * S - a * D - u * P, this._onChangeCallback(), this
                        }

                        slerp(e, n) {
                            if (n === 0) return this;
                            if (n === 1) return this.copy(e);
                            const r = this._x, a = this._y, u = this._z, y = this._w;
                            let S = y * e._w + r * e._x + a * e._y + u * e._z;
                            if (S < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, S = -S) : this.copy(e), S >= 1) return this._w = y, this._x = r, this._y = a, this._z = u, this;
                            const D = 1 - S * S;
                            if (D <= Number.EPSILON) {
                                const q = 1 - n;
                                return this._w = q * y + n * this._w, this._x = q * r + n * this._x, this._y = q * a + n * this._y, this._z = q * u + n * this._z, this.normalize(), this
                            }
                            const P = Math.sqrt(D), z = Math.atan2(P, S), Q = Math.sin((1 - n) * z) / P,
                                K = Math.sin(n * z) / P;
                            return this._w = y * Q + this._w * K, this._x = r * Q + this._x * K, this._y = a * Q + this._y * K, this._z = u * Q + this._z * K, this._onChangeCallback(), this
                        }

                        slerpQuaternions(e, n, r) {
                            return this.copy(e).slerp(n, r)
                        }

                        random() {
                            const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), r = Math.random(),
                                a = Math.sqrt(1 - r), u = Math.sqrt(r);
                            return this.set(a * Math.sin(e), a * Math.cos(e), u * Math.sin(n), u * Math.cos(n))
                        }

                        equals(e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                        }

                        fromArray(e, n = 0) {
                            return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this
                        }

                        toArray(e = [], n = 0) {
                            return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e
                        }

                        fromBufferAttribute(e, n) {
                            return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this
                        }

                        toJSON() {
                            return this.toArray()
                        }

                        _onChange(e) {
                            return this._onChangeCallback = e, this
                        }

                        _onChangeCallback() {
                        }

                        * [Symbol.iterator]() {
                            yield this._x, yield this._y, yield this._z, yield this._w
                        }
                    }

                    class Ne {
                        constructor(e = 0, n = 0, r = 0) {
                            Ne.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = r
                        }

                        set(e, n, r) {
                            return r === void 0 && (r = this.z), this.x = e, this.y = n, this.z = r, this
                        }

                        setScalar(e) {
                            return this.x = e, this.y = e, this.z = e, this
                        }

                        setX(e) {
                            return this.x = e, this
                        }

                        setY(e) {
                            return this.y = e, this
                        }

                        setZ(e) {
                            return this.z = e, this
                        }

                        setComponent(e, n) {
                            switch (e) {
                                case 0:
                                    this.x = n;
                                    break;
                                case 1:
                                    this.y = n;
                                    break;
                                case 2:
                                    this.z = n;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }

                        getComponent(e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }

                        clone() {
                            return new this.constructor(this.x, this.y, this.z)
                        }

                        copy(e) {
                            return this.x = e.x, this.y = e.y, this.z = e.z, this
                        }

                        add(e) {
                            return this.x += e.x, this.y += e.y, this.z += e.z, this
                        }

                        addScalar(e) {
                            return this.x += e, this.y += e, this.z += e, this
                        }

                        addVectors(e, n) {
                            return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this
                        }

                        addScaledVector(e, n) {
                            return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this
                        }

                        sub(e) {
                            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                        }

                        subScalar(e) {
                            return this.x -= e, this.y -= e, this.z -= e, this
                        }

                        subVectors(e, n) {
                            return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this
                        }

                        multiply(e) {
                            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
                        }

                        multiplyScalar(e) {
                            return this.x *= e, this.y *= e, this.z *= e, this
                        }

                        multiplyVectors(e, n) {
                            return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this
                        }

                        applyEuler(e) {
                            return this.applyQuaternion(qr.setFromEuler(e))
                        }

                        applyAxisAngle(e, n) {
                            return this.applyQuaternion(qr.setFromAxisAngle(e, n))
                        }

                        applyMatrix3(e) {
                            const n = this.x, r = this.y, a = this.z, u = e.elements;
                            return this.x = u[0] * n + u[3] * r + u[6] * a, this.y = u[1] * n + u[4] * r + u[7] * a, this.z = u[2] * n + u[5] * r + u[8] * a, this
                        }

                        applyNormalMatrix(e) {
                            return this.applyMatrix3(e).normalize()
                        }

                        applyMatrix4(e) {
                            const n = this.x, r = this.y, a = this.z, u = e.elements,
                                y = 1 / (u[3] * n + u[7] * r + u[11] * a + u[15]);
                            return this.x = (u[0] * n + u[4] * r + u[8] * a + u[12]) * y, this.y = (u[1] * n + u[5] * r + u[9] * a + u[13]) * y, this.z = (u[2] * n + u[6] * r + u[10] * a + u[14]) * y, this
                        }

                        applyQuaternion(e) {
                            const n = this.x, r = this.y, a = this.z, u = e.x, y = e.y, S = e.z, D = e.w,
                                P = 2 * (y * a - S * r), z = 2 * (S * n - u * a), Q = 2 * (u * r - y * n);
                            return this.x = n + D * P + y * Q - S * z, this.y = r + D * z + S * P - u * Q, this.z = a + D * Q + u * z - y * P, this
                        }

                        project(e) {
                            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                        }

                        unproject(e) {
                            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                        }

                        transformDirection(e) {
                            const n = this.x, r = this.y, a = this.z, u = e.elements;
                            return this.x = u[0] * n + u[4] * r + u[8] * a, this.y = u[1] * n + u[5] * r + u[9] * a, this.z = u[2] * n + u[6] * r + u[10] * a, this.normalize()
                        }

                        divide(e) {
                            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                        }

                        divideScalar(e) {
                            return this.multiplyScalar(1 / e)
                        }

                        min(e) {
                            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                        }

                        max(e) {
                            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                        }

                        clamp(e, n) {
                            return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this
                        }

                        clampScalar(e, n) {
                            return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this
                        }

                        clampLength(e, n) {
                            const r = this.length();
                            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
                        }

                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                        }

                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                        }

                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                        }

                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
                        }

                        negate() {
                            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                        }

                        dot(e) {
                            return this.x * e.x + this.y * e.y + this.z * e.z
                        }

                        lengthSq() {
                            return this.x * this.x + this.y * this.y + this.z * this.z
                        }

                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                        }

                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                        }

                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }

                        setLength(e) {
                            return this.normalize().multiplyScalar(e)
                        }

                        lerp(e, n) {
                            return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this
                        }

                        lerpVectors(e, n, r) {
                            return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this
                        }

                        cross(e) {
                            return this.crossVectors(this, e)
                        }

                        crossVectors(e, n) {
                            const r = e.x, a = e.y, u = e.z, y = n.x, S = n.y, D = n.z;
                            return this.x = a * D - u * S, this.y = u * y - r * D, this.z = r * S - a * y, this
                        }

                        projectOnVector(e) {
                            const n = e.lengthSq();
                            if (n === 0) return this.set(0, 0, 0);
                            const r = e.dot(this) / n;
                            return this.copy(e).multiplyScalar(r)
                        }

                        projectOnPlane(e) {
                            return Lo.copy(this).projectOnVector(e), this.sub(Lo)
                        }

                        reflect(e) {
                            return this.sub(Lo.copy(e).multiplyScalar(2 * this.dot(e)))
                        }

                        angleTo(e) {
                            const n = Math.sqrt(this.lengthSq() * e.lengthSq());
                            if (n === 0) return Math.PI / 2;
                            const r = this.dot(e) / n;
                            return Math.acos(Hr(r, -1, 1))
                        }

                        distanceTo(e) {
                            return Math.sqrt(this.distanceToSquared(e))
                        }

                        distanceToSquared(e) {
                            const n = this.x - e.x, r = this.y - e.y, a = this.z - e.z;
                            return n * n + r * r + a * a
                        }

                        manhattanDistanceTo(e) {
                            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                        }

                        setFromSpherical(e) {
                            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                        }

                        setFromSphericalCoords(e, n, r) {
                            const a = Math.sin(n) * e;
                            return this.x = a * Math.sin(r), this.y = Math.cos(n) * e, this.z = a * Math.cos(r), this
                        }

                        setFromCylindrical(e) {
                            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                        }

                        setFromCylindricalCoords(e, n, r) {
                            return this.x = e * Math.sin(n), this.y = r, this.z = e * Math.cos(n), this
                        }

                        setFromMatrixPosition(e) {
                            const n = e.elements;
                            return this.x = n[12], this.y = n[13], this.z = n[14], this
                        }

                        setFromMatrixScale(e) {
                            const n = this.setFromMatrixColumn(e, 0).length(),
                                r = this.setFromMatrixColumn(e, 1).length(),
                                a = this.setFromMatrixColumn(e, 2).length();
                            return this.x = n, this.y = r, this.z = a, this
                        }

                        setFromMatrixColumn(e, n) {
                            return this.fromArray(e.elements, n * 4)
                        }

                        setFromMatrix3Column(e, n) {
                            return this.fromArray(e.elements, n * 3)
                        }

                        setFromEuler(e) {
                            return this.x = e._x, this.y = e._y, this.z = e._z, this
                        }

                        setFromColor(e) {
                            return this.x = e.r, this.y = e.g, this.z = e.b, this
                        }

                        equals(e) {
                            return e.x === this.x && e.y === this.y && e.z === this.z
                        }

                        fromArray(e, n = 0) {
                            return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this
                        }

                        toArray(e = [], n = 0) {
                            return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e
                        }

                        fromBufferAttribute(e, n) {
                            return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this
                        }

                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                        }

                        randomDirection() {
                            const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, r = Math.sqrt(1 - n * n);
                            return this.x = r * Math.cos(e), this.y = n, this.z = r * Math.sin(e), this
                        }

                        * [Symbol.iterator]() {
                            yield this.x, yield this.y, yield this.z
                        }
                    }

                    const Lo = new Ne, qr = new $i;

                    class Ei {
                        constructor(e = new Ne(1 / 0, 1 / 0, 1 / 0), n = new Ne(-1 / 0, -1 / 0, -1 / 0)) {
                            this.isBox3 = !0, this.min = e, this.max = n
                        }

                        set(e, n) {
                            return this.min.copy(e), this.max.copy(n), this
                        }

                        setFromArray(e) {
                            this.makeEmpty();
                            for (let n = 0, r = e.length; n < r; n += 3) this.expandByPoint(Ts.fromArray(e, n));
                            return this
                        }

                        setFromBufferAttribute(e) {
                            this.makeEmpty();
                            for (let n = 0, r = e.count; n < r; n++) this.expandByPoint(Ts.fromBufferAttribute(e, n));
                            return this
                        }

                        setFromPoints(e) {
                            this.makeEmpty();
                            for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
                            return this
                        }

                        setFromCenterAndSize(e, n) {
                            const r = Ts.copy(n).multiplyScalar(.5);
                            return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                        }

                        setFromObject(e, n = !1) {
                            return this.makeEmpty(), this.expandByObject(e, n)
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        copy(e) {
                            return this.min.copy(e.min), this.max.copy(e.max), this
                        }

                        makeEmpty() {
                            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                        }

                        isEmpty() {
                            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                        }

                        getCenter(e) {
                            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                        }

                        getSize(e) {
                            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                        }

                        expandByPoint(e) {
                            return this.min.min(e), this.max.max(e), this
                        }

                        expandByVector(e) {
                            return this.min.sub(e), this.max.add(e), this
                        }

                        expandByScalar(e) {
                            return this.min.addScalar(-e), this.max.addScalar(e), this
                        }

                        expandByObject(e, n = !1) {
                            e.updateWorldMatrix(!1, !1);
                            const r = e.geometry;
                            if (r !== void 0) {
                                const u = r.getAttribute("position");
                                if (n === !0 && u !== void 0 && e.isInstancedMesh !== !0) for (let y = 0, S = u.count; y < S; y++) e.isMesh === !0 ? e.getVertexPosition(y, Ts) : Ts.fromBufferAttribute(u, y), Ts.applyMatrix4(e.matrixWorld), this.expandByPoint(Ts); else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Do.copy(e.boundingBox)) : (r.boundingBox === null && r.computeBoundingBox(), Do.copy(r.boundingBox)), Do.applyMatrix4(e.matrixWorld), this.union(Do)
                            }
                            const a = e.children;
                            for (let u = 0, y = a.length; u < y; u++) this.expandByObject(a[u], n);
                            return this
                        }

                        containsPoint(e) {
                            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                        }

                        containsBox(e) {
                            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                        }

                        getParameter(e, n) {
                            return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                        }

                        intersectsBox(e) {
                            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                        }

                        intersectsSphere(e) {
                            return this.clampPoint(e.center, Ts), Ts.distanceToSquared(e.center) <= e.radius * e.radius
                        }

                        intersectsPlane(e) {
                            let n, r;
                            return e.normal.x > 0 ? (n = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, r += e.normal.z * this.min.z), n <= -e.constant && r >= -e.constant
                        }

                        intersectsTriangle(e) {
                            if (this.isEmpty()) return !1;
                            this.getCenter(lr), Sr.subVectors(this.max, lr), wo.subVectors(e.a, lr), ms.subVectors(e.b, lr), Si.subVectors(e.c, lr), As.subVectors(ms, wo), Hs.subVectors(Si, ms), Is.subVectors(wo, Si);
                            let n = [0, -As.z, As.y, 0, -Hs.z, Hs.y, 0, -Is.z, Is.y, As.z, 0, -As.x, Hs.z, 0, -Hs.x, Is.z, 0, -Is.x, -As.y, As.x, 0, -Hs.y, Hs.x, 0, -Is.y, Is.x, 0];
                            return !Qs(n, wo, ms, Si, Sr) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Qs(n, wo, ms, Si, Sr)) ? !1 : (Li.crossVectors(As, Hs), n = [Li.x, Li.y, Li.z], Qs(n, wo, ms, Si, Sr))
                        }

                        clampPoint(e, n) {
                            return n.copy(e).clamp(this.min, this.max)
                        }

                        distanceToPoint(e) {
                            return this.clampPoint(e, Ts).distanceTo(e)
                        }

                        getBoundingSphere(e) {
                            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Ts).length() * .5), e
                        }

                        intersect(e) {
                            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                        }

                        union(e) {
                            return this.min.min(e.min), this.max.max(e.max), this
                        }

                        applyMatrix4(e) {
                            return this.isEmpty() ? this : (Ni[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ni[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ni[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ni[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ni[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ni[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ni[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ni[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ni), this)
                        }

                        translate(e) {
                            return this.min.add(e), this.max.add(e), this
                        }

                        equals(e) {
                            return e.min.equals(this.min) && e.max.equals(this.max)
                        }
                    }

                    const Ni = [new Ne, new Ne, new Ne, new Ne, new Ne, new Ne, new Ne, new Ne], Ts = new Ne,
                        Do = new Ei, wo = new Ne, ms = new Ne, Si = new Ne, As = new Ne, Hs = new Ne, Is = new Ne,
                        lr = new Ne, Sr = new Ne, Li = new Ne, Ki = new Ne;

                    function Qs(d, e, n, r, a) {
                        for (let u = 0, y = d.length - 3; u <= y; u += 3) {
                            Ki.fromArray(d, u);
                            const S = a.x * Math.abs(Ki.x) + a.y * Math.abs(Ki.y) + a.z * Math.abs(Ki.z), D = e.dot(Ki),
                                P = n.dot(Ki), z = r.dot(Ki);
                            if (Math.max(-Math.max(D, P, z), Math.min(D, P, z)) > S) return !1
                        }
                        return !0
                    }

                    const Va = new Ei, wa = new Ne, Il = new Ne;

                    class as {
                        constructor(e = new Ne, n = -1) {
                            this.isSphere = !0, this.center = e, this.radius = n
                        }

                        set(e, n) {
                            return this.center.copy(e), this.radius = n, this
                        }

                        setFromPoints(e, n) {
                            const r = this.center;
                            n !== void 0 ? r.copy(n) : Va.setFromPoints(e).getCenter(r);
                            let a = 0;
                            for (let u = 0, y = e.length; u < y; u++) a = Math.max(a, r.distanceToSquared(e[u]));
                            return this.radius = Math.sqrt(a), this
                        }

                        copy(e) {
                            return this.center.copy(e.center), this.radius = e.radius, this
                        }

                        isEmpty() {
                            return this.radius < 0
                        }

                        makeEmpty() {
                            return this.center.set(0, 0, 0), this.radius = -1, this
                        }

                        containsPoint(e) {
                            return e.distanceToSquared(this.center) <= this.radius * this.radius
                        }

                        distanceToPoint(e) {
                            return e.distanceTo(this.center) - this.radius
                        }

                        intersectsSphere(e) {
                            const n = this.radius + e.radius;
                            return e.center.distanceToSquared(this.center) <= n * n
                        }

                        intersectsBox(e) {
                            return e.intersectsSphere(this)
                        }

                        intersectsPlane(e) {
                            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                        }

                        clampPoint(e, n) {
                            const r = this.center.distanceToSquared(e);
                            return n.copy(e), r > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
                        }

                        getBoundingBox(e) {
                            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                        }

                        applyMatrix4(e) {
                            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                        }

                        translate(e) {
                            return this.center.add(e), this
                        }

                        expandByPoint(e) {
                            if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
                            wa.subVectors(e, this.center);
                            const n = wa.lengthSq();
                            if (n > this.radius * this.radius) {
                                const r = Math.sqrt(n), a = (r - this.radius) * .5;
                                this.center.addScaledVector(wa, a / r), this.radius += a
                            }
                            return this
                        }

                        union(e) {
                            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Il.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(wa.copy(e.center).add(Il)), this.expandByPoint(wa.copy(e.center).sub(Il))), this)
                        }

                        equals(e) {
                            return e.center.equals(this.center) && e.radius === this.radius
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    const fa = new Ne, cc = new Ne, Yc = new Ne, Ha = new Ne, uc = new Ne, Ko = new Ne, qc = new Ne;

                    class jr {
                        constructor(e = new Ne, n = new Ne(0, 0, -1)) {
                            this.origin = e, this.direction = n
                        }

                        set(e, n) {
                            return this.origin.copy(e), this.direction.copy(n), this
                        }

                        copy(e) {
                            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                        }

                        at(e, n) {
                            return n.copy(this.origin).addScaledVector(this.direction, e)
                        }

                        lookAt(e) {
                            return this.direction.copy(e).sub(this.origin).normalize(), this
                        }

                        recast(e) {
                            return this.origin.copy(this.at(e, fa)), this
                        }

                        closestPointToPoint(e, n) {
                            n.subVectors(e, this.origin);
                            const r = n.dot(this.direction);
                            return r < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, r)
                        }

                        distanceToPoint(e) {
                            return Math.sqrt(this.distanceSqToPoint(e))
                        }

                        distanceSqToPoint(e) {
                            const n = fa.subVectors(e, this.origin).dot(this.direction);
                            return n < 0 ? this.origin.distanceToSquared(e) : (fa.copy(this.origin).addScaledVector(this.direction, n), fa.distanceToSquared(e))
                        }

                        distanceSqToSegment(e, n, r, a) {
                            cc.copy(e).add(n).multiplyScalar(.5), Yc.copy(n).sub(e).normalize(), Ha.copy(this.origin).sub(cc);
                            const u = e.distanceTo(n) * .5, y = -this.direction.dot(Yc), S = Ha.dot(this.direction),
                                D = -Ha.dot(Yc), P = Ha.lengthSq(), z = Math.abs(1 - y * y);
                            let Q, K, q, te;
                            if (z > 0) if (Q = y * D - S, K = y * S - D, te = u * z, Q >= 0) if (K >= -te) if (K <= te) {
                                const le = 1 / z;
                                Q *= le, K *= le, q = Q * (Q + y * K + 2 * S) + K * (y * Q + K + 2 * D) + P
                            } else K = u, Q = Math.max(0, -(y * K + S)), q = -Q * Q + K * (K + 2 * D) + P; else K = -u, Q = Math.max(0, -(y * K + S)), q = -Q * Q + K * (K + 2 * D) + P; else K <= -te ? (Q = Math.max(0, -(-y * u + S)), K = Q > 0 ? -u : Math.min(Math.max(-u, -D), u), q = -Q * Q + K * (K + 2 * D) + P) : K <= te ? (Q = 0, K = Math.min(Math.max(-u, -D), u), q = K * (K + 2 * D) + P) : (Q = Math.max(0, -(y * u + S)), K = Q > 0 ? u : Math.min(Math.max(-u, -D), u), q = -Q * Q + K * (K + 2 * D) + P); else K = y > 0 ? -u : u, Q = Math.max(0, -(y * K + S)), q = -Q * Q + K * (K + 2 * D) + P;
                            return r && r.copy(this.origin).addScaledVector(this.direction, Q), a && a.copy(cc).addScaledVector(Yc, K), q
                        }

                        intersectSphere(e, n) {
                            fa.subVectors(e.center, this.origin);
                            const r = fa.dot(this.direction), a = fa.dot(fa) - r * r, u = e.radius * e.radius;
                            if (a > u) return null;
                            const y = Math.sqrt(u - a), S = r - y, D = r + y;
                            return D < 0 ? null : S < 0 ? this.at(D, n) : this.at(S, n)
                        }

                        intersectsSphere(e) {
                            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                        }

                        distanceToPlane(e) {
                            const n = e.normal.dot(this.direction);
                            if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
                            const r = -(this.origin.dot(e.normal) + e.constant) / n;
                            return r >= 0 ? r : null
                        }

                        intersectPlane(e, n) {
                            const r = this.distanceToPlane(e);
                            return r === null ? null : this.at(r, n)
                        }

                        intersectsPlane(e) {
                            const n = e.distanceToPoint(this.origin);
                            return n === 0 || e.normal.dot(this.direction) * n < 0
                        }

                        intersectBox(e, n) {
                            let r, a, u, y, S, D;
                            const P = 1 / this.direction.x, z = 1 / this.direction.y, Q = 1 / this.direction.z,
                                K = this.origin;
                            return P >= 0 ? (r = (e.min.x - K.x) * P, a = (e.max.x - K.x) * P) : (r = (e.max.x - K.x) * P, a = (e.min.x - K.x) * P), z >= 0 ? (u = (e.min.y - K.y) * z, y = (e.max.y - K.y) * z) : (u = (e.max.y - K.y) * z, y = (e.min.y - K.y) * z), r > y || u > a || ((u > r || isNaN(r)) && (r = u), (y < a || isNaN(a)) && (a = y), Q >= 0 ? (S = (e.min.z - K.z) * Q, D = (e.max.z - K.z) * Q) : (S = (e.max.z - K.z) * Q, D = (e.min.z - K.z) * Q), r > D || S > a) || ((S > r || r !== r) && (r = S), (D < a || a !== a) && (a = D), a < 0) ? null : this.at(r >= 0 ? r : a, n)
                        }

                        intersectsBox(e) {
                            return this.intersectBox(e, fa) !== null
                        }

                        intersectTriangle(e, n, r, a, u) {
                            uc.subVectors(n, e), Ko.subVectors(r, e), qc.crossVectors(uc, Ko);
                            let y = this.direction.dot(qc), S;
                            if (y > 0) {
                                if (a) return null;
                                S = 1
                            } else if (y < 0) S = -1, y = -y; else return null;
                            Ha.subVectors(this.origin, e);
                            const D = S * this.direction.dot(Ko.crossVectors(Ha, Ko));
                            if (D < 0) return null;
                            const P = S * this.direction.dot(uc.cross(Ha));
                            if (P < 0 || D + P > y) return null;
                            const z = -S * Ha.dot(qc);
                            return z < 0 ? null : this.at(z / y, u)
                        }

                        applyMatrix4(e) {
                            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                        }

                        equals(e) {
                            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    class Mn {
                        constructor(e, n, r, a, u, y, S, D, P, z, Q, K, q, te, le, ne) {
                            Mn.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, n, r, a, u, y, S, D, P, z, Q, K, q, te, le, ne)
                        }

                        set(e, n, r, a, u, y, S, D, P, z, Q, K, q, te, le, ne) {
                            const J = this.elements;
                            return J[0] = e, J[4] = n, J[8] = r, J[12] = a, J[1] = u, J[5] = y, J[9] = S, J[13] = D, J[2] = P, J[6] = z, J[10] = Q, J[14] = K, J[3] = q, J[7] = te, J[11] = le, J[15] = ne, this
                        }

                        identity() {
                            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }

                        clone() {
                            return new Mn().fromArray(this.elements)
                        }

                        copy(e) {
                            const n = this.elements, r = e.elements;
                            return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this
                        }

                        copyPosition(e) {
                            const n = this.elements, r = e.elements;
                            return n[12] = r[12], n[13] = r[13], n[14] = r[14], this
                        }

                        setFromMatrix3(e) {
                            const n = e.elements;
                            return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1), this
                        }

                        extractBasis(e, n, r) {
                            return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this
                        }

                        makeBasis(e, n, r) {
                            return this.set(e.x, n.x, r.x, 0, e.y, n.y, r.y, 0, e.z, n.z, r.z, 0, 0, 0, 0, 1), this
                        }

                        extractRotation(e) {
                            const n = this.elements, r = e.elements, a = 1 / Xo.setFromMatrixColumn(e, 0).length(),
                                u = 1 / Xo.setFromMatrixColumn(e, 1).length(),
                                y = 1 / Xo.setFromMatrixColumn(e, 2).length();
                            return n[0] = r[0] * a, n[1] = r[1] * a, n[2] = r[2] * a, n[3] = 0, n[4] = r[4] * u, n[5] = r[5] * u, n[6] = r[6] * u, n[7] = 0, n[8] = r[8] * y, n[9] = r[9] * y, n[10] = r[10] * y, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
                        }

                        makeRotationFromEuler(e) {
                            const n = this.elements, r = e.x, a = e.y, u = e.z, y = Math.cos(r), S = Math.sin(r),
                                D = Math.cos(a), P = Math.sin(a), z = Math.cos(u), Q = Math.sin(u);
                            if (e.order === "XYZ") {
                                const K = y * z, q = y * Q, te = S * z, le = S * Q;
                                n[0] = D * z, n[4] = -D * Q, n[8] = P, n[1] = q + te * P, n[5] = K - le * P, n[9] = -S * D, n[2] = le - K * P, n[6] = te + q * P, n[10] = y * D
                            } else if (e.order === "YXZ") {
                                const K = D * z, q = D * Q, te = P * z, le = P * Q;
                                n[0] = K + le * S, n[4] = te * S - q, n[8] = y * P, n[1] = y * Q, n[5] = y * z, n[9] = -S, n[2] = q * S - te, n[6] = le + K * S, n[10] = y * D
                            } else if (e.order === "ZXY") {
                                const K = D * z, q = D * Q, te = P * z, le = P * Q;
                                n[0] = K - le * S, n[4] = -y * Q, n[8] = te + q * S, n[1] = q + te * S, n[5] = y * z, n[9] = le - K * S, n[2] = -y * P, n[6] = S, n[10] = y * D
                            } else if (e.order === "ZYX") {
                                const K = y * z, q = y * Q, te = S * z, le = S * Q;
                                n[0] = D * z, n[4] = te * P - q, n[8] = K * P + le, n[1] = D * Q, n[5] = le * P + K, n[9] = q * P - te, n[2] = -P, n[6] = S * D, n[10] = y * D
                            } else if (e.order === "YZX") {
                                const K = y * D, q = y * P, te = S * D, le = S * P;
                                n[0] = D * z, n[4] = le - K * Q, n[8] = te * Q + q, n[1] = Q, n[5] = y * z, n[9] = -S * z, n[2] = -P * z, n[6] = q * Q + te, n[10] = K - le * Q
                            } else if (e.order === "XZY") {
                                const K = y * D, q = y * P, te = S * D, le = S * P;
                                n[0] = D * z, n[4] = -Q, n[8] = P * z, n[1] = K * Q + le, n[5] = y * z, n[9] = q * Q - te, n[2] = te * Q - q, n[6] = S * z, n[10] = le * Q + K
                            }
                            return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
                        }

                        makeRotationFromQuaternion(e) {
                            return this.compose(Df, e, U0)
                        }

                        lookAt(e, n, r) {
                            const a = this.elements;
                            return to.subVectors(e, n), to.lengthSq() === 0 && (to.z = 1), to.normalize(), Rl.crossVectors(r, to), Rl.lengthSq() === 0 && (Math.abs(r.z) === 1 ? to.x += 1e-4 : to.z += 1e-4, to.normalize(), Rl.crossVectors(r, to)), Rl.normalize(), Qa.crossVectors(to, Rl), a[0] = Rl.x, a[4] = Qa.x, a[8] = to.x, a[1] = Rl.y, a[5] = Qa.y, a[9] = to.y, a[2] = Rl.z, a[6] = Qa.z, a[10] = to.z, this
                        }

                        multiply(e) {
                            return this.multiplyMatrices(this, e)
                        }

                        premultiply(e) {
                            return this.multiplyMatrices(e, this)
                        }

                        multiplyMatrices(e, n) {
                            const r = e.elements, a = n.elements, u = this.elements, y = r[0], S = r[4], D = r[8],
                                P = r[12], z = r[1], Q = r[5], K = r[9], q = r[13], te = r[2], le = r[6], ne = r[10],
                                J = r[14], Ce = r[3], ye = r[7], ge = r[11], $e = r[15], ze = a[0], We = a[4],
                                qe = a[8], Pe = a[12], Te = a[1], Je = a[5], ht = a[9], lt = a[13], pt = a[2],
                                Mt = a[6], Ut = a[10], mn = a[14], Tt = a[3], dn = a[7], fn = a[11], Kn = a[15];
                            return u[0] = y * ze + S * Te + D * pt + P * Tt, u[4] = y * We + S * Je + D * Mt + P * dn, u[8] = y * qe + S * ht + D * Ut + P * fn, u[12] = y * Pe + S * lt + D * mn + P * Kn, u[1] = z * ze + Q * Te + K * pt + q * Tt, u[5] = z * We + Q * Je + K * Mt + q * dn, u[9] = z * qe + Q * ht + K * Ut + q * fn, u[13] = z * Pe + Q * lt + K * mn + q * Kn, u[2] = te * ze + le * Te + ne * pt + J * Tt, u[6] = te * We + le * Je + ne * Mt + J * dn, u[10] = te * qe + le * ht + ne * Ut + J * fn, u[14] = te * Pe + le * lt + ne * mn + J * Kn, u[3] = Ce * ze + ye * Te + ge * pt + $e * Tt, u[7] = Ce * We + ye * Je + ge * Mt + $e * dn, u[11] = Ce * qe + ye * ht + ge * Ut + $e * fn, u[15] = Ce * Pe + ye * lt + ge * mn + $e * Kn, this
                        }

                        multiplyScalar(e) {
                            const n = this.elements;
                            return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this
                        }

                        determinant() {
                            const e = this.elements, n = e[0], r = e[4], a = e[8], u = e[12], y = e[1], S = e[5],
                                D = e[9], P = e[13], z = e[2], Q = e[6], K = e[10], q = e[14], te = e[3], le = e[7],
                                ne = e[11], J = e[15];
                            return te * (+u * D * Q - a * P * Q - u * S * K + r * P * K + a * S * q - r * D * q) + le * (+n * D * q - n * P * K + u * y * K - a * y * q + a * P * z - u * D * z) + ne * (+n * P * Q - n * S * q - u * y * Q + r * y * q + u * S * z - r * P * z) + J * (-a * S * z - n * D * Q + n * S * K + a * y * Q - r * y * K + r * D * z)
                        }

                        transpose() {
                            const e = this.elements;
                            let n;
                            return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this
                        }

                        setPosition(e, n, r) {
                            const a = this.elements;
                            return e.isVector3 ? (a[12] = e.x, a[13] = e.y, a[14] = e.z) : (a[12] = e, a[13] = n, a[14] = r), this
                        }

                        invert() {
                            const e = this.elements, n = e[0], r = e[1], a = e[2], u = e[3], y = e[4], S = e[5],
                                D = e[6], P = e[7], z = e[8], Q = e[9], K = e[10], q = e[11], te = e[12], le = e[13],
                                ne = e[14], J = e[15],
                                Ce = Q * ne * P - le * K * P + le * D * q - S * ne * q - Q * D * J + S * K * J,
                                ye = te * K * P - z * ne * P - te * D * q + y * ne * q + z * D * J - y * K * J,
                                ge = z * le * P - te * Q * P + te * S * q - y * le * q - z * S * J + y * Q * J,
                                $e = te * Q * D - z * le * D - te * S * K + y * le * K + z * S * ne - y * Q * ne,
                                ze = n * Ce + r * ye + a * ge + u * $e;
                            if (ze === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                            const We = 1 / ze;
                            return e[0] = Ce * We, e[1] = (le * K * u - Q * ne * u - le * a * q + r * ne * q + Q * a * J - r * K * J) * We, e[2] = (S * ne * u - le * D * u + le * a * P - r * ne * P - S * a * J + r * D * J) * We, e[3] = (Q * D * u - S * K * u - Q * a * P + r * K * P + S * a * q - r * D * q) * We, e[4] = ye * We, e[5] = (z * ne * u - te * K * u + te * a * q - n * ne * q - z * a * J + n * K * J) * We, e[6] = (te * D * u - y * ne * u - te * a * P + n * ne * P + y * a * J - n * D * J) * We, e[7] = (y * K * u - z * D * u + z * a * P - n * K * P - y * a * q + n * D * q) * We, e[8] = ge * We, e[9] = (te * Q * u - z * le * u - te * r * q + n * le * q + z * r * J - n * Q * J) * We, e[10] = (y * le * u - te * S * u + te * r * P - n * le * P - y * r * J + n * S * J) * We, e[11] = (z * S * u - y * Q * u - z * r * P + n * Q * P + y * r * q - n * S * q) * We, e[12] = $e * We, e[13] = (z * le * a - te * Q * a + te * r * K - n * le * K - z * r * ne + n * Q * ne) * We, e[14] = (te * S * a - y * le * a - te * r * D + n * le * D + y * r * ne - n * S * ne) * We, e[15] = (y * Q * a - z * S * a + z * r * D - n * Q * D - y * r * K + n * S * K) * We, this
                        }

                        scale(e) {
                            const n = this.elements, r = e.x, a = e.y, u = e.z;
                            return n[0] *= r, n[4] *= a, n[8] *= u, n[1] *= r, n[5] *= a, n[9] *= u, n[2] *= r, n[6] *= a, n[10] *= u, n[3] *= r, n[7] *= a, n[11] *= u, this
                        }

                        getMaxScaleOnAxis() {
                            const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                                r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                                a = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                            return Math.sqrt(Math.max(n, r, a))
                        }

                        makeTranslation(e, n, r) {
                            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1), this
                        }

                        makeRotationX(e) {
                            const n = Math.cos(e), r = Math.sin(e);
                            return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1), this
                        }

                        makeRotationY(e) {
                            const n = Math.cos(e), r = Math.sin(e);
                            return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1), this
                        }

                        makeRotationZ(e) {
                            const n = Math.cos(e), r = Math.sin(e);
                            return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }

                        makeRotationAxis(e, n) {
                            const r = Math.cos(n), a = Math.sin(n), u = 1 - r, y = e.x, S = e.y, D = e.z, P = u * y,
                                z = u * S;
                            return this.set(P * y + r, P * S - a * D, P * D + a * S, 0, P * S + a * D, z * S + r, z * D - a * y, 0, P * D - a * S, z * D + a * y, u * D * D + r, 0, 0, 0, 0, 1), this
                        }

                        makeScale(e, n, r) {
                            return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this
                        }

                        makeShear(e, n, r, a, u, y) {
                            return this.set(1, r, u, 0, e, 1, y, 0, n, a, 1, 0, 0, 0, 0, 1), this
                        }

                        compose(e, n, r) {
                            const a = this.elements, u = n._x, y = n._y, S = n._z, D = n._w, P = u + u, z = y + y,
                                Q = S + S, K = u * P, q = u * z, te = u * Q, le = y * z, ne = y * Q, J = S * Q,
                                Ce = D * P, ye = D * z, ge = D * Q, $e = r.x, ze = r.y, We = r.z;
                            return a[0] = (1 - (le + J)) * $e, a[1] = (q + ge) * $e, a[2] = (te - ye) * $e, a[3] = 0, a[4] = (q - ge) * ze, a[5] = (1 - (K + J)) * ze, a[6] = (ne + Ce) * ze, a[7] = 0, a[8] = (te + ye) * We, a[9] = (ne - Ce) * We, a[10] = (1 - (K + le)) * We, a[11] = 0, a[12] = e.x, a[13] = e.y, a[14] = e.z, a[15] = 1, this
                        }

                        decompose(e, n, r) {
                            const a = this.elements;
                            let u = Xo.set(a[0], a[1], a[2]).length();
                            const y = Xo.set(a[4], a[5], a[6]).length(), S = Xo.set(a[8], a[9], a[10]).length();
                            this.determinant() < 0 && (u = -u), e.x = a[12], e.y = a[13], e.z = a[14], ts.copy(this);
                            const P = 1 / u, z = 1 / y, Q = 1 / S;
                            return ts.elements[0] *= P, ts.elements[1] *= P, ts.elements[2] *= P, ts.elements[4] *= z, ts.elements[5] *= z, ts.elements[6] *= z, ts.elements[8] *= Q, ts.elements[9] *= Q, ts.elements[10] *= Q, n.setFromRotationMatrix(ts), r.x = u, r.y = y, r.z = S, this
                        }

                        makePerspective(e, n, r, a, u, y, S = da) {
                            const D = this.elements, P = 2 * u / (n - e), z = 2 * u / (r - a), Q = (n + e) / (n - e),
                                K = (r + a) / (r - a);
                            let q, te;
                            if (S === da) q = -(y + u) / (y - u), te = -2 * y * u / (y - u); else if (S === sl) q = -y / (y - u), te = -y * u / (y - u); else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + S);
                            return D[0] = P, D[4] = 0, D[8] = Q, D[12] = 0, D[1] = 0, D[5] = z, D[9] = K, D[13] = 0, D[2] = 0, D[6] = 0, D[10] = q, D[14] = te, D[3] = 0, D[7] = 0, D[11] = -1, D[15] = 0, this
                        }

                        makeOrthographic(e, n, r, a, u, y, S = da) {
                            const D = this.elements, P = 1 / (n - e), z = 1 / (r - a), Q = 1 / (y - u), K = (n + e) * P,
                                q = (r + a) * z;
                            let te, le;
                            if (S === da) te = (y + u) * Q, le = -2 * Q; else if (S === sl) te = u * Q, le = -1 * Q; else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + S);
                            return D[0] = 2 * P, D[4] = 0, D[8] = 0, D[12] = -K, D[1] = 0, D[5] = 2 * z, D[9] = 0, D[13] = -q, D[2] = 0, D[6] = 0, D[10] = le, D[14] = -te, D[3] = 0, D[7] = 0, D[11] = 0, D[15] = 1, this
                        }

                        equals(e) {
                            const n = this.elements, r = e.elements;
                            for (let a = 0; a < 16; a++) if (n[a] !== r[a]) return !1;
                            return !0
                        }

                        fromArray(e, n = 0) {
                            for (let r = 0; r < 16; r++) this.elements[r] = e[r + n];
                            return this
                        }

                        toArray(e = [], n = 0) {
                            const r = this.elements;
                            return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e[n + 9] = r[9], e[n + 10] = r[10], e[n + 11] = r[11], e[n + 12] = r[12], e[n + 13] = r[13], e[n + 14] = r[14], e[n + 15] = r[15], e
                        }
                    }

                    const Xo = new Ne, ts = new Mn, Df = new Ne(0, 0, 0), U0 = new Ne(1, 1, 1), Rl = new Ne,
                        Qa = new Ne, to = new Ne, hc = new Mn, Ku = new $i;

                    class bo {
                        constructor(e = 0, n = 0, r = 0, a = bo.DEFAULT_ORDER) {
                            this.isEuler = !0, this._x = e, this._y = n, this._z = r, this._order = a
                        }

                        get x() {
                            return this._x
                        }

                        set x(e) {
                            this._x = e, this._onChangeCallback()
                        }

                        get y() {
                            return this._y
                        }

                        set y(e) {
                            this._y = e, this._onChangeCallback()
                        }

                        get z() {
                            return this._z
                        }

                        set z(e) {
                            this._z = e, this._onChangeCallback()
                        }

                        get order() {
                            return this._order
                        }

                        set order(e) {
                            this._order = e, this._onChangeCallback()
                        }

                        set(e, n, r, a = this._order) {
                            return this._x = e, this._y = n, this._z = r, this._order = a, this._onChangeCallback(), this
                        }

                        clone() {
                            return new this.constructor(this._x, this._y, this._z, this._order)
                        }

                        copy(e) {
                            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                        }

                        setFromRotationMatrix(e, n = this._order, r = !0) {
                            const a = e.elements, u = a[0], y = a[4], S = a[8], D = a[1], P = a[5], z = a[9], Q = a[2],
                                K = a[6], q = a[10];
                            switch (n) {
                                case"XYZ":
                                    this._y = Math.asin(Hr(S, -1, 1)), Math.abs(S) < .9999999 ? (this._x = Math.atan2(-z, q), this._z = Math.atan2(-y, u)) : (this._x = Math.atan2(K, P), this._z = 0);
                                    break;
                                case"YXZ":
                                    this._x = Math.asin(-Hr(z, -1, 1)), Math.abs(z) < .9999999 ? (this._y = Math.atan2(S, q), this._z = Math.atan2(D, P)) : (this._y = Math.atan2(-Q, u), this._z = 0);
                                    break;
                                case"ZXY":
                                    this._x = Math.asin(Hr(K, -1, 1)), Math.abs(K) < .9999999 ? (this._y = Math.atan2(-Q, q), this._z = Math.atan2(-y, P)) : (this._y = 0, this._z = Math.atan2(D, u));
                                    break;
                                case"ZYX":
                                    this._y = Math.asin(-Hr(Q, -1, 1)), Math.abs(Q) < .9999999 ? (this._x = Math.atan2(K, q), this._z = Math.atan2(D, u)) : (this._x = 0, this._z = Math.atan2(-y, P));
                                    break;
                                case"YZX":
                                    this._z = Math.asin(Hr(D, -1, 1)), Math.abs(D) < .9999999 ? (this._x = Math.atan2(-z, P), this._y = Math.atan2(-Q, u)) : (this._x = 0, this._y = Math.atan2(S, q));
                                    break;
                                case"XZY":
                                    this._z = Math.asin(-Hr(y, -1, 1)), Math.abs(y) < .9999999 ? (this._x = Math.atan2(K, P), this._y = Math.atan2(S, u)) : (this._x = Math.atan2(-z, q), this._y = 0);
                                    break;
                                default:
                                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
                            }
                            return this._order = n, r === !0 && this._onChangeCallback(), this
                        }

                        setFromQuaternion(e, n, r) {
                            return hc.makeRotationFromQuaternion(e), this.setFromRotationMatrix(hc, n, r)
                        }

                        setFromVector3(e, n = this._order) {
                            return this.set(e.x, e.y, e.z, n)
                        }

                        reorder(e) {
                            return Ku.setFromEuler(this), this.setFromQuaternion(Ku, e)
                        }

                        equals(e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                        }

                        fromArray(e) {
                            return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
                        }

                        toArray(e = [], n = 0) {
                            return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e
                        }

                        _onChange(e) {
                            return this._onChangeCallback = e, this
                        }

                        _onChangeCallback() {
                        }

                        * [Symbol.iterator]() {
                            yield this._x, yield this._y, yield this._z, yield this._order
                        }
                    }

                    bo.DEFAULT_ORDER = "XYZ";

                    class hl {
                        constructor() {
                            this.mask = 1
                        }

                        set(e) {
                            this.mask = (1 << e | 0) >>> 0
                        }

                        enable(e) {
                            this.mask |= 1 << e | 0
                        }

                        enableAll() {
                            this.mask = -1
                        }

                        toggle(e) {
                            this.mask ^= 1 << e | 0
                        }

                        disable(e) {
                            this.mask &= ~(1 << e | 0)
                        }

                        disableAll() {
                            this.mask = 0
                        }

                        test(e) {
                            return (this.mask & e.mask) !== 0
                        }

                        isEnabled(e) {
                            return (this.mask & (1 << e | 0)) !== 0
                        }
                    }

                    let Bl = 0;
                    const Gr = new Ne, Ar = new $i, ho = new Mn, Rs = new Ne, js = new Ne, dc = new Ne, Jc = new $i,
                        _o = new Ne(1, 0, 0), Xu = new Ne(0, 1, 0), Pf = new Ne(0, 0, 1), Of = {type: "added"},
                        id = {type: "removed"}, fc = {type: "childadded", child: null},
                        ba = {type: "childremoved", child: null};

                    class or extends Ss {
                        constructor() {
                            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {value: Bl++}), this.uuid = uo(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = or.DEFAULT_UP.clone();
                            const e = new Ne, n = new bo, r = new $i, a = new Ne(1, 1, 1);

                            function u() {
                                r.setFromEuler(n, !1)
                            }

                            function y() {
                                n.setFromQuaternion(r, void 0, !1)
                            }

                            n._onChange(u), r._onChange(y), Object.defineProperties(this, {
                                position: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: e
                                },
                                rotation: {configurable: !0, enumerable: !0, value: n},
                                quaternion: {configurable: !0, enumerable: !0, value: r},
                                scale: {configurable: !0, enumerable: !0, value: a},
                                modelViewMatrix: {value: new Mn},
                                normalMatrix: {value: new ai}
                            }), this.matrix = new Mn, this.matrixWorld = new Mn, this.matrixAutoUpdate = or.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = or.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new hl, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                        }

                        onBeforeShadow() {
                        }

                        onAfterShadow() {
                        }

                        onBeforeRender() {
                        }

                        onAfterRender() {
                        }

                        applyMatrix4(e) {
                            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                        }

                        applyQuaternion(e) {
                            return this.quaternion.premultiply(e), this
                        }

                        setRotationFromAxisAngle(e, n) {
                            this.quaternion.setFromAxisAngle(e, n)
                        }

                        setRotationFromEuler(e) {
                            this.quaternion.setFromEuler(e, !0)
                        }

                        setRotationFromMatrix(e) {
                            this.quaternion.setFromRotationMatrix(e)
                        }

                        setRotationFromQuaternion(e) {
                            this.quaternion.copy(e)
                        }

                        rotateOnAxis(e, n) {
                            return Ar.setFromAxisAngle(e, n), this.quaternion.multiply(Ar), this
                        }

                        rotateOnWorldAxis(e, n) {
                            return Ar.setFromAxisAngle(e, n), this.quaternion.premultiply(Ar), this
                        }

                        rotateX(e) {
                            return this.rotateOnAxis(_o, e)
                        }

                        rotateY(e) {
                            return this.rotateOnAxis(Xu, e)
                        }

                        rotateZ(e) {
                            return this.rotateOnAxis(Pf, e)
                        }

                        translateOnAxis(e, n) {
                            return Gr.copy(e).applyQuaternion(this.quaternion), this.position.add(Gr.multiplyScalar(n)), this
                        }

                        translateX(e) {
                            return this.translateOnAxis(_o, e)
                        }

                        translateY(e) {
                            return this.translateOnAxis(Xu, e)
                        }

                        translateZ(e) {
                            return this.translateOnAxis(Pf, e)
                        }

                        localToWorld(e) {
                            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
                        }

                        worldToLocal(e) {
                            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ho.copy(this.matrixWorld).invert())
                        }

                        lookAt(e, n, r) {
                            e.isVector3 ? Rs.copy(e) : Rs.set(e, n, r);
                            const a = this.parent;
                            this.updateWorldMatrix(!0, !1), js.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ho.lookAt(js, Rs, this.up) : ho.lookAt(Rs, js, this.up), this.quaternion.setFromRotationMatrix(ho), a && (ho.extractRotation(a.matrixWorld), Ar.setFromRotationMatrix(ho), this.quaternion.premultiply(Ar.invert()))
                        }

                        add(e) {
                            if (arguments.length > 1) {
                                for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
                                return this
                            }
                            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Of), fc.child = e, this.dispatchEvent(fc), fc.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                        }

                        remove(e) {
                            if (arguments.length > 1) {
                                for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
                                return this
                            }
                            const n = this.children.indexOf(e);
                            return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(id), ba.child = e, this.dispatchEvent(ba), ba.child = null), this
                        }

                        removeFromParent() {
                            const e = this.parent;
                            return e !== null && e.remove(this), this
                        }

                        clear() {
                            return this.remove(...this.children)
                        }

                        attach(e) {
                            return this.updateWorldMatrix(!0, !1), ho.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), ho.multiply(e.parent.matrixWorld)), e.applyMatrix4(ho), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Of), fc.child = e, this.dispatchEvent(fc), fc.child = null, this
                        }

                        getObjectById(e) {
                            return this.getObjectByProperty("id", e)
                        }

                        getObjectByName(e) {
                            return this.getObjectByProperty("name", e)
                        }

                        getObjectByProperty(e, n) {
                            if (this[e] === n) return this;
                            for (let r = 0, a = this.children.length; r < a; r++) {
                                const y = this.children[r].getObjectByProperty(e, n);
                                if (y !== void 0) return y
                            }
                        }

                        getObjectsByProperty(e, n, r = []) {
                            this[e] === n && r.push(this);
                            const a = this.children;
                            for (let u = 0, y = a.length; u < y; u++) a[u].getObjectsByProperty(e, n, r);
                            return r
                        }

                        getWorldPosition(e) {
                            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                        }

                        getWorldQuaternion(e) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(js, e, dc), e
                        }

                        getWorldScale(e) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(js, Jc, e), e
                        }

                        getWorldDirection(e) {
                            this.updateWorldMatrix(!0, !1);
                            const n = this.matrixWorld.elements;
                            return e.set(n[8], n[9], n[10]).normalize()
                        }

                        raycast() {
                        }

                        traverse(e) {
                            e(this);
                            const n = this.children;
                            for (let r = 0, a = n.length; r < a; r++) n[r].traverse(e)
                        }

                        traverseVisible(e) {
                            if (this.visible === !1) return;
                            e(this);
                            const n = this.children;
                            for (let r = 0, a = n.length; r < a; r++) n[r].traverseVisible(e)
                        }

                        traverseAncestors(e) {
                            const n = this.parent;
                            n !== null && (e(n), n.traverseAncestors(e))
                        }

                        updateMatrix() {
                            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                        }

                        updateMatrixWorld(e) {
                            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                            const n = this.children;
                            for (let r = 0, a = n.length; r < a; r++) {
                                const u = n[r];
                                (u.matrixWorldAutoUpdate === !0 || e === !0) && u.updateMatrixWorld(e)
                            }
                        }

                        updateWorldMatrix(e, n) {
                            const r = this.parent;
                            if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), n === !0) {
                                const a = this.children;
                                for (let u = 0, y = a.length; u < y; u++) {
                                    const S = a[u];
                                    S.matrixWorldAutoUpdate === !0 && S.updateWorldMatrix(!1, !0)
                                }
                            }
                        }

                        toJSON(e) {
                            const n = e === void 0 || typeof e == "string", r = {};
                            n && (e = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {}
                            }, r.metadata = {version: 4.6, type: "Object", generator: "Object3D.toJSON"});
                            const a = {};
                            a.uuid = this.uuid, a.type = this.type, this.name !== "" && (a.name = this.name), this.castShadow === !0 && (a.castShadow = !0), this.receiveShadow === !0 && (a.receiveShadow = !0), this.visible === !1 && (a.visible = !1), this.frustumCulled === !1 && (a.frustumCulled = !1), this.renderOrder !== 0 && (a.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), a.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1), this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (a.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (a.type = "BatchedMesh", a.perObjectFrustumCulled = this.perObjectFrustumCulled, a.sortObjects = this.sortObjects, a.drawRanges = this._drawRanges, a.reservedRanges = this._reservedRanges, a.visibility = this._visibility, a.active = this._active, a.bounds = this._bounds.map(S => ({
                                boxInitialized: S.boxInitialized,
                                boxMin: S.box.min.toArray(),
                                boxMax: S.box.max.toArray(),
                                sphereInitialized: S.sphereInitialized,
                                sphereRadius: S.sphere.radius,
                                sphereCenter: S.sphere.center.toArray()
                            })), a.maxGeometryCount = this._maxGeometryCount, a.maxVertexCount = this._maxVertexCount, a.maxIndexCount = this._maxIndexCount, a.geometryInitialized = this._geometryInitialized, a.geometryCount = this._geometryCount, a.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (a.boundingSphere = {
                                center: a.boundingSphere.center.toArray(),
                                radius: a.boundingSphere.radius
                            }), this.boundingBox !== null && (a.boundingBox = {
                                min: a.boundingBox.min.toArray(),
                                max: a.boundingBox.max.toArray()
                            }));

                            function u(S, D) {
                                return S[D.uuid] === void 0 && (S[D.uuid] = D.toJSON(e)), D.uuid
                            }

                            if (this.isScene) this.background && (this.background.isColor ? a.background = this.background.toJSON() : this.background.isTexture && (a.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (a.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) {
                                a.geometry = u(e.geometries, this.geometry);
                                const S = this.geometry.parameters;
                                if (S !== void 0 && S.shapes !== void 0) {
                                    const D = S.shapes;
                                    if (Array.isArray(D)) for (let P = 0, z = D.length; P < z; P++) {
                                        const Q = D[P];
                                        u(e.shapes, Q)
                                    } else u(e.shapes, D)
                                }
                            }
                            if (this.isSkinnedMesh && (a.bindMode = this.bindMode, a.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (u(e.skeletons, this.skeleton), a.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
                                const S = [];
                                for (let D = 0, P = this.material.length; D < P; D++) S.push(u(e.materials, this.material[D]));
                                a.material = S
                            } else a.material = u(e.materials, this.material);
                            if (this.children.length > 0) {
                                a.children = [];
                                for (let S = 0; S < this.children.length; S++) a.children.push(this.children[S].toJSON(e).object)
                            }
                            if (this.animations.length > 0) {
                                a.animations = [];
                                for (let S = 0; S < this.animations.length; S++) {
                                    const D = this.animations[S];
                                    a.animations.push(u(e.animations, D))
                                }
                            }
                            if (n) {
                                const S = y(e.geometries), D = y(e.materials), P = y(e.textures), z = y(e.images),
                                    Q = y(e.shapes), K = y(e.skeletons), q = y(e.animations), te = y(e.nodes);
                                S.length > 0 && (r.geometries = S), D.length > 0 && (r.materials = D), P.length > 0 && (r.textures = P), z.length > 0 && (r.images = z), Q.length > 0 && (r.shapes = Q), K.length > 0 && (r.skeletons = K), q.length > 0 && (r.animations = q), te.length > 0 && (r.nodes = te)
                            }
                            return r.object = a, r;

                            function y(S) {
                                const D = [];
                                for (const P in S) {
                                    const z = S[P];
                                    delete z.metadata, D.push(z)
                                }
                                return D
                            }
                        }

                        clone(e) {
                            return new this.constructor().copy(this, e)
                        }

                        copy(e, n = !0) {
                            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0) for (let r = 0; r < e.children.length; r++) {
                                const a = e.children[r];
                                this.add(a.clone())
                            }
                            return this
                        }
                    }

                    or.DEFAULT_UP = new Ne(0, 1, 0), or.DEFAULT_MATRIX_AUTO_UPDATE = !0, or.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                    const Yo = new Ne, ja = new Ne, kf = new Ne, fo = new Ne, _a = new Ne, Ma = new Ne, Yu = new Ne,
                        Zc = new Ne, Po = new Ne, Oo = new Ne;

                    class Bs {
                        constructor(e = new Ne, n = new Ne, r = new Ne) {
                            this.a = e, this.b = n, this.c = r
                        }

                        static getNormal(e, n, r, a) {
                            a.subVectors(r, n), Yo.subVectors(e, n), a.cross(Yo);
                            const u = a.lengthSq();
                            return u > 0 ? a.multiplyScalar(1 / Math.sqrt(u)) : a.set(0, 0, 0)
                        }

                        static getBarycoord(e, n, r, a, u) {
                            Yo.subVectors(a, n), ja.subVectors(r, n), kf.subVectors(e, n);
                            const y = Yo.dot(Yo), S = Yo.dot(ja), D = Yo.dot(kf), P = ja.dot(ja), z = ja.dot(kf),
                                Q = y * P - S * S;
                            if (Q === 0) return u.set(0, 0, 0), null;
                            const K = 1 / Q, q = (P * D - S * z) * K, te = (y * z - S * D) * K;
                            return u.set(1 - q - te, te, q)
                        }

                        static containsPoint(e, n, r, a) {
                            return this.getBarycoord(e, n, r, a, fo) === null ? !1 : fo.x >= 0 && fo.y >= 0 && fo.x + fo.y <= 1
                        }

                        static getInterpolation(e, n, r, a, u, y, S, D) {
                            return this.getBarycoord(e, n, r, a, fo) === null ? (D.x = 0, D.y = 0, "z" in D && (D.z = 0), "w" in D && (D.w = 0), null) : (D.setScalar(0), D.addScaledVector(u, fo.x), D.addScaledVector(y, fo.y), D.addScaledVector(S, fo.z), D)
                        }

                        static isFrontFacing(e, n, r, a) {
                            return Yo.subVectors(r, n), ja.subVectors(e, n), Yo.cross(ja).dot(a) < 0
                        }

                        set(e, n, r) {
                            return this.a.copy(e), this.b.copy(n), this.c.copy(r), this
                        }

                        setFromPointsAndIndices(e, n, r, a) {
                            return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[a]), this
                        }

                        setFromAttributeAndIndices(e, n, r, a) {
                            return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, a), this
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        copy(e) {
                            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                        }

                        getArea() {
                            return Yo.subVectors(this.c, this.b), ja.subVectors(this.a, this.b), Yo.cross(ja).length() * .5
                        }

                        getMidpoint(e) {
                            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(.3333333333333333)
                        }

                        getNormal(e) {
                            return Bs.getNormal(this.a, this.b, this.c, e)
                        }

                        getPlane(e) {
                            return e.setFromCoplanarPoints(this.a, this.b, this.c)
                        }

                        getBarycoord(e, n) {
                            return Bs.getBarycoord(e, this.a, this.b, this.c, n)
                        }

                        getInterpolation(e, n, r, a, u) {
                            return Bs.getInterpolation(e, this.a, this.b, this.c, n, r, a, u)
                        }

                        containsPoint(e) {
                            return Bs.containsPoint(e, this.a, this.b, this.c)
                        }

                        isFrontFacing(e) {
                            return Bs.isFrontFacing(this.a, this.b, this.c, e)
                        }

                        intersectsBox(e) {
                            return e.intersectsTriangle(this)
                        }

                        closestPointToPoint(e, n) {
                            const r = this.a, a = this.b, u = this.c;
                            let y, S;
                            _a.subVectors(a, r), Ma.subVectors(u, r), Zc.subVectors(e, r);
                            const D = _a.dot(Zc), P = Ma.dot(Zc);
                            if (D <= 0 && P <= 0) return n.copy(r);
                            Po.subVectors(e, a);
                            const z = _a.dot(Po), Q = Ma.dot(Po);
                            if (z >= 0 && Q <= z) return n.copy(a);
                            const K = D * Q - z * P;
                            if (K <= 0 && D >= 0 && z <= 0) return y = D / (D - z), n.copy(r).addScaledVector(_a, y);
                            Oo.subVectors(e, u);
                            const q = _a.dot(Oo), te = Ma.dot(Oo);
                            if (te >= 0 && q <= te) return n.copy(u);
                            const le = q * P - D * te;
                            if (le <= 0 && P >= 0 && te <= 0) return S = P / (P - te), n.copy(r).addScaledVector(Ma, S);
                            const ne = z * te - q * Q;
                            if (ne <= 0 && Q - z >= 0 && q - te >= 0) return Yu.subVectors(u, a), S = (Q - z) / (Q - z + (q - te)), n.copy(a).addScaledVector(Yu, S);
                            const J = 1 / (ne + le + K);
                            return y = le * J, S = K * J, n.copy(r).addScaledVector(_a, y).addScaledVector(Ma, S)
                        }

                        equals(e) {
                            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                        }
                    }

                    const Wa = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074
                    }, po = {h: 0, s: 0, l: 0}, Ka = {h: 0, s: 0, l: 0};

                    function rd(d, e, n) {
                        return n < 0 && (n += 1), n > 1 && (n -= 1), n < .16666666666666666 ? d + (e - d) * 6 * n : n < .5 ? e : n < .6666666666666666 ? d + (e - d) * 6 * (.6666666666666666 - n) : d
                    }

                    class Bn {
                        constructor(e, n, r) {
                            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, r)
                        }

                        set(e, n, r) {
                            if (n === void 0 && r === void 0) {
                                const a = e;
                                a && a.isColor ? this.copy(a) : typeof a == "number" ? this.setHex(a) : typeof a == "string" && this.setStyle(a)
                            } else this.setRGB(e, n, r);
                            return this
                        }

                        setScalar(e) {
                            return this.r = e, this.g = e, this.b = e, this
                        }

                        setHex(e, n = rr) {
                            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ur.toWorkingColorSpace(this, n), this
                        }

                        setRGB(e, n, r, a = ur.workingColorSpace) {
                            return this.r = e, this.g = n, this.b = r, ur.toWorkingColorSpace(this, a), this
                        }

                        setHSL(e, n, r, a = ur.workingColorSpace) {
                            if (e = Ua(e, 1), n = Hr(n, 0, 1), r = Hr(r, 0, 1), n === 0) this.r = this.g = this.b = r; else {
                                const u = r <= .5 ? r * (1 + n) : r + n - r * n, y = 2 * r - u;
                                this.r = rd(y, u, e + .3333333333333333), this.g = rd(y, u, e), this.b = rd(y, u, e - .3333333333333333)
                            }
                            return ur.toWorkingColorSpace(this, a), this
                        }

                        setStyle(e, n = rr) {
                            function r(u) {
                                u !== void 0 && parseFloat(u) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                            }

                            let a;
                            if (a = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                                let u;
                                const y = a[1], S = a[2];
                                switch (y) {
                                    case"rgb":
                                    case"rgba":
                                        if (u = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(S)) return r(u[4]), this.setRGB(Math.min(255, parseInt(u[1], 10)) / 255, Math.min(255, parseInt(u[2], 10)) / 255, Math.min(255, parseInt(u[3], 10)) / 255, n);
                                        if (u = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(S)) return r(u[4]), this.setRGB(Math.min(100, parseInt(u[1], 10)) / 100, Math.min(100, parseInt(u[2], 10)) / 100, Math.min(100, parseInt(u[3], 10)) / 100, n);
                                        break;
                                    case"hsl":
                                    case"hsla":
                                        if (u = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(S)) return r(u[4]), this.setHSL(parseFloat(u[1]) / 360, parseFloat(u[2]) / 100, parseFloat(u[3]) / 100, n);
                                        break;
                                    default:
                                        console.warn("THREE.Color: Unknown color model " + e)
                                }
                            } else if (a = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                                const u = a[1], y = u.length;
                                if (y === 3) return this.setRGB(parseInt(u.charAt(0), 16) / 15, parseInt(u.charAt(1), 16) / 15, parseInt(u.charAt(2), 16) / 15, n);
                                if (y === 6) return this.setHex(parseInt(u, 16), n);
                                console.warn("THREE.Color: Invalid hex color " + e)
                            } else if (e && e.length > 0) return this.setColorName(e, n);
                            return this
                        }

                        setColorName(e, n = rr) {
                            const r = Wa[e.toLowerCase()];
                            return r !== void 0 ? this.setHex(r, n) : console.warn("THREE.Color: Unknown color " + e), this
                        }

                        clone() {
                            return new this.constructor(this.r, this.g, this.b)
                        }

                        copy(e) {
                            return this.r = e.r, this.g = e.g, this.b = e.b, this
                        }

                        copySRGBToLinear(e) {
                            return this.r = xa(e.r), this.g = xa(e.g), this.b = xa(e.b), this
                        }

                        copyLinearToSRGB(e) {
                            return this.r = Ga(e.r), this.g = Ga(e.g), this.b = Ga(e.b), this
                        }

                        convertSRGBToLinear() {
                            return this.copySRGBToLinear(this), this
                        }

                        convertLinearToSRGB() {
                            return this.copyLinearToSRGB(this), this
                        }

                        getHex(e = rr) {
                            return ur.fromWorkingColorSpace(Ws.copy(this), e), Math.round(Hr(Ws.r * 255, 0, 255)) * 65536 + Math.round(Hr(Ws.g * 255, 0, 255)) * 256 + Math.round(Hr(Ws.b * 255, 0, 255))
                        }

                        getHexString(e = rr) {
                            return ("000000" + this.getHex(e).toString(16)).slice(-6)
                        }

                        getHSL(e, n = ur.workingColorSpace) {
                            ur.fromWorkingColorSpace(Ws.copy(this), n);
                            const r = Ws.r, a = Ws.g, u = Ws.b, y = Math.max(r, a, u), S = Math.min(r, a, u);
                            let D, P;
                            const z = (S + y) / 2;
                            if (S === y) D = 0, P = 0; else {
                                const Q = y - S;
                                switch (P = z <= .5 ? Q / (y + S) : Q / (2 - y - S), y) {
                                    case r:
                                        D = (a - u) / Q + (a < u ? 6 : 0);
                                        break;
                                    case a:
                                        D = (u - r) / Q + 2;
                                        break;
                                    case u:
                                        D = (r - a) / Q + 4;
                                        break
                                }
                                D /= 6
                            }
                            return e.h = D, e.s = P, e.l = z, e
                        }

                        getRGB(e, n = ur.workingColorSpace) {
                            return ur.fromWorkingColorSpace(Ws.copy(this), n), e.r = Ws.r, e.g = Ws.g, e.b = Ws.b, e
                        }

                        getStyle(e = rr) {
                            ur.fromWorkingColorSpace(Ws.copy(this), e);
                            const n = Ws.r, r = Ws.g, a = Ws.b;
                            return e !== rr ? `color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${a.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(r * 255)},${Math.round(a * 255)})`
                        }

                        offsetHSL(e, n, r) {
                            return this.getHSL(po), this.setHSL(po.h + e, po.s + n, po.l + r)
                        }

                        add(e) {
                            return this.r += e.r, this.g += e.g, this.b += e.b, this
                        }

                        addColors(e, n) {
                            return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this
                        }

                        addScalar(e) {
                            return this.r += e, this.g += e, this.b += e, this
                        }

                        sub(e) {
                            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                        }

                        multiply(e) {
                            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                        }

                        multiplyScalar(e) {
                            return this.r *= e, this.g *= e, this.b *= e, this
                        }

                        lerp(e, n) {
                            return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this
                        }

                        lerpColors(e, n, r) {
                            return this.r = e.r + (n.r - e.r) * r, this.g = e.g + (n.g - e.g) * r, this.b = e.b + (n.b - e.b) * r, this
                        }

                        lerpHSL(e, n) {
                            this.getHSL(po), e.getHSL(Ka);
                            const r = ic(po.h, Ka.h, n), a = ic(po.s, Ka.s, n), u = ic(po.l, Ka.l, n);
                            return this.setHSL(r, a, u), this
                        }

                        setFromVector3(e) {
                            return this.r = e.x, this.g = e.y, this.b = e.z, this
                        }

                        applyMatrix3(e) {
                            const n = this.r, r = this.g, a = this.b, u = e.elements;
                            return this.r = u[0] * n + u[3] * r + u[6] * a, this.g = u[1] * n + u[4] * r + u[7] * a, this.b = u[2] * n + u[5] * r + u[8] * a, this
                        }

                        equals(e) {
                            return e.r === this.r && e.g === this.g && e.b === this.b
                        }

                        fromArray(e, n = 0) {
                            return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this
                        }

                        toArray(e = [], n = 0) {
                            return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e
                        }

                        fromBufferAttribute(e, n) {
                            return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this
                        }

                        toJSON() {
                            return this.getHex()
                        }

                        * [Symbol.iterator]() {
                            yield this.r, yield this.g, yield this.b
                        }
                    }

                    const Ws = new Bn;
                    Bn.NAMES = Wa;
                    let qo = 0;

                    class Dr extends Ss {
                        constructor() {
                            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {value: qo++}), this.uuid = uo(), this.name = "", this.type = "Material", this.blending = V, this.side = L, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Re, this.blendDst = ke, this.blendEquation = se, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Bn(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Vn, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Uu, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Bo, this.stencilZFail = Bo, this.stencilZPass = Bo, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                        }

                        get alphaTest() {
                            return this._alphaTest
                        }

                        set alphaTest(e) {
                            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                        }

                        onBuild() {
                        }

                        onBeforeRender() {
                        }

                        onBeforeCompile() {
                        }

                        customProgramCacheKey() {
                            return this.onBeforeCompile.toString()
                        }

                        setValues(e) {
                            if (e !== void 0) for (const n in e) {
                                const r = e[n];
                                if (r === void 0) {
                                    console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
                                    continue
                                }
                                const a = this[n];
                                if (a === void 0) {
                                    console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
                                    continue
                                }
                                a && a.isColor ? a.set(r) : a && a.isVector3 && r && r.isVector3 ? a.copy(r) : this[n] = r
                            }
                        }

                        toJSON(e) {
                            const n = e === void 0 || typeof e == "string";
                            n && (e = {textures: {}, images: {}});
                            const r = {metadata: {version: 4.6, type: "Material", generator: "Material.toJSON"}};
                            r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (r.dispersion = this.dispersion), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapRotation !== void 0 && (r.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== V && (r.blending = this.blending), this.side !== L && (r.side = this.side), this.vertexColors === !0 && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = !0), this.blendSrc !== Re && (r.blendSrc = this.blendSrc), this.blendDst !== ke && (r.blendDst = this.blendDst), this.blendEquation !== se && (r.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (r.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (r.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha), this.depthFunc !== Vn && (r.depthFunc = this.depthFunc), this.depthTest === !1 && (r.depthTest = this.depthTest), this.depthWrite === !1 && (r.depthWrite = this.depthWrite), this.colorWrite === !1 && (r.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (r.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Uu && (r.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (r.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (r.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Bo && (r.stencilFail = this.stencilFail), this.stencilZFail !== Bo && (r.stencilZFail = this.stencilZFail), this.stencilZPass !== Bo && (r.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaHash === !0 && (r.alphaHash = !0), this.alphaToCoverage === !0 && (r.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0), this.forceSinglePass === !0 && (r.forceSinglePass = !0), this.wireframe === !0 && (r.wireframe = !0), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin),this.flatShading === !0 && (r.flatShading = !0),this.visible === !1 && (r.visible = !1),this.toneMapped === !1 && (r.toneMapped = !1),this.fog === !1 && (r.fog = !1),Object.keys(this.userData).length > 0 && (r.userData = this.userData);

                            function a(u) {
                                const y = [];
                                for (const S in u) {
                                    const D = u[S];
                                    delete D.metadata, y.push(D)
                                }
                                return y
                            }

                            if (n) {
                                const u = a(e.textures), y = a(e.images);
                                u.length > 0 && (r.textures = u), y.length > 0 && (r.images = y)
                            }
                            return r
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        copy(e) {
                            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                            const n = e.clippingPlanes;
                            let r = null;
                            if (n !== null) {
                                const a = n.length;
                                r = new Array(a);
                                for (let u = 0; u !== a; ++u) r[u] = n[u].clone()
                            }
                            return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                        }

                        dispose() {
                            this.dispatchEvent({type: "dispose"})
                        }

                        set needsUpdate(e) {
                            e === !0 && this.version++
                        }
                    }

                    class gr extends Dr {
                        constructor(e) {
                            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Bn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bo, this.combine = Ji, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                        }
                    }

                    const Ls = bm();

                    function bm() {
                        const d = new ArrayBuffer(4), e = new Float32Array(d), n = new Uint32Array(d),
                            r = new Uint32Array(512), a = new Uint32Array(512);
                        for (let D = 0; D < 256; ++D) {
                            const P = D - 127;
                            P < -27 ? (r[D] = 0, r[D | 256] = 32768, a[D] = 24, a[D | 256] = 24) : P < -14 ? (r[D] = 1024 >> -P - 14, r[D | 256] = 1024 >> -P - 14 | 32768, a[D] = -P - 1, a[D | 256] = -P - 1) : P <= 15 ? (r[D] = P + 15 << 10, r[D | 256] = P + 15 << 10 | 32768, a[D] = 13, a[D | 256] = 13) : P < 128 ? (r[D] = 31744, r[D | 256] = 64512, a[D] = 24, a[D | 256] = 24) : (r[D] = 31744, r[D | 256] = 64512, a[D] = 13, a[D | 256] = 13)
                        }
                        const u = new Uint32Array(2048), y = new Uint32Array(64), S = new Uint32Array(64);
                        for (let D = 1; D < 1024; ++D) {
                            let P = D << 13, z = 0;
                            for (; !(P & 8388608);) P <<= 1, z -= 8388608;
                            P &= -8388609, z += 947912704, u[D] = P | z
                        }
                        for (let D = 1024; D < 2048; ++D) u[D] = 939524096 + (D - 1024 << 13);
                        for (let D = 1; D < 31; ++D) y[D] = D << 23;
                        y[31] = 1199570944, y[32] = 2147483648;
                        for (let D = 33; D < 63; ++D) y[D] = 2147483648 + (D - 32 << 23);
                        y[63] = 3347054592;
                        for (let D = 1; D < 64; ++D) D !== 32 && (S[D] = 1024);
                        return {
                            floatView: e,
                            uint32View: n,
                            baseTable: r,
                            shiftTable: a,
                            mantissaTable: u,
                            exponentTable: y,
                            offsetTable: S
                        }
                    }

                    function Mo(d) {
                        Math.abs(d) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), d = Hr(d, -65504, 65504), Ls.floatView[0] = d;
                        const e = Ls.uint32View[0], n = e >> 23 & 511;
                        return Ls.baseTable[n] + ((e & 8388607) >> Ls.shiftTable[n])
                    }

                    function pc(d) {
                        const e = d >> 10;
                        return Ls.uint32View[0] = Ls.mantissaTable[Ls.offsetTable[e] + (d & 1023)] + Ls.exponentTable[e], Ls.floatView[0]
                    }

                    const Ff = {toHalfFloat: Mo, fromHalfFloat: pc}, ls = new Ne, mc = new zt;

                    class Er {
                        constructor(e, n, r = !1) {
                            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                            this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = r, this.usage = rl, this._updateRange = {
                                offset: 0,
                                count: -1
                            }, this.updateRanges = [], this.gpuType = kr, this.version = 0
                        }

                        onUploadCallback() {
                        }

                        set needsUpdate(e) {
                            e === !0 && this.version++
                        }

                        get updateRange() {
                            return nd("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
                        }

                        setUsage(e) {
                            return this.usage = e, this
                        }

                        addUpdateRange(e, n) {
                            this.updateRanges.push({start: e, count: n})
                        }

                        clearUpdateRanges() {
                            this.updateRanges.length = 0
                        }

                        copy(e) {
                            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
                        }

                        copyAt(e, n, r) {
                            e *= this.itemSize, r *= n.itemSize;
                            for (let a = 0, u = this.itemSize; a < u; a++) this.array[e + a] = n.array[r + a];
                            return this
                        }

                        copyArray(e) {
                            return this.array.set(e), this
                        }

                        applyMatrix3(e) {
                            if (this.itemSize === 2) for (let n = 0, r = this.count; n < r; n++) mc.fromBufferAttribute(this, n), mc.applyMatrix3(e), this.setXY(n, mc.x, mc.y); else if (this.itemSize === 3) for (let n = 0, r = this.count; n < r; n++) ls.fromBufferAttribute(this, n), ls.applyMatrix3(e), this.setXYZ(n, ls.x, ls.y, ls.z);
                            return this
                        }

                        applyMatrix4(e) {
                            for (let n = 0, r = this.count; n < r; n++) ls.fromBufferAttribute(this, n), ls.applyMatrix4(e), this.setXYZ(n, ls.x, ls.y, ls.z);
                            return this
                        }

                        applyNormalMatrix(e) {
                            for (let n = 0, r = this.count; n < r; n++) ls.fromBufferAttribute(this, n), ls.applyNormalMatrix(e), this.setXYZ(n, ls.x, ls.y, ls.z);
                            return this
                        }

                        transformDirection(e) {
                            for (let n = 0, r = this.count; n < r; n++) ls.fromBufferAttribute(this, n), ls.transformDirection(e), this.setXYZ(n, ls.x, ls.y, ls.z);
                            return this
                        }

                        set(e, n = 0) {
                            return this.array.set(e, n), this
                        }

                        getComponent(e, n) {
                            let r = this.array[e * this.itemSize + n];
                            return this.normalized && (r = eo(r, this.array)), r
                        }

                        setComponent(e, n, r) {
                            return this.normalized && (r = Ri(r, this.array)), this.array[e * this.itemSize + n] = r, this
                        }

                        getX(e) {
                            let n = this.array[e * this.itemSize];
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setX(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.array[e * this.itemSize] = n, this
                        }

                        getY(e) {
                            let n = this.array[e * this.itemSize + 1];
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setY(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.array[e * this.itemSize + 1] = n, this
                        }

                        getZ(e) {
                            let n = this.array[e * this.itemSize + 2];
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setZ(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.array[e * this.itemSize + 2] = n, this
                        }

                        getW(e) {
                            let n = this.array[e * this.itemSize + 3];
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setW(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.array[e * this.itemSize + 3] = n, this
                        }

                        setXY(e, n, r) {
                            return e *= this.itemSize, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this
                        }

                        setXYZ(e, n, r, a) {
                            return e *= this.itemSize, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array), a = Ri(a, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this.array[e + 2] = a, this
                        }

                        setXYZW(e, n, r, a, u) {
                            return e *= this.itemSize, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array), a = Ri(a, this.array), u = Ri(u, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this.array[e + 2] = a, this.array[e + 3] = u, this
                        }

                        onUpload(e) {
                            return this.onUploadCallback = e, this
                        }

                        clone() {
                            return new this.constructor(this.array, this.itemSize).copy(this)
                        }

                        toJSON() {
                            const e = {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: Array.from(this.array),
                                normalized: this.normalized
                            };
                            return this.name !== "" && (e.name = this.name), this.usage !== rl && (e.usage = this.usage), e
                        }
                    }

                    class $c extends Er {
                        constructor(e, n, r) {
                            super(new Int8Array(e), n, r)
                        }
                    }

                    class Nf extends Er {
                        constructor(e, n, r) {
                            super(new Uint8Array(e), n, r)
                        }
                    }

                    class z0 extends Er {
                        constructor(e, n, r) {
                            super(new Uint8ClampedArray(e), n, r)
                        }
                    }

                    class qu extends Er {
                        constructor(e, n, r) {
                            super(new Int16Array(e), n, r)
                        }
                    }

                    class eu extends Er {
                        constructor(e, n, r) {
                            super(new Uint16Array(e), n, r)
                        }
                    }

                    class _m extends Er {
                        constructor(e, n, r) {
                            super(new Int32Array(e), n, r)
                        }
                    }

                    class sd extends Er {
                        constructor(e, n, r) {
                            super(new Uint32Array(e), n, r)
                        }
                    }

                    class tu extends Er {
                        constructor(e, n, r) {
                            super(new Uint16Array(e), n, r), this.isFloat16BufferAttribute = !0
                        }

                        getX(e) {
                            let n = pc(this.array[e * this.itemSize]);
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setX(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.array[e * this.itemSize] = Mo(n), this
                        }

                        getY(e) {
                            let n = pc(this.array[e * this.itemSize + 1]);
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setY(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.array[e * this.itemSize + 1] = Mo(n), this
                        }

                        getZ(e) {
                            let n = pc(this.array[e * this.itemSize + 2]);
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setZ(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.array[e * this.itemSize + 2] = Mo(n), this
                        }

                        getW(e) {
                            let n = pc(this.array[e * this.itemSize + 3]);
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setW(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.array[e * this.itemSize + 3] = Mo(n), this
                        }

                        setXY(e, n, r) {
                            return e *= this.itemSize, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array)), this.array[e + 0] = Mo(n), this.array[e + 1] = Mo(r), this
                        }

                        setXYZ(e, n, r, a) {
                            return e *= this.itemSize, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array), a = Ri(a, this.array)), this.array[e + 0] = Mo(n), this.array[e + 1] = Mo(r), this.array[e + 2] = Mo(a), this
                        }

                        setXYZW(e, n, r, a, u) {
                            return e *= this.itemSize, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array), a = Ri(a, this.array), u = Ri(u, this.array)), this.array[e + 0] = Mo(n), this.array[e + 1] = Mo(r), this.array[e + 2] = Mo(a), this.array[e + 3] = Mo(u), this
                        }
                    }

                    class Xn extends Er {
                        constructor(e, n, r) {
                            super(new Float32Array(e), n, r)
                        }
                    }

                    let od = 0;
                    const So = new Mn, Ll = new or, Dl = new Ne, To = new Ei, Ac = new Ei, gs = new Ne;

                    class Ti extends Ss {
                        constructor() {
                            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {value: od++}), this.uuid = uo(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                                start: 0,
                                count: 1 / 0
                            }, this.userData = {}
                        }

                        getIndex() {
                            return this.index
                        }

                        setIndex(e) {
                            return Array.isArray(e) ? this.index = new (Qu(e) ? sd : eu)(e, 1) : this.index = e, this
                        }

                        getAttribute(e) {
                            return this.attributes[e]
                        }

                        setAttribute(e, n) {
                            return this.attributes[e] = n, this
                        }

                        deleteAttribute(e) {
                            return delete this.attributes[e], this
                        }

                        hasAttribute(e) {
                            return this.attributes[e] !== void 0
                        }

                        addGroup(e, n, r = 0) {
                            this.groups.push({start: e, count: n, materialIndex: r})
                        }

                        clearGroups() {
                            this.groups = []
                        }

                        setDrawRange(e, n) {
                            this.drawRange.start = e, this.drawRange.count = n
                        }

                        applyMatrix4(e) {
                            const n = this.attributes.position;
                            n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
                            const r = this.attributes.normal;
                            if (r !== void 0) {
                                const u = new ai().getNormalMatrix(e);
                                r.applyNormalMatrix(u), r.needsUpdate = !0
                            }
                            const a = this.attributes.tangent;
                            return a !== void 0 && (a.transformDirection(e), a.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
                        }

                        applyQuaternion(e) {
                            return So.makeRotationFromQuaternion(e), this.applyMatrix4(So), this
                        }

                        rotateX(e) {
                            return So.makeRotationX(e), this.applyMatrix4(So), this
                        }

                        rotateY(e) {
                            return So.makeRotationY(e), this.applyMatrix4(So), this
                        }

                        rotateZ(e) {
                            return So.makeRotationZ(e), this.applyMatrix4(So), this
                        }

                        translate(e, n, r) {
                            return So.makeTranslation(e, n, r), this.applyMatrix4(So), this
                        }

                        scale(e, n, r) {
                            return So.makeScale(e, n, r), this.applyMatrix4(So), this
                        }

                        lookAt(e) {
                            return Ll.lookAt(e), Ll.updateMatrix(), this.applyMatrix4(Ll.matrix), this
                        }

                        center() {
                            return this.computeBoundingBox(), this.boundingBox.getCenter(Dl).negate(), this.translate(Dl.x, Dl.y, Dl.z), this
                        }

                        setFromPoints(e) {
                            const n = [];
                            for (let r = 0, a = e.length; r < a; r++) {
                                const u = e[r];
                                n.push(u.x, u.y, u.z || 0)
                            }
                            return this.setAttribute("position", new Xn(n, 3)), this
                        }

                        computeBoundingBox() {
                            this.boundingBox === null && (this.boundingBox = new Ei);
                            const e = this.attributes.position, n = this.morphAttributes.position;
                            if (e && e.isGLBufferAttribute) {
                                console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new Ne(-1 / 0, -1 / 0, -1 / 0), new Ne(1 / 0, 1 / 0, 1 / 0));
                                return
                            }
                            if (e !== void 0) {
                                if (this.boundingBox.setFromBufferAttribute(e), n) for (let r = 0, a = n.length; r < a; r++) {
                                    const u = n[r];
                                    To.setFromBufferAttribute(u), this.morphTargetsRelative ? (gs.addVectors(this.boundingBox.min, To.min), this.boundingBox.expandByPoint(gs), gs.addVectors(this.boundingBox.max, To.max), this.boundingBox.expandByPoint(gs)) : (this.boundingBox.expandByPoint(To.min), this.boundingBox.expandByPoint(To.max))
                                }
                            } else this.boundingBox.makeEmpty();
                            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                        }

                        computeBoundingSphere() {
                            this.boundingSphere === null && (this.boundingSphere = new as);
                            const e = this.attributes.position, n = this.morphAttributes.position;
                            if (e && e.isGLBufferAttribute) {
                                console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Ne, 1 / 0);
                                return
                            }
                            if (e) {
                                const r = this.boundingSphere.center;
                                if (To.setFromBufferAttribute(e), n) for (let u = 0, y = n.length; u < y; u++) {
                                    const S = n[u];
                                    Ac.setFromBufferAttribute(S), this.morphTargetsRelative ? (gs.addVectors(To.min, Ac.min), To.expandByPoint(gs), gs.addVectors(To.max, Ac.max), To.expandByPoint(gs)) : (To.expandByPoint(Ac.min), To.expandByPoint(Ac.max))
                                }
                                To.getCenter(r);
                                let a = 0;
                                for (let u = 0, y = e.count; u < y; u++) gs.fromBufferAttribute(e, u), a = Math.max(a, r.distanceToSquared(gs));
                                if (n) for (let u = 0, y = n.length; u < y; u++) {
                                    const S = n[u], D = this.morphTargetsRelative;
                                    for (let P = 0, z = S.count; P < z; P++) gs.fromBufferAttribute(S, P), D && (Dl.fromBufferAttribute(e, P), gs.add(Dl)), a = Math.max(a, r.distanceToSquared(gs))
                                }
                                this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }

                        computeTangents() {
                            const e = this.index, n = this.attributes;
                            if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
                                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                                return
                            }
                            const r = n.position, a = n.normal, u = n.uv;
                            this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Er(new Float32Array(4 * r.count), 4));
                            const y = this.getAttribute("tangent"), S = [], D = [];
                            for (let qe = 0; qe < r.count; qe++) S[qe] = new Ne, D[qe] = new Ne;
                            const P = new Ne, z = new Ne, Q = new Ne, K = new zt, q = new zt, te = new zt, le = new Ne,
                                ne = new Ne;

                            function J(qe, Pe, Te) {
                                P.fromBufferAttribute(r, qe), z.fromBufferAttribute(r, Pe), Q.fromBufferAttribute(r, Te), K.fromBufferAttribute(u, qe), q.fromBufferAttribute(u, Pe), te.fromBufferAttribute(u, Te), z.sub(P), Q.sub(P), q.sub(K), te.sub(K);
                                const Je = 1 / (q.x * te.y - te.x * q.y);
                                isFinite(Je) && (le.copy(z).multiplyScalar(te.y).addScaledVector(Q, -q.y).multiplyScalar(Je), ne.copy(Q).multiplyScalar(q.x).addScaledVector(z, -te.x).multiplyScalar(Je), S[qe].add(le), S[Pe].add(le), S[Te].add(le), D[qe].add(ne), D[Pe].add(ne), D[Te].add(ne))
                            }

                            let Ce = this.groups;
                            Ce.length === 0 && (Ce = [{start: 0, count: e.count}]);
                            for (let qe = 0, Pe = Ce.length; qe < Pe; ++qe) {
                                const Te = Ce[qe], Je = Te.start, ht = Te.count;
                                for (let lt = Je, pt = Je + ht; lt < pt; lt += 3) J(e.getX(lt + 0), e.getX(lt + 1), e.getX(lt + 2))
                            }
                            const ye = new Ne, ge = new Ne, $e = new Ne, ze = new Ne;

                            function We(qe) {
                                $e.fromBufferAttribute(a, qe), ze.copy($e);
                                const Pe = S[qe];
                                ye.copy(Pe), ye.sub($e.multiplyScalar($e.dot(Pe))).normalize(), ge.crossVectors(ze, Pe);
                                const Je = ge.dot(D[qe]) < 0 ? -1 : 1;
                                y.setXYZW(qe, ye.x, ye.y, ye.z, Je)
                            }

                            for (let qe = 0, Pe = Ce.length; qe < Pe; ++qe) {
                                const Te = Ce[qe], Je = Te.start, ht = Te.count;
                                for (let lt = Je, pt = Je + ht; lt < pt; lt += 3) We(e.getX(lt + 0)), We(e.getX(lt + 1)), We(e.getX(lt + 2))
                            }
                        }

                        computeVertexNormals() {
                            const e = this.index, n = this.getAttribute("position");
                            if (n !== void 0) {
                                let r = this.getAttribute("normal");
                                if (r === void 0) r = new Er(new Float32Array(n.count * 3), 3), this.setAttribute("normal", r); else for (let K = 0, q = r.count; K < q; K++) r.setXYZ(K, 0, 0, 0);
                                const a = new Ne, u = new Ne, y = new Ne, S = new Ne, D = new Ne, P = new Ne,
                                    z = new Ne, Q = new Ne;
                                if (e) for (let K = 0, q = e.count; K < q; K += 3) {
                                    const te = e.getX(K + 0), le = e.getX(K + 1), ne = e.getX(K + 2);
                                    a.fromBufferAttribute(n, te), u.fromBufferAttribute(n, le), y.fromBufferAttribute(n, ne), z.subVectors(y, u), Q.subVectors(a, u), z.cross(Q), S.fromBufferAttribute(r, te), D.fromBufferAttribute(r, le), P.fromBufferAttribute(r, ne), S.add(z), D.add(z), P.add(z), r.setXYZ(te, S.x, S.y, S.z), r.setXYZ(le, D.x, D.y, D.z), r.setXYZ(ne, P.x, P.y, P.z)
                                } else for (let K = 0, q = n.count; K < q; K += 3) a.fromBufferAttribute(n, K + 0), u.fromBufferAttribute(n, K + 1), y.fromBufferAttribute(n, K + 2), z.subVectors(y, u), Q.subVectors(a, u), z.cross(Q), r.setXYZ(K + 0, z.x, z.y, z.z), r.setXYZ(K + 1, z.x, z.y, z.z), r.setXYZ(K + 2, z.x, z.y, z.z);
                                this.normalizeNormals(), r.needsUpdate = !0
                            }
                        }

                        normalizeNormals() {
                            const e = this.attributes.normal;
                            for (let n = 0, r = e.count; n < r; n++) gs.fromBufferAttribute(e, n), gs.normalize(), e.setXYZ(n, gs.x, gs.y, gs.z)
                        }

                        toNonIndexed() {
                            function e(S, D) {
                                const P = S.array, z = S.itemSize, Q = S.normalized,
                                    K = new P.constructor(D.length * z);
                                let q = 0, te = 0;
                                for (let le = 0, ne = D.length; le < ne; le++) {
                                    S.isInterleavedBufferAttribute ? q = D[le] * S.data.stride + S.offset : q = D[le] * z;
                                    for (let J = 0; J < z; J++) K[te++] = P[q++]
                                }
                                return new Er(K, z, Q)
                            }

                            if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                            const n = new Ti, r = this.index.array, a = this.attributes;
                            for (const S in a) {
                                const D = a[S], P = e(D, r);
                                n.setAttribute(S, P)
                            }
                            const u = this.morphAttributes;
                            for (const S in u) {
                                const D = [], P = u[S];
                                for (let z = 0, Q = P.length; z < Q; z++) {
                                    const K = P[z], q = e(K, r);
                                    D.push(q)
                                }
                                n.morphAttributes[S] = D
                            }
                            n.morphTargetsRelative = this.morphTargetsRelative;
                            const y = this.groups;
                            for (let S = 0, D = y.length; S < D; S++) {
                                const P = y[S];
                                n.addGroup(P.start, P.count, P.materialIndex)
                            }
                            return n
                        }

                        toJSON() {
                            const e = {
                                metadata: {
                                    version: 4.6,
                                    type: "BufferGeometry",
                                    generator: "BufferGeometry.toJSON"
                                }
                            };
                            if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
                                const D = this.parameters;
                                for (const P in D) D[P] !== void 0 && (e[P] = D[P]);
                                return e
                            }
                            e.data = {attributes: {}};
                            const n = this.index;
                            n !== null && (e.data.index = {
                                type: n.array.constructor.name,
                                array: Array.prototype.slice.call(n.array)
                            });
                            const r = this.attributes;
                            for (const D in r) {
                                const P = r[D];
                                e.data.attributes[D] = P.toJSON(e.data)
                            }
                            const a = {};
                            let u = !1;
                            for (const D in this.morphAttributes) {
                                const P = this.morphAttributes[D], z = [];
                                for (let Q = 0, K = P.length; Q < K; Q++) {
                                    const q = P[Q];
                                    z.push(q.toJSON(e.data))
                                }
                                z.length > 0 && (a[D] = z, u = !0)
                            }
                            u && (e.data.morphAttributes = a, e.data.morphTargetsRelative = this.morphTargetsRelative);
                            const y = this.groups;
                            y.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(y)));
                            const S = this.boundingSphere;
                            return S !== null && (e.data.boundingSphere = {
                                center: S.center.toArray(),
                                radius: S.radius
                            }), e
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        copy(e) {
                            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                            const n = {};
                            this.name = e.name;
                            const r = e.index;
                            r !== null && this.setIndex(r.clone(n));
                            const a = e.attributes;
                            for (const P in a) {
                                const z = a[P];
                                this.setAttribute(P, z.clone(n))
                            }
                            const u = e.morphAttributes;
                            for (const P in u) {
                                const z = [], Q = u[P];
                                for (let K = 0, q = Q.length; K < q; K++) z.push(Q[K].clone(n));
                                this.morphAttributes[P] = z
                            }
                            this.morphTargetsRelative = e.morphTargetsRelative;
                            const y = e.groups;
                            for (let P = 0, z = y.length; P < z; P++) {
                                const Q = y[P];
                                this.addGroup(Q.start, Q.count, Q.materialIndex)
                            }
                            const S = e.boundingBox;
                            S !== null && (this.boundingBox = S.clone());
                            const D = e.boundingSphere;
                            return D !== null && (this.boundingSphere = D.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                        }

                        dispose() {
                            this.dispatchEvent({type: "dispose"})
                        }
                    }

                    const Jo = new Mn, Zo = new jr, nu = new as, Uf = new Ne, ko = new Ne, $o = new Ne, Pl = new Ne,
                        ad = new Ne, pa = new Ne, Sa = new zt, gc = new zt, Ju = new zt, Zu = new Ne, zf = new Ne,
                        iu = new Ne, ea = new Ne, Ol = new Ne;

                    class Wr extends or {
                        constructor(e = new Ti, n = new gr) {
                            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets()
                        }

                        copy(e, n) {
                            return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                        }

                        updateMorphTargets() {
                            const n = this.geometry.morphAttributes, r = Object.keys(n);
                            if (r.length > 0) {
                                const a = n[r[0]];
                                if (a !== void 0) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let u = 0, y = a.length; u < y; u++) {
                                        const S = a[u].name || String(u);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[S] = u
                                    }
                                }
                            }
                        }

                        getVertexPosition(e, n) {
                            const r = this.geometry, a = r.attributes.position, u = r.morphAttributes.position,
                                y = r.morphTargetsRelative;
                            n.fromBufferAttribute(a, e);
                            const S = this.morphTargetInfluences;
                            if (u && S) {
                                pa.set(0, 0, 0);
                                for (let D = 0, P = u.length; D < P; D++) {
                                    const z = S[D], Q = u[D];
                                    z !== 0 && (ad.fromBufferAttribute(Q, e), y ? pa.addScaledVector(ad, z) : pa.addScaledVector(ad.sub(n), z))
                                }
                                n.add(pa)
                            }
                            return n
                        }

                        raycast(e, n) {
                            const r = this.geometry, a = this.material, u = this.matrixWorld;
                            a !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), nu.copy(r.boundingSphere), nu.applyMatrix4(u), Zo.copy(e.ray).recast(e.near), !(nu.containsPoint(Zo.origin) === !1 && (Zo.intersectSphere(nu, Uf) === null || Zo.origin.distanceToSquared(Uf) > (e.far - e.near) ** 2)) && (Jo.copy(u).invert(), Zo.copy(e.ray).applyMatrix4(Jo), !(r.boundingBox !== null && Zo.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, n, Zo)))
                        }

                        _computeIntersections(e, n, r) {
                            let a;
                            const u = this.geometry, y = this.material, S = u.index, D = u.attributes.position,
                                P = u.attributes.uv, z = u.attributes.uv1, Q = u.attributes.normal, K = u.groups,
                                q = u.drawRange;
                            if (S !== null) if (Array.isArray(y)) for (let te = 0, le = K.length; te < le; te++) {
                                const ne = K[te], J = y[ne.materialIndex], Ce = Math.max(ne.start, q.start),
                                    ye = Math.min(S.count, Math.min(ne.start + ne.count, q.start + q.count));
                                for (let ge = Ce, $e = ye; ge < $e; ge += 3) {
                                    const ze = S.getX(ge), We = S.getX(ge + 1), qe = S.getX(ge + 2);
                                    a = ru(this, J, e, r, P, z, Q, ze, We, qe), a && (a.faceIndex = Math.floor(ge / 3), a.face.materialIndex = ne.materialIndex, n.push(a))
                                }
                            } else {
                                const te = Math.max(0, q.start), le = Math.min(S.count, q.start + q.count);
                                for (let ne = te, J = le; ne < J; ne += 3) {
                                    const Ce = S.getX(ne), ye = S.getX(ne + 1), ge = S.getX(ne + 2);
                                    a = ru(this, y, e, r, P, z, Q, Ce, ye, ge), a && (a.faceIndex = Math.floor(ne / 3), n.push(a))
                                }
                            } else if (D !== void 0) if (Array.isArray(y)) for (let te = 0, le = K.length; te < le; te++) {
                                const ne = K[te], J = y[ne.materialIndex], Ce = Math.max(ne.start, q.start),
                                    ye = Math.min(D.count, Math.min(ne.start + ne.count, q.start + q.count));
                                for (let ge = Ce, $e = ye; ge < $e; ge += 3) {
                                    const ze = ge, We = ge + 1, qe = ge + 2;
                                    a = ru(this, J, e, r, P, z, Q, ze, We, qe), a && (a.faceIndex = Math.floor(ge / 3), a.face.materialIndex = ne.materialIndex, n.push(a))
                                }
                            } else {
                                const te = Math.max(0, q.start), le = Math.min(D.count, q.start + q.count);
                                for (let ne = te, J = le; ne < J; ne += 3) {
                                    const Ce = ne, ye = ne + 1, ge = ne + 2;
                                    a = ru(this, y, e, r, P, z, Q, Ce, ye, ge), a && (a.faceIndex = Math.floor(ne / 3), n.push(a))
                                }
                            }
                        }
                    }

                    function vc(d, e, n, r, a, u, y, S) {
                        let D;
                        if (e.side === O ? D = r.intersectTriangle(y, u, a, !0, S) : D = r.intersectTriangle(a, u, y, e.side === L, S), D === null) return null;
                        Ol.copy(S), Ol.applyMatrix4(d.matrixWorld);
                        const P = n.ray.origin.distanceTo(Ol);
                        return P < n.near || P > n.far ? null : {distance: P, point: Ol.clone(), object: d}
                    }

                    function ru(d, e, n, r, a, u, y, S, D, P) {
                        d.getVertexPosition(S, ko), d.getVertexPosition(D, $o), d.getVertexPosition(P, Pl);
                        const z = vc(d, e, n, r, ko, $o, Pl, ea);
                        if (z) {
                            a && (Sa.fromBufferAttribute(a, S), gc.fromBufferAttribute(a, D), Ju.fromBufferAttribute(a, P), z.uv = Bs.getInterpolation(ea, ko, $o, Pl, Sa, gc, Ju, new zt)), u && (Sa.fromBufferAttribute(u, S), gc.fromBufferAttribute(u, D), Ju.fromBufferAttribute(u, P), z.uv1 = Bs.getInterpolation(ea, ko, $o, Pl, Sa, gc, Ju, new zt)), y && (Zu.fromBufferAttribute(y, S), zf.fromBufferAttribute(y, D), iu.fromBufferAttribute(y, P), z.normal = Bs.getInterpolation(ea, ko, $o, Pl, Zu, zf, iu, new Ne), z.normal.dot(r.direction) > 0 && z.normal.multiplyScalar(-1));
                            const Q = {a: S, b: D, c: P, normal: new Ne, materialIndex: 0};
                            Bs.getNormal(ko, $o, Pl, Q.normal), z.face = Q
                        }
                        return z
                    }

                    class ma extends Ti {
                        constructor(e = 1, n = 1, r = 1, a = 1, u = 1, y = 1) {
                            super(), this.type = "BoxGeometry", this.parameters = {
                                width: e,
                                height: n,
                                depth: r,
                                widthSegments: a,
                                heightSegments: u,
                                depthSegments: y
                            };
                            const S = this;
                            a = Math.floor(a), u = Math.floor(u), y = Math.floor(y);
                            const D = [], P = [], z = [], Q = [];
                            let K = 0, q = 0;
                            te("z", "y", "x", -1, -1, r, n, e, y, u, 0), te("z", "y", "x", 1, -1, r, n, -e, y, u, 1), te("x", "z", "y", 1, 1, e, r, n, a, y, 2), te("x", "z", "y", 1, -1, e, r, -n, a, y, 3), te("x", "y", "z", 1, -1, e, n, r, a, u, 4), te("x", "y", "z", -1, -1, e, n, -r, a, u, 5), this.setIndex(D), this.setAttribute("position", new Xn(P, 3)), this.setAttribute("normal", new Xn(z, 3)), this.setAttribute("uv", new Xn(Q, 2));

                            function te(le, ne, J, Ce, ye, ge, $e, ze, We, qe, Pe) {
                                const Te = ge / We, Je = $e / qe, ht = ge / 2, lt = $e / 2, pt = ze / 2, Mt = We + 1,
                                    Ut = qe + 1;
                                let mn = 0, Tt = 0;
                                const dn = new Ne;
                                for (let fn = 0; fn < Ut; fn++) {
                                    const Kn = fn * Je - lt;
                                    for (let Qi = 0; Qi < Mt; Qi++) {
                                        const Tr = Qi * Te - ht;
                                        dn[le] = Tr * Ce, dn[ne] = Kn * ye, dn[J] = pt, P.push(dn.x, dn.y, dn.z), dn[le] = 0, dn[ne] = 0, dn[J] = ze > 0 ? 1 : -1, z.push(dn.x, dn.y, dn.z), Q.push(Qi / We), Q.push(1 - fn / qe), mn += 1
                                    }
                                }
                                for (let fn = 0; fn < qe; fn++) for (let Kn = 0; Kn < We; Kn++) {
                                    const Qi = K + Kn + Mt * fn, Tr = K + Kn + Mt * (fn + 1),
                                        Kr = K + (Kn + 1) + Mt * (fn + 1), Cr = K + (Kn + 1) + Mt * fn;
                                    D.push(Qi, Tr, Cr), D.push(Tr, Kr, Cr), Tt += 6
                                }
                                S.addGroup(q, Tt, Pe), q += Tt, K += mn
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new ma(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                        }
                    }

                    function yc(d) {
                        const e = {};
                        for (const n in d) {
                            e[n] = {};
                            for (const r in d[n]) {
                                const a = d[n][r];
                                a && (a.isColor || a.isMatrix3 || a.isMatrix4 || a.isVector2 || a.isVector3 || a.isVector4 || a.isTexture || a.isQuaternion) ? a.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][r] = null) : e[n][r] = a.clone() : Array.isArray(a) ? e[n][r] = a.slice() : e[n][r] = a
                            }
                        }
                        return e
                    }

                    function no(d) {
                        const e = {};
                        for (let n = 0; n < d.length; n++) {
                            const r = yc(d[n]);
                            for (const a in r) e[a] = r[a]
                        }
                        return e
                    }

                    function Jr(d) {
                        const e = [];
                        for (let n = 0; n < d.length; n++) e.push(d[n].clone());
                        return e
                    }

                    function $u(d) {
                        const e = d.getRenderTarget();
                        return e === null ? d.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : ur.workingColorSpace
                    }

                    const ld = {clone: yc, merge: no};
                    var Gf = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, cd = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;

                    class ta extends Dr {
                        constructor(e) {
                            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Gf, this.fragmentShader = cd, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                                clipCullDistance: !1,
                                multiDraw: !1
                            }, this.defaultAttributeValues = {
                                color: [1, 1, 1],
                                uv: [0, 0],
                                uv1: [0, 0]
                            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = yc(e.uniforms), this.uniformsGroups = Jr(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            n.glslVersion = this.glslVersion, n.uniforms = {};
                            for (const a in this.uniforms) {
                                const y = this.uniforms[a].value;
                                y && y.isTexture ? n.uniforms[a] = {
                                    type: "t",
                                    value: y.toJSON(e).uuid
                                } : y && y.isColor ? n.uniforms[a] = {
                                    type: "c",
                                    value: y.getHex()
                                } : y && y.isVector2 ? n.uniforms[a] = {
                                    type: "v2",
                                    value: y.toArray()
                                } : y && y.isVector3 ? n.uniforms[a] = {
                                    type: "v3",
                                    value: y.toArray()
                                } : y && y.isVector4 ? n.uniforms[a] = {
                                    type: "v4",
                                    value: y.toArray()
                                } : y && y.isMatrix3 ? n.uniforms[a] = {
                                    type: "m3",
                                    value: y.toArray()
                                } : y && y.isMatrix4 ? n.uniforms[a] = {
                                    type: "m4",
                                    value: y.toArray()
                                } : n.uniforms[a] = {value: y}
                            }
                            Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
                            const r = {};
                            for (const a in this.extensions) this.extensions[a] === !0 && (r[a] = !0);
                            return Object.keys(r).length > 0 && (n.extensions = r), n
                        }
                    }

                    class Xa extends or {
                        constructor() {
                            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Mn, this.projectionMatrix = new Mn, this.projectionMatrixInverse = new Mn, this.coordinateSystem = da
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
                        }

                        getWorldDirection(e) {
                            return super.getWorldDirection(e).negate()
                        }

                        updateMatrixWorld(e) {
                            super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                        }

                        updateWorldMatrix(e, n) {
                            super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    const xr = new Ne, vs = new zt, Ds = new zt;

                    class ns extends Xa {
                        constructor(e = 50, n = 1, r = .1, a = 2e3) {
                            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = a, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                        }

                        setFocalLength(e) {
                            const n = .5 * this.getFilmHeight() / e;
                            this.fov = ol * 2 * Math.atan(n), this.updateProjectionMatrix()
                        }

                        getFocalLength() {
                            const e = Math.tan(Na * .5 * this.fov);
                            return .5 * this.getFilmHeight() / e
                        }

                        getEffectiveFOV() {
                            return ol * 2 * Math.atan(Math.tan(Na * .5 * this.fov) / this.zoom)
                        }

                        getFilmWidth() {
                            return this.filmGauge * Math.min(this.aspect, 1)
                        }

                        getFilmHeight() {
                            return this.filmGauge / Math.max(this.aspect, 1)
                        }

                        getViewBounds(e, n, r) {
                            xr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(xr.x, xr.y).multiplyScalar(-e / xr.z), xr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), r.set(xr.x, xr.y).multiplyScalar(-e / xr.z)
                        }

                        getViewSize(e, n) {
                            return this.getViewBounds(e, vs, Ds), n.subVectors(Ds, vs)
                        }

                        setViewOffset(e, n, r, a, u, y) {
                            this.aspect = e / n, this.view === null && (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = r, this.view.offsetY = a, this.view.width = u, this.view.height = y, this.updateProjectionMatrix()
                        }

                        clearViewOffset() {
                            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
                        }

                        updateProjectionMatrix() {
                            const e = this.near;
                            let n = e * Math.tan(Na * .5 * this.fov) / this.zoom, r = 2 * n, a = this.aspect * r,
                                u = -.5 * a;
                            const y = this.view;
                            if (this.view !== null && this.view.enabled) {
                                const D = y.fullWidth, P = y.fullHeight;
                                u += y.offsetX * a / D, n -= y.offsetY * r / P, a *= y.width / D, r *= y.height / P
                            }
                            const S = this.filmOffset;
                            S !== 0 && (u += e * S / this.getFilmWidth()), this.projectionMatrix.makePerspective(u, u + a, n, n - r, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n
                        }
                    }

                    const Ya = -90, qa = 1;

                    class Mm extends or {
                        constructor(e, n, r) {
                            super(), this.type = "CubeCamera", this.renderTarget = r, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                            const a = new ns(Ya, qa, e, n);
                            a.layers = this.layers, this.add(a);
                            const u = new ns(Ya, qa, e, n);
                            u.layers = this.layers, this.add(u);
                            const y = new ns(Ya, qa, e, n);
                            y.layers = this.layers, this.add(y);
                            const S = new ns(Ya, qa, e, n);
                            S.layers = this.layers, this.add(S);
                            const D = new ns(Ya, qa, e, n);
                            D.layers = this.layers, this.add(D);
                            const P = new ns(Ya, qa, e, n);
                            P.layers = this.layers, this.add(P)
                        }

                        updateCoordinateSystem() {
                            const e = this.coordinateSystem, n = this.children.concat(), [r, a, u, y, S, D] = n;
                            for (const P of n) this.remove(P);
                            if (e === da) r.up.set(0, 1, 0), r.lookAt(1, 0, 0), a.up.set(0, 1, 0), a.lookAt(-1, 0, 0), u.up.set(0, 0, -1), u.lookAt(0, 1, 0), y.up.set(0, 0, 1), y.lookAt(0, -1, 0), S.up.set(0, 1, 0), S.lookAt(0, 0, 1), D.up.set(0, 1, 0), D.lookAt(0, 0, -1); else if (e === sl) r.up.set(0, -1, 0), r.lookAt(-1, 0, 0), a.up.set(0, -1, 0), a.lookAt(1, 0, 0), u.up.set(0, 0, 1), u.lookAt(0, 1, 0), y.up.set(0, 0, -1), y.lookAt(0, -1, 0), S.up.set(0, -1, 0), S.lookAt(0, 0, 1), D.up.set(0, -1, 0), D.lookAt(0, 0, -1); else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                            for (const P of n) this.add(P), P.updateMatrixWorld()
                        }

                        update(e, n) {
                            this.parent === null && this.updateMatrixWorld();
                            const {renderTarget: r, activeMipmapLevel: a} = this;
                            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
                            const [u, y, S, D, P, z] = this.children, Q = e.getRenderTarget(),
                                K = e.getActiveCubeFace(), q = e.getActiveMipmapLevel(), te = e.xr.enabled;
                            e.xr.enabled = !1;
                            const le = r.texture.generateMipmaps;
                            r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0, a), e.render(n, u), e.setRenderTarget(r, 1, a), e.render(n, y), e.setRenderTarget(r, 2, a), e.render(n, S), e.setRenderTarget(r, 3, a), e.render(n, D), e.setRenderTarget(r, 4, a), e.render(n, P), r.texture.generateMipmaps = le, e.setRenderTarget(r, 5, a), e.render(n, z), e.setRenderTarget(Q, K, q), e.xr.enabled = te, r.texture.needsPMREMUpdate = !0
                        }
                    }

                    class ys extends Lr {
                        constructor(e, n, r, a, u, y, S, D, P, z) {
                            e = e !== void 0 ? e : [], n = n !== void 0 ? n : oe, super(e, n, r, a, u, y, S, D, P, z), this.isCubeTexture = !0, this.flipY = !1
                        }

                        get images() {
                            return this.image
                        }

                        set images(e) {
                            this.image = e
                        }
                    }

                    class ud extends os {
                        constructor(e = 1, n = {}) {
                            super(e, e, n), this.isWebGLCubeRenderTarget = !0;
                            const r = {width: e, height: e, depth: 1}, a = [r, r, r, r, r, r];
                            this.texture = new ys(a, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : qn
                        }

                        fromEquirectangularTexture(e, n) {
                            this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
                            const r = {
                                uniforms: {tEquirect: {value: null}}, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                            }, a = new ma(5, 5, 5), u = new ta({
                                name: "CubemapFromEquirect",
                                uniforms: yc(r.uniforms),
                                vertexShader: r.vertexShader,
                                fragmentShader: r.fragmentShader,
                                side: O,
                                blending: F
                            });
                            u.uniforms.tEquirect.value = n;
                            const y = new Wr(a, u), S = n.minFilter;
                            return n.minFilter === Zi && (n.minFilter = qn), new Mm(1, 10, this).update(e, y), n.minFilter = S, y.geometry.dispose(), y.material.dispose(), this
                        }

                        clear(e, n, r, a) {
                            const u = e.getRenderTarget();
                            for (let y = 0; y < 6; y++) e.setRenderTarget(this, y), e.clear(n, r, a);
                            e.setRenderTarget(u)
                        }
                    }

                    const eh = new Ne, Vf = new Ne, Ja = new ai;

                    class Ps {
                        constructor(e = new Ne(1, 0, 0), n = 0) {
                            this.isPlane = !0, this.normal = e, this.constant = n
                        }

                        set(e, n) {
                            return this.normal.copy(e), this.constant = n, this
                        }

                        setComponents(e, n, r, a) {
                            return this.normal.set(e, n, r), this.constant = a, this
                        }

                        setFromNormalAndCoplanarPoint(e, n) {
                            return this.normal.copy(e), this.constant = -n.dot(this.normal), this
                        }

                        setFromCoplanarPoints(e, n, r) {
                            const a = eh.subVectors(r, n).cross(Vf.subVectors(e, n)).normalize();
                            return this.setFromNormalAndCoplanarPoint(a, e), this
                        }

                        copy(e) {
                            return this.normal.copy(e.normal), this.constant = e.constant, this
                        }

                        normalize() {
                            const e = 1 / this.normal.length();
                            return this.normal.multiplyScalar(e), this.constant *= e, this
                        }

                        negate() {
                            return this.constant *= -1, this.normal.negate(), this
                        }

                        distanceToPoint(e) {
                            return this.normal.dot(e) + this.constant
                        }

                        distanceToSphere(e) {
                            return this.distanceToPoint(e.center) - e.radius
                        }

                        projectPoint(e, n) {
                            return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                        }

                        intersectLine(e, n) {
                            const r = e.delta(eh), a = this.normal.dot(r);
                            if (a === 0) return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
                            const u = -(e.start.dot(this.normal) + this.constant) / a;
                            return u < 0 || u > 1 ? null : n.copy(e.start).addScaledVector(r, u)
                        }

                        intersectsLine(e) {
                            const n = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
                            return n < 0 && r > 0 || r < 0 && n > 0
                        }

                        intersectsBox(e) {
                            return e.intersectsPlane(this)
                        }

                        intersectsSphere(e) {
                            return e.intersectsPlane(this)
                        }

                        coplanarPoint(e) {
                            return e.copy(this.normal).multiplyScalar(-this.constant)
                        }

                        applyMatrix4(e, n) {
                            const r = n || Ja.getNormalMatrix(e), a = this.coplanarPoint(eh).applyMatrix4(e),
                                u = this.normal.applyMatrix3(r).normalize();
                            return this.constant = -a.dot(u), this
                        }

                        translate(e) {
                            return this.constant -= e.dot(this.normal), this
                        }

                        equals(e) {
                            return e.normal.equals(this.normal) && e.constant === this.constant
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    const Ta = new as, su = new Ne;

                    class Ec {
                        constructor(e = new Ps, n = new Ps, r = new Ps, a = new Ps, u = new Ps, y = new Ps) {
                            this.planes = [e, n, r, a, u, y]
                        }

                        set(e, n, r, a, u, y) {
                            const S = this.planes;
                            return S[0].copy(e), S[1].copy(n), S[2].copy(r), S[3].copy(a), S[4].copy(u), S[5].copy(y), this
                        }

                        copy(e) {
                            const n = this.planes;
                            for (let r = 0; r < 6; r++) n[r].copy(e.planes[r]);
                            return this
                        }

                        setFromProjectionMatrix(e, n = da) {
                            const r = this.planes, a = e.elements, u = a[0], y = a[1], S = a[2], D = a[3], P = a[4],
                                z = a[5], Q = a[6], K = a[7], q = a[8], te = a[9], le = a[10], ne = a[11], J = a[12],
                                Ce = a[13], ye = a[14], ge = a[15];
                            if (r[0].setComponents(D - u, K - P, ne - q, ge - J).normalize(), r[1].setComponents(D + u, K + P, ne + q, ge + J).normalize(), r[2].setComponents(D + y, K + z, ne + te, ge + Ce).normalize(), r[3].setComponents(D - y, K - z, ne - te, ge - Ce).normalize(), r[4].setComponents(D - S, K - Q, ne - le, ge - ye).normalize(), n === da) r[5].setComponents(D + S, K + Q, ne + le, ge + ye).normalize(); else if (n === sl) r[5].setComponents(S, Q, le, ye).normalize(); else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
                            return this
                        }

                        intersectsObject(e) {
                            if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ta.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else {
                                const n = e.geometry;
                                n.boundingSphere === null && n.computeBoundingSphere(), Ta.copy(n.boundingSphere).applyMatrix4(e.matrixWorld)
                            }
                            return this.intersectsSphere(Ta)
                        }

                        intersectsSprite(e) {
                            return Ta.center.set(0, 0, 0), Ta.radius = .7071067811865476, Ta.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ta)
                        }

                        intersectsSphere(e) {
                            const n = this.planes, r = e.center, a = -e.radius;
                            for (let u = 0; u < 6; u++) if (n[u].distanceToPoint(r) < a) return !1;
                            return !0
                        }

                        intersectsBox(e) {
                            const n = this.planes;
                            for (let r = 0; r < 6; r++) {
                                const a = n[r];
                                if (su.x = a.normal.x > 0 ? e.max.x : e.min.x, su.y = a.normal.y > 0 ? e.max.y : e.min.y, su.z = a.normal.z > 0 ? e.max.z : e.min.z, a.distanceToPoint(su) < 0) return !1
                            }
                            return !0
                        }

                        containsPoint(e) {
                            const n = this.planes;
                            for (let r = 0; r < 6; r++) if (n[r].distanceToPoint(e) < 0) return !1;
                            return !0
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    function hd() {
                        let d = null, e = !1, n = null, r = null;

                        function a(u, y) {
                            n(u, y), r = d.requestAnimationFrame(a)
                        }

                        return {
                            start: function () {
                                e !== !0 && n !== null && (r = d.requestAnimationFrame(a), e = !0)
                            }, stop: function () {
                                d.cancelAnimationFrame(r), e = !1
                            }, setAnimationLoop: function (u) {
                                n = u
                            }, setContext: function (u) {
                                d = u
                            }
                        }
                    }

                    function Sm(d) {
                        const e = new WeakMap;

                        function n(S, D) {
                            const P = S.array, z = S.usage, Q = P.byteLength, K = d.createBuffer();
                            d.bindBuffer(D, K), d.bufferData(D, P, z), S.onUploadCallback();
                            let q;
                            if (P instanceof Float32Array) q = d.FLOAT; else if (P instanceof Uint16Array) S.isFloat16BufferAttribute ? q = d.HALF_FLOAT : q = d.UNSIGNED_SHORT; else if (P instanceof Int16Array) q = d.SHORT; else if (P instanceof Uint32Array) q = d.UNSIGNED_INT; else if (P instanceof Int32Array) q = d.INT; else if (P instanceof Int8Array) q = d.BYTE; else if (P instanceof Uint8Array) q = d.UNSIGNED_BYTE; else if (P instanceof Uint8ClampedArray) q = d.UNSIGNED_BYTE; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + P);
                            return {
                                buffer: K,
                                type: q,
                                bytesPerElement: P.BYTES_PER_ELEMENT,
                                version: S.version,
                                size: Q
                            }
                        }

                        function r(S, D, P) {
                            const z = D.array, Q = D._updateRange, K = D.updateRanges;
                            if (d.bindBuffer(P, S), Q.count === -1 && K.length === 0 && d.bufferSubData(P, 0, z), K.length !== 0) {
                                for (let q = 0, te = K.length; q < te; q++) {
                                    const le = K[q];
                                    d.bufferSubData(P, le.start * z.BYTES_PER_ELEMENT, z, le.start, le.count)
                                }
                                D.clearUpdateRanges()
                            }
                            Q.count !== -1 && (d.bufferSubData(P, Q.offset * z.BYTES_PER_ELEMENT, z, Q.offset, Q.count), Q.count = -1), D.onUploadCallback()
                        }

                        function a(S) {
                            return S.isInterleavedBufferAttribute && (S = S.data), e.get(S)
                        }

                        function u(S) {
                            S.isInterleavedBufferAttribute && (S = S.data);
                            const D = e.get(S);
                            D && (d.deleteBuffer(D.buffer), e.delete(S))
                        }

                        function y(S, D) {
                            if (S.isGLBufferAttribute) {
                                const z = e.get(S);
                                (!z || z.version < S.version) && e.set(S, {
                                    buffer: S.buffer,
                                    type: S.type,
                                    bytesPerElement: S.elementSize,
                                    version: S.version
                                });
                                return
                            }
                            S.isInterleavedBufferAttribute && (S = S.data);
                            const P = e.get(S);
                            if (P === void 0) e.set(S, n(S, D)); else if (P.version < S.version) {
                                if (P.size !== S.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                                r(P.buffer, S, D), P.version = S.version
                            }
                        }

                        return {get: a, remove: u, update: y}
                    }

                    class xc extends Ti {
                        constructor(e = 1, n = 1, r = 1, a = 1) {
                            super(), this.type = "PlaneGeometry", this.parameters = {
                                width: e,
                                height: n,
                                widthSegments: r,
                                heightSegments: a
                            };
                            const u = e / 2, y = n / 2, S = Math.floor(r), D = Math.floor(a), P = S + 1, z = D + 1,
                                Q = e / S, K = n / D, q = [], te = [], le = [], ne = [];
                            for (let J = 0; J < z; J++) {
                                const Ce = J * K - y;
                                for (let ye = 0; ye < P; ye++) {
                                    const ge = ye * Q - u;
                                    te.push(ge, -Ce, 0), le.push(0, 0, 1), ne.push(ye / S), ne.push(1 - J / D)
                                }
                            }
                            for (let J = 0; J < D; J++) for (let Ce = 0; Ce < S; Ce++) {
                                const ye = Ce + P * J, ge = Ce + P * (J + 1), $e = Ce + 1 + P * (J + 1),
                                    ze = Ce + 1 + P * J;
                                q.push(ye, ge, ze), q.push(ge, $e, ze)
                            }
                            this.setIndex(q), this.setAttribute("position", new Xn(te, 3)), this.setAttribute("normal", new Xn(le, 3)), this.setAttribute("uv", new Xn(ne, 2))
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new xc(e.width, e.height, e.widthSegments, e.heightSegments)
                        }
                    }

                    var Tm = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Im = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Rm = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Bm = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Lm = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, th = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Dm = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, dd = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, fd = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Pm = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, Hf = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Om = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, km = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Fm = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Nm = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Qf = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, Um = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, zm = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Gm = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, G0 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Vm = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, V0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, H0 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Hm = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Qm = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, jm = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, pd = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Q0 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, j0 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, W0 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Ia = "gl_FragColor = linearToOutputTexel( gl_FragColor );", jf = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, md = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Wm = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Km = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Xm = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Wf = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, ou = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Kf = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Xf = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, K0 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Ym = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, qm = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Jm = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Zm = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, $m = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, X0 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Fo = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Io = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, eA = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, tA = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, nA = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, iA = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, rA = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Yf = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, sA = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, qf = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, oA = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, aA = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Jf = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Zf = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, lA = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, $f = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Ad = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Y0 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, cA = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, ep = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, uA = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, gd = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, dl = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, q0 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, hA = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, tp = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, dA = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, fA = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, nh = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, mo = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, J0 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Z0 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, vd = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Ao = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, $0 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Un = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, au = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, np = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, pA = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, ev = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, ih = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, yd = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, ip = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, mA = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, AA = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, gA = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, rp = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, sp = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, io = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Ra = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, kl = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, vA = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, yA = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Ba = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, EA = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Za = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, tv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, xA = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, CA = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, wA = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
                    const ci = {
                        alphahash_fragment: Tm,
                        alphahash_pars_fragment: Im,
                        alphamap_fragment: Rm,
                        alphamap_pars_fragment: Bm,
                        alphatest_fragment: Lm,
                        alphatest_pars_fragment: th,
                        aomap_fragment: Dm,
                        aomap_pars_fragment: dd,
                        batching_pars_vertex: fd,
                        batching_vertex: Pm,
                        begin_vertex: Hf,
                        beginnormal_vertex: Om,
                        bsdfs: km,
                        iridescence_fragment: Fm,
                        bumpmap_pars_fragment: Nm,
                        clipping_planes_fragment: Qf,
                        clipping_planes_pars_fragment: Um,
                        clipping_planes_pars_vertex: zm,
                        clipping_planes_vertex: Gm,
                        color_fragment: G0,
                        color_pars_fragment: Vm,
                        color_pars_vertex: V0,
                        color_vertex: H0,
                        common: Hm,
                        cube_uv_reflection_fragment: Qm,
                        defaultnormal_vertex: jm,
                        displacementmap_pars_vertex: pd,
                        displacementmap_vertex: Q0,
                        emissivemap_fragment: j0,
                        emissivemap_pars_fragment: W0,
                        colorspace_fragment: Ia,
                        colorspace_pars_fragment: jf,
                        envmap_fragment: md,
                        envmap_common_pars_fragment: Wm,
                        envmap_pars_fragment: Km,
                        envmap_pars_vertex: Xm,
                        envmap_physical_pars_fragment: X0,
                        envmap_vertex: Wf,
                        fog_vertex: ou,
                        fog_pars_vertex: Kf,
                        fog_fragment: Xf,
                        fog_pars_fragment: K0,
                        gradientmap_pars_fragment: Ym,
                        lightmap_pars_fragment: qm,
                        lights_lambert_fragment: Jm,
                        lights_lambert_pars_fragment: Zm,
                        lights_pars_begin: $m,
                        lights_toon_fragment: Fo,
                        lights_toon_pars_fragment: Io,
                        lights_phong_fragment: eA,
                        lights_phong_pars_fragment: tA,
                        lights_physical_fragment: nA,
                        lights_physical_pars_fragment: iA,
                        lights_fragment_begin: rA,
                        lights_fragment_maps: Yf,
                        lights_fragment_end: sA,
                        logdepthbuf_fragment: qf,
                        logdepthbuf_pars_fragment: oA,
                        logdepthbuf_pars_vertex: aA,
                        logdepthbuf_vertex: Jf,
                        map_fragment: Zf,
                        map_pars_fragment: lA,
                        map_particle_fragment: $f,
                        map_particle_pars_fragment: Ad,
                        metalnessmap_fragment: Y0,
                        metalnessmap_pars_fragment: cA,
                        morphinstance_vertex: ep,
                        morphcolor_vertex: uA,
                        morphnormal_vertex: gd,
                        morphtarget_pars_vertex: dl,
                        morphtarget_vertex: q0,
                        normal_fragment_begin: hA,
                        normal_fragment_maps: tp,
                        normal_pars_fragment: dA,
                        normal_pars_vertex: fA,
                        normal_vertex: nh,
                        normalmap_pars_fragment: mo,
                        clearcoat_normal_fragment_begin: J0,
                        clearcoat_normal_fragment_maps: Z0,
                        clearcoat_pars_fragment: vd,
                        iridescence_pars_fragment: Ao,
                        opaque_fragment: $0,
                        packing: Un,
                        premultiplied_alpha_fragment: au,
                        project_vertex: np,
                        dithering_fragment: pA,
                        dithering_pars_fragment: ev,
                        roughnessmap_fragment: ih,
                        roughnessmap_pars_fragment: yd,
                        shadowmap_pars_fragment: ip,
                        shadowmap_pars_vertex: mA,
                        shadowmap_vertex: AA,
                        shadowmask_pars_fragment: gA,
                        skinbase_vertex: rp,
                        skinning_pars_vertex: sp,
                        skinning_vertex: io,
                        skinnormal_vertex: Ra,
                        specularmap_fragment: kl,
                        specularmap_pars_fragment: vA,
                        tonemapping_fragment: yA,
                        tonemapping_pars_fragment: Ba,
                        transmission_fragment: EA,
                        transmission_pars_fragment: Za,
                        uv_pars_fragment: tv,
                        uv_pars_vertex: xA,
                        uv_vertex: CA,
                        worldpos_vertex: wA,
                        background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
                        background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                        backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                        backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                        cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
                        cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                        depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
                        depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
                        distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
                        distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
                        equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
                        equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
                        linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                        linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                        meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
                        meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                        meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                        meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                        meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
                        meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                        meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
                        meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
                        meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                        meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                        meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
                        meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                        meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                        meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
                        points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
                        points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
                        shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
                        shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
                        sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
                        sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
                    }, wn = {
                        common: {
                            diffuse: {value: new Bn(16777215)},
                            opacity: {value: 1},
                            map: {value: null},
                            mapTransform: {value: new ai},
                            alphaMap: {value: null},
                            alphaMapTransform: {value: new ai},
                            alphaTest: {value: 0}
                        },
                        specularmap: {specularMap: {value: null}, specularMapTransform: {value: new ai}},
                        envmap: {
                            envMap: {value: null},
                            envMapRotation: {value: new ai},
                            flipEnvMap: {value: -1},
                            reflectivity: {value: 1},
                            ior: {value: 1.5},
                            refractionRatio: {value: .98}
                        },
                        aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}, aoMapTransform: {value: new ai}},
                        lightmap: {
                            lightMap: {value: null},
                            lightMapIntensity: {value: 1},
                            lightMapTransform: {value: new ai}
                        },
                        bumpmap: {bumpMap: {value: null}, bumpMapTransform: {value: new ai}, bumpScale: {value: 1}},
                        normalmap: {
                            normalMap: {value: null},
                            normalMapTransform: {value: new ai},
                            normalScale: {value: new zt(1, 1)}
                        },
                        displacementmap: {
                            displacementMap: {value: null},
                            displacementMapTransform: {value: new ai},
                            displacementScale: {value: 1},
                            displacementBias: {value: 0}
                        },
                        emissivemap: {emissiveMap: {value: null}, emissiveMapTransform: {value: new ai}},
                        metalnessmap: {metalnessMap: {value: null}, metalnessMapTransform: {value: new ai}},
                        roughnessmap: {roughnessMap: {value: null}, roughnessMapTransform: {value: new ai}},
                        gradientmap: {gradientMap: {value: null}},
                        fog: {
                            fogDensity: {value: 25e-5},
                            fogNear: {value: 1},
                            fogFar: {value: 2e3},
                            fogColor: {value: new Bn(16777215)}
                        },
                        lights: {
                            ambientLightColor: {value: []},
                            lightProbe: {value: []},
                            directionalLights: {value: [], properties: {direction: {}, color: {}}},
                            directionalLightShadows: {
                                value: [],
                                properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
                            },
                            directionalShadowMap: {value: []},
                            directionalShadowMatrix: {value: []},
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {}
                                }
                            },
                            spotLightShadows: {
                                value: [],
                                properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
                            },
                            spotLightMap: {value: []},
                            spotShadowMap: {value: []},
                            spotLightMatrix: {value: []},
                            pointLights: {value: [], properties: {color: {}, position: {}, decay: {}, distance: {}}},
                            pointLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {}
                                }
                            },
                            pointShadowMap: {value: []},
                            pointShadowMatrix: {value: []},
                            hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
                            rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}},
                            ltc_1: {value: null},
                            ltc_2: {value: null}
                        },
                        points: {
                            diffuse: {value: new Bn(16777215)},
                            opacity: {value: 1},
                            size: {value: 1},
                            scale: {value: 1},
                            map: {value: null},
                            alphaMap: {value: null},
                            alphaMapTransform: {value: new ai},
                            alphaTest: {value: 0},
                            uvTransform: {value: new ai}
                        },
                        sprite: {
                            diffuse: {value: new Bn(16777215)},
                            opacity: {value: 1},
                            center: {value: new zt(.5, .5)},
                            rotation: {value: 0},
                            map: {value: null},
                            mapTransform: {value: new ai},
                            alphaMap: {value: null},
                            alphaMapTransform: {value: new ai},
                            alphaTest: {value: 0}
                        }
                    }, ia = {
                        basic: {
                            uniforms: no([wn.common, wn.specularmap, wn.envmap, wn.aomap, wn.lightmap, wn.fog]),
                            vertexShader: ci.meshbasic_vert,
                            fragmentShader: ci.meshbasic_frag
                        },
                        lambert: {
                            uniforms: no([wn.common, wn.specularmap, wn.envmap, wn.aomap, wn.lightmap, wn.emissivemap, wn.bumpmap, wn.normalmap, wn.displacementmap, wn.fog, wn.lights, {emissive: {value: new Bn(0)}}]),
                            vertexShader: ci.meshlambert_vert,
                            fragmentShader: ci.meshlambert_frag
                        },
                        phong: {
                            uniforms: no([wn.common, wn.specularmap, wn.envmap, wn.aomap, wn.lightmap, wn.emissivemap, wn.bumpmap, wn.normalmap, wn.displacementmap, wn.fog, wn.lights, {
                                emissive: {value: new Bn(0)},
                                specular: {value: new Bn(1118481)},
                                shininess: {value: 30}
                            }]), vertexShader: ci.meshphong_vert, fragmentShader: ci.meshphong_frag
                        },
                        standard: {
                            uniforms: no([wn.common, wn.envmap, wn.aomap, wn.lightmap, wn.emissivemap, wn.bumpmap, wn.normalmap, wn.displacementmap, wn.roughnessmap, wn.metalnessmap, wn.fog, wn.lights, {
                                emissive: {value: new Bn(0)},
                                roughness: {value: 1},
                                metalness: {value: 0},
                                envMapIntensity: {value: 1}
                            }]), vertexShader: ci.meshphysical_vert, fragmentShader: ci.meshphysical_frag
                        },
                        toon: {
                            uniforms: no([wn.common, wn.aomap, wn.lightmap, wn.emissivemap, wn.bumpmap, wn.normalmap, wn.displacementmap, wn.gradientmap, wn.fog, wn.lights, {emissive: {value: new Bn(0)}}]),
                            vertexShader: ci.meshtoon_vert,
                            fragmentShader: ci.meshtoon_frag
                        },
                        matcap: {
                            uniforms: no([wn.common, wn.bumpmap, wn.normalmap, wn.displacementmap, wn.fog, {matcap: {value: null}}]),
                            vertexShader: ci.meshmatcap_vert,
                            fragmentShader: ci.meshmatcap_frag
                        },
                        points: {
                            uniforms: no([wn.points, wn.fog]),
                            vertexShader: ci.points_vert,
                            fragmentShader: ci.points_frag
                        },
                        dashed: {
                            uniforms: no([wn.common, wn.fog, {
                                scale: {value: 1},
                                dashSize: {value: 1},
                                totalSize: {value: 2}
                            }]), vertexShader: ci.linedashed_vert, fragmentShader: ci.linedashed_frag
                        },
                        depth: {
                            uniforms: no([wn.common, wn.displacementmap]),
                            vertexShader: ci.depth_vert,
                            fragmentShader: ci.depth_frag
                        },
                        normal: {
                            uniforms: no([wn.common, wn.bumpmap, wn.normalmap, wn.displacementmap, {opacity: {value: 1}}]),
                            vertexShader: ci.meshnormal_vert,
                            fragmentShader: ci.meshnormal_frag
                        },
                        sprite: {
                            uniforms: no([wn.sprite, wn.fog]),
                            vertexShader: ci.sprite_vert,
                            fragmentShader: ci.sprite_frag
                        },
                        background: {
                            uniforms: {
                                uvTransform: {value: new ai},
                                t2D: {value: null},
                                backgroundIntensity: {value: 1}
                            }, vertexShader: ci.background_vert, fragmentShader: ci.background_frag
                        },
                        backgroundCube: {
                            uniforms: {
                                envMap: {value: null},
                                flipEnvMap: {value: -1},
                                backgroundBlurriness: {value: 0},
                                backgroundIntensity: {value: 1},
                                backgroundRotation: {value: new ai}
                            }, vertexShader: ci.backgroundCube_vert, fragmentShader: ci.backgroundCube_frag
                        },
                        cube: {
                            uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
                            vertexShader: ci.cube_vert,
                            fragmentShader: ci.cube_frag
                        },
                        equirect: {
                            uniforms: {tEquirect: {value: null}},
                            vertexShader: ci.equirect_vert,
                            fragmentShader: ci.equirect_frag
                        },
                        distanceRGBA: {
                            uniforms: no([wn.common, wn.displacementmap, {
                                referencePosition: {value: new Ne},
                                nearDistance: {value: 1},
                                farDistance: {value: 1e3}
                            }]), vertexShader: ci.distanceRGBA_vert, fragmentShader: ci.distanceRGBA_frag
                        },
                        shadow: {
                            uniforms: no([wn.lights, wn.fog, {color: {value: new Bn(0)}, opacity: {value: 1}}]),
                            vertexShader: ci.shadow_vert,
                            fragmentShader: ci.shadow_frag
                        }
                    };
                    ia.physical = {
                        uniforms: no([ia.standard.uniforms, {
                            clearcoat: {value: 0},
                            clearcoatMap: {value: null},
                            clearcoatMapTransform: {value: new ai},
                            clearcoatNormalMap: {value: null},
                            clearcoatNormalMapTransform: {value: new ai},
                            clearcoatNormalScale: {value: new zt(1, 1)},
                            clearcoatRoughness: {value: 0},
                            clearcoatRoughnessMap: {value: null},
                            clearcoatRoughnessMapTransform: {value: new ai},
                            dispersion: {value: 0},
                            iridescence: {value: 0},
                            iridescenceMap: {value: null},
                            iridescenceMapTransform: {value: new ai},
                            iridescenceIOR: {value: 1.3},
                            iridescenceThicknessMinimum: {value: 100},
                            iridescenceThicknessMaximum: {value: 400},
                            iridescenceThicknessMap: {value: null},
                            iridescenceThicknessMapTransform: {value: new ai},
                            sheen: {value: 0},
                            sheenColor: {value: new Bn(0)},
                            sheenColorMap: {value: null},
                            sheenColorMapTransform: {value: new ai},
                            sheenRoughness: {value: 1},
                            sheenRoughnessMap: {value: null},
                            sheenRoughnessMapTransform: {value: new ai},
                            transmission: {value: 0},
                            transmissionMap: {value: null},
                            transmissionMapTransform: {value: new ai},
                            transmissionSamplerSize: {value: new zt},
                            transmissionSamplerMap: {value: null},
                            thickness: {value: 0},
                            thicknessMap: {value: null},
                            thicknessMapTransform: {value: new ai},
                            attenuationDistance: {value: 0},
                            attenuationColor: {value: new Bn(0)},
                            specularColor: {value: new Bn(1, 1, 1)},
                            specularColorMap: {value: null},
                            specularColorMapTransform: {value: new ai},
                            specularIntensity: {value: 1},
                            specularIntensityMap: {value: null},
                            specularIntensityMapTransform: {value: new ai},
                            anisotropyVector: {value: new zt},
                            anisotropyMap: {value: null},
                            anisotropyMapTransform: {value: new ai}
                        }]), vertexShader: ci.meshphysical_vert, fragmentShader: ci.meshphysical_frag
                    };
                    const cu = {r: 0, b: 0, g: 0}, _c = new bo, Nl = new Mn;

                    function IA(d, e, n, r, a, u, y) {
                        const S = new Bn(0);
                        let D = u === !0 ? 0 : 1, P, z, Q = null, K = 0, q = null;

                        function te(Ce) {
                            let ye = Ce.isScene === !0 ? Ce.background : null;
                            return ye && ye.isTexture && (ye = (Ce.backgroundBlurriness > 0 ? n : e).get(ye)), ye
                        }

                        function le(Ce) {
                            let ye = !1;
                            const ge = te(Ce);
                            ge === null ? J(S, D) : ge && ge.isColor && (J(ge, 1), ye = !0);
                            const $e = d.xr.getEnvironmentBlendMode();
                            $e === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, y) : $e === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, y), (d.autoClear || ye) && d.clear(d.autoClearColor, d.autoClearDepth, d.autoClearStencil)
                        }

                        function ne(Ce, ye) {
                            const ge = te(ye);
                            ge && (ge.isCubeTexture || ge.mapping === Be) ? (z === void 0 && (z = new Wr(new ma(1e4, 1e4, 1e4), new ta({
                                name: "BackgroundCubeMaterial",
                                uniforms: yc(ia.backgroundCube.uniforms),
                                vertexShader: ia.backgroundCube.vertexShader,
                                fragmentShader: ia.backgroundCube.fragmentShader,
                                side: O,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })), z.geometry.deleteAttribute("normal"), z.geometry.deleteAttribute("uv"), z.onBeforeRender = function ($e, ze, We) {
                                this.matrixWorld.copyPosition(We.matrixWorld)
                            }, Object.defineProperty(z.material, "envMap", {
                                get: function () {
                                    return this.uniforms.envMap.value
                                }
                            }), a.update(z)), _c.copy(ye.backgroundRotation), _c.x *= -1, _c.y *= -1, _c.z *= -1, ge.isCubeTexture && ge.isRenderTargetTexture === !1 && (_c.y *= -1, _c.z *= -1), z.material.uniforms.envMap.value = ge, z.material.uniforms.flipEnvMap.value = ge.isCubeTexture && ge.isRenderTargetTexture === !1 ? -1 : 1, z.material.uniforms.backgroundBlurriness.value = ye.backgroundBlurriness, z.material.uniforms.backgroundIntensity.value = ye.backgroundIntensity, z.material.uniforms.backgroundRotation.value.setFromMatrix4(Nl.makeRotationFromEuler(_c)), z.material.toneMapped = ur.getTransfer(ge.colorSpace) !== mr, (Q !== ge || K !== ge.version || q !== d.toneMapping) && (z.material.needsUpdate = !0, Q = ge, K = ge.version, q = d.toneMapping), z.layers.enableAll(), Ce.unshift(z, z.geometry, z.material, 0, 0, null)) : ge && ge.isTexture && (P === void 0 && (P = new Wr(new xc(2, 2), new ta({
                                name: "BackgroundMaterial",
                                uniforms: yc(ia.background.uniforms),
                                vertexShader: ia.background.vertexShader,
                                fragmentShader: ia.background.fragmentShader,
                                side: L,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })), P.geometry.deleteAttribute("normal"), Object.defineProperty(P.material, "map", {
                                get: function () {
                                    return this.uniforms.t2D.value
                                }
                            }), a.update(P)), P.material.uniforms.t2D.value = ge, P.material.uniforms.backgroundIntensity.value = ye.backgroundIntensity, P.material.toneMapped = ur.getTransfer(ge.colorSpace) !== mr, ge.matrixAutoUpdate === !0 && ge.updateMatrix(), P.material.uniforms.uvTransform.value.copy(ge.matrix), (Q !== ge || K !== ge.version || q !== d.toneMapping) && (P.material.needsUpdate = !0, Q = ge, K = ge.version, q = d.toneMapping), P.layers.enableAll(), Ce.unshift(P, P.geometry, P.material, 0, 0, null))
                        }

                        function J(Ce, ye) {
                            Ce.getRGB(cu, $u(d)), r.buffers.color.setClear(cu.r, cu.g, cu.b, ye, y)
                        }

                        return {
                            getClearColor: function () {
                                return S
                            }, setClearColor: function (Ce, ye = 1) {
                                S.set(Ce), D = ye, J(S, D)
                            }, getClearAlpha: function () {
                                return D
                            }, setClearAlpha: function (Ce) {
                                D = Ce, J(S, D)
                            }, render: le, addToRenderList: ne
                        }
                    }

                    function fp(d, e) {
                        const n = d.getParameter(d.MAX_VERTEX_ATTRIBS), r = {}, a = K(null);
                        let u = a, y = !1;

                        function S(Te, Je, ht, lt, pt) {
                            let Mt = !1;
                            const Ut = Q(lt, ht, Je);
                            u !== Ut && (u = Ut, P(u.object)), Mt = q(Te, lt, ht, pt), Mt && te(Te, lt, ht, pt), pt !== null && e.update(pt, d.ELEMENT_ARRAY_BUFFER), (Mt || y) && (y = !1, ge(Te, Je, ht, lt), pt !== null && d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, e.get(pt).buffer))
                        }

                        function D() {
                            return d.createVertexArray()
                        }

                        function P(Te) {
                            return d.bindVertexArray(Te)
                        }

                        function z(Te) {
                            return d.deleteVertexArray(Te)
                        }

                        function Q(Te, Je, ht) {
                            const lt = ht.wireframe === !0;
                            let pt = r[Te.id];
                            pt === void 0 && (pt = {}, r[Te.id] = pt);
                            let Mt = pt[Je.id];
                            Mt === void 0 && (Mt = {}, pt[Je.id] = Mt);
                            let Ut = Mt[lt];
                            return Ut === void 0 && (Ut = K(D()), Mt[lt] = Ut), Ut
                        }

                        function K(Te) {
                            const Je = [], ht = [], lt = [];
                            for (let pt = 0; pt < n; pt++) Je[pt] = 0, ht[pt] = 0, lt[pt] = 0;
                            return {
                                geometry: null,
                                program: null,
                                wireframe: !1,
                                newAttributes: Je,
                                enabledAttributes: ht,
                                attributeDivisors: lt,
                                object: Te,
                                attributes: {},
                                index: null
                            }
                        }

                        function q(Te, Je, ht, lt) {
                            const pt = u.attributes, Mt = Je.attributes;
                            let Ut = 0;
                            const mn = ht.getAttributes();
                            for (const Tt in mn) if (mn[Tt].location >= 0) {
                                const fn = pt[Tt];
                                let Kn = Mt[Tt];
                                if (Kn === void 0 && (Tt === "instanceMatrix" && Te.instanceMatrix && (Kn = Te.instanceMatrix), Tt === "instanceColor" && Te.instanceColor && (Kn = Te.instanceColor)), fn === void 0 || fn.attribute !== Kn || Kn && fn.data !== Kn.data) return !0;
                                Ut++
                            }
                            return u.attributesNum !== Ut || u.index !== lt
                        }

                        function te(Te, Je, ht, lt) {
                            const pt = {}, Mt = Je.attributes;
                            let Ut = 0;
                            const mn = ht.getAttributes();
                            for (const Tt in mn) if (mn[Tt].location >= 0) {
                                let fn = Mt[Tt];
                                fn === void 0 && (Tt === "instanceMatrix" && Te.instanceMatrix && (fn = Te.instanceMatrix), Tt === "instanceColor" && Te.instanceColor && (fn = Te.instanceColor));
                                const Kn = {};
                                Kn.attribute = fn, fn && fn.data && (Kn.data = fn.data), pt[Tt] = Kn, Ut++
                            }
                            u.attributes = pt, u.attributesNum = Ut, u.index = lt
                        }

                        function le() {
                            const Te = u.newAttributes;
                            for (let Je = 0, ht = Te.length; Je < ht; Je++) Te[Je] = 0
                        }

                        function ne(Te) {
                            J(Te, 0)
                        }

                        function J(Te, Je) {
                            const ht = u.newAttributes, lt = u.enabledAttributes, pt = u.attributeDivisors;
                            ht[Te] = 1, lt[Te] === 0 && (d.enableVertexAttribArray(Te), lt[Te] = 1), pt[Te] !== Je && (d.vertexAttribDivisor(Te, Je), pt[Te] = Je)
                        }

                        function Ce() {
                            const Te = u.newAttributes, Je = u.enabledAttributes;
                            for (let ht = 0, lt = Je.length; ht < lt; ht++) Je[ht] !== Te[ht] && (d.disableVertexAttribArray(ht), Je[ht] = 0)
                        }

                        function ye(Te, Je, ht, lt, pt, Mt, Ut) {
                            Ut === !0 ? d.vertexAttribIPointer(Te, Je, ht, pt, Mt) : d.vertexAttribPointer(Te, Je, ht, lt, pt, Mt)
                        }

                        function ge(Te, Je, ht, lt) {
                            le();
                            const pt = lt.attributes, Mt = ht.getAttributes(), Ut = Je.defaultAttributeValues;
                            for (const mn in Mt) {
                                const Tt = Mt[mn];
                                if (Tt.location >= 0) {
                                    let dn = pt[mn];
                                    if (dn === void 0 && (mn === "instanceMatrix" && Te.instanceMatrix && (dn = Te.instanceMatrix), mn === "instanceColor" && Te.instanceColor && (dn = Te.instanceColor)), dn !== void 0) {
                                        const fn = dn.normalized, Kn = dn.itemSize, Qi = e.get(dn);
                                        if (Qi === void 0) continue;
                                        const Tr = Qi.buffer, Kr = Qi.type, Cr = Qi.bytesPerElement,
                                            Vr = Kr === d.INT || Kr === d.UNSIGNED_INT || dn.gpuType === Eo;
                                        if (dn.isInterleavedBufferAttribute) {
                                            const Jn = dn.data, Ht = Jn.stride, vn = dn.offset;
                                            if (Jn.isInstancedInterleavedBuffer) {
                                                for (let bn = 0; bn < Tt.locationSize; bn++) J(Tt.location + bn, Jn.meshPerAttribute);
                                                Te.isInstancedMesh !== !0 && lt._maxInstanceCount === void 0 && (lt._maxInstanceCount = Jn.meshPerAttribute * Jn.count)
                                            } else for (let bn = 0; bn < Tt.locationSize; bn++) ne(Tt.location + bn);
                                            d.bindBuffer(d.ARRAY_BUFFER, Tr);
                                            for (let bn = 0; bn < Tt.locationSize; bn++) ye(Tt.location + bn, Kn / Tt.locationSize, Kr, fn, Ht * Cr, (vn + Kn / Tt.locationSize * bn) * Cr, Vr)
                                        } else {
                                            if (dn.isInstancedBufferAttribute) {
                                                for (let Jn = 0; Jn < Tt.locationSize; Jn++) J(Tt.location + Jn, dn.meshPerAttribute);
                                                Te.isInstancedMesh !== !0 && lt._maxInstanceCount === void 0 && (lt._maxInstanceCount = dn.meshPerAttribute * dn.count)
                                            } else for (let Jn = 0; Jn < Tt.locationSize; Jn++) ne(Tt.location + Jn);
                                            d.bindBuffer(d.ARRAY_BUFFER, Tr);
                                            for (let Jn = 0; Jn < Tt.locationSize; Jn++) ye(Tt.location + Jn, Kn / Tt.locationSize, Kr, fn, Kn * Cr, Kn / Tt.locationSize * Jn * Cr, Vr)
                                        }
                                    } else if (Ut !== void 0) {
                                        const fn = Ut[mn];
                                        if (fn !== void 0) switch (fn.length) {
                                            case 2:
                                                d.vertexAttrib2fv(Tt.location, fn);
                                                break;
                                            case 3:
                                                d.vertexAttrib3fv(Tt.location, fn);
                                                break;
                                            case 4:
                                                d.vertexAttrib4fv(Tt.location, fn);
                                                break;
                                            default:
                                                d.vertexAttrib1fv(Tt.location, fn)
                                        }
                                    }
                                }
                            }
                            Ce()
                        }

                        function $e() {
                            qe();
                            for (const Te in r) {
                                const Je = r[Te];
                                for (const ht in Je) {
                                    const lt = Je[ht];
                                    for (const pt in lt) z(lt[pt].object), delete lt[pt];
                                    delete Je[ht]
                                }
                                delete r[Te]
                            }
                        }

                        function ze(Te) {
                            if (r[Te.id] === void 0) return;
                            const Je = r[Te.id];
                            for (const ht in Je) {
                                const lt = Je[ht];
                                for (const pt in lt) z(lt[pt].object), delete lt[pt];
                                delete Je[ht]
                            }
                            delete r[Te.id]
                        }

                        function We(Te) {
                            for (const Je in r) {
                                const ht = r[Je];
                                if (ht[Te.id] === void 0) continue;
                                const lt = ht[Te.id];
                                for (const pt in lt) z(lt[pt].object), delete lt[pt];
                                delete ht[Te.id]
                            }
                        }

                        function qe() {
                            Pe(), y = !0, u !== a && (u = a, P(u.object))
                        }

                        function Pe() {
                            a.geometry = null, a.program = null, a.wireframe = !1
                        }

                        return {
                            setup: S,
                            reset: qe,
                            resetDefaultState: Pe,
                            dispose: $e,
                            releaseStatesOfGeometry: ze,
                            releaseStatesOfProgram: We,
                            initAttributes: le,
                            enableAttribute: ne,
                            disableUnusedAttributes: Ce
                        }
                    }

                    function Mc(d, e, n) {
                        let r;

                        function a(P) {
                            r = P
                        }

                        function u(P, z) {
                            d.drawArrays(r, P, z), n.update(z, r, 1)
                        }

                        function y(P, z, Q) {
                            Q !== 0 && (d.drawArraysInstanced(r, P, z, Q), n.update(z, r, Q))
                        }

                        function S(P, z, Q) {
                            if (Q === 0) return;
                            const K = e.get("WEBGL_multi_draw");
                            if (K === null) for (let q = 0; q < Q; q++) this.render(P[q], z[q]); else {
                                K.multiDrawArraysWEBGL(r, P, 0, z, 0, Q);
                                let q = 0;
                                for (let te = 0; te < Q; te++) q += z[te];
                                n.update(q, r, 1)
                            }
                        }

                        function D(P, z, Q, K) {
                            if (Q === 0) return;
                            const q = e.get("WEBGL_multi_draw");
                            if (q === null) for (let te = 0; te < P.length; te++) y(P[te], z[te], K[te]); else {
                                q.multiDrawArraysInstancedWEBGL(r, P, 0, z, 0, K, 0, Q);
                                let te = 0;
                                for (let le = 0; le < Q; le++) te += z[le];
                                for (let le = 0; le < K.length; le++) n.update(te, r, K[le])
                            }
                        }

                        this.setMode = a, this.render = u, this.renderInstances = y, this.renderMultiDraw = S, this.renderMultiDrawInstances = D
                    }

                    function pp(d, e, n, r) {
                        let a;

                        function u() {
                            if (a !== void 0) return a;
                            if (e.has("EXT_texture_filter_anisotropic") === !0) {
                                const ze = e.get("EXT_texture_filter_anisotropic");
                                a = d.getParameter(ze.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                            } else a = 0;
                            return a
                        }

                        function y(ze) {
                            return !(ze !== Ke && r.convert(ze) !== d.getParameter(d.IMPLEMENTATION_COLOR_READ_FORMAT))
                        }

                        function S(ze) {
                            const We = ze === Hi && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
                            return !(ze !== pr && r.convert(ze) !== d.getParameter(d.IMPLEMENTATION_COLOR_READ_TYPE) && ze !== kr && !We)
                        }

                        function D(ze) {
                            if (ze === "highp") {
                                if (d.getShaderPrecisionFormat(d.VERTEX_SHADER, d.HIGH_FLOAT).precision > 0 && d.getShaderPrecisionFormat(d.FRAGMENT_SHADER, d.HIGH_FLOAT).precision > 0) return "highp";
                                ze = "mediump"
                            }
                            return ze === "mediump" && d.getShaderPrecisionFormat(d.VERTEX_SHADER, d.MEDIUM_FLOAT).precision > 0 && d.getShaderPrecisionFormat(d.FRAGMENT_SHADER, d.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                        }

                        let P = n.precision !== void 0 ? n.precision : "highp";
                        const z = D(P);
                        z !== P && (console.warn("THREE.WebGLRenderer:", P, "not supported, using", z, "instead."), P = z);
                        const Q = n.logarithmicDepthBuffer === !0, K = d.getParameter(d.MAX_TEXTURE_IMAGE_UNITS),
                            q = d.getParameter(d.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                            te = d.getParameter(d.MAX_TEXTURE_SIZE), le = d.getParameter(d.MAX_CUBE_MAP_TEXTURE_SIZE),
                            ne = d.getParameter(d.MAX_VERTEX_ATTRIBS), J = d.getParameter(d.MAX_VERTEX_UNIFORM_VECTORS),
                            Ce = d.getParameter(d.MAX_VARYING_VECTORS),
                            ye = d.getParameter(d.MAX_FRAGMENT_UNIFORM_VECTORS), ge = q > 0,
                            $e = d.getParameter(d.MAX_SAMPLES);
                        return {
                            isWebGL2: !0,
                            getMaxAnisotropy: u,
                            getMaxPrecision: D,
                            textureFormatReadable: y,
                            textureTypeReadable: S,
                            precision: P,
                            logarithmicDepthBuffer: Q,
                            maxTextures: K,
                            maxVertexTextures: q,
                            maxTextureSize: te,
                            maxCubemapSize: le,
                            maxAttributes: ne,
                            maxVertexUniforms: J,
                            maxVaryings: Ce,
                            maxFragmentUniforms: ye,
                            vertexTextures: ge,
                            maxSamples: $e
                        }
                    }

                    function Sc(d) {
                        const e = this;
                        let n = null, r = 0, a = !1, u = !1;
                        const y = new Ps, S = new ai, D = {value: null, needsUpdate: !1};
                        this.uniform = D, this.numPlanes = 0, this.numIntersection = 0, this.init = function (Q, K) {
                            const q = Q.length !== 0 || K || r !== 0 || a;
                            return a = K, r = Q.length, q
                        }, this.beginShadows = function () {
                            u = !0, z(null)
                        }, this.endShadows = function () {
                            u = !1
                        }, this.setGlobalState = function (Q, K) {
                            n = z(Q, K, 0)
                        }, this.setState = function (Q, K, q) {
                            const te = Q.clippingPlanes, le = Q.clipIntersection, ne = Q.clipShadows, J = d.get(Q);
                            if (!a || te === null || te.length === 0 || u && !ne) u ? z(null) : P(); else {
                                const Ce = u ? 0 : r, ye = Ce * 4;
                                let ge = J.clippingState || null;
                                D.value = ge, ge = z(te, K, ye, q);
                                for (let $e = 0; $e !== ye; ++$e) ge[$e] = n[$e];
                                J.clippingState = ge, this.numIntersection = le ? this.numPlanes : 0, this.numPlanes += Ce
                            }
                        };

                        function P() {
                            D.value !== n && (D.value = n, D.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
                        }

                        function z(Q, K, q, te) {
                            const le = Q !== null ? Q.length : 0;
                            let ne = null;
                            if (le !== 0) {
                                if (ne = D.value, te !== !0 || ne === null) {
                                    const J = q + le * 4, Ce = K.matrixWorldInverse;
                                    S.getNormalMatrix(Ce), (ne === null || ne.length < J) && (ne = new Float32Array(J));
                                    for (let ye = 0, ge = q; ye !== le; ++ye, ge += 4) y.copy(Q[ye]).applyMatrix4(Ce, S), y.normal.toArray(ne, ge), ne[ge + 3] = y.constant
                                }
                                D.value = ne, D.needsUpdate = !0
                            }
                            return e.numPlanes = le, e.numIntersection = 0, ne
                        }
                    }

                    function RA(d) {
                        let e = new WeakMap;

                        function n(y, S) {
                            return S === X ? y.mapping = oe : S === ve && (y.mapping = G), y
                        }

                        function r(y) {
                            if (y && y.isTexture) {
                                const S = y.mapping;
                                if (S === X || S === ve) if (e.has(y)) {
                                    const D = e.get(y).texture;
                                    return n(D, y.mapping)
                                } else {
                                    const D = y.image;
                                    if (D && D.height > 0) {
                                        const P = new ud(D.height);
                                        return P.fromEquirectangularTexture(d, y), e.set(y, P), y.addEventListener("dispose", a), n(P.texture, y.mapping)
                                    } else return null
                                }
                            }
                            return y
                        }

                        function a(y) {
                            const S = y.target;
                            S.removeEventListener("dispose", a);
                            const D = e.get(S);
                            D !== void 0 && (e.delete(S), D.dispose())
                        }

                        function u() {
                            e = new WeakMap
                        }

                        return {get: r, dispose: u}
                    }

                    class oh extends Xa {
                        constructor(e = -1, n = 1, r = 1, a = -1, u = .1, y = 2e3) {
                            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = r, this.bottom = a, this.near = u, this.far = y, this.updateProjectionMatrix()
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
                        }

                        setViewOffset(e, n, r, a, u, y) {
                            this.view === null && (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = r, this.view.offsetY = a, this.view.width = u, this.view.height = y, this.updateProjectionMatrix()
                        }

                        clearViewOffset() {
                            this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
                        }

                        updateProjectionMatrix() {
                            const e = (this.right - this.left) / (2 * this.zoom),
                                n = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2,
                                a = (this.top + this.bottom) / 2;
                            let u = r - e, y = r + e, S = a + n, D = a - n;
                            if (this.view !== null && this.view.enabled) {
                                const P = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                    z = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                                u += P * this.view.offsetX, y = u + P * this.view.width, S -= z * this.view.offsetY, D = S - z * this.view.height
                            }
                            this.projectionMatrix.makeOrthographic(u, y, S, D, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n
                        }
                    }

                    const Ul = 4, ah = [.125, .215, .35, .446, .526, .582], Tc = 20, mp = new oh, Ap = new Bn;
                    let wd = null, fl = 0, gp = 0, zl = !1;
                    const Gl = (1 + Math.sqrt(5)) / 2, Fr = 1 / Gl,
                        BA = [new Ne(-Gl, Fr, 0), new Ne(Gl, Fr, 0), new Ne(-Fr, 0, Gl), new Ne(Fr, 0, Gl), new Ne(0, Gl, -Fr), new Ne(0, Gl, Fr), new Ne(-1, 1, -1), new Ne(1, 1, -1), new Ne(-1, 1, 1), new Ne(1, 1, 1)];

                    class bd {
                        constructor(e) {
                            this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                        }

                        fromScene(e, n = 0, r = .1, a = 100) {
                            wd = this._renderer.getRenderTarget(), fl = this._renderer.getActiveCubeFace(), gp = this._renderer.getActiveMipmapLevel(), zl = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
                            const u = this._allocateTargets();
                            return u.depthBuffer = !0, this._sceneToCubeUV(e, r, a, u), n > 0 && this._blur(u, 0, 0, n), this._applyPMREM(u), this._cleanup(u), u
                        }

                        fromEquirectangular(e, n = null) {
                            return this._fromTexture(e, n)
                        }

                        fromCubemap(e, n = null) {
                            return this._fromTexture(e, n)
                        }

                        compileCubemapShader() {
                            this._cubemapMaterial === null && (this._cubemapMaterial = ra(), this._compileMaterial(this._cubemapMaterial))
                        }

                        compileEquirectangularShader() {
                            this._equirectMaterial === null && (this._equirectMaterial = PA(), this._compileMaterial(this._equirectMaterial))
                        }

                        dispose() {
                            this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
                        }

                        _setSize(e) {
                            this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
                        }

                        _dispose() {
                            this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                            for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
                        }

                        _cleanup(e) {
                            this._renderer.setRenderTarget(wd, fl, gp), this._renderer.xr.enabled = zl, e.scissorTest = !1, lh(e, 0, 0, e.width, e.height)
                        }

                        _fromTexture(e, n) {
                            e.mapping === oe || e.mapping === G ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), wd = this._renderer.getRenderTarget(), fl = this._renderer.getActiveCubeFace(), gp = this._renderer.getActiveMipmapLevel(), zl = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
                            const r = n || this._allocateTargets();
                            return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
                        }

                        _allocateTargets() {
                            const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, r = {
                                magFilter: qn,
                                minFilter: qn,
                                generateMipmaps: !1,
                                type: Hi,
                                format: Ke,
                                colorSpace: Gs,
                                depthBuffer: !1
                            }, a = LA(e, n, r);
                            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
                                this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = LA(e, n, r);
                                const {_lodMax: u} = this;
                                ({
                                    sizeLods: this._sizeLods,
                                    lodPlanes: this._lodPlanes,
                                    sigmas: this._sigmas
                                } = iv(u)), this._blurMaterial = DA(u, e, n)
                            }
                            return a
                        }

                        _compileMaterial(e) {
                            const n = new Wr(this._lodPlanes[0], e);
                            this._renderer.compile(n, mp)
                        }

                        _sceneToCubeUV(e, n, r, a) {
                            const S = new ns(90, 1, n, r), D = [1, -1, 1, 1, 1, 1], P = [1, 1, 1, -1, -1, -1],
                                z = this._renderer, Q = z.autoClear, K = z.toneMapping;
                            z.getClearColor(Ap), z.toneMapping = cr, z.autoClear = !1;
                            const q = new gr({name: "PMREM.Background", side: O, depthWrite: !1, depthTest: !1}),
                                te = new Wr(new ma, q);
                            let le = !1;
                            const ne = e.background;
                            ne ? ne.isColor && (q.color.copy(ne), e.background = null, le = !0) : (q.color.copy(Ap), le = !0);
                            for (let J = 0; J < 6; J++) {
                                const Ce = J % 3;
                                Ce === 0 ? (S.up.set(0, D[J], 0), S.lookAt(P[J], 0, 0)) : Ce === 1 ? (S.up.set(0, 0, D[J]), S.lookAt(0, P[J], 0)) : (S.up.set(0, D[J], 0), S.lookAt(0, 0, P[J]));
                                const ye = this._cubeSize;
                                lh(a, Ce * ye, J > 2 ? ye : 0, ye, ye), z.setRenderTarget(a), le && z.render(te, S), z.render(e, S)
                            }
                            te.geometry.dispose(), te.material.dispose(), z.toneMapping = K, z.autoClear = Q, e.background = ne
                        }

                        _textureToCubeUV(e, n) {
                            const r = this._renderer, a = e.mapping === oe || e.mapping === G;
                            a ? (this._cubemapMaterial === null && (this._cubemapMaterial = ra()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = PA());
                            const u = a ? this._cubemapMaterial : this._equirectMaterial,
                                y = new Wr(this._lodPlanes[0], u), S = u.uniforms;
                            S.envMap.value = e;
                            const D = this._cubeSize;
                            lh(n, 0, 0, 3 * D, 2 * D), r.setRenderTarget(n), r.render(y, mp)
                        }

                        _applyPMREM(e) {
                            const n = this._renderer, r = n.autoClear;
                            n.autoClear = !1;
                            const a = this._lodPlanes.length;
                            for (let u = 1; u < a; u++) {
                                const y = Math.sqrt(this._sigmas[u] * this._sigmas[u] - this._sigmas[u - 1] * this._sigmas[u - 1]),
                                    S = BA[(a - u - 1) % BA.length];
                                this._blur(e, u - 1, u, y, S)
                            }
                            n.autoClear = r
                        }

                        _blur(e, n, r, a, u) {
                            const y = this._pingPongRenderTarget;
                            this._halfBlur(e, y, n, r, a, "latitudinal", u), this._halfBlur(y, e, r, r, a, "longitudinal", u)
                        }

                        _halfBlur(e, n, r, a, u, y, S) {
                            const D = this._renderer, P = this._blurMaterial;
                            y !== "latitudinal" && y !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                            const z = 3, Q = new Wr(this._lodPlanes[a], P), K = P.uniforms, q = this._sizeLods[r] - 1,
                                te = isFinite(u) ? Math.PI / (2 * q) : 2 * Math.PI / (2 * Tc - 1), le = u / te,
                                ne = isFinite(u) ? 1 + Math.floor(z * le) : Tc;
                            ne > Tc && console.warn(`sigmaRadians, ${u}, is too large and will clip, as it requested ${ne} samples when the maximum is set to ${Tc}`);
                            const J = [];
                            let Ce = 0;
                            for (let We = 0; We < Tc; ++We) {
                                const qe = We / le, Pe = Math.exp(-qe * qe / 2);
                                J.push(Pe), We === 0 ? Ce += Pe : We < ne && (Ce += 2 * Pe)
                            }
                            for (let We = 0; We < J.length; We++) J[We] = J[We] / Ce;
                            K.envMap.value = e.texture, K.samples.value = ne, K.weights.value = J, K.latitudinal.value = y === "latitudinal", S && (K.poleAxis.value = S);
                            const {_lodMax: ye} = this;
                            K.dTheta.value = te, K.mipInt.value = ye - r;
                            const ge = this._sizeLods[a], $e = 3 * ge * (a > ye - Ul ? a - ye + Ul : 0),
                                ze = 4 * (this._cubeSize - ge);
                            lh(n, $e, ze, 3 * ge, 2 * ge), D.setRenderTarget(n), D.render(Q, mp)
                        }
                    }

                    function iv(d) {
                        const e = [], n = [], r = [];
                        let a = d;
                        const u = d - Ul + 1 + ah.length;
                        for (let y = 0; y < u; y++) {
                            const S = Math.pow(2, a);
                            n.push(S);
                            let D = 1 / S;
                            y > d - Ul ? D = ah[y - d + Ul - 1] : y === 0 && (D = 0), r.push(D);
                            const P = 1 / (S - 2), z = -P, Q = 1 + P, K = [z, z, Q, z, Q, Q, z, z, Q, Q, z, Q], q = 6,
                                te = 6, le = 3, ne = 2, J = 1, Ce = new Float32Array(le * te * q),
                                ye = new Float32Array(ne * te * q), ge = new Float32Array(J * te * q);
                            for (let ze = 0; ze < q; ze++) {
                                const We = ze % 3 * 2 / 3 - 1, qe = ze > 2 ? 0 : -1,
                                    Pe = [We, qe, 0, We + 2 / 3, qe, 0, We + 2 / 3, qe + 1, 0, We, qe, 0, We + 2 / 3, qe + 1, 0, We, qe + 1, 0];
                                Ce.set(Pe, le * te * ze), ye.set(K, ne * te * ze);
                                const Te = [ze, ze, ze, ze, ze, ze];
                                ge.set(Te, J * te * ze)
                            }
                            const $e = new Ti;
                            $e.setAttribute("position", new Er(Ce, le)), $e.setAttribute("uv", new Er(ye, ne)), $e.setAttribute("faceIndex", new Er(ge, J)), e.push($e), a > Ul && a--
                        }
                        return {lodPlanes: e, sizeLods: n, sigmas: r}
                    }

                    function LA(d, e, n) {
                        const r = new os(d, e, n);
                        return r.texture.mapping = Be, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
                    }

                    function lh(d, e, n, r, a) {
                        d.viewport.set(e, n, r, a), d.scissor.set(e, n, r, a)
                    }

                    function DA(d, e, n) {
                        const r = new Float32Array(Tc), a = new Ne(0, 1, 0);
                        return new ta({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: Tc,
                                CUBEUV_TEXEL_WIDTH: 1 / e,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${d}.0`
                            },
                            uniforms: {
                                envMap: {value: null},
                                samples: {value: 1},
                                weights: {value: r},
                                latitudinal: {value: !1},
                                dTheta: {value: 0},
                                mipInt: {value: 0},
                                poleAxis: {value: a}
                            },
                            vertexShader: ch(),
                            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                            blending: F,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }

                    function PA() {
                        return new ta({
                            name: "EquirectangularToCubeUV",
                            uniforms: {envMap: {value: null}},
                            vertexShader: ch(),
                            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                            blending: F,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }

                    function ra() {
                        return new ta({
                            name: "CubemapToCubeUV",
                            uniforms: {envMap: {value: null}, flipEnvMap: {value: -1}},
                            vertexShader: ch(),
                            fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                            blending: F,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }

                    function ch() {
                        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
                    }

                    function rv(d) {
                        let e = new WeakMap, n = null;

                        function r(S) {
                            if (S && S.isTexture) {
                                const D = S.mapping, P = D === X || D === ve, z = D === oe || D === G;
                                if (P || z) {
                                    let Q = e.get(S);
                                    const K = Q !== void 0 ? Q.texture.pmremVersion : 0;
                                    if (S.isRenderTargetTexture && S.pmremVersion !== K) return n === null && (n = new bd(d)), Q = P ? n.fromEquirectangular(S, Q) : n.fromCubemap(S, Q), Q.texture.pmremVersion = S.pmremVersion, e.set(S, Q), Q.texture;
                                    if (Q !== void 0) return Q.texture;
                                    {
                                        const q = S.image;
                                        return P && q && q.height > 0 || z && q && a(q) ? (n === null && (n = new bd(d)), Q = P ? n.fromEquirectangular(S) : n.fromCubemap(S), Q.texture.pmremVersion = S.pmremVersion, e.set(S, Q), S.addEventListener("dispose", u), Q.texture) : null
                                    }
                                }
                            }
                            return S
                        }

                        function a(S) {
                            let D = 0;
                            const P = 6;
                            for (let z = 0; z < P; z++) S[z] !== void 0 && D++;
                            return D === P
                        }

                        function u(S) {
                            const D = S.target;
                            D.removeEventListener("dispose", u);
                            const P = e.get(D);
                            P !== void 0 && (e.delete(D), P.dispose())
                        }

                        function y() {
                            e = new WeakMap, n !== null && (n.dispose(), n = null)
                        }

                        return {get: r, dispose: y}
                    }

                    function Vl(d) {
                        const e = {};

                        function n(r) {
                            if (e[r] !== void 0) return e[r];
                            let a;
                            switch (r) {
                                case"WEBGL_depth_texture":
                                    a = d.getExtension("WEBGL_depth_texture") || d.getExtension("MOZ_WEBGL_depth_texture") || d.getExtension("WEBKIT_WEBGL_depth_texture");
                                    break;
                                case"EXT_texture_filter_anisotropic":
                                    a = d.getExtension("EXT_texture_filter_anisotropic") || d.getExtension("MOZ_EXT_texture_filter_anisotropic") || d.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                    break;
                                case"WEBGL_compressed_texture_s3tc":
                                    a = d.getExtension("WEBGL_compressed_texture_s3tc") || d.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || d.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                    break;
                                case"WEBGL_compressed_texture_pvrtc":
                                    a = d.getExtension("WEBGL_compressed_texture_pvrtc") || d.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                    break;
                                default:
                                    a = d.getExtension(r)
                            }
                            return e[r] = a, a
                        }

                        return {
                            has: function (r) {
                                return n(r) !== null
                            }, init: function () {
                                n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent")
                            }, get: function (r) {
                                const a = n(r);
                                return a === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), a
                            }
                        }
                    }

                    function _d(d, e, n, r) {
                        const a = {}, u = new WeakMap;

                        function y(Q) {
                            const K = Q.target;
                            K.index !== null && e.remove(K.index);
                            for (const te in K.attributes) e.remove(K.attributes[te]);
                            for (const te in K.morphAttributes) {
                                const le = K.morphAttributes[te];
                                for (let ne = 0, J = le.length; ne < J; ne++) e.remove(le[ne])
                            }
                            K.removeEventListener("dispose", y), delete a[K.id];
                            const q = u.get(K);
                            q && (e.remove(q), u.delete(K)), r.releaseStatesOfGeometry(K), K.isInstancedBufferGeometry === !0 && delete K._maxInstanceCount, n.memory.geometries--
                        }

                        function S(Q, K) {
                            return a[K.id] === !0 || (K.addEventListener("dispose", y), a[K.id] = !0, n.memory.geometries++), K
                        }

                        function D(Q) {
                            const K = Q.attributes;
                            for (const te in K) e.update(K[te], d.ARRAY_BUFFER);
                            const q = Q.morphAttributes;
                            for (const te in q) {
                                const le = q[te];
                                for (let ne = 0, J = le.length; ne < J; ne++) e.update(le[ne], d.ARRAY_BUFFER)
                            }
                        }

                        function P(Q) {
                            const K = [], q = Q.index, te = Q.attributes.position;
                            let le = 0;
                            if (q !== null) {
                                const Ce = q.array;
                                le = q.version;
                                for (let ye = 0, ge = Ce.length; ye < ge; ye += 3) {
                                    const $e = Ce[ye + 0], ze = Ce[ye + 1], We = Ce[ye + 2];
                                    K.push($e, ze, ze, We, We, $e)
                                }
                            } else if (te !== void 0) {
                                const Ce = te.array;
                                le = te.version;
                                for (let ye = 0, ge = Ce.length / 3 - 1; ye < ge; ye += 3) {
                                    const $e = ye + 0, ze = ye + 1, We = ye + 2;
                                    K.push($e, ze, ze, We, We, $e)
                                }
                            } else return;
                            const ne = new (Qu(K) ? sd : eu)(K, 1);
                            ne.version = le;
                            const J = u.get(Q);
                            J && e.remove(J), u.set(Q, ne)
                        }

                        function z(Q) {
                            const K = u.get(Q);
                            if (K) {
                                const q = Q.index;
                                q !== null && K.version < q.version && P(Q)
                            } else P(Q);
                            return u.get(Q)
                        }

                        return {get: S, update: D, getWireframeAttribute: z}
                    }

                    function Ic(d, e, n) {
                        let r;

                        function a(K) {
                            r = K
                        }

                        let u, y;

                        function S(K) {
                            u = K.type, y = K.bytesPerElement
                        }

                        function D(K, q) {
                            d.drawElements(r, q, u, K * y), n.update(q, r, 1)
                        }

                        function P(K, q, te) {
                            te !== 0 && (d.drawElementsInstanced(r, q, u, K * y, te), n.update(q, r, te))
                        }

                        function z(K, q, te) {
                            if (te === 0) return;
                            const le = e.get("WEBGL_multi_draw");
                            if (le === null) for (let ne = 0; ne < te; ne++) this.render(K[ne] / y, q[ne]); else {
                                le.multiDrawElementsWEBGL(r, q, 0, u, K, 0, te);
                                let ne = 0;
                                for (let J = 0; J < te; J++) ne += q[J];
                                n.update(ne, r, 1)
                            }
                        }

                        function Q(K, q, te, le) {
                            if (te === 0) return;
                            const ne = e.get("WEBGL_multi_draw");
                            if (ne === null) for (let J = 0; J < K.length; J++) P(K[J] / y, q[J], le[J]); else {
                                ne.multiDrawElementsInstancedWEBGL(r, q, 0, u, K, 0, le, 0, te);
                                let J = 0;
                                for (let Ce = 0; Ce < te; Ce++) J += q[Ce];
                                for (let Ce = 0; Ce < le.length; Ce++) n.update(J, r, le[Ce])
                            }
                        }

                        this.setMode = a, this.setIndex = S, this.render = D, this.renderInstances = P, this.renderMultiDraw = z, this.renderMultiDrawInstances = Q
                    }

                    function Md(d) {
                        const e = {geometries: 0, textures: 0},
                            n = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};

                        function r(u, y, S) {
                            switch (n.calls++, y) {
                                case d.TRIANGLES:
                                    n.triangles += S * (u / 3);
                                    break;
                                case d.LINES:
                                    n.lines += S * (u / 2);
                                    break;
                                case d.LINE_STRIP:
                                    n.lines += S * (u - 1);
                                    break;
                                case d.LINE_LOOP:
                                    n.lines += S * u;
                                    break;
                                case d.POINTS:
                                    n.points += S * u;
                                    break;
                                default:
                                    console.error("THREE.WebGLInfo: Unknown draw mode:", y);
                                    break
                            }
                        }

                        function a() {
                            n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
                        }

                        return {memory: e, render: n, programs: null, autoReset: !0, reset: a, update: r}
                    }

                    function vp(d, e, n) {
                        const r = new WeakMap, a = new ar;

                        function u(y, S, D) {
                            const P = y.morphTargetInfluences,
                                z = S.morphAttributes.position || S.morphAttributes.normal || S.morphAttributes.color,
                                Q = z !== void 0 ? z.length : 0;
                            let K = r.get(S);
                            if (K === void 0 || K.count !== Q) {
                                let q = function () {
                                    qe.dispose(), r.delete(S), S.removeEventListener("dispose", q)
                                };
                                K !== void 0 && K.texture.dispose();
                                const te = S.morphAttributes.position !== void 0,
                                    le = S.morphAttributes.normal !== void 0, ne = S.morphAttributes.color !== void 0,
                                    J = S.morphAttributes.position || [], Ce = S.morphAttributes.normal || [],
                                    ye = S.morphAttributes.color || [];
                                let ge = 0;
                                te === !0 && (ge = 1), le === !0 && (ge = 2), ne === !0 && (ge = 3);
                                let $e = S.attributes.position.count * ge, ze = 1;
                                $e > e.maxTextureSize && (ze = Math.ceil($e / e.maxTextureSize), $e = e.maxTextureSize);
                                const We = new Float32Array($e * ze * 4 * Q), qe = new Tl(We, $e, ze, Q);
                                qe.type = kr, qe.needsUpdate = !0;
                                const Pe = ge * 4;
                                for (let Te = 0; Te < Q; Te++) {
                                    const Je = J[Te], ht = Ce[Te], lt = ye[Te], pt = $e * ze * 4 * Te;
                                    for (let Mt = 0; Mt < Je.count; Mt++) {
                                        const Ut = Mt * Pe;
                                        te === !0 && (a.fromBufferAttribute(Je, Mt), We[pt + Ut + 0] = a.x, We[pt + Ut + 1] = a.y, We[pt + Ut + 2] = a.z, We[pt + Ut + 3] = 0), le === !0 && (a.fromBufferAttribute(ht, Mt), We[pt + Ut + 4] = a.x, We[pt + Ut + 5] = a.y, We[pt + Ut + 6] = a.z, We[pt + Ut + 7] = 0), ne === !0 && (a.fromBufferAttribute(lt, Mt), We[pt + Ut + 8] = a.x, We[pt + Ut + 9] = a.y, We[pt + Ut + 10] = a.z, We[pt + Ut + 11] = lt.itemSize === 4 ? a.w : 1)
                                    }
                                }
                                K = {
                                    count: Q,
                                    texture: qe,
                                    size: new zt($e, ze)
                                }, r.set(S, K), S.addEventListener("dispose", q)
                            }
                            if (y.isInstancedMesh === !0 && y.morphTexture !== null) D.getUniforms().setValue(d, "morphTexture", y.morphTexture, n); else {
                                let q = 0;
                                for (let le = 0; le < P.length; le++) q += P[le];
                                const te = S.morphTargetsRelative ? 1 : 1 - q;
                                D.getUniforms().setValue(d, "morphTargetBaseInfluence", te), D.getUniforms().setValue(d, "morphTargetInfluences", P)
                            }
                            D.getUniforms().setValue(d, "morphTargetsTexture", K.texture, n), D.getUniforms().setValue(d, "morphTargetsTextureSize", K.size)
                        }

                        return {update: u}
                    }

                    class yp {
                        constructor(e, n, r) {
                            if (this.renderer = e, this.DEFAULT_NUMVIEWS = 2, this.maxNumViews = 0, this.gl = r, this.extensions = n, this.available = this.extensions.has("OCULUS_multiview"), this.available) {
                                const u = this.extensions.get("OCULUS_multiview");
                                this.maxNumViews = this.gl.getParameter(u.MAX_VIEWS_OVR), this.mat4 = [], this.mat3 = [], this.cameraArray = [];
                                for (var a = 0; a < this.maxNumViews; a++) this.mat4[a] = new Mn, this.mat3[a] = new ai
                            }
                        }

                        getCameraArray(e) {
                            return e.isArrayCamera ? e.cameras : (this.cameraArray[0] = e, this.cameraArray)
                        }

                        updateCameraProjectionMatricesUniform(e, n) {
                            for (var r = this.getCameraArray(e), a = 0; a < r.length; a++) this.mat4[a].copy(r[a].projectionMatrix);
                            n.setValue(this.gl, "projectionMatrices", this.mat4)
                        }

                        updateCameraViewMatricesUniform(e, n) {
                            for (var r = this.getCameraArray(e), a = 0; a < r.length; a++) this.mat4[a].copy(r[a].matrixWorldInverse);
                            n.setValue(this.gl, "viewMatrices", this.mat4)
                        }

                        updateObjectMatricesUniforms(e, n, r) {
                            for (var a = this.getCameraArray(n), u = 0; u < a.length; u++) this.mat4[u].multiplyMatrices(a[u].matrixWorldInverse, e.matrixWorld), this.mat3[u].getNormalMatrix(this.mat4[u]);
                            r.setValue(this.gl, "modelViewMatrices", this.mat4), r.setValue(this.gl, "normalMatrices", this.mat3)
                        }
                    }

                    function sv(d, e, n, r) {
                        let a = new WeakMap;

                        function u(D) {
                            const P = r.render.frame, z = D.geometry, Q = e.get(D, z);
                            if (a.get(Q) !== P && (e.update(Q), a.set(Q, P)), D.isInstancedMesh && (D.hasEventListener("dispose", S) === !1 && D.addEventListener("dispose", S), a.get(D) !== P && (n.update(D.instanceMatrix, d.ARRAY_BUFFER), D.instanceColor !== null && n.update(D.instanceColor, d.ARRAY_BUFFER), a.set(D, P))), D.isSkinnedMesh) {
                                const K = D.skeleton;
                                a.get(K) !== P && (K.update(), a.set(K, P))
                            }
                            return Q
                        }

                        function y() {
                            a = new WeakMap
                        }

                        function S(D) {
                            const P = D.target;
                            P.removeEventListener("dispose", S), n.remove(P.instanceMatrix), P.instanceColor !== null && n.remove(P.instanceColor)
                        }

                        return {update: u, dispose: y}
                    }

                    class uh extends Lr {
                        constructor(e, n, r, a, u, y, S, D, P, z) {
                            if (z = z !== void 0 ? z : dt, z !== dt && z !== Lt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                            r === void 0 && z === dt && (r = bs), r === void 0 && z === Lt && (r = xo), super(null, a, u, y, S, D, z, r, P), this.isDepthTexture = !0, this.image = {
                                width: e,
                                height: n
                            }, this.magFilter = S !== void 0 ? S : cn, this.minFilter = D !== void 0 ? D : cn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
                        }

                        copy(e) {
                            return super.copy(e), this.compareFunction = e.compareFunction, this
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n
                        }
                    }

                    const OA = new Lr, Ep = new uh(1, 1);
                    Ep.compareFunction = jc;
                    const xp = new Tl, hh = new Mi, dh = new ys, Cp = [], Sd = [], kA = new Float32Array(16),
                        wp = new Float32Array(9), Td = new Float32Array(4);

                    function pl(d, e, n) {
                        const r = d[0];
                        if (r <= 0 || r > 0) return d;
                        const a = e * n;
                        let u = Cp[a];
                        if (u === void 0 && (u = new Float32Array(a), Cp[a] = u), e !== 0) {
                            r.toArray(u, 0);
                            for (let y = 1, S = 0; y !== e; ++y) S += n, d[y].toArray(u, S)
                        }
                        return u
                    }

                    function cs(d, e) {
                        if (d.length !== e.length) return !1;
                        for (let n = 0, r = d.length; n < r; n++) if (d[n] !== e[n]) return !1;
                        return !0
                    }

                    function is(d, e) {
                        for (let n = 0, r = e.length; n < r; n++) d[n] = e[n]
                    }

                    function fh(d, e) {
                        let n = Sd[e];
                        n === void 0 && (n = new Int32Array(e), Sd[e] = n);
                        for (let r = 0; r !== e; ++r) n[r] = d.allocateTextureUnit();
                        return n
                    }

                    function ov(d, e) {
                        const n = this.cache;
                        n[0] !== e && (d.uniform1f(this.addr, e), n[0] = e)
                    }

                    function Id(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y) && (d.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else {
                            if (cs(n, e)) return;
                            d.uniform2fv(this.addr, e), is(n, e)
                        }
                    }

                    function av(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (d.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (e.r !== void 0) (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (d.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else {
                            if (cs(n, e)) return;
                            d.uniform3fv(this.addr, e), is(n, e)
                        }
                    }

                    function ph(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (d.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else {
                            if (cs(n, e)) return;
                            d.uniform4fv(this.addr, e), is(n, e)
                        }
                    }

                    function lv(d, e) {
                        const n = this.cache, r = e.elements;
                        if (r === void 0) {
                            if (cs(n, e)) return;
                            d.uniformMatrix2fv(this.addr, !1, e), is(n, e)
                        } else {
                            if (cs(n, r)) return;
                            Td.set(r), d.uniformMatrix2fv(this.addr, !1, Td), is(n, r)
                        }
                    }

                    function Rd(d, e) {
                        const n = this.cache, r = e.elements;
                        if (r === void 0) {
                            if (cs(n, e)) return;
                            d.uniformMatrix3fv(this.addr, !1, e), is(n, e)
                        } else {
                            if (cs(n, r)) return;
                            wp.set(r), d.uniformMatrix3fv(this.addr, !1, wp), is(n, r)
                        }
                    }

                    function s(d, e) {
                        const n = this.cache, r = e.elements;
                        if (r === void 0) {
                            if (cs(n, e)) return;
                            d.uniformMatrix4fv(this.addr, !1, e), is(n, e)
                        } else {
                            if (cs(n, r)) return;
                            kA.set(r), d.uniformMatrix4fv(this.addr, !1, kA), is(n, r)
                        }
                    }

                    function l(d, e) {
                        const n = this.cache;
                        n[0] !== e && (d.uniform1i(this.addr, e), n[0] = e)
                    }

                    function _(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y) && (d.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else {
                            if (cs(n, e)) return;
                            d.uniform2iv(this.addr, e), is(n, e)
                        }
                    }

                    function k(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (d.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else {
                            if (cs(n, e)) return;
                            d.uniform3iv(this.addr, e), is(n, e)
                        }
                    }

                    function W(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (d.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else {
                            if (cs(n, e)) return;
                            d.uniform4iv(this.addr, e), is(n, e)
                        }
                    }

                    function ie(d, e) {
                        const n = this.cache;
                        n[0] !== e && (d.uniform1ui(this.addr, e), n[0] = e)
                    }

                    function be(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y) && (d.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else {
                            if (cs(n, e)) return;
                            d.uniform2uiv(this.addr, e), is(n, e)
                        }
                    }

                    function Xe(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (d.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else {
                            if (cs(n, e)) return;
                            d.uniform3uiv(this.addr, e), is(n, e)
                        }
                    }

                    function nt(d, e) {
                        const n = this.cache;
                        if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (d.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else {
                            if (cs(n, e)) return;
                            d.uniform4uiv(this.addr, e), is(n, e)
                        }
                    }

                    function Et(d, e, n) {
                        const r = this.cache, a = n.allocateTextureUnit();
                        r[0] !== a && (d.uniform1i(this.addr, a), r[0] = a);
                        const u = this.type === d.SAMPLER_2D_SHADOW ? Ep : OA;
                        n.setTexture2D(e || u, a)
                    }

                    function Zt(d, e, n) {
                        const r = this.cache, a = n.allocateTextureUnit();
                        r[0] !== a && (d.uniform1i(this.addr, a), r[0] = a), n.setTexture3D(e || hh, a)
                    }

                    function rn(d, e, n) {
                        const r = this.cache, a = n.allocateTextureUnit();
                        r[0] !== a && (d.uniform1i(this.addr, a), r[0] = a), n.setTextureCube(e || dh, a)
                    }

                    function qt(d, e, n) {
                        const r = this.cache, a = n.allocateTextureUnit();
                        r[0] !== a && (d.uniform1i(this.addr, a), r[0] = a), n.setTexture2DArray(e || xp, a)
                    }

                    function Ln(d) {
                        switch (d) {
                            case 5126:
                                return ov;
                            case 35664:
                                return Id;
                            case 35665:
                                return av;
                            case 35666:
                                return ph;
                            case 35674:
                                return lv;
                            case 35675:
                                return Rd;
                            case 35676:
                                return s;
                            case 5124:
                            case 35670:
                                return l;
                            case 35667:
                            case 35671:
                                return _;
                            case 35668:
                            case 35672:
                                return k;
                            case 35669:
                            case 35673:
                                return W;
                            case 5125:
                                return ie;
                            case 36294:
                                return be;
                            case 36295:
                                return Xe;
                            case 36296:
                                return nt;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Et;
                            case 35679:
                            case 36299:
                            case 36307:
                                return Zt;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return rn;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return qt
                        }
                    }

                    function Qn(d, e) {
                        d.uniform1fv(this.addr, e)
                    }

                    function Yn(d, e) {
                        const n = pl(e, this.size, 2);
                        d.uniform2fv(this.addr, n)
                    }

                    function us(d, e) {
                        const n = pl(e, this.size, 3);
                        d.uniform3fv(this.addr, n)
                    }

                    function vt(d, e) {
                        const n = pl(e, this.size, 4);
                        d.uniform4fv(this.addr, n)
                    }

                    function ct(d, e) {
                        const n = pl(e, this.size, 4);
                        d.uniformMatrix2fv(this.addr, !1, n)
                    }

                    function yt(d, e) {
                        const n = pl(e, this.size, 9);
                        d.uniformMatrix3fv(this.addr, !1, n)
                    }

                    function hn(d, e) {
                        const n = pl(e, this.size, 16);
                        d.uniformMatrix4fv(this.addr, !1, n)
                    }

                    function Zn(d, e) {
                        d.uniform1iv(this.addr, e)
                    }

                    function di(d, e) {
                        d.uniform2iv(this.addr, e)
                    }

                    function fi(d, e) {
                        d.uniform3iv(this.addr, e)
                    }

                    function xi(d, e) {
                        d.uniform4iv(this.addr, e)
                    }

                    function Xs(d, e) {
                        d.uniform1uiv(this.addr, e)
                    }

                    function dr(d, e) {
                        d.uniform2uiv(this.addr, e)
                    }

                    function Hl(d, e) {
                        d.uniform3uiv(this.addr, e)
                    }

                    function cv(d, e) {
                        d.uniform4uiv(this.addr, e)
                    }

                    function gb(d, e, n) {
                        const r = this.cache, a = e.length, u = fh(n, a);
                        cs(r, u) || (d.uniform1iv(this.addr, u), is(r, u));
                        for (let y = 0; y !== a; ++y) n.setTexture2D(e[y] || OA, u[y])
                    }

                    function vb(d, e, n) {
                        const r = this.cache, a = e.length, u = fh(n, a);
                        cs(r, u) || (d.uniform1iv(this.addr, u), is(r, u));
                        for (let y = 0; y !== a; ++y) n.setTexture3D(e[y] || hh, u[y])
                    }

                    function yb(d, e, n) {
                        const r = this.cache, a = e.length, u = fh(n, a);
                        cs(r, u) || (d.uniform1iv(this.addr, u), is(r, u));
                        for (let y = 0; y !== a; ++y) n.setTextureCube(e[y] || dh, u[y])
                    }

                    function Eb(d, e, n) {
                        const r = this.cache, a = e.length, u = fh(n, a);
                        cs(r, u) || (d.uniform1iv(this.addr, u), is(r, u));
                        for (let y = 0; y !== a; ++y) n.setTexture2DArray(e[y] || xp, u[y])
                    }

                    function xb(d) {
                        switch (d) {
                            case 5126:
                                return Qn;
                            case 35664:
                                return Yn;
                            case 35665:
                                return us;
                            case 35666:
                                return vt;
                            case 35674:
                                return ct;
                            case 35675:
                                return yt;
                            case 35676:
                                return hn;
                            case 5124:
                            case 35670:
                                return Zn;
                            case 35667:
                            case 35671:
                                return di;
                            case 35668:
                            case 35672:
                                return fi;
                            case 35669:
                            case 35673:
                                return xi;
                            case 5125:
                                return Xs;
                            case 36294:
                                return dr;
                            case 36295:
                                return Hl;
                            case 36296:
                                return cv;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return gb;
                            case 35679:
                            case 36299:
                            case 36307:
                                return vb;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return yb;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return Eb
                        }
                    }

                    class Cb {
                        constructor(e, n, r) {
                            this.id = e, this.addr = r, this.cache = [], this.type = n.type, this.setValue = Ln(n.type)
                        }
                    }

                    class wb {
                        constructor(e, n, r) {
                            this.id = e, this.addr = r, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = xb(n.type)
                        }
                    }

                    class bb {
                        constructor(e) {
                            this.id = e, this.seq = [], this.map = {}
                        }

                        setValue(e, n, r) {
                            const a = this.seq;
                            for (let u = 0, y = a.length; u !== y; ++u) {
                                const S = a[u];
                                S.setValue(e, n[S.id], r)
                            }
                        }
                    }

                    const uv = /(\w+)(\])?(\[|\.)?/g;

                    function H1(d, e) {
                        d.seq.push(e), d.map[e.id] = e
                    }

                    function _b(d, e, n) {
                        const r = d.name, a = r.length;
                        for (uv.lastIndex = 0; ;) {
                            const u = uv.exec(r), y = uv.lastIndex;
                            let S = u[1];
                            const D = u[2] === "]", P = u[3];
                            if (D && (S = S | 0), P === void 0 || P === "[" && y + 2 === a) {
                                H1(n, P === void 0 ? new Cb(S, d, e) : new wb(S, d, e));
                                break
                            } else {
                                let Q = n.map[S];
                                Q === void 0 && (Q = new bb(S), H1(n, Q)), n = Q
                            }
                        }
                    }

                    class FA {
                        constructor(e, n) {
                            this.seq = [], this.map = {};
                            const r = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
                            for (let a = 0; a < r; ++a) {
                                const u = e.getActiveUniform(n, a), y = e.getUniformLocation(n, u.name);
                                _b(u, y, this)
                            }
                        }

                        setValue(e, n, r, a) {
                            const u = this.map[n];
                            u !== void 0 && u.setValue(e, r, a)
                        }

                        setOptional(e, n, r) {
                            const a = n[r];
                            a !== void 0 && this.setValue(e, r, a)
                        }

                        static upload(e, n, r, a) {
                            for (let u = 0, y = n.length; u !== y; ++u) {
                                const S = n[u], D = r[S.id];
                                D.needsUpdate !== !1 && S.setValue(e, D.value, a)
                            }
                        }

                        static seqWithValue(e, n) {
                            const r = [];
                            for (let a = 0, u = e.length; a !== u; ++a) {
                                const y = e[a];
                                y.id in n && r.push(y)
                            }
                            return r
                        }
                    }

                    function Q1(d, e, n) {
                        const r = d.createShader(e);
                        return d.shaderSource(r, n), d.compileShader(r), r
                    }

                    const Mb = 37297;
                    let Sb = 0;

                    function Tb(d, e) {
                        const n = d.split(`
`), r = [], a = Math.max(e - 6, 0), u = Math.min(e + 6, n.length);
                        for (let y = a; y < u; y++) {
                            const S = y + 1;
                            r.push(`${S === e ? ">" : " "} ${S}: ${n[y]}`)
                        }
                        return r.join(`
`)
                    }

                    function Ib(d) {
                        const e = ur.getPrimaries(ur.workingColorSpace), n = ur.getPrimaries(d);
                        let r;
                        switch (e === n ? r = "" : e === Ml && n === Fa ? r = "LinearDisplayP3ToLinearSRGB" : e === Fa && n === Ml && (r = "LinearSRGBToLinearDisplayP3"), d) {
                            case Gs:
                            case ka:
                                return [r, "LinearTransferOETF"];
                            case rr:
                            case bl:
                                return [r, "sRGBTransferOETF"];
                            default:
                                return console.warn("THREE.WebGLProgram: Unsupported color space:", d), [r, "LinearTransferOETF"]
                        }
                    }

                    function j1(d, e, n) {
                        const r = d.getShaderParameter(e, d.COMPILE_STATUS), a = d.getShaderInfoLog(e).trim();
                        if (r && a === "") return "";
                        const u = /ERROR: 0:(\d+)/.exec(a);
                        if (u) {
                            const y = parseInt(u[1]);
                            return n.toUpperCase() + `

` + a + `

` + Tb(d.getShaderSource(e), y)
                        } else return a
                    }

                    function Rb(d, e) {
                        const n = Ib(e);
                        return `vec4 ${d}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
                    }

                    function Bb(d, e) {
                        let n;
                        switch (e) {
                            case ss:
                                n = "Linear";
                                break;
                            case Nr:
                                n = "Reinhard";
                                break;
                            case ir:
                                n = "OptimizedCineon";
                                break;
                            case jt:
                                n = "ACESFilmic";
                                break;
                            case _e:
                                n = "AgX";
                                break;
                            case Ge:
                                n = "Neutral";
                                break;
                            case Se:
                                n = "Custom";
                                break;
                            default:
                                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                        }
                        return "vec3 " + d + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                    }

                    function Lb(d) {
                        return [d.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", d.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(bp).join(`
`)
                    }

                    function Db(d) {
                        const e = [];
                        for (const n in d) {
                            const r = d[n];
                            r !== !1 && e.push("#define " + n + " " + r)
                        }
                        return e.join(`
`)
                    }

                    function Pb(d, e) {
                        const n = {}, r = d.getProgramParameter(e, d.ACTIVE_ATTRIBUTES);
                        for (let a = 0; a < r; a++) {
                            const u = d.getActiveAttrib(e, a), y = u.name;
                            let S = 1;
                            u.type === d.FLOAT_MAT2 && (S = 2), u.type === d.FLOAT_MAT3 && (S = 3), u.type === d.FLOAT_MAT4 && (S = 4), n[y] = {
                                type: u.type,
                                location: d.getAttribLocation(e, y),
                                locationSize: S
                            }
                        }
                        return n
                    }

                    function bp(d) {
                        return d !== ""
                    }

                    function W1(d, e) {
                        const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
                        return d.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                    }

                    function K1(d, e) {
                        return d.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                    }

                    const Ob = /^[ \t]*#include +<([\w\d./]+)>/gm;

                    function hv(d) {
                        return d.replace(Ob, Fb)
                    }

                    const kb = new Map;

                    function Fb(d, e) {
                        let n = ci[e];
                        if (n === void 0) {
                            const r = kb.get(e);
                            if (r !== void 0) n = ci[r], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r); else throw new Error("Can not resolve #include <" + e + ">")
                        }
                        return hv(n)
                    }

                    const Nb = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                    function X1(d) {
                        return d.replace(Nb, Ub)
                    }

                    function Ub(d, e, n, r) {
                        let a = "";
                        for (let u = parseInt(e); u < parseInt(n); u++) a += r.replace(/\[\s*i\s*\]/g, "[ " + u + " ]").replace(/UNROLLED_LOOP_INDEX/g, u);
                        return a
                    }

                    function Y1(d) {
                        let e = `precision ${d.precision} float;
	precision ${d.precision} int;
	precision ${d.precision} sampler2D;
	precision ${d.precision} samplerCube;
	precision ${d.precision} sampler3D;
	precision ${d.precision} sampler2DArray;
	precision ${d.precision} sampler2DShadow;
	precision ${d.precision} samplerCubeShadow;
	precision ${d.precision} sampler2DArrayShadow;
	precision ${d.precision} isampler2D;
	precision ${d.precision} isampler3D;
	precision ${d.precision} isamplerCube;
	precision ${d.precision} isampler2DArray;
	precision ${d.precision} usampler2D;
	precision ${d.precision} usampler3D;
	precision ${d.precision} usamplerCube;
	precision ${d.precision} usampler2DArray;
	`;
                        return d.precision === "highp" ? e += `
#define HIGH_PRECISION` : d.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : d.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
                    }

                    function zb(d) {
                        let e = "SHADOWMAP_TYPE_BASIC";
                        return d.shadowMapType === B ? e = "SHADOWMAP_TYPE_PCF" : d.shadowMapType === R ? e = "SHADOWMAP_TYPE_PCF_SOFT" : d.shadowMapType === I && (e = "SHADOWMAP_TYPE_VSM"), e
                    }

                    function Gb(d) {
                        let e = "ENVMAP_TYPE_CUBE";
                        if (d.envMap) switch (d.envMapMode) {
                            case oe:
                            case G:
                                e = "ENVMAP_TYPE_CUBE";
                                break;
                            case Be:
                                e = "ENVMAP_TYPE_CUBE_UV";
                                break
                        }
                        return e
                    }

                    function Vb(d) {
                        let e = "ENVMAP_MODE_REFLECTION";
                        if (d.envMap) switch (d.envMapMode) {
                            case G:
                                e = "ENVMAP_MODE_REFRACTION";
                                break
                        }
                        return e
                    }

                    function Hb(d) {
                        let e = "ENVMAP_BLENDING_NONE";
                        if (d.envMap) switch (d.combine) {
                            case Ji:
                                e = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case Pi:
                                e = "ENVMAP_BLENDING_MIX";
                                break;
                            case Br:
                                e = "ENVMAP_BLENDING_ADD";
                                break
                        }
                        return e
                    }

                    function Qb(d) {
                        const e = d.envMapCubeUVHeight;
                        if (e === null) return null;
                        const n = Math.log2(e) - 2, r = 1 / e;
                        return {texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)), texelHeight: r, maxMip: n}
                    }

                    function jb(d, e, n, r) {
                        const a = d.getContext(), u = n.defines;
                        let y = n.vertexShader, S = n.fragmentShader;
                        const D = zb(n), P = Gb(n), z = Vb(n), Q = Hb(n), K = Qb(n), q = Lb(n), te = Db(u),
                            le = a.createProgram();
                        let ne, J, Ce = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
                        const ye = n.numMultiviewViews;
                        n.isRawShaderMaterial ? (ne = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, te].filter(bp).join(`
`), ne.length > 0 && (ne += `
`), J = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, te].filter(bp).join(`
`), J.length > 0 && (J += `
`)) : (ne = [Y1(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, te, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + z : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + D : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(bp).join(`
`), J = [Y1(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, te, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + P : "", n.envMap ? "#define " + z : "", n.envMap ? "#define " + Q : "", K ? "#define CUBEUV_TEXEL_WIDTH " + K.texelWidth : "", K ? "#define CUBEUV_TEXEL_HEIGHT " + K.texelHeight : "", K ? "#define CUBEUV_MAX_MIP " + K.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + D : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== cr ? "#define TONE_MAPPING" : "", n.toneMapping !== cr ? ci.tonemapping_pars_fragment : "", n.toneMapping !== cr ? Bb("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", ci.colorspace_pars_fragment, Rb("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(bp).join(`
`)), y = hv(y), y = W1(y, n), y = K1(y, n), S = hv(S), S = W1(S, n), S = K1(S, n), y = X1(y), S = X1(S), n.isRawShaderMaterial !== !0 && (Ce = `#version 300 es
`, ne = [q, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + ne, J = ["#define varying in", n.glslVersion === zu ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === zu ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + J, ye > 0 && (ne = ["#extension GL_OVR_multiview : require", "layout(num_views = " + ye + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join(`
`) + `
` + ne, ne = ne.replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join(`
`), ["uniform mat4 modelViewMatrices[" + ye + "];", "uniform mat4 projectionMatrices[" + ye + "];", "uniform mat4 viewMatrices[" + ye + "];", "uniform mat3 normalMatrices[" + ye + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join(`
`)), J = ["#extension GL_OVR_multiview : require", "#define VIEW_ID gl_ViewID_OVR"].join(`
`) + `
` + J, J = J.replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + ye + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join(`
`))));
                        const ge = Ce + ne + y, $e = Ce + J + S, ze = Q1(a, a.VERTEX_SHADER, ge),
                            We = Q1(a, a.FRAGMENT_SHADER, $e);
                        a.attachShader(le, ze), a.attachShader(le, We), n.index0AttributeName !== void 0 ? a.bindAttribLocation(le, 0, n.index0AttributeName) : n.morphTargets === !0 && a.bindAttribLocation(le, 0, "position"), a.linkProgram(le);

                        function qe(ht) {
                            if (d.debug.checkShaderErrors) {
                                const lt = a.getProgramInfoLog(le).trim(), pt = a.getShaderInfoLog(ze).trim(),
                                    Mt = a.getShaderInfoLog(We).trim();
                                let Ut = !0, mn = !0;
                                if (a.getProgramParameter(le, a.LINK_STATUS) === !1) if (Ut = !1, typeof d.debug.onShaderError == "function") d.debug.onShaderError(a, le, ze, We); else {
                                    const Tt = j1(a, ze, "vertex"), dn = j1(a, We, "fragment");
                                    console.error("THREE.WebGLProgram: Shader Error " + a.getError() + " - VALIDATE_STATUS " + a.getProgramParameter(le, a.VALIDATE_STATUS) + `

Material Name: ` + ht.name + `
Material Type: ` + ht.type + `

Program Info Log: ` + lt + `
` + Tt + `
` + dn)
                                } else lt !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", lt) : (pt === "" || Mt === "") && (mn = !1);
                                mn && (ht.diagnostics = {
                                    runnable: Ut,
                                    programLog: lt,
                                    vertexShader: {log: pt, prefix: ne},
                                    fragmentShader: {log: Mt, prefix: J}
                                })
                            }
                            a.deleteShader(ze), a.deleteShader(We), Pe = new FA(a, le), Te = Pb(a, le)
                        }

                        let Pe;
                        this.getUniforms = function () {
                            return Pe === void 0 && qe(this), Pe
                        };
                        let Te;
                        this.getAttributes = function () {
                            return Te === void 0 && qe(this), Te
                        };
                        let Je = n.rendererExtensionParallelShaderCompile === !1;
                        return this.isReady = function () {
                            return Je === !1 && (Je = a.getProgramParameter(le, Mb)), Je
                        }, this.destroy = function () {
                            r.releaseStatesOfProgram(this), a.deleteProgram(le), this.program = void 0
                        }, this.type = n.shaderType, this.name = n.shaderName, this.id = Sb++, this.cacheKey = e, this.usedTimes = 1, this.program = le, this.vertexShader = ze, this.fragmentShader = We, this.numMultiviewViews = ye, this
                    }

                    let Wb = 0;

                    class Kb {
                        constructor() {
                            this.shaderCache = new Map, this.materialCache = new Map
                        }

                        update(e) {
                            const n = e.vertexShader, r = e.fragmentShader, a = this._getShaderStage(n),
                                u = this._getShaderStage(r), y = this._getShaderCacheForMaterial(e);
                            return y.has(a) === !1 && (y.add(a), a.usedTimes++), y.has(u) === !1 && (y.add(u), u.usedTimes++), this
                        }

                        remove(e) {
                            const n = this.materialCache.get(e);
                            for (const r of n) r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
                            return this.materialCache.delete(e), this
                        }

                        getVertexShaderID(e) {
                            return this._getShaderStage(e.vertexShader).id
                        }

                        getFragmentShaderID(e) {
                            return this._getShaderStage(e.fragmentShader).id
                        }

                        dispose() {
                            this.shaderCache.clear(), this.materialCache.clear()
                        }

                        _getShaderCacheForMaterial(e) {
                            const n = this.materialCache;
                            let r = n.get(e);
                            return r === void 0 && (r = new Set, n.set(e, r)), r
                        }

                        _getShaderStage(e) {
                            const n = this.shaderCache;
                            let r = n.get(e);
                            return r === void 0 && (r = new Xb(e), n.set(e, r)), r
                        }
                    }

                    class Xb {
                        constructor(e) {
                            this.id = Wb++, this.code = e, this.usedTimes = 0
                        }
                    }

                    function Yb(d, e, n, r, a, u, y) {
                        const S = new hl, D = new Kb, P = new Set, z = [], Q = a.logarithmicDepthBuffer,
                            K = a.vertexTextures;
                        let q = a.precision;
                        const te = {
                            MeshDepthMaterial: "depth",
                            MeshDistanceMaterial: "distanceRGBA",
                            MeshNormalMaterial: "normal",
                            MeshBasicMaterial: "basic",
                            MeshLambertMaterial: "lambert",
                            MeshPhongMaterial: "phong",
                            MeshToonMaterial: "toon",
                            MeshStandardMaterial: "physical",
                            MeshPhysicalMaterial: "physical",
                            MeshMatcapMaterial: "matcap",
                            LineBasicMaterial: "basic",
                            LineDashedMaterial: "dashed",
                            PointsMaterial: "points",
                            ShadowMaterial: "shadow",
                            SpriteMaterial: "sprite"
                        };

                        function le(Pe) {
                            return P.add(Pe), Pe === 0 ? "uv" : `uv${Pe}`
                        }

                        function ne(Pe, Te, Je, ht, lt) {
                            const pt = ht.fog, Mt = lt.geometry, Ut = Pe.isMeshStandardMaterial ? ht.environment : null,
                                mn = (Pe.isMeshStandardMaterial ? n : e).get(Pe.envMap || Ut),
                                Tt = mn && mn.mapping === Be ? mn.image.height : null, dn = te[Pe.type];
                            Pe.precision !== null && (q = a.getMaxPrecision(Pe.precision), q !== Pe.precision && console.warn("THREE.WebGLProgram.getParameters:", Pe.precision, "not supported, using", q, "instead."));
                            const fn = Mt.morphAttributes.position || Mt.morphAttributes.normal || Mt.morphAttributes.color,
                                Kn = fn !== void 0 ? fn.length : 0;
                            let Qi = 0;
                            Mt.morphAttributes.position !== void 0 && (Qi = 1), Mt.morphAttributes.normal !== void 0 && (Qi = 2), Mt.morphAttributes.color !== void 0 && (Qi = 3);
                            let Tr, Kr, Cr, Vr;
                            if (dn) {
                                const so = ia[dn];
                                Tr = so.vertexShader, Kr = so.fragmentShader
                            } else Tr = Pe.vertexShader, Kr = Pe.fragmentShader, D.update(Pe), Cr = D.getVertexShaderID(Pe), Vr = D.getFragmentShaderID(Pe);
                            const Jn = d.getRenderTarget(),
                                Ht = Jn && Jn.isWebGLMultiviewRenderTarget ? Jn.numViews : 0,
                                vn = lt.isInstancedMesh === !0, bn = lt.isBatchedMesh === !0, mt = !!Pe.map,
                                Qt = !!Pe.matcap, Ot = !!mn, ln = !!Pe.aoMap, on = !!Pe.lightMap, tn = !!Pe.bumpMap,
                                Tn = !!Pe.normalMap, Fn = !!Pe.displacementMap, Bi = !!Pe.emissiveMap,
                                Di = !!Pe.metalnessMap, wr = !!Pe.roughnessMap, ds = Pe.anisotropy > 0,
                                Xr = Pe.clearcoat > 0, Ye = Pe.dispersion > 0, Ie = Pe.iridescence > 0,
                                It = Pe.sheen > 0, Gt = Pe.transmission > 0, Xt = ds && !!Pe.anisotropyMap,
                                Wt = Xr && !!Pe.clearcoatMap, ei = Xr && !!Pe.clearcoatNormalMap,
                                An = Xr && !!Pe.clearcoatRoughnessMap, zn = Ie && !!Pe.iridescenceMap,
                                Pr = Ie && !!Pe.iridescenceThicknessMap, Gn = It && !!Pe.sheenColorMap,
                                ni = It && !!Pe.sheenRoughnessMap, Ui = !!Pe.specularMap, vi = !!Pe.specularColorMap,
                                it = !!Pe.specularIntensityMap, nn = Gt && !!Pe.transmissionMap,
                                pn = Gt && !!Pe.thicknessMap, ti = !!Pe.gradientMap, On = !!Pe.alphaMap,
                                zi = Pe.alphaTest > 0, kn = !!Pe.alphaHash, In = !!Pe.extensions;
                            let Xi = cr;
                            Pe.toneMapped && (Jn === null || Jn.isXRRenderTarget === !0) && (Xi = d.toneMapping);
                            const Ci = {
                                shaderID: dn,
                                shaderType: Pe.type,
                                shaderName: Pe.name,
                                vertexShader: Tr,
                                fragmentShader: Kr,
                                defines: Pe.defines,
                                customVertexShaderID: Cr,
                                customFragmentShaderID: Vr,
                                isRawShaderMaterial: Pe.isRawShaderMaterial === !0,
                                glslVersion: Pe.glslVersion,
                                precision: q,
                                batching: bn,
                                instancing: vn,
                                instancingColor: vn && lt.instanceColor !== null,
                                instancingMorph: vn && lt.morphTexture !== null,
                                supportsVertexTextures: K,
                                numMultiviewViews: Ht,
                                outputColorSpace: Jn === null ? d.outputColorSpace : Jn.isXRRenderTarget === !0 ? Jn.texture.colorSpace : Gs,
                                alphaToCoverage: !!Pe.alphaToCoverage,
                                map: mt,
                                matcap: Qt,
                                envMap: Ot,
                                envMapMode: Ot && mn.mapping,
                                envMapCubeUVHeight: Tt,
                                aoMap: ln,
                                lightMap: on,
                                bumpMap: tn,
                                normalMap: Tn,
                                displacementMap: K && Fn,
                                emissiveMap: Bi,
                                normalMapObjectSpace: Tn && Pe.normalMapType === Wo,
                                normalMapTangentSpace: Tn && Pe.normalMapType === zs,
                                metalnessMap: Di,
                                roughnessMap: wr,
                                anisotropy: ds,
                                anisotropyMap: Xt,
                                clearcoat: Xr,
                                clearcoatMap: Wt,
                                clearcoatNormalMap: ei,
                                clearcoatRoughnessMap: An,
                                dispersion: Ye,
                                iridescence: Ie,
                                iridescenceMap: zn,
                                iridescenceThicknessMap: Pr,
                                sheen: It,
                                sheenColorMap: Gn,
                                sheenRoughnessMap: ni,
                                specularMap: Ui,
                                specularColorMap: vi,
                                specularIntensityMap: it,
                                transmission: Gt,
                                transmissionMap: nn,
                                thicknessMap: pn,
                                gradientMap: ti,
                                opaque: Pe.transparent === !1 && Pe.blending === V && Pe.alphaToCoverage === !1,
                                alphaMap: On,
                                alphaTest: zi,
                                alphaHash: kn,
                                combine: Pe.combine,
                                mapUv: mt && le(Pe.map.channel),
                                aoMapUv: ln && le(Pe.aoMap.channel),
                                lightMapUv: on && le(Pe.lightMap.channel),
                                bumpMapUv: tn && le(Pe.bumpMap.channel),
                                normalMapUv: Tn && le(Pe.normalMap.channel),
                                displacementMapUv: Fn && le(Pe.displacementMap.channel),
                                emissiveMapUv: Bi && le(Pe.emissiveMap.channel),
                                metalnessMapUv: Di && le(Pe.metalnessMap.channel),
                                roughnessMapUv: wr && le(Pe.roughnessMap.channel),
                                anisotropyMapUv: Xt && le(Pe.anisotropyMap.channel),
                                clearcoatMapUv: Wt && le(Pe.clearcoatMap.channel),
                                clearcoatNormalMapUv: ei && le(Pe.clearcoatNormalMap.channel),
                                clearcoatRoughnessMapUv: An && le(Pe.clearcoatRoughnessMap.channel),
                                iridescenceMapUv: zn && le(Pe.iridescenceMap.channel),
                                iridescenceThicknessMapUv: Pr && le(Pe.iridescenceThicknessMap.channel),
                                sheenColorMapUv: Gn && le(Pe.sheenColorMap.channel),
                                sheenRoughnessMapUv: ni && le(Pe.sheenRoughnessMap.channel),
                                specularMapUv: Ui && le(Pe.specularMap.channel),
                                specularColorMapUv: vi && le(Pe.specularColorMap.channel),
                                specularIntensityMapUv: it && le(Pe.specularIntensityMap.channel),
                                transmissionMapUv: nn && le(Pe.transmissionMap.channel),
                                thicknessMapUv: pn && le(Pe.thicknessMap.channel),
                                alphaMapUv: On && le(Pe.alphaMap.channel),
                                vertexTangents: !!Mt.attributes.tangent && (Tn || ds),
                                vertexColors: Pe.vertexColors,
                                vertexAlphas: Pe.vertexColors === !0 && !!Mt.attributes.color && Mt.attributes.color.itemSize === 4,
                                pointsUvs: lt.isPoints === !0 && !!Mt.attributes.uv && (mt || On),
                                fog: !!pt,
                                useFog: Pe.fog === !0,
                                fogExp2: !!pt && pt.isFogExp2,
                                flatShading: Pe.flatShading === !0,
                                sizeAttenuation: Pe.sizeAttenuation === !0,
                                logarithmicDepthBuffer: Q,
                                skinning: lt.isSkinnedMesh === !0,
                                morphTargets: Mt.morphAttributes.position !== void 0,
                                morphNormals: Mt.morphAttributes.normal !== void 0,
                                morphColors: Mt.morphAttributes.color !== void 0,
                                morphTargetsCount: Kn,
                                morphTextureStride: Qi,
                                numDirLights: Te.directional.length,
                                numPointLights: Te.point.length,
                                numSpotLights: Te.spot.length,
                                numSpotLightMaps: Te.spotLightMap.length,
                                numRectAreaLights: Te.rectArea.length,
                                numHemiLights: Te.hemi.length,
                                numDirLightShadows: Te.directionalShadowMap.length,
                                numPointLightShadows: Te.pointShadowMap.length,
                                numSpotLightShadows: Te.spotShadowMap.length,
                                numSpotLightShadowsWithMaps: Te.numSpotLightShadowsWithMaps,
                                numLightProbes: Te.numLightProbes,
                                numClippingPlanes: y.numPlanes,
                                numClipIntersection: y.numIntersection,
                                dithering: Pe.dithering,
                                shadowMapEnabled: d.shadowMap.enabled && Je.length > 0,
                                shadowMapType: d.shadowMap.type,
                                toneMapping: Xi,
                                useLegacyLights: d._useLegacyLights,
                                decodeVideoTexture: mt && Pe.map.isVideoTexture === !0 && ur.getTransfer(Pe.map.colorSpace) === mr,
                                premultipliedAlpha: Pe.premultipliedAlpha,
                                doubleSided: Pe.side === N,
                                flipSided: Pe.side === O,
                                useDepthPacking: Pe.depthPacking >= 0,
                                depthPacking: Pe.depthPacking || 0,
                                index0AttributeName: Pe.index0AttributeName,
                                extensionClipCullDistance: In && Pe.extensions.clipCullDistance === !0 && r.has("WEBGL_clip_cull_distance"),
                                extensionMultiDraw: In && Pe.extensions.multiDraw === !0 && r.has("WEBGL_multi_draw"),
                                rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                                customProgramCacheKey: Pe.customProgramCacheKey()
                            };
                            return Ci.vertexUv1s = P.has(1), Ci.vertexUv2s = P.has(2), Ci.vertexUv3s = P.has(3), P.clear(), Ci
                        }

                        function J(Pe) {
                            const Te = [];
                            if (Pe.shaderID ? Te.push(Pe.shaderID) : (Te.push(Pe.customVertexShaderID), Te.push(Pe.customFragmentShaderID)), Pe.defines !== void 0) for (const Je in Pe.defines) Te.push(Je), Te.push(Pe.defines[Je]);
                            return Pe.isRawShaderMaterial === !1 && (Ce(Te, Pe), ye(Te, Pe), Te.push(d.outputColorSpace)), Te.push(Pe.customProgramCacheKey), Te.join()
                        }

                        function Ce(Pe, Te) {
                            Pe.push(Te.precision), Pe.push(Te.outputColorSpace), Pe.push(Te.envMapMode), Pe.push(Te.envMapCubeUVHeight), Pe.push(Te.mapUv), Pe.push(Te.alphaMapUv), Pe.push(Te.lightMapUv), Pe.push(Te.aoMapUv), Pe.push(Te.bumpMapUv), Pe.push(Te.normalMapUv), Pe.push(Te.displacementMapUv), Pe.push(Te.emissiveMapUv), Pe.push(Te.metalnessMapUv), Pe.push(Te.roughnessMapUv), Pe.push(Te.anisotropyMapUv), Pe.push(Te.clearcoatMapUv), Pe.push(Te.clearcoatNormalMapUv), Pe.push(Te.clearcoatRoughnessMapUv), Pe.push(Te.iridescenceMapUv), Pe.push(Te.iridescenceThicknessMapUv), Pe.push(Te.sheenColorMapUv), Pe.push(Te.sheenRoughnessMapUv), Pe.push(Te.specularMapUv), Pe.push(Te.specularColorMapUv), Pe.push(Te.specularIntensityMapUv), Pe.push(Te.transmissionMapUv), Pe.push(Te.thicknessMapUv), Pe.push(Te.combine), Pe.push(Te.fogExp2), Pe.push(Te.sizeAttenuation), Pe.push(Te.morphTargetsCount), Pe.push(Te.morphAttributeCount), Pe.push(Te.numDirLights), Pe.push(Te.numPointLights), Pe.push(Te.numSpotLights), Pe.push(Te.numSpotLightMaps), Pe.push(Te.numHemiLights), Pe.push(Te.numRectAreaLights), Pe.push(Te.numDirLightShadows), Pe.push(Te.numPointLightShadows), Pe.push(Te.numSpotLightShadows), Pe.push(Te.numSpotLightShadowsWithMaps), Pe.push(Te.numLightProbes), Pe.push(Te.shadowMapType), Pe.push(Te.toneMapping), Pe.push(Te.numClippingPlanes), Pe.push(Te.numClipIntersection), Pe.push(Te.depthPacking)
                        }

                        function ye(Pe, Te) {
                            S.disableAll(), Te.supportsVertexTextures && S.enable(0), Te.instancing && S.enable(1), Te.instancingColor && S.enable(2), Te.instancingMorph && S.enable(3), Te.matcap && S.enable(4), Te.envMap && S.enable(5), Te.normalMapObjectSpace && S.enable(6), Te.normalMapTangentSpace && S.enable(7), Te.clearcoat && S.enable(8), Te.iridescence && S.enable(9), Te.alphaTest && S.enable(10), Te.vertexColors && S.enable(11), Te.vertexAlphas && S.enable(12), Te.vertexUv1s && S.enable(13), Te.vertexUv2s && S.enable(14), Te.vertexUv3s && S.enable(15), Te.vertexTangents && S.enable(16), Te.anisotropy && S.enable(17), Te.alphaHash && S.enable(18), Te.batching && S.enable(19), Te.dispersion && S.enable(20), Pe.push(S.mask), S.disableAll(), Te.fog && S.enable(0), Te.useFog && S.enable(1), Te.flatShading && S.enable(2), Te.logarithmicDepthBuffer && S.enable(3), Te.skinning && S.enable(4), Te.morphTargets && S.enable(5), Te.morphNormals && S.enable(6), Te.morphColors && S.enable(7), Te.premultipliedAlpha && S.enable(8), Te.shadowMapEnabled && S.enable(9), Te.useLegacyLights && S.enable(10), Te.doubleSided && S.enable(11), Te.flipSided && S.enable(12), Te.useDepthPacking && S.enable(13), Te.dithering && S.enable(14), Te.transmission && S.enable(15), Te.sheen && S.enable(16), Te.opaque && S.enable(17), Te.pointsUvs && S.enable(18), Te.decodeVideoTexture && S.enable(19), Te.alphaToCoverage && S.enable(20), Te.numMultiviewViews && S.enable(21), Pe.push(S.mask)
                        }

                        function ge(Pe) {
                            const Te = te[Pe.type];
                            let Je;
                            if (Te) {
                                const ht = ia[Te];
                                Je = ld.clone(ht.uniforms)
                            } else Je = Pe.uniforms;
                            return Je
                        }

                        function $e(Pe, Te) {
                            let Je;
                            for (let ht = 0, lt = z.length; ht < lt; ht++) {
                                const pt = z[ht];
                                if (pt.cacheKey === Te) {
                                    Je = pt, ++Je.usedTimes;
                                    break
                                }
                            }
                            return Je === void 0 && (Je = new jb(d, Te, Pe, u), z.push(Je)), Je
                        }

                        function ze(Pe) {
                            if (--Pe.usedTimes === 0) {
                                const Te = z.indexOf(Pe);
                                z[Te] = z[z.length - 1], z.pop(), Pe.destroy()
                            }
                        }

                        function We(Pe) {
                            D.remove(Pe)
                        }

                        function qe() {
                            D.dispose()
                        }

                        return {
                            getParameters: ne,
                            getProgramCacheKey: J,
                            getUniforms: ge,
                            acquireProgram: $e,
                            releaseProgram: ze,
                            releaseShaderCache: We,
                            programs: z,
                            dispose: qe
                        }
                    }

                    function qb() {
                        let d = new WeakMap;

                        function e(u) {
                            let y = d.get(u);
                            return y === void 0 && (y = {}, d.set(u, y)), y
                        }

                        function n(u) {
                            d.delete(u)
                        }

                        function r(u, y, S) {
                            d.get(u)[y] = S
                        }

                        function a() {
                            d = new WeakMap
                        }

                        return {get: e, remove: n, update: r, dispose: a}
                    }

                    function Jb(d, e) {
                        return d.groupOrder !== e.groupOrder ? d.groupOrder - e.groupOrder : d.renderOrder !== e.renderOrder ? d.renderOrder - e.renderOrder : d.material.id !== e.material.id ? d.material.id - e.material.id : d.z !== e.z ? d.z - e.z : d.id - e.id
                    }

                    function q1(d, e) {
                        return d.groupOrder !== e.groupOrder ? d.groupOrder - e.groupOrder : d.renderOrder !== e.renderOrder ? d.renderOrder - e.renderOrder : d.z !== e.z ? e.z - d.z : d.id - e.id
                    }

                    function J1() {
                        const d = [];
                        let e = 0;
                        const n = [], r = [], a = [];

                        function u() {
                            e = 0, n.length = 0, r.length = 0, a.length = 0
                        }

                        function y(Q, K, q, te, le, ne) {
                            let J = d[e];
                            return J === void 0 ? (J = {
                                id: Q.id,
                                object: Q,
                                geometry: K,
                                material: q,
                                groupOrder: te,
                                renderOrder: Q.renderOrder,
                                z: le,
                                group: ne
                            }, d[e] = J) : (J.id = Q.id, J.object = Q, J.geometry = K, J.material = q, J.groupOrder = te, J.renderOrder = Q.renderOrder, J.z = le, J.group = ne), e++, J
                        }

                        function S(Q, K, q, te, le, ne) {
                            const J = y(Q, K, q, te, le, ne);
                            q.transmission > 0 ? r.push(J) : q.transparent === !0 ? a.push(J) : n.push(J)
                        }

                        function D(Q, K, q, te, le, ne) {
                            const J = y(Q, K, q, te, le, ne);
                            q.transmission > 0 ? r.unshift(J) : q.transparent === !0 ? a.unshift(J) : n.unshift(J)
                        }

                        function P(Q, K) {
                            n.length > 1 && n.sort(Q || Jb), r.length > 1 && r.sort(K || q1), a.length > 1 && a.sort(K || q1)
                        }

                        function z() {
                            for (let Q = e, K = d.length; Q < K; Q++) {
                                const q = d[Q];
                                if (q.id === null) break;
                                q.id = null, q.object = null, q.geometry = null, q.material = null, q.group = null
                            }
                        }

                        return {
                            opaque: n,
                            transmissive: r,
                            transparent: a,
                            init: u,
                            push: S,
                            unshift: D,
                            finish: z,
                            sort: P
                        }
                    }

                    function Zb() {
                        let d = new WeakMap;

                        function e(r, a) {
                            const u = d.get(r);
                            let y;
                            return u === void 0 ? (y = new J1, d.set(r, [y])) : a >= u.length ? (y = new J1, u.push(y)) : y = u[a], y
                        }

                        function n() {
                            d = new WeakMap
                        }

                        return {get: e, dispose: n}
                    }

                    function $b() {
                        const d = {};
                        return {
                            get: function (e) {
                                if (d[e.id] !== void 0) return d[e.id];
                                let n;
                                switch (e.type) {
                                    case"DirectionalLight":
                                        n = {direction: new Ne, color: new Bn};
                                        break;
                                    case"SpotLight":
                                        n = {
                                            position: new Ne,
                                            direction: new Ne,
                                            color: new Bn,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0
                                        };
                                        break;
                                    case"PointLight":
                                        n = {position: new Ne, color: new Bn, distance: 0, decay: 0};
                                        break;
                                    case"HemisphereLight":
                                        n = {direction: new Ne, skyColor: new Bn, groundColor: new Bn};
                                        break;
                                    case"RectAreaLight":
                                        n = {color: new Bn, position: new Ne, halfWidth: new Ne, halfHeight: new Ne};
                                        break
                                }
                                return d[e.id] = n, n
                            }
                        }
                    }

                    function e_() {
                        const d = {};
                        return {
                            get: function (e) {
                                if (d[e.id] !== void 0) return d[e.id];
                                let n;
                                switch (e.type) {
                                    case"DirectionalLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new zt
                                        };
                                        break;
                                    case"SpotLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new zt
                                        };
                                        break;
                                    case"PointLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new zt,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        };
                                        break
                                }
                                return d[e.id] = n, n
                            }
                        }
                    }

                    let t_ = 0;

                    function n_(d, e) {
                        return (e.castShadow ? 2 : 0) - (d.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (d.map ? 1 : 0)
                    }

                    function i_(d) {
                        const e = new $b, n = e_(), r = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1,
                                numSpotMaps: -1,
                                numLightProbes: -1
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotLightMap: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotLightMatrix: [],
                            rectArea: [],
                            rectAreaLTC1: null,
                            rectAreaLTC2: null,
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: [],
                            numSpotLightShadowsWithMaps: 0,
                            numLightProbes: 0
                        };
                        for (let P = 0; P < 9; P++) r.probe.push(new Ne);
                        const a = new Ne, u = new Mn, y = new Mn;

                        function S(P, z) {
                            let Q = 0, K = 0, q = 0;
                            for (let Je = 0; Je < 9; Je++) r.probe[Je].set(0, 0, 0);
                            let te = 0, le = 0, ne = 0, J = 0, Ce = 0, ye = 0, ge = 0, $e = 0, ze = 0, We = 0, qe = 0;
                            P.sort(n_);
                            const Pe = z === !0 ? Math.PI : 1;
                            for (let Je = 0, ht = P.length; Je < ht; Je++) {
                                const lt = P[Je], pt = lt.color, Mt = lt.intensity, Ut = lt.distance,
                                    mn = lt.shadow && lt.shadow.map ? lt.shadow.map.texture : null;
                                if (lt.isAmbientLight) Q += pt.r * Mt * Pe, K += pt.g * Mt * Pe, q += pt.b * Mt * Pe; else if (lt.isLightProbe) {
                                    for (let Tt = 0; Tt < 9; Tt++) r.probe[Tt].addScaledVector(lt.sh.coefficients[Tt], Mt);
                                    qe++
                                } else if (lt.isDirectionalLight) {
                                    const Tt = e.get(lt);
                                    if (Tt.color.copy(lt.color).multiplyScalar(lt.intensity * Pe), lt.castShadow) {
                                        const dn = lt.shadow, fn = n.get(lt);
                                        fn.shadowBias = dn.bias, fn.shadowNormalBias = dn.normalBias, fn.shadowRadius = dn.radius, fn.shadowMapSize = dn.mapSize, r.directionalShadow[te] = fn, r.directionalShadowMap[te] = mn, r.directionalShadowMatrix[te] = lt.shadow.matrix, ye++
                                    }
                                    r.directional[te] = Tt, te++
                                } else if (lt.isSpotLight) {
                                    const Tt = e.get(lt);
                                    Tt.position.setFromMatrixPosition(lt.matrixWorld), Tt.color.copy(pt).multiplyScalar(Mt * Pe), Tt.distance = Ut, Tt.coneCos = Math.cos(lt.angle), Tt.penumbraCos = Math.cos(lt.angle * (1 - lt.penumbra)), Tt.decay = lt.decay, r.spot[ne] = Tt;
                                    const dn = lt.shadow;
                                    if (lt.map && (r.spotLightMap[ze] = lt.map, ze++, dn.updateMatrices(lt), lt.castShadow && We++), r.spotLightMatrix[ne] = dn.matrix, lt.castShadow) {
                                        const fn = n.get(lt);
                                        fn.shadowBias = dn.bias, fn.shadowNormalBias = dn.normalBias, fn.shadowRadius = dn.radius, fn.shadowMapSize = dn.mapSize, r.spotShadow[ne] = fn, r.spotShadowMap[ne] = mn, $e++
                                    }
                                    ne++
                                } else if (lt.isRectAreaLight) {
                                    const Tt = e.get(lt);
                                    Tt.color.copy(pt).multiplyScalar(Mt), Tt.halfWidth.set(lt.width * .5, 0, 0), Tt.halfHeight.set(0, lt.height * .5, 0), r.rectArea[J] = Tt, J++
                                } else if (lt.isPointLight) {
                                    const Tt = e.get(lt);
                                    if (Tt.color.copy(lt.color).multiplyScalar(lt.intensity * Pe), Tt.distance = lt.distance, Tt.decay = lt.decay, lt.castShadow) {
                                        const dn = lt.shadow, fn = n.get(lt);
                                        fn.shadowBias = dn.bias, fn.shadowNormalBias = dn.normalBias, fn.shadowRadius = dn.radius, fn.shadowMapSize = dn.mapSize, fn.shadowCameraNear = dn.camera.near, fn.shadowCameraFar = dn.camera.far, r.pointShadow[le] = fn, r.pointShadowMap[le] = mn, r.pointShadowMatrix[le] = lt.shadow.matrix, ge++
                                    }
                                    r.point[le] = Tt, le++
                                } else if (lt.isHemisphereLight) {
                                    const Tt = e.get(lt);
                                    Tt.skyColor.copy(lt.color).multiplyScalar(Mt * Pe), Tt.groundColor.copy(lt.groundColor).multiplyScalar(Mt * Pe), r.hemi[Ce] = Tt, Ce++
                                }
                            }
                            J > 0 && (d.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = wn.LTC_FLOAT_1, r.rectAreaLTC2 = wn.LTC_FLOAT_2) : (r.rectAreaLTC1 = wn.LTC_HALF_1, r.rectAreaLTC2 = wn.LTC_HALF_2)), r.ambient[0] = Q, r.ambient[1] = K, r.ambient[2] = q;
                            const Te = r.hash;
                            (Te.directionalLength !== te || Te.pointLength !== le || Te.spotLength !== ne || Te.rectAreaLength !== J || Te.hemiLength !== Ce || Te.numDirectionalShadows !== ye || Te.numPointShadows !== ge || Te.numSpotShadows !== $e || Te.numSpotMaps !== ze || Te.numLightProbes !== qe) && (r.directional.length = te, r.spot.length = ne, r.rectArea.length = J, r.point.length = le, r.hemi.length = Ce, r.directionalShadow.length = ye, r.directionalShadowMap.length = ye, r.pointShadow.length = ge, r.pointShadowMap.length = ge, r.spotShadow.length = $e, r.spotShadowMap.length = $e, r.directionalShadowMatrix.length = ye, r.pointShadowMatrix.length = ge, r.spotLightMatrix.length = $e + ze - We, r.spotLightMap.length = ze, r.numSpotLightShadowsWithMaps = We, r.numLightProbes = qe, Te.directionalLength = te, Te.pointLength = le, Te.spotLength = ne, Te.rectAreaLength = J, Te.hemiLength = Ce, Te.numDirectionalShadows = ye, Te.numPointShadows = ge, Te.numSpotShadows = $e, Te.numSpotMaps = ze, Te.numLightProbes = qe, r.version = t_++)
                        }

                        function D(P, z) {
                            let Q = 0, K = 0, q = 0, te = 0, le = 0;
                            const ne = z.matrixWorldInverse;
                            for (let J = 0, Ce = P.length; J < Ce; J++) {
                                const ye = P[J];
                                if (ye.isDirectionalLight) {
                                    const ge = r.directional[Q];
                                    ge.direction.setFromMatrixPosition(ye.matrixWorld), a.setFromMatrixPosition(ye.target.matrixWorld), ge.direction.sub(a), ge.direction.transformDirection(ne), Q++
                                } else if (ye.isSpotLight) {
                                    const ge = r.spot[q];
                                    ge.position.setFromMatrixPosition(ye.matrixWorld), ge.position.applyMatrix4(ne), ge.direction.setFromMatrixPosition(ye.matrixWorld), a.setFromMatrixPosition(ye.target.matrixWorld), ge.direction.sub(a), ge.direction.transformDirection(ne), q++
                                } else if (ye.isRectAreaLight) {
                                    const ge = r.rectArea[te];
                                    ge.position.setFromMatrixPosition(ye.matrixWorld), ge.position.applyMatrix4(ne), y.identity(), u.copy(ye.matrixWorld), u.premultiply(ne), y.extractRotation(u), ge.halfWidth.set(ye.width * .5, 0, 0), ge.halfHeight.set(0, ye.height * .5, 0), ge.halfWidth.applyMatrix4(y), ge.halfHeight.applyMatrix4(y), te++
                                } else if (ye.isPointLight) {
                                    const ge = r.point[K];
                                    ge.position.setFromMatrixPosition(ye.matrixWorld), ge.position.applyMatrix4(ne), K++
                                } else if (ye.isHemisphereLight) {
                                    const ge = r.hemi[le];
                                    ge.direction.setFromMatrixPosition(ye.matrixWorld), ge.direction.transformDirection(ne), le++
                                }
                            }
                        }

                        return {setup: S, setupView: D, state: r}
                    }

                    function Z1(d) {
                        const e = new i_(d), n = [], r = [];

                        function a(z) {
                            P.camera = z, n.length = 0, r.length = 0
                        }

                        function u(z) {
                            n.push(z)
                        }

                        function y(z) {
                            r.push(z)
                        }

                        function S(z) {
                            e.setup(n, z)
                        }

                        function D(z) {
                            e.setupView(n, z)
                        }

                        const P = {
                            lightsArray: n,
                            shadowsArray: r,
                            camera: null,
                            lights: e,
                            transmissionRenderTarget: {}
                        };
                        return {init: a, state: P, setupLights: S, setupLightsView: D, pushLight: u, pushShadow: y}
                    }

                    function r_(d) {
                        let e = new WeakMap;

                        function n(a, u = 0) {
                            const y = e.get(a);
                            let S;
                            return y === void 0 ? (S = new Z1(d), e.set(a, [S])) : u >= y.length ? (S = new Z1(d), y.push(S)) : S = y[u], S
                        }

                        function r() {
                            e = new WeakMap
                        }

                        return {get: n, dispose: r}
                    }

                    class dv extends Dr {
                        constructor(e) {
                            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = ha, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                        }
                    }

                    class fv extends Dr {
                        constructor(e) {
                            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                        }
                    }

                    const s_ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, o_ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

                    function a_(d, e, n) {
                        let r = new Ec;
                        const a = new zt, u = new zt, y = new ar, S = new dv({depthPacking: jo}), D = new fv, P = {},
                            z = n.maxTextureSize, Q = {[L]: O, [O]: L, [N]: N}, K = new ta({
                                defines: {VSM_SAMPLES: 8},
                                uniforms: {shadow_pass: {value: null}, resolution: {value: new zt}, radius: {value: 4}},
                                vertexShader: s_,
                                fragmentShader: o_
                            }), q = K.clone();
                        q.defines.HORIZONTAL_PASS = 1;
                        const te = new Ti;
                        te.setAttribute("position", new Er(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                        const le = new Wr(te, K), ne = this;
                        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = B;
                        let J = this.type;
                        this.render = function (ze, We, qe) {
                            if (ne.enabled === !1 || ne.autoUpdate === !1 && ne.needsUpdate === !1 || ze.length === 0) return;
                            const Pe = d.getRenderTarget(), Te = d.getActiveCubeFace(), Je = d.getActiveMipmapLevel(),
                                ht = d.state;
                            ht.setBlending(F), ht.buffers.color.setClear(1, 1, 1, 1), ht.buffers.depth.setTest(!0), ht.setScissorTest(!1);
                            const lt = J !== I && this.type === I, pt = J === I && this.type !== I;
                            for (let Mt = 0, Ut = ze.length; Mt < Ut; Mt++) {
                                const mn = ze[Mt], Tt = mn.shadow;
                                if (Tt === void 0) {
                                    console.warn("THREE.WebGLShadowMap:", mn, "has no shadow.");
                                    continue
                                }
                                if (Tt.autoUpdate === !1 && Tt.needsUpdate === !1) continue;
                                a.copy(Tt.mapSize);
                                const dn = Tt.getFrameExtents();
                                if (a.multiply(dn), u.copy(Tt.mapSize), (a.x > z || a.y > z) && (a.x > z && (u.x = Math.floor(z / dn.x), a.x = u.x * dn.x, Tt.mapSize.x = u.x), a.y > z && (u.y = Math.floor(z / dn.y), a.y = u.y * dn.y, Tt.mapSize.y = u.y)), Tt.map === null || lt === !0 || pt === !0) {
                                    const Kn = this.type !== I ? {minFilter: cn, magFilter: cn} : {};
                                    Tt.map !== null && Tt.map.dispose(), Tt.map = new os(a.x, a.y, Kn), Tt.map.texture.name = mn.name + ".shadowMap", Tt.camera.updateProjectionMatrix()
                                }
                                d.setRenderTarget(Tt.map), d.clear();
                                const fn = Tt.getViewportCount();
                                for (let Kn = 0; Kn < fn; Kn++) {
                                    const Qi = Tt.getViewport(Kn);
                                    y.set(u.x * Qi.x, u.y * Qi.y, u.x * Qi.z, u.y * Qi.w), ht.viewport(y), Tt.updateMatrices(mn, Kn), r = Tt.getFrustum(), ge(We, qe, Tt.camera, mn, this.type)
                                }
                                Tt.isPointLightShadow !== !0 && this.type === I && Ce(Tt, qe), Tt.needsUpdate = !1
                            }
                            J = this.type, ne.needsUpdate = !1, d.setRenderTarget(Pe, Te, Je)
                        };

                        function Ce(ze, We) {
                            const qe = e.update(le);
                            K.defines.VSM_SAMPLES !== ze.blurSamples && (K.defines.VSM_SAMPLES = ze.blurSamples, q.defines.VSM_SAMPLES = ze.blurSamples, K.needsUpdate = !0, q.needsUpdate = !0), ze.mapPass === null && (ze.mapPass = new os(a.x, a.y)), K.uniforms.shadow_pass.value = ze.map.texture, K.uniforms.resolution.value = ze.mapSize, K.uniforms.radius.value = ze.radius, d.setRenderTarget(ze.mapPass), d.clear(), d.renderBufferDirect(We, null, qe, K, le, null), q.uniforms.shadow_pass.value = ze.mapPass.texture, q.uniforms.resolution.value = ze.mapSize, q.uniforms.radius.value = ze.radius, d.setRenderTarget(ze.map), d.clear(), d.renderBufferDirect(We, null, qe, q, le, null)
                        }

                        function ye(ze, We, qe, Pe) {
                            let Te = null;
                            const Je = qe.isPointLight === !0 ? ze.customDistanceMaterial : ze.customDepthMaterial;
                            if (Je !== void 0) Te = Je; else if (Te = qe.isPointLight === !0 ? D : S, d.localClippingEnabled && We.clipShadows === !0 && Array.isArray(We.clippingPlanes) && We.clippingPlanes.length !== 0 || We.displacementMap && We.displacementScale !== 0 || We.alphaMap && We.alphaTest > 0 || We.map && We.alphaTest > 0) {
                                const ht = Te.uuid, lt = We.uuid;
                                let pt = P[ht];
                                pt === void 0 && (pt = {}, P[ht] = pt);
                                let Mt = pt[lt];
                                Mt === void 0 && (Mt = Te.clone(), pt[lt] = Mt, We.addEventListener("dispose", $e)), Te = Mt
                            }
                            if (Te.visible = We.visible, Te.wireframe = We.wireframe, Pe === I ? Te.side = We.shadowSide !== null ? We.shadowSide : We.side : Te.side = We.shadowSide !== null ? We.shadowSide : Q[We.side], Te.alphaMap = We.alphaMap, Te.alphaTest = We.alphaTest, Te.map = We.map, Te.clipShadows = We.clipShadows, Te.clippingPlanes = We.clippingPlanes, Te.clipIntersection = We.clipIntersection, Te.displacementMap = We.displacementMap, Te.displacementScale = We.displacementScale, Te.displacementBias = We.displacementBias, Te.wireframeLinewidth = We.wireframeLinewidth, Te.linewidth = We.linewidth, qe.isPointLight === !0 && Te.isMeshDistanceMaterial === !0) {
                                const ht = d.properties.get(Te);
                                ht.light = qe
                            }
                            return Te
                        }

                        function ge(ze, We, qe, Pe, Te) {
                            if (ze.visible === !1) return;
                            if (ze.layers.test(We.layers) && (ze.isMesh || ze.isLine || ze.isPoints) && (ze.castShadow || ze.receiveShadow && Te === I) && (!ze.frustumCulled || r.intersectsObject(ze))) {
                                ze.modelViewMatrix.multiplyMatrices(qe.matrixWorldInverse, ze.matrixWorld);
                                const lt = e.update(ze), pt = ze.material;
                                if (Array.isArray(pt)) {
                                    const Mt = lt.groups;
                                    for (let Ut = 0, mn = Mt.length; Ut < mn; Ut++) {
                                        const Tt = Mt[Ut], dn = pt[Tt.materialIndex];
                                        if (dn && dn.visible) {
                                            const fn = ye(ze, dn, Pe, Te);
                                            ze.onBeforeShadow(d, ze, We, qe, lt, fn, Tt), d.renderBufferDirect(qe, null, lt, fn, ze, Tt), ze.onAfterShadow(d, ze, We, qe, lt, fn, Tt)
                                        }
                                    }
                                } else if (pt.visible) {
                                    const Mt = ye(ze, pt, Pe, Te);
                                    ze.onBeforeShadow(d, ze, We, qe, lt, Mt, null), d.renderBufferDirect(qe, null, lt, Mt, ze, null), ze.onAfterShadow(d, ze, We, qe, lt, Mt, null)
                                }
                            }
                            const ht = ze.children;
                            for (let lt = 0, pt = ht.length; lt < pt; lt++) ge(ht[lt], We, qe, Pe, Te)
                        }

                        function $e(ze) {
                            ze.target.removeEventListener("dispose", $e);
                            for (const qe in P) {
                                const Pe = P[qe], Te = ze.target.uuid;
                                Te in Pe && (Pe[Te].dispose(), delete Pe[Te])
                            }
                        }
                    }

                    function l_(d) {
                        function e() {
                            let it = !1;
                            const nn = new ar;
                            let pn = null;
                            const ti = new ar(0, 0, 0, 0);
                            return {
                                setMask: function (On) {
                                    pn !== On && !it && (d.colorMask(On, On, On, On), pn = On)
                                }, setLocked: function (On) {
                                    it = On
                                }, setClear: function (On, zi, kn, In, Xi) {
                                    Xi === !0 && (On *= In, zi *= In, kn *= In), nn.set(On, zi, kn, In), ti.equals(nn) === !1 && (d.clearColor(On, zi, kn, In), ti.copy(nn))
                                }, reset: function () {
                                    it = !1, pn = null, ti.set(-1, 0, 0, 0)
                                }
                            }
                        }

                        function n() {
                            let it = !1, nn = null, pn = null, ti = null;
                            return {
                                setTest: function (On) {
                                    On ? Vr(d.DEPTH_TEST) : Jn(d.DEPTH_TEST)
                                }, setMask: function (On) {
                                    nn !== On && !it && (d.depthMask(On), nn = On)
                                }, setFunc: function (On) {
                                    if (pn !== On) {
                                        switch (On) {
                                            case oi:
                                                d.depthFunc(d.NEVER);
                                                break;
                                            case pi:
                                                d.depthFunc(d.ALWAYS);
                                                break;
                                            case hi:
                                                d.depthFunc(d.LESS);
                                                break;
                                            case Vn:
                                                d.depthFunc(d.LEQUAL);
                                                break;
                                            case yi:
                                                d.depthFunc(d.EQUAL);
                                                break;
                                            case nr:
                                                d.depthFunc(d.GEQUAL);
                                                break;
                                            case Oi:
                                                d.depthFunc(d.GREATER);
                                                break;
                                            case Rr:
                                                d.depthFunc(d.NOTEQUAL);
                                                break;
                                            default:
                                                d.depthFunc(d.LEQUAL)
                                        }
                                        pn = On
                                    }
                                }, setLocked: function (On) {
                                    it = On
                                }, setClear: function (On) {
                                    ti !== On && (d.clearDepth(On), ti = On)
                                }, reset: function () {
                                    it = !1, nn = null, pn = null, ti = null
                                }
                            }
                        }

                        function r() {
                            let it = !1, nn = null, pn = null, ti = null, On = null, zi = null, kn = null, In = null,
                                Xi = null;
                            return {
                                setTest: function (Ci) {
                                    it || (Ci ? Vr(d.STENCIL_TEST) : Jn(d.STENCIL_TEST))
                                }, setMask: function (Ci) {
                                    nn !== Ci && !it && (d.stencilMask(Ci), nn = Ci)
                                }, setFunc: function (Ci, so, Wl) {
                                    (pn !== Ci || ti !== so || On !== Wl) && (d.stencilFunc(Ci, so, Wl), pn = Ci, ti = so, On = Wl)
                                }, setOp: function (Ci, so, Wl) {
                                    (zi !== Ci || kn !== so || In !== Wl) && (d.stencilOp(Ci, so, Wl), zi = Ci, kn = so, In = Wl)
                                }, setLocked: function (Ci) {
                                    it = Ci
                                }, setClear: function (Ci) {
                                    Xi !== Ci && (d.clearStencil(Ci), Xi = Ci)
                                }, reset: function () {
                                    it = !1, nn = null, pn = null, ti = null, On = null, zi = null, kn = null, In = null, Xi = null
                                }
                            }
                        }

                        const a = new e, u = new n, y = new r, S = new WeakMap, D = new WeakMap;
                        let P = {}, z = {}, Q = new WeakMap, K = [], q = null, te = !1, le = null, ne = null, J = null,
                            Ce = null, ye = null, ge = null, $e = null, ze = new Bn(0, 0, 0), We = 0, qe = !1,
                            Pe = null, Te = null, Je = null, ht = null, lt = null;
                        const pt = d.getParameter(d.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                        let Mt = !1, Ut = 0;
                        const mn = d.getParameter(d.VERSION);
                        mn.indexOf("WebGL") !== -1 ? (Ut = parseFloat(/^WebGL (\d)/.exec(mn)[1]), Mt = Ut >= 1) : mn.indexOf("OpenGL ES") !== -1 && (Ut = parseFloat(/^OpenGL ES (\d)/.exec(mn)[1]), Mt = Ut >= 2);
                        let Tt = null, dn = {};
                        const fn = d.getParameter(d.SCISSOR_BOX), Kn = d.getParameter(d.VIEWPORT),
                            Qi = new ar().fromArray(fn), Tr = new ar().fromArray(Kn);

                        function Kr(it, nn, pn, ti) {
                            const On = new Uint8Array(4), zi = d.createTexture();
                            d.bindTexture(it, zi), d.texParameteri(it, d.TEXTURE_MIN_FILTER, d.NEAREST), d.texParameteri(it, d.TEXTURE_MAG_FILTER, d.NEAREST);
                            for (let kn = 0; kn < pn; kn++) it === d.TEXTURE_3D || it === d.TEXTURE_2D_ARRAY ? d.texImage3D(nn, 0, d.RGBA, 1, 1, ti, 0, d.RGBA, d.UNSIGNED_BYTE, On) : d.texImage2D(nn + kn, 0, d.RGBA, 1, 1, 0, d.RGBA, d.UNSIGNED_BYTE, On);
                            return zi
                        }

                        const Cr = {};
                        Cr[d.TEXTURE_2D] = Kr(d.TEXTURE_2D, d.TEXTURE_2D, 1), Cr[d.TEXTURE_CUBE_MAP] = Kr(d.TEXTURE_CUBE_MAP, d.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Cr[d.TEXTURE_2D_ARRAY] = Kr(d.TEXTURE_2D_ARRAY, d.TEXTURE_2D_ARRAY, 1, 1), Cr[d.TEXTURE_3D] = Kr(d.TEXTURE_3D, d.TEXTURE_3D, 1, 1), a.setClear(0, 0, 0, 1), u.setClear(1), y.setClear(0), Vr(d.DEPTH_TEST), u.setFunc(Vn), on(!1), tn(p), Vr(d.CULL_FACE), Ot(F);

                        function Vr(it) {
                            P[it] !== !0 && (d.enable(it), P[it] = !0)
                        }

                        function Jn(it) {
                            P[it] !== !1 && (d.disable(it), P[it] = !1)
                        }

                        function Ht(it, nn) {
                            return z[it] !== nn ? (d.bindFramebuffer(it, nn), z[it] = nn, it === d.DRAW_FRAMEBUFFER && (z[d.FRAMEBUFFER] = nn), it === d.FRAMEBUFFER && (z[d.DRAW_FRAMEBUFFER] = nn), !0) : !1
                        }

                        function vn(it, nn) {
                            let pn = K, ti = !1;
                            if (it) {
                                pn = Q.get(nn), pn === void 0 && (pn = [], Q.set(nn, pn));
                                const On = it.textures;
                                if (pn.length !== On.length || pn[0] !== d.COLOR_ATTACHMENT0) {
                                    for (let zi = 0, kn = On.length; zi < kn; zi++) pn[zi] = d.COLOR_ATTACHMENT0 + zi;
                                    pn.length = On.length, ti = !0
                                }
                            } else pn[0] !== d.BACK && (pn[0] = d.BACK, ti = !0);
                            ti && d.drawBuffers(pn)
                        }

                        function bn(it) {
                            return q !== it ? (d.useProgram(it), q = it, !0) : !1
                        }

                        const mt = {[se]: d.FUNC_ADD, [pe]: d.FUNC_SUBTRACT, [ue]: d.FUNC_REVERSE_SUBTRACT};
                        mt[he] = d.MIN, mt[Z] = d.MAX;
                        const Qt = {
                            [H]: d.ZERO,
                            [ae]: d.ONE,
                            [ee]: d.SRC_COLOR,
                            [Re]: d.SRC_ALPHA,
                            [Bt]: d.SRC_ALPHA_SATURATE,
                            [ot]: d.DST_COLOR,
                            [Ve]: d.DST_ALPHA,
                            [me]: d.ONE_MINUS_SRC_COLOR,
                            [ke]: d.ONE_MINUS_SRC_ALPHA,
                            [gt]: d.ONE_MINUS_DST_COLOR,
                            [He]: d.ONE_MINUS_DST_ALPHA,
                            [Rt]: d.CONSTANT_COLOR,
                            [an]: d.ONE_MINUS_CONSTANT_COLOR,
                            [En]: d.CONSTANT_ALPHA,
                            [Nn]: d.ONE_MINUS_CONSTANT_ALPHA
                        };

                        function Ot(it, nn, pn, ti, On, zi, kn, In, Xi, Ci) {
                            if (it === F) {
                                te === !0 && (Jn(d.BLEND), te = !1);
                                return
                            }
                            if (te === !1 && (Vr(d.BLEND), te = !0), it !== fe) {
                                if (it !== le || Ci !== qe) {
                                    if ((ne !== se || ye !== se) && (d.blendEquation(d.FUNC_ADD), ne = se, ye = se), Ci) switch (it) {
                                        case V:
                                            d.blendFuncSeparate(d.ONE, d.ONE_MINUS_SRC_ALPHA, d.ONE, d.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case U:
                                            d.blendFunc(d.ONE, d.ONE);
                                            break;
                                        case j:
                                            d.blendFuncSeparate(d.ZERO, d.ONE_MINUS_SRC_COLOR, d.ZERO, d.ONE);
                                            break;
                                        case Y:
                                            d.blendFuncSeparate(d.ZERO, d.SRC_COLOR, d.ZERO, d.SRC_ALPHA);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", it);
                                            break
                                    } else switch (it) {
                                        case V:
                                            d.blendFuncSeparate(d.SRC_ALPHA, d.ONE_MINUS_SRC_ALPHA, d.ONE, d.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case U:
                                            d.blendFunc(d.SRC_ALPHA, d.ONE);
                                            break;
                                        case j:
                                            d.blendFuncSeparate(d.ZERO, d.ONE_MINUS_SRC_COLOR, d.ZERO, d.ONE);
                                            break;
                                        case Y:
                                            d.blendFunc(d.ZERO, d.SRC_COLOR);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", it);
                                            break
                                    }
                                    J = null, Ce = null, ge = null, $e = null, ze.set(0, 0, 0), We = 0, le = it, qe = Ci
                                }
                                return
                            }
                            On = On || nn, zi = zi || pn, kn = kn || ti, (nn !== ne || On !== ye) && (d.blendEquationSeparate(mt[nn], mt[On]), ne = nn, ye = On), (pn !== J || ti !== Ce || zi !== ge || kn !== $e) && (d.blendFuncSeparate(Qt[pn], Qt[ti], Qt[zi], Qt[kn]), J = pn, Ce = ti, ge = zi, $e = kn), (In.equals(ze) === !1 || Xi !== We) && (d.blendColor(In.r, In.g, In.b, Xi), ze.copy(In), We = Xi), le = it, qe = !1
                        }

                        function ln(it, nn) {
                            it.side === N ? Jn(d.CULL_FACE) : Vr(d.CULL_FACE);
                            let pn = it.side === O;
                            nn && (pn = !pn), on(pn), it.blending === V && it.transparent === !1 ? Ot(F) : Ot(it.blending, it.blendEquation, it.blendSrc, it.blendDst, it.blendEquationAlpha, it.blendSrcAlpha, it.blendDstAlpha, it.blendColor, it.blendAlpha, it.premultipliedAlpha), u.setFunc(it.depthFunc), u.setTest(it.depthTest), u.setMask(it.depthWrite), a.setMask(it.colorWrite);
                            const ti = it.stencilWrite;
                            y.setTest(ti), ti && (y.setMask(it.stencilWriteMask), y.setFunc(it.stencilFunc, it.stencilRef, it.stencilFuncMask), y.setOp(it.stencilFail, it.stencilZFail, it.stencilZPass)), Fn(it.polygonOffset, it.polygonOffsetFactor, it.polygonOffsetUnits), it.alphaToCoverage === !0 ? Vr(d.SAMPLE_ALPHA_TO_COVERAGE) : Jn(d.SAMPLE_ALPHA_TO_COVERAGE)
                        }

                        function on(it) {
                            Pe !== it && (it ? d.frontFace(d.CW) : d.frontFace(d.CCW), Pe = it)
                        }

                        function tn(it) {
                            it !== E ? (Vr(d.CULL_FACE), it !== Te && (it === p ? d.cullFace(d.BACK) : it === C ? d.cullFace(d.FRONT) : d.cullFace(d.FRONT_AND_BACK))) : Jn(d.CULL_FACE), Te = it
                        }

                        function Tn(it) {
                            it !== Je && (Mt && d.lineWidth(it), Je = it)
                        }

                        function Fn(it, nn, pn) {
                            it ? (Vr(d.POLYGON_OFFSET_FILL), (ht !== nn || lt !== pn) && (d.polygonOffset(nn, pn), ht = nn, lt = pn)) : Jn(d.POLYGON_OFFSET_FILL)
                        }

                        function Bi(it) {
                            it ? Vr(d.SCISSOR_TEST) : Jn(d.SCISSOR_TEST)
                        }

                        function Di(it) {
                            it === void 0 && (it = d.TEXTURE0 + pt - 1), Tt !== it && (d.activeTexture(it), Tt = it)
                        }

                        function wr(it, nn, pn) {
                            pn === void 0 && (Tt === null ? pn = d.TEXTURE0 + pt - 1 : pn = Tt);
                            let ti = dn[pn];
                            ti === void 0 && (ti = {
                                type: void 0,
                                texture: void 0
                            }, dn[pn] = ti), (ti.type !== it || ti.texture !== nn) && (Tt !== pn && (d.activeTexture(pn), Tt = pn), d.bindTexture(it, nn || Cr[it]), ti.type = it, ti.texture = nn)
                        }

                        function ds() {
                            const it = dn[Tt];
                            it !== void 0 && it.type !== void 0 && (d.bindTexture(it.type, null), it.type = void 0, it.texture = void 0)
                        }

                        function Xr() {
                            try {
                                d.compressedTexImage2D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function Ye() {
                            try {
                                d.compressedTexImage3D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function Ie() {
                            try {
                                d.texSubImage2D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function It() {
                            try {
                                d.texSubImage3D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function Gt() {
                            try {
                                d.compressedTexSubImage2D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function Xt() {
                            try {
                                d.compressedTexSubImage3D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function Wt() {
                            try {
                                d.texStorage2D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function ei() {
                            try {
                                d.texStorage3D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function An() {
                            try {
                                d.texImage2D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function zn() {
                            try {
                                d.texImage3D.apply(d, arguments)
                            } catch (it) {
                                console.error("THREE.WebGLState:", it)
                            }
                        }

                        function Pr(it) {
                            Qi.equals(it) === !1 && (d.scissor(it.x, it.y, it.z, it.w), Qi.copy(it))
                        }

                        function Gn(it) {
                            Tr.equals(it) === !1 && (d.viewport(it.x, it.y, it.z, it.w), Tr.copy(it))
                        }

                        function ni(it, nn) {
                            let pn = D.get(nn);
                            pn === void 0 && (pn = new WeakMap, D.set(nn, pn));
                            let ti = pn.get(it);
                            ti === void 0 && (ti = d.getUniformBlockIndex(nn, it.name), pn.set(it, ti))
                        }

                        function Ui(it, nn) {
                            const ti = D.get(nn).get(it);
                            S.get(nn) !== ti && (d.uniformBlockBinding(nn, ti, it.__bindingPointIndex), S.set(nn, ti))
                        }

                        function vi() {
                            d.disable(d.BLEND), d.disable(d.CULL_FACE), d.disable(d.DEPTH_TEST), d.disable(d.POLYGON_OFFSET_FILL), d.disable(d.SCISSOR_TEST), d.disable(d.STENCIL_TEST), d.disable(d.SAMPLE_ALPHA_TO_COVERAGE), d.blendEquation(d.FUNC_ADD), d.blendFunc(d.ONE, d.ZERO), d.blendFuncSeparate(d.ONE, d.ZERO, d.ONE, d.ZERO), d.blendColor(0, 0, 0, 0), d.colorMask(!0, !0, !0, !0), d.clearColor(0, 0, 0, 0), d.depthMask(!0), d.depthFunc(d.LESS), d.clearDepth(1), d.stencilMask(4294967295), d.stencilFunc(d.ALWAYS, 0, 4294967295), d.stencilOp(d.KEEP, d.KEEP, d.KEEP), d.clearStencil(0), d.cullFace(d.BACK), d.frontFace(d.CCW), d.polygonOffset(0, 0), d.activeTexture(d.TEXTURE0), d.bindFramebuffer(d.FRAMEBUFFER, null), d.bindFramebuffer(d.DRAW_FRAMEBUFFER, null), d.bindFramebuffer(d.READ_FRAMEBUFFER, null), d.useProgram(null), d.lineWidth(1), d.scissor(0, 0, d.canvas.width, d.canvas.height), d.viewport(0, 0, d.canvas.width, d.canvas.height), P = {}, Tt = null, dn = {}, z = {}, Q = new WeakMap, K = [], q = null, te = !1, le = null, ne = null, J = null, Ce = null, ye = null, ge = null, $e = null, ze = new Bn(0, 0, 0), We = 0, qe = !1, Pe = null, Te = null, Je = null, ht = null, lt = null, Qi.set(0, 0, d.canvas.width, d.canvas.height), Tr.set(0, 0, d.canvas.width, d.canvas.height), a.reset(), u.reset(), y.reset()
                        }

                        return {
                            buffers: {color: a, depth: u, stencil: y},
                            enable: Vr,
                            disable: Jn,
                            bindFramebuffer: Ht,
                            drawBuffers: vn,
                            useProgram: bn,
                            setBlending: Ot,
                            setMaterial: ln,
                            setFlipSided: on,
                            setCullFace: tn,
                            setLineWidth: Tn,
                            setPolygonOffset: Fn,
                            setScissorTest: Bi,
                            activeTexture: Di,
                            bindTexture: wr,
                            unbindTexture: ds,
                            compressedTexImage2D: Xr,
                            compressedTexImage3D: Ye,
                            texImage2D: An,
                            texImage3D: zn,
                            updateUBOMapping: ni,
                            uniformBlockBinding: Ui,
                            texStorage2D: Wt,
                            texStorage3D: ei,
                            texSubImage2D: Ie,
                            texSubImage3D: It,
                            compressedTexSubImage2D: Gt,
                            compressedTexSubImage3D: Xt,
                            scissor: Pr,
                            viewport: Gn,
                            reset: vi
                        }
                    }

                    function c_(d, e, n, r, a, u, y) {
                        const S = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                            D = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
                            P = e.has("OCULUS_multiview") ? e.get("OCULUS_multiview") : null, z = new zt,
                            Q = new WeakMap;
                        let K;
                        const q = new WeakMap;
                        let te = [], le = !1, ne = !1;
                        try {
                            ne = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
                        } catch {
                        }

                        function J(Ye, Ie) {
                            return ne ? new OffscreenCanvas(Ye, Ie) : Sl("canvas")
                        }

                        function Ce(Ye, Ie, It) {
                            let Gt = 1;
                            const Xt = Xr(Ye);
                            if ((Xt.width > It || Xt.height > It) && (Gt = It / Math.max(Xt.width, Xt.height)), Gt < 1) if (typeof HTMLImageElement < "u" && Ye instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Ye instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Ye instanceof ImageBitmap || typeof VideoFrame < "u" && Ye instanceof VideoFrame) {
                                const Wt = Math.floor(Gt * Xt.width), ei = Math.floor(Gt * Xt.height);
                                K === void 0 && (K = J(Wt, ei));
                                const An = Ie ? J(Wt, ei) : K;
                                return An.width = Wt, An.height = ei, An.getContext("2d").drawImage(Ye, 0, 0, Wt, ei), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Xt.width + "x" + Xt.height + ") to (" + Wt + "x" + ei + ")."), An
                            } else return "data" in Ye && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Xt.width + "x" + Xt.height + ")."), Ye;
                            return Ye
                        }

                        function ye(Ye) {
                            return Ye.generateMipmaps && Ye.minFilter !== cn && Ye.minFilter !== qn
                        }

                        function ge(Ye) {
                            d.generateMipmap(Ye)
                        }

                        function $e(Ye, Ie, It, Gt, Xt = !1) {
                            if (Ye !== null) {
                                if (d[Ye] !== void 0) return d[Ye];
                                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Ye + "'")
                            }
                            let Wt = Ie;
                            if (Ie === d.RED && (It === d.FLOAT && (Wt = d.R32F), It === d.HALF_FLOAT && (Wt = d.R16F), It === d.UNSIGNED_BYTE && (Wt = d.R8)), Ie === d.RED_INTEGER && (It === d.UNSIGNED_BYTE && (Wt = d.R8UI), It === d.UNSIGNED_SHORT && (Wt = d.R16UI), It === d.UNSIGNED_INT && (Wt = d.R32UI), It === d.BYTE && (Wt = d.R8I), It === d.SHORT && (Wt = d.R16I), It === d.INT && (Wt = d.R32I)), Ie === d.RG && (It === d.FLOAT && (Wt = d.RG32F), It === d.HALF_FLOAT && (Wt = d.RG16F), It === d.UNSIGNED_BYTE && (Wt = d.RG8)), Ie === d.RG_INTEGER && (It === d.UNSIGNED_BYTE && (Wt = d.RG8UI), It === d.UNSIGNED_SHORT && (Wt = d.RG16UI), It === d.UNSIGNED_INT && (Wt = d.RG32UI), It === d.BYTE && (Wt = d.RG8I), It === d.SHORT && (Wt = d.RG16I), It === d.INT && (Wt = d.RG32I)), Ie === d.RGB && It === d.UNSIGNED_INT_5_9_9_9_REV && (Wt = d.RGB9_E5), Ie === d.RGBA) {
                                const ei = Xt ? _l : ur.getTransfer(Gt);
                                It === d.FLOAT && (Wt = d.RGBA32F), It === d.HALF_FLOAT && (Wt = d.RGBA16F), It === d.UNSIGNED_BYTE && (Wt = ei === mr ? d.SRGB8_ALPHA8 : d.RGBA8), It === d.UNSIGNED_SHORT_4_4_4_4 && (Wt = d.RGBA4), It === d.UNSIGNED_SHORT_5_5_5_1 && (Wt = d.RGB5_A1)
                            }
                            return (Wt === d.R16F || Wt === d.R32F || Wt === d.RG16F || Wt === d.RG32F || Wt === d.RGBA16F || Wt === d.RGBA32F) && e.get("EXT_color_buffer_float"), Wt
                        }

                        function ze(Ye, Ie) {
                            return ye(Ye) === !0 || Ye.isFramebufferTexture && Ye.minFilter !== cn && Ye.minFilter !== qn ? Math.log2(Math.max(Ie.width, Ie.height)) + 1 : Ye.mipmaps !== void 0 && Ye.mipmaps.length > 0 ? Ye.mipmaps.length : Ye.isCompressedTexture && Array.isArray(Ye.image) ? Ie.mipmaps.length : 1
                        }

                        function We(Ye) {
                            const Ie = Ye.target;
                            Ie.removeEventListener("dispose", We), Pe(Ie), Ie.isVideoTexture && Q.delete(Ie)
                        }

                        function qe(Ye) {
                            const Ie = Ye.target;
                            Ie.removeEventListener("dispose", qe), Je(Ie)
                        }

                        function Pe(Ye) {
                            const Ie = r.get(Ye);
                            if (Ie.__webglInit === void 0) return;
                            const It = Ye.source, Gt = q.get(It);
                            if (Gt) {
                                const Xt = Gt[Ie.__cacheKey];
                                Xt.usedTimes--, Xt.usedTimes === 0 && Te(Ye), Object.keys(Gt).length === 0 && q.delete(It)
                            }
                            r.remove(Ye)
                        }

                        function Te(Ye) {
                            const Ie = r.get(Ye);
                            d.deleteTexture(Ie.__webglTexture);
                            const It = Ye.source, Gt = q.get(It);
                            delete Gt[Ie.__cacheKey], y.memory.textures--
                        }

                        function Je(Ye) {
                            const Ie = r.get(Ye);
                            if (Ye.depthTexture && Ye.depthTexture.dispose(), Ye.isWebGLCubeRenderTarget) for (let Gt = 0; Gt < 6; Gt++) {
                                if (Array.isArray(Ie.__webglFramebuffer[Gt])) for (let Xt = 0; Xt < Ie.__webglFramebuffer[Gt].length; Xt++) d.deleteFramebuffer(Ie.__webglFramebuffer[Gt][Xt]); else d.deleteFramebuffer(Ie.__webglFramebuffer[Gt]);
                                Ie.__webglDepthbuffer && d.deleteRenderbuffer(Ie.__webglDepthbuffer[Gt])
                            } else {
                                if (Array.isArray(Ie.__webglFramebuffer)) for (let Gt = 0; Gt < Ie.__webglFramebuffer.length; Gt++) d.deleteFramebuffer(Ie.__webglFramebuffer[Gt]); else d.deleteFramebuffer(Ie.__webglFramebuffer);
                                if (Ie.__webglDepthbuffer && d.deleteRenderbuffer(Ie.__webglDepthbuffer), Ie.__webglMultisampledFramebuffer && d.deleteFramebuffer(Ie.__webglMultisampledFramebuffer), Ie.__webglColorRenderbuffer) for (let Gt = 0; Gt < Ie.__webglColorRenderbuffer.length; Gt++) Ie.__webglColorRenderbuffer[Gt] && d.deleteRenderbuffer(Ie.__webglColorRenderbuffer[Gt]);
                                Ie.__webglDepthRenderbuffer && d.deleteRenderbuffer(Ie.__webglDepthRenderbuffer)
                            }
                            const It = Ye.textures;
                            for (let Gt = 0, Xt = It.length; Gt < Xt; Gt++) {
                                const Wt = r.get(It[Gt]);
                                Wt.__webglTexture && (d.deleteTexture(Wt.__webglTexture), y.memory.textures--), r.remove(It[Gt])
                            }
                            r.remove(Ye)
                        }

                        let ht = 0;

                        function lt() {
                            ht = 0
                        }

                        function pt() {
                            const Ye = ht;
                            return Ye >= a.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + Ye + " texture units while this GPU supports only " + a.maxTextures), ht += 1, Ye
                        }

                        function Mt(Ye) {
                            const Ie = [];
                            return Ie.push(Ye.wrapS), Ie.push(Ye.wrapT), Ie.push(Ye.wrapR || 0), Ie.push(Ye.magFilter), Ie.push(Ye.minFilter), Ie.push(Ye.anisotropy), Ie.push(Ye.internalFormat), Ie.push(Ye.format), Ie.push(Ye.type), Ie.push(Ye.generateMipmaps), Ie.push(Ye.premultiplyAlpha), Ie.push(Ye.flipY), Ie.push(Ye.unpackAlignment), Ie.push(Ye.colorSpace), Ie.join()
                        }

                        function Ut(Ye, Ie) {
                            const It = r.get(Ye);
                            if (Ye.isVideoTexture && wr(Ye), Ye.isRenderTargetTexture === !1 && Ye.version > 0 && It.__version !== Ye.version) {
                                const Gt = Ye.image;
                                if (Gt === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (Gt.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else if (Jn(It, Ye, Ie)) return
                            }
                            n.bindTexture(d.TEXTURE_2D, It.__webglTexture, d.TEXTURE0 + Ie)
                        }

                        function mn(Ye, Ie) {
                            const It = r.get(Ye);
                            if (Ye.version > 0 && It.__version !== Ye.version) {
                                Jn(It, Ye, Ie);
                                return
                            }
                            n.bindTexture(d.TEXTURE_2D_ARRAY, It.__webglTexture, d.TEXTURE0 + Ie)
                        }

                        function Tt(Ye, Ie) {
                            const It = r.get(Ye);
                            if (Ye.version > 0 && It.__version !== Ye.version) {
                                Jn(It, Ye, Ie);
                                return
                            }
                            n.bindTexture(d.TEXTURE_3D, It.__webglTexture, d.TEXTURE0 + Ie)
                        }

                        function dn(Ye, Ie) {
                            const It = r.get(Ye);
                            if (Ye.version > 0 && It.__version !== Ye.version) {
                                Ht(It, Ye, Ie);
                                return
                            }
                            n.bindTexture(d.TEXTURE_CUBE_MAP, It.__webglTexture, d.TEXTURE0 + Ie)
                        }

                        const fn = {[je]: d.REPEAT, [tt]: d.CLAMP_TO_EDGE, [Yt]: d.MIRRORED_REPEAT}, Kn = {
                            [cn]: d.NEAREST,
                            [$t]: d.NEAREST_MIPMAP_NEAREST,
                            [Sn]: d.NEAREST_MIPMAP_LINEAR,
                            [qn]: d.LINEAR,
                            [fr]: d.LINEAR_MIPMAP_NEAREST,
                            [Zi]: d.LINEAR_MIPMAP_LINEAR
                        }, Qi = {
                            [zh]: d.NEVER,
                            [Wh]: d.ALWAYS,
                            [Gh]: d.LESS,
                            [jc]: d.LEQUAL,
                            [Vh]: d.EQUAL,
                            [jh]: d.GEQUAL,
                            [Hh]: d.GREATER,
                            [Qh]: d.NOTEQUAL
                        };

                        function Tr(Ye, Ie) {
                            if (Ie.type === kr && e.has("OES_texture_float_linear") === !1 && (Ie.magFilter === qn || Ie.magFilter === fr || Ie.magFilter === Sn || Ie.magFilter === Zi || Ie.minFilter === qn || Ie.minFilter === fr || Ie.minFilter === Sn || Ie.minFilter === Zi) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), d.texParameteri(Ye, d.TEXTURE_WRAP_S, fn[Ie.wrapS]), d.texParameteri(Ye, d.TEXTURE_WRAP_T, fn[Ie.wrapT]), (Ye === d.TEXTURE_3D || Ye === d.TEXTURE_2D_ARRAY) && d.texParameteri(Ye, d.TEXTURE_WRAP_R, fn[Ie.wrapR]), d.texParameteri(Ye, d.TEXTURE_MAG_FILTER, Kn[Ie.magFilter]), d.texParameteri(Ye, d.TEXTURE_MIN_FILTER, Kn[Ie.minFilter]), Ie.compareFunction && (d.texParameteri(Ye, d.TEXTURE_COMPARE_MODE, d.COMPARE_REF_TO_TEXTURE), d.texParameteri(Ye, d.TEXTURE_COMPARE_FUNC, Qi[Ie.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
                                if (Ie.magFilter === cn || Ie.minFilter !== Sn && Ie.minFilter !== Zi || Ie.type === kr && e.has("OES_texture_float_linear") === !1) return;
                                if (Ie.anisotropy > 1 || r.get(Ie).__currentAnisotropy) {
                                    const It = e.get("EXT_texture_filter_anisotropic");
                                    d.texParameterf(Ye, It.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(Ie.anisotropy, a.getMaxAnisotropy())), r.get(Ie).__currentAnisotropy = Ie.anisotropy
                                }
                            }
                        }

                        function Kr(Ye, Ie) {
                            let It = !1;
                            Ye.__webglInit === void 0 && (Ye.__webglInit = !0, Ie.addEventListener("dispose", We));
                            const Gt = Ie.source;
                            let Xt = q.get(Gt);
                            Xt === void 0 && (Xt = {}, q.set(Gt, Xt));
                            const Wt = Mt(Ie);
                            if (Wt !== Ye.__cacheKey) {
                                Xt[Wt] === void 0 && (Xt[Wt] = {
                                    texture: d.createTexture(),
                                    usedTimes: 0
                                }, y.memory.textures++, It = !0), Xt[Wt].usedTimes++;
                                const ei = Xt[Ye.__cacheKey];
                                ei !== void 0 && (Xt[Ye.__cacheKey].usedTimes--, ei.usedTimes === 0 && Te(Ie)), Ye.__cacheKey = Wt, Ye.__webglTexture = Xt[Wt].texture
                            }
                            return It
                        }

                        function Cr(Ye) {
                            le = Ye
                        }

                        function Vr() {
                            const Ye = le;
                            le = !1;
                            for (const Ie of te) Jn(Ie.textureProperties, Ie.texture, Ie.slot), Ie.texture.isPendingDeferredUpload = !1;
                            te = [], le = Ye
                        }

                        function Jn(Ye, Ie, It) {
                            if (le) return Ie.isPendingDeferredUpload || (Ie.isPendingDeferredUpload = !0, te.push({
                                textureProperties: Ye,
                                texture: Ie,
                                slot: It
                            })), !1;
                            let Gt = d.TEXTURE_2D;
                            (Ie.isDataArrayTexture || Ie.isCompressedArrayTexture) && (Gt = d.TEXTURE_2D_ARRAY), Ie.isData3DTexture && (Gt = d.TEXTURE_3D);
                            const Xt = Kr(Ye, Ie), Wt = Ie.source;
                            n.bindTexture(Gt, Ye.__webglTexture, d.TEXTURE0 + It);
                            const ei = r.get(Wt);
                            if (Wt.version !== ei.__version || Xt === !0) {
                                n.activeTexture(d.TEXTURE0 + It);
                                const An = ur.getPrimaries(ur.workingColorSpace),
                                    zn = Ie.colorSpace === Ms ? null : ur.getPrimaries(Ie.colorSpace),
                                    Pr = Ie.colorSpace === Ms || An === zn ? d.NONE : d.BROWSER_DEFAULT_WEBGL;
                                d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, Ie.flipY), d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ie.premultiplyAlpha), d.pixelStorei(d.UNPACK_ALIGNMENT, Ie.unpackAlignment), d.pixelStorei(d.UNPACK_COLORSPACE_CONVERSION_WEBGL, Pr);
                                let Gn = Ce(Ie.image, !1, a.maxTextureSize);
                                Gn = ds(Ie, Gn);
                                const ni = u.convert(Ie.format, Ie.colorSpace), Ui = u.convert(Ie.type);
                                let vi = $e(Ie.internalFormat, ni, Ui, Ie.colorSpace, Ie.isVideoTexture);
                                Tr(Gt, Ie);
                                let it;
                                const nn = Ie.mipmaps, pn = Ie.isVideoTexture !== !0,
                                    ti = ei.__version === void 0 || Xt === !0, On = Wt.dataReady, zi = ze(Ie, Gn);
                                if (Ie.isDepthTexture) vi = d.DEPTH_COMPONENT16, Ie.type === kr ? vi = d.DEPTH_COMPONENT32F : Ie.type === bs ? vi = d.DEPTH_COMPONENT24 : Ie.type === xo && (vi = d.DEPTH24_STENCIL8), ti && (pn ? n.texStorage2D(d.TEXTURE_2D, 1, vi, Gn.width, Gn.height) : n.texImage2D(d.TEXTURE_2D, 0, vi, Gn.width, Gn.height, 0, ni, Ui, null)); else if (Ie.isDataTexture) if (nn.length > 0) {
                                    pn && ti && n.texStorage2D(d.TEXTURE_2D, zi, vi, nn[0].width, nn[0].height);
                                    for (let kn = 0, In = nn.length; kn < In; kn++) it = nn[kn], pn ? On && n.texSubImage2D(d.TEXTURE_2D, kn, 0, 0, it.width, it.height, ni, Ui, it.data) : n.texImage2D(d.TEXTURE_2D, kn, vi, it.width, it.height, 0, ni, Ui, it.data);
                                    Ie.generateMipmaps = !1
                                } else pn ? (ti && n.texStorage2D(d.TEXTURE_2D, zi, vi, Gn.width, Gn.height), On && n.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, Gn.width, Gn.height, ni, Ui, Gn.data)) : n.texImage2D(d.TEXTURE_2D, 0, vi, Gn.width, Gn.height, 0, ni, Ui, Gn.data); else if (Ie.isCompressedTexture) if (Ie.isCompressedArrayTexture) {
                                    pn && ti && n.texStorage3D(d.TEXTURE_2D_ARRAY, zi, vi, nn[0].width, nn[0].height, Gn.depth);
                                    for (let kn = 0, In = nn.length; kn < In; kn++) it = nn[kn], Ie.format !== Ke ? ni !== null ? pn ? On && n.compressedTexSubImage3D(d.TEXTURE_2D_ARRAY, kn, 0, 0, 0, it.width, it.height, Gn.depth, ni, it.data, 0, 0) : n.compressedTexImage3D(d.TEXTURE_2D_ARRAY, kn, vi, it.width, it.height, Gn.depth, 0, it.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : pn ? On && n.texSubImage3D(d.TEXTURE_2D_ARRAY, kn, 0, 0, 0, it.width, it.height, Gn.depth, ni, Ui, it.data) : n.texImage3D(d.TEXTURE_2D_ARRAY, kn, vi, it.width, it.height, Gn.depth, 0, ni, Ui, it.data)
                                } else {
                                    pn && ti && n.texStorage2D(d.TEXTURE_2D, zi, vi, nn[0].width, nn[0].height);
                                    for (let kn = 0, In = nn.length; kn < In; kn++) it = nn[kn], Ie.format !== Ke ? ni !== null ? pn ? On && n.compressedTexSubImage2D(d.TEXTURE_2D, kn, 0, 0, it.width, it.height, ni, it.data) : n.compressedTexImage2D(d.TEXTURE_2D, kn, vi, it.width, it.height, 0, it.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : pn ? On && n.texSubImage2D(d.TEXTURE_2D, kn, 0, 0, it.width, it.height, ni, Ui, it.data) : n.texImage2D(d.TEXTURE_2D, kn, vi, it.width, it.height, 0, ni, Ui, it.data)
                                } else if (Ie.isDataArrayTexture) pn ? (ti && n.texStorage3D(d.TEXTURE_2D_ARRAY, zi, vi, Gn.width, Gn.height, Gn.depth), On && n.texSubImage3D(d.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Gn.width, Gn.height, Gn.depth, ni, Ui, Gn.data)) : n.texImage3D(d.TEXTURE_2D_ARRAY, 0, vi, Gn.width, Gn.height, Gn.depth, 0, ni, Ui, Gn.data); else if (Ie.isData3DTexture) pn ? (ti && n.texStorage3D(d.TEXTURE_3D, zi, vi, Gn.width, Gn.height, Gn.depth), On && n.texSubImage3D(d.TEXTURE_3D, 0, 0, 0, 0, Gn.width, Gn.height, Gn.depth, ni, Ui, Gn.data)) : n.texImage3D(d.TEXTURE_3D, 0, vi, Gn.width, Gn.height, Gn.depth, 0, ni, Ui, Gn.data); else if (Ie.isFramebufferTexture) {
                                    if (ti) if (pn) n.texStorage2D(d.TEXTURE_2D, zi, vi, Gn.width, Gn.height); else {
                                        let kn = Gn.width, In = Gn.height;
                                        for (let Xi = 0; Xi < zi; Xi++) n.texImage2D(d.TEXTURE_2D, Xi, vi, kn, In, 0, ni, Ui, null), kn >>= 1, In >>= 1
                                    }
                                } else if (nn.length > 0) {
                                    if (pn && ti) {
                                        const kn = Xr(nn[0]);
                                        n.texStorage2D(d.TEXTURE_2D, zi, vi, kn.width, kn.height)
                                    }
                                    for (let kn = 0, In = nn.length; kn < In; kn++) it = nn[kn], pn ? On && n.texSubImage2D(d.TEXTURE_2D, kn, 0, 0, ni, Ui, it) : n.texImage2D(d.TEXTURE_2D, kn, vi, ni, Ui, it);
                                    Ie.generateMipmaps = !1
                                } else if (pn) {
                                    if (ti) {
                                        const kn = Xr(Gn);
                                        n.texStorage2D(d.TEXTURE_2D, zi, vi, kn.width, kn.height)
                                    }
                                    On && n.texSubImage2D(d.TEXTURE_2D, 0, 0, 0, ni, Ui, Gn)
                                } else n.texImage2D(d.TEXTURE_2D, 0, vi, ni, Ui, Gn);
                                ye(Ie) && ge(Gt), ei.__version = Wt.version, Ie.onUpdate && Ie.onUpdate(Ie)
                            }
                            return Ye.__version = Ie.version, !0
                        }

                        function Ht(Ye, Ie, It) {
                            if (Ie.image.length !== 6) return;
                            const Gt = Kr(Ye, Ie), Xt = Ie.source;
                            n.bindTexture(d.TEXTURE_CUBE_MAP, Ye.__webglTexture, d.TEXTURE0 + It);
                            const Wt = r.get(Xt);
                            if (Xt.version !== Wt.__version || Gt === !0) {
                                n.activeTexture(d.TEXTURE0 + It);
                                const ei = ur.getPrimaries(ur.workingColorSpace),
                                    An = Ie.colorSpace === Ms ? null : ur.getPrimaries(Ie.colorSpace),
                                    zn = Ie.colorSpace === Ms || ei === An ? d.NONE : d.BROWSER_DEFAULT_WEBGL;
                                d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, Ie.flipY), d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ie.premultiplyAlpha), d.pixelStorei(d.UNPACK_ALIGNMENT, Ie.unpackAlignment), d.pixelStorei(d.UNPACK_COLORSPACE_CONVERSION_WEBGL, zn);
                                const Pr = Ie.isCompressedTexture || Ie.image[0].isCompressedTexture,
                                    Gn = Ie.image[0] && Ie.image[0].isDataTexture, ni = [];
                                for (let In = 0; In < 6; In++) !Pr && !Gn ? ni[In] = Ce(Ie.image[In], !0, a.maxCubemapSize) : ni[In] = Gn ? Ie.image[In].image : Ie.image[In], ni[In] = ds(Ie, ni[In]);
                                const Ui = ni[0], vi = u.convert(Ie.format, Ie.colorSpace), it = u.convert(Ie.type),
                                    nn = $e(Ie.internalFormat, vi, it, Ie.colorSpace), pn = Ie.isVideoTexture !== !0,
                                    ti = Wt.__version === void 0 || Gt === !0, On = Xt.dataReady;
                                let zi = ze(Ie, Ui);
                                Tr(d.TEXTURE_CUBE_MAP, Ie);
                                let kn;
                                if (Pr) {
                                    pn && ti && n.texStorage2D(d.TEXTURE_CUBE_MAP, zi, nn, Ui.width, Ui.height);
                                    for (let In = 0; In < 6; In++) {
                                        kn = ni[In].mipmaps;
                                        for (let Xi = 0; Xi < kn.length; Xi++) {
                                            const Ci = kn[Xi];
                                            Ie.format !== Ke ? vi !== null ? pn ? On && n.compressedTexSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, Xi, 0, 0, Ci.width, Ci.height, vi, Ci.data) : n.compressedTexImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, Xi, nn, Ci.width, Ci.height, 0, Ci.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : pn ? On && n.texSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, Xi, 0, 0, Ci.width, Ci.height, vi, it, Ci.data) : n.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, Xi, nn, Ci.width, Ci.height, 0, vi, it, Ci.data)
                                        }
                                    }
                                } else {
                                    if (kn = Ie.mipmaps, pn && ti) {
                                        kn.length > 0 && zi++;
                                        const In = Xr(ni[0]);
                                        n.texStorage2D(d.TEXTURE_CUBE_MAP, zi, nn, In.width, In.height)
                                    }
                                    for (let In = 0; In < 6; In++) if (Gn) {
                                        pn ? On && n.texSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, 0, 0, 0, ni[In].width, ni[In].height, vi, it, ni[In].data) : n.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, 0, nn, ni[In].width, ni[In].height, 0, vi, it, ni[In].data);
                                        for (let Xi = 0; Xi < kn.length; Xi++) {
                                            const so = kn[Xi].image[In].image;
                                            pn ? On && n.texSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, Xi + 1, 0, 0, so.width, so.height, vi, it, so.data) : n.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, Xi + 1, nn, so.width, so.height, 0, vi, it, so.data)
                                        }
                                    } else {
                                        pn ? On && n.texSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, 0, 0, 0, vi, it, ni[In]) : n.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, 0, nn, vi, it, ni[In]);
                                        for (let Xi = 0; Xi < kn.length; Xi++) {
                                            const Ci = kn[Xi];
                                            pn ? On && n.texSubImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, Xi + 1, 0, 0, vi, it, Ci.image[In]) : n.texImage2D(d.TEXTURE_CUBE_MAP_POSITIVE_X + In, Xi + 1, nn, vi, it, Ci.image[In])
                                        }
                                    }
                                }
                                ye(Ie) && ge(d.TEXTURE_CUBE_MAP), Wt.__version = Xt.version, Ie.onUpdate && Ie.onUpdate(Ie)
                            }
                            Ye.__version = Ie.version
                        }

                        function vn(Ye, Ie, It, Gt, Xt, Wt) {
                            const ei = u.convert(It.format, It.colorSpace), An = u.convert(It.type),
                                zn = $e(It.internalFormat, ei, An, It.colorSpace);
                            if (!r.get(Ie).__hasExternalTextures) {
                                const ni = Math.max(1, Ie.width >> Wt), Ui = Math.max(1, Ie.height >> Wt);
                                Ie.isWebGLMultiviewRenderTarget === !0 ? n.texStorage3D(d.TEXTURE_2D_ARRAY, 0, zn, Ie.width, Ie.height, Ie.numViews) : Xt === d.TEXTURE_3D || Xt === d.TEXTURE_2D_ARRAY ? n.texImage3D(Xt, Wt, zn, ni, Ui, Ie.depth, 0, ei, An, null) : n.texImage2D(Xt, Wt, zn, ni, Ui, 0, ei, An, null)
                            }
                            n.bindFramebuffer(d.FRAMEBUFFER, Ye);
                            const Gn = Di(Ie);
                            Ie.isWebGLMultiviewRenderTarget === !0 ? Gn ? P.framebufferTextureMultisampleMultiviewOVR(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, r.get(It).__webglTexture, 0, Bi(Ie), 0, Ie.numViews) : P.framebufferTextureMultiviewOVR(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, r.get(It).__webglTexture, 0, 0, Ie.numViews) : (Xt === d.TEXTURE_2D || Xt >= d.TEXTURE_CUBE_MAP_POSITIVE_X && Xt <= d.TEXTURE_CUBE_MAP_NEGATIVE_Z) && (Gn ? S.framebufferTexture2DMultisampleEXT(d.FRAMEBUFFER, Gt, Xt, r.get(It).__webglTexture, 0, Bi(Ie)) : d.framebufferTexture2D(d.FRAMEBUFFER, Gt, Xt, r.get(It).__webglTexture, Wt)), n.bindFramebuffer(d.FRAMEBUFFER, null)
                        }

                        function bn(Ye, Ie, It) {
                            if (d.bindRenderbuffer(d.RENDERBUFFER, Ye), Ie.isWebGLMultiviewRenderTarget === !0) {
                                const Gt = Di(Ie), Xt = Ie.numViews, Wt = Ie.depthTexture;
                                let ei = d.DEPTH_COMPONENT24, An = d.DEPTH_ATTACHMENT;
                                Wt && Wt.isDepthTexture && (Wt.type === kr ? ei = d.DEPTH_COMPONENT32F : Wt.type === xo && (ei = d.DEPTH24_STENCIL8, An = d.DEPTH_STENCIL_ATTACHMENT));
                                let zn = r.get(Ie.depthTexture).__webglTexture;
                                zn === void 0 && (zn = d.createTexture(), d.bindTexture(d.TEXTURE_2D_ARRAY, zn), d.texStorage3D(d.TEXTURE_2D_ARRAY, 1, ei, Ie.width, Ie.height, Xt)), Gt ? P.framebufferTextureMultisampleMultiviewOVR(d.FRAMEBUFFER, An, zn, 0, Bi(Ie), 0, Xt) : P.framebufferTextureMultiviewOVR(d.FRAMEBUFFER, An, zn, 0, 0, Xt)
                            } else if (Ie.depthBuffer && !Ie.stencilBuffer) {
                                let Gt = d.DEPTH_COMPONENT24;
                                if (It || Di(Ie)) {
                                    const Xt = Ie.depthTexture;
                                    Xt && Xt.isDepthTexture && (Xt.type === kr ? Gt = d.DEPTH_COMPONENT32F : Xt.type === bs && (Gt = d.DEPTH_COMPONENT24));
                                    const Wt = Bi(Ie);
                                    Di(Ie) ? S.renderbufferStorageMultisampleEXT(d.RENDERBUFFER, Wt, Gt, Ie.width, Ie.height) : d.renderbufferStorageMultisample(d.RENDERBUFFER, Wt, Gt, Ie.width, Ie.height)
                                } else d.renderbufferStorage(d.RENDERBUFFER, Gt, Ie.width, Ie.height);
                                d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.RENDERBUFFER, Ye)
                            } else if (Ie.depthBuffer && Ie.stencilBuffer) {
                                const Gt = Bi(Ie);
                                It && Di(Ie) === !1 ? d.renderbufferStorageMultisample(d.RENDERBUFFER, Gt, d.DEPTH24_STENCIL8, Ie.width, Ie.height) : Di(Ie) ? S.renderbufferStorageMultisampleEXT(d.RENDERBUFFER, Gt, d.DEPTH24_STENCIL8, Ie.width, Ie.height) : d.renderbufferStorage(d.RENDERBUFFER, d.DEPTH_STENCIL, Ie.width, Ie.height), d.framebufferRenderbuffer(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, d.RENDERBUFFER, Ye)
                            } else {
                                const Gt = Ie.textures;
                                for (let Xt = 0; Xt < Gt.length; Xt++) {
                                    const Wt = Gt[Xt], ei = u.convert(Wt.format, Wt.colorSpace),
                                        An = u.convert(Wt.type), zn = $e(Wt.internalFormat, ei, An, Wt.colorSpace),
                                        Pr = Bi(Ie);
                                    It && Di(Ie) === !1 ? d.renderbufferStorageMultisample(d.RENDERBUFFER, Pr, zn, Ie.width, Ie.height) : Di(Ie) ? S.renderbufferStorageMultisampleEXT(d.RENDERBUFFER, Pr, zn, Ie.width, Ie.height) : d.renderbufferStorage(d.RENDERBUFFER, zn, Ie.width, Ie.height)
                                }
                            }
                            d.bindRenderbuffer(d.RENDERBUFFER, null)
                        }

                        function mt(Ye, Ie) {
                            if (Ie && Ie.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(d.FRAMEBUFFER, Ye), !(Ie.depthTexture && Ie.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            (!r.get(Ie.depthTexture).__webglTexture || Ie.depthTexture.image.width !== Ie.width || Ie.depthTexture.image.height !== Ie.height) && (Ie.depthTexture.image.width = Ie.width, Ie.depthTexture.image.height = Ie.height, Ie.depthTexture.needsUpdate = !0), Ut(Ie.depthTexture, 0), Ie.depthTexture.image.depth != 1 ? mn(Ie.depthTexture, 0) : Ut(Ie.depthTexture, 0);
                            const Gt = r.get(Ie.depthTexture).__webglTexture, Xt = Bi(Ie);
                            if (Ie.isWebGLMultiviewRenderTarget === !0) {
                                const Wt = Di(Ie), ei = Ie.numViews;
                                if (Ie.depthTexture.format === dt) Wt ? P.framebufferTextureMultisampleMultiviewOVR(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, Gt, 0, Xt, 0, ei) : P.framebufferTextureMultiviewOVR(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, Gt, 0, 0, ei); else if (Ie.depthTexture.format === Lt) Wt ? P.framebufferTextureMultisampleMultiviewOVR(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, Gt, 0, Xt, 0, ei) : P.framebufferTextureMultiviewOVR(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, Gt, 0, 0, ei); else throw new Error("Unknown depthTexture format")
                            } else if (Ie.depthTexture.format === dt) Di(Ie) ? S.framebufferTexture2DMultisampleEXT(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.TEXTURE_2D, Gt, 0, Xt) : d.framebufferTexture2D(d.FRAMEBUFFER, d.DEPTH_ATTACHMENT, d.TEXTURE_2D, Gt, 0); else if (Ie.depthTexture.format === Lt) Di(Ie) ? S.framebufferTexture2DMultisampleEXT(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, d.TEXTURE_2D, Gt, 0, Xt) : d.framebufferTexture2D(d.FRAMEBUFFER, d.DEPTH_STENCIL_ATTACHMENT, d.TEXTURE_2D, Gt, 0); else throw new Error("Unknown depthTexture format")
                        }

                        function Qt(Ye) {
                            const Ie = r.get(Ye), It = Ye.isWebGLCubeRenderTarget === !0;
                            if (Ye.depthTexture && !Ie.__autoAllocateDepthBuffer) {
                                if (It) throw new Error("target.depthTexture not supported in Cube render targets");
                                mt(Ie.__webglFramebuffer, Ye)
                            } else if (It) {
                                Ie.__webglDepthbuffer = [];
                                for (let Gt = 0; Gt < 6; Gt++) n.bindFramebuffer(d.FRAMEBUFFER, Ie.__webglFramebuffer[Gt]), Ie.__webglDepthbuffer[Gt] = d.createRenderbuffer(), bn(Ie.__webglDepthbuffer[Gt], Ye, !1)
                            } else n.bindFramebuffer(d.FRAMEBUFFER, Ie.__webglFramebuffer), Ie.__webglDepthbuffer = d.createRenderbuffer(), bn(Ie.__webglDepthbuffer, Ye, !1);
                            n.bindFramebuffer(d.FRAMEBUFFER, null)
                        }

                        function Ot(Ye, Ie, It) {
                            const Gt = r.get(Ye);
                            Ie !== void 0 && vn(Gt.__webglFramebuffer, Ye, Ye.texture, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, 0), It !== void 0 && Qt(Ye)
                        }

                        function ln(Ye) {
                            const Ie = Ye.texture, It = r.get(Ye), Gt = r.get(Ie);
                            Ye.addEventListener("dispose", qe);
                            const Xt = Ye.textures, Wt = Ye.isWebGLCubeRenderTarget === !0, ei = Xt.length > 1;
                            if (ei || (Gt.__webglTexture === void 0 && (Gt.__webglTexture = d.createTexture()), Gt.__version = Ie.version, y.memory.textures++), Wt) {
                                It.__webglFramebuffer = [];
                                for (let An = 0; An < 6; An++) if (Ie.mipmaps && Ie.mipmaps.length > 0) {
                                    It.__webglFramebuffer[An] = [];
                                    for (let zn = 0; zn < Ie.mipmaps.length; zn++) It.__webglFramebuffer[An][zn] = d.createFramebuffer()
                                } else It.__webglFramebuffer[An] = d.createFramebuffer()
                            } else {
                                if (Ie.mipmaps && Ie.mipmaps.length > 0) {
                                    It.__webglFramebuffer = [];
                                    for (let An = 0; An < Ie.mipmaps.length; An++) It.__webglFramebuffer[An] = d.createFramebuffer()
                                } else It.__webglFramebuffer = d.createFramebuffer();
                                if (ei) for (let An = 0, zn = Xt.length; An < zn; An++) {
                                    const Pr = r.get(Xt[An]);
                                    Pr.__webglTexture === void 0 && (Pr.__webglTexture = d.createTexture(), y.memory.textures++)
                                }
                                if (Ye.samples > 0 && Di(Ye) === !1) {
                                    It.__webglMultisampledFramebuffer = d.createFramebuffer(), It.__webglColorRenderbuffer = [], n.bindFramebuffer(d.FRAMEBUFFER, It.__webglMultisampledFramebuffer);
                                    for (let An = 0; An < Xt.length; An++) {
                                        const zn = Xt[An];
                                        It.__webglColorRenderbuffer[An] = d.createRenderbuffer(), d.bindRenderbuffer(d.RENDERBUFFER, It.__webglColorRenderbuffer[An]);
                                        const Pr = u.convert(zn.format, zn.colorSpace), Gn = u.convert(zn.type),
                                            ni = $e(zn.internalFormat, Pr, Gn, zn.colorSpace, Ye.isXRRenderTarget === !0),
                                            Ui = Bi(Ye);
                                        d.renderbufferStorageMultisample(d.RENDERBUFFER, Ui, ni, Ye.width, Ye.height), d.framebufferRenderbuffer(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0 + An, d.RENDERBUFFER, It.__webglColorRenderbuffer[An])
                                    }
                                    d.bindRenderbuffer(d.RENDERBUFFER, null), Ye.depthBuffer && (It.__webglDepthRenderbuffer = d.createRenderbuffer(), bn(It.__webglDepthRenderbuffer, Ye, !0)), n.bindFramebuffer(d.FRAMEBUFFER, null)
                                }
                            }
                            if (Wt) {
                                n.bindTexture(d.TEXTURE_CUBE_MAP, Gt.__webglTexture), Tr(d.TEXTURE_CUBE_MAP, Ie);
                                for (let An = 0; An < 6; An++) if (Ie.mipmaps && Ie.mipmaps.length > 0) for (let zn = 0; zn < Ie.mipmaps.length; zn++) vn(It.__webglFramebuffer[An][zn], Ye, Ie, d.COLOR_ATTACHMENT0, d.TEXTURE_CUBE_MAP_POSITIVE_X + An, zn); else vn(It.__webglFramebuffer[An], Ye, Ie, d.COLOR_ATTACHMENT0, d.TEXTURE_CUBE_MAP_POSITIVE_X + An, 0);
                                ye(Ie) && ge(d.TEXTURE_CUBE_MAP), n.unbindTexture()
                            } else if (ei) {
                                for (let An = 0, zn = Xt.length; An < zn; An++) {
                                    const Pr = Xt[An], Gn = r.get(Pr);
                                    n.bindTexture(d.TEXTURE_2D, Gn.__webglTexture), Tr(d.TEXTURE_2D, Pr), vn(It.__webglFramebuffer, Ye, Pr, d.COLOR_ATTACHMENT0 + An, d.TEXTURE_2D, 0), ye(Pr) && ge(d.TEXTURE_2D)
                                }
                                n.unbindTexture()
                            } else {
                                let An = d.TEXTURE_2D;
                                if ((Ye.isWebGL3DRenderTarget || Ye.isWebGLArrayRenderTarget) && (An = Ye.isWebGL3DRenderTarget ? d.TEXTURE_3D : d.TEXTURE_2D_ARRAY), Ye.isWebGLMultiviewRenderTarget === !0 && (An = d.TEXTURE_2D_ARRAY), n.bindTexture(An, Gt.__webglTexture), Tr(An, Ie), Ie.mipmaps && Ie.mipmaps.length > 0) for (let zn = 0; zn < Ie.mipmaps.length; zn++) vn(It.__webglFramebuffer[zn], Ye, Ie, d.COLOR_ATTACHMENT0, An, zn); else vn(It.__webglFramebuffer, Ye, Ie, d.COLOR_ATTACHMENT0, An, 0);
                                ye(Ie) && ge(An), n.unbindTexture()
                            }
                            (Ye.depthBuffer || Ye.isWebGLMultiviewRenderTarget === !0) && this.setupDepthRenderbuffer(Ye)
                        }

                        function on(Ye) {
                            const Ie = Ye.textures;
                            for (let It = 0, Gt = Ie.length; It < Gt; It++) {
                                const Xt = Ie[It];
                                if (ye(Xt)) {
                                    const Wt = Ye.isWebGLCubeRenderTarget ? d.TEXTURE_CUBE_MAP : d.TEXTURE_2D,
                                        ei = r.get(Xt).__webglTexture;
                                    n.bindTexture(Wt, ei), ge(Wt), n.unbindTexture()
                                }
                            }
                        }

                        const tn = [], Tn = [];

                        function Fn(Ye) {
                            if (Ye.samples > 0) {
                                if (Di(Ye) === !1) {
                                    const Ie = Ye.textures, It = Ye.width, Gt = Ye.height;
                                    let Xt = d.COLOR_BUFFER_BIT;
                                    const Wt = Ye.stencilBuffer ? d.DEPTH_STENCIL_ATTACHMENT : d.DEPTH_ATTACHMENT,
                                        ei = r.get(Ye), An = Ie.length > 1;
                                    if (An) for (let zn = 0; zn < Ie.length; zn++) n.bindFramebuffer(d.FRAMEBUFFER, ei.__webglMultisampledFramebuffer), d.framebufferRenderbuffer(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0 + zn, d.RENDERBUFFER, null), n.bindFramebuffer(d.FRAMEBUFFER, ei.__webglFramebuffer), d.framebufferTexture2D(d.DRAW_FRAMEBUFFER, d.COLOR_ATTACHMENT0 + zn, d.TEXTURE_2D, null, 0);
                                    n.bindFramebuffer(d.READ_FRAMEBUFFER, ei.__webglMultisampledFramebuffer), n.bindFramebuffer(d.DRAW_FRAMEBUFFER, ei.__webglFramebuffer);
                                    for (let zn = 0; zn < Ie.length; zn++) {
                                        if (Ye.resolveDepthBuffer && (Ye.depthBuffer && (Xt |= d.DEPTH_BUFFER_BIT), Ye.stencilBuffer && Ye.resolveStencilBuffer && (Xt |= d.STENCIL_BUFFER_BIT)), An) {
                                            d.framebufferRenderbuffer(d.READ_FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.RENDERBUFFER, ei.__webglColorRenderbuffer[zn]);
                                            const Pr = r.get(Ie[zn]).__webglTexture;
                                            d.framebufferTexture2D(d.DRAW_FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, Pr, 0)
                                        }
                                        d.blitFramebuffer(0, 0, It, Gt, 0, 0, It, Gt, Xt, d.NEAREST), D === !0 && (tn.length = 0, Tn.length = 0, tn.push(d.COLOR_ATTACHMENT0 + zn), Ye.depthBuffer && Ye.resolveDepthBuffer === !1 && (tn.push(Wt), Tn.push(Wt), d.invalidateFramebuffer(d.DRAW_FRAMEBUFFER, Tn)), d.invalidateFramebuffer(d.READ_FRAMEBUFFER, tn))
                                    }
                                    if (n.bindFramebuffer(d.READ_FRAMEBUFFER, null), n.bindFramebuffer(d.DRAW_FRAMEBUFFER, null), An) for (let zn = 0; zn < Ie.length; zn++) {
                                        n.bindFramebuffer(d.FRAMEBUFFER, ei.__webglMultisampledFramebuffer), d.framebufferRenderbuffer(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0 + zn, d.RENDERBUFFER, ei.__webglColorRenderbuffer[zn]);
                                        const Pr = r.get(Ie[zn]).__webglTexture;
                                        n.bindFramebuffer(d.FRAMEBUFFER, ei.__webglFramebuffer), d.framebufferTexture2D(d.DRAW_FRAMEBUFFER, d.COLOR_ATTACHMENT0 + zn, d.TEXTURE_2D, Pr, 0)
                                    }
                                    n.bindFramebuffer(d.DRAW_FRAMEBUFFER, ei.__webglMultisampledFramebuffer)
                                } else if (Ye.depthBuffer && Ye.resolveDepthBuffer === !1 && D) {
                                    const Ie = Ye.stencilBuffer ? d.DEPTH_STENCIL_ATTACHMENT : d.DEPTH_ATTACHMENT;
                                    d.invalidateFramebuffer(d.DRAW_FRAMEBUFFER, [Ie])
                                }
                            }
                        }

                        function Bi(Ye) {
                            return Math.min(a.maxSamples, Ye.samples)
                        }

                        function Di(Ye) {
                            const Ie = r.get(Ye);
                            return Ye.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && Ie.__useRenderToTexture !== !1
                        }

                        function wr(Ye) {
                            const Ie = y.render.frame;
                            Q.get(Ye) !== Ie && (Q.set(Ye, Ie), Ye.update())
                        }

                        function ds(Ye, Ie) {
                            const It = Ye.colorSpace, Gt = Ye.format, Xt = Ye.type;
                            return Ye.isCompressedTexture === !0 || Ye.isVideoTexture === !0 || It !== Gs && It !== Ms && (ur.getTransfer(It) === mr ? (Gt !== Ke || Xt !== pr) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", It)), Ie
                        }

                        function Xr(Ye) {
                            return typeof HTMLImageElement < "u" && Ye instanceof HTMLImageElement ? (z.width = Ye.naturalWidth || Ye.width, z.height = Ye.naturalHeight || Ye.height) : typeof VideoFrame < "u" && Ye instanceof VideoFrame ? (z.width = Ye.displayWidth, z.height = Ye.displayHeight) : (z.width = Ye.width, z.height = Ye.height), z
                        }

                        this.allocateTextureUnit = pt, this.resetTextureUnits = lt, this.setTexture2D = Ut, this.setTexture2DArray = mn, this.setTexture3D = Tt, this.setTextureCube = dn, this.rebindTextures = Ot, this.uploadTexture = Jn, this.setupRenderTarget = ln, this.updateRenderTargetMipmap = on, this.updateMultisampleRenderTarget = Fn, this.setupDepthTexture = mt, this.setupDepthRenderbuffer = Qt, this.setupFrameBufferTexture = vn, this.useMultisampledRTT = Di, this.runDeferredUploads = Vr, this.setDeferTextureUploads = Cr
                    }

                    function $1(d, e) {
                        function n(r, a = Ms) {
                            let u;
                            const y = ur.getTransfer(a);
                            if (r === pr) return d.UNSIGNED_BYTE;
                            if (r === Qr) return d.UNSIGNED_SHORT_4_4_4_4;
                            if (r === ua) return d.UNSIGNED_SHORT_5_5_5_1;
                            if (r === Ea) return d.UNSIGNED_INT_5_9_9_9_REV;
                            if (r === $s) return d.BYTE;
                            if (r === Or) return d.SHORT;
                            if (r === ws) return d.UNSIGNED_SHORT;
                            if (r === Eo) return d.INT;
                            if (r === bs) return d.UNSIGNED_INT;
                            if (r === kr) return d.FLOAT;
                            if (r === Hi) return d.HALF_FLOAT;
                            if (r === Qo) return d.ALPHA;
                            if (r === De) return d.RGB;
                            if (r === Ke) return d.RGBA;
                            if (r === rt) return d.LUMINANCE;
                            if (r === Ct) return d.LUMINANCE_ALPHA;
                            if (r === dt) return d.DEPTH_COMPONENT;
                            if (r === Lt) return d.DEPTH_STENCIL;
                            if (r === Kt) return d.RED;
                            if (r === Rn) return d.RED_INTEGER;
                            if (r === xn) return d.RG;
                            if (r === Dt) return d.RG_INTEGER;
                            if (r === Hn) return d.RGBA_INTEGER;
                            if (r === jn || r === Wn || r === Wi || r === li) if (y === mr) if (u = e.get("WEBGL_compressed_texture_s3tc_srgb"), u !== null) {
                                if (r === jn) return u.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (r === Wn) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (r === Wi) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (r === li) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else return null; else if (u = e.get("WEBGL_compressed_texture_s3tc"), u !== null) {
                                if (r === jn) return u.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (r === Wn) return u.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (r === Wi) return u.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (r === li) return u.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            } else return null;
                            if (r === mi || r === ki || r === yr || r === Ur) if (u = e.get("WEBGL_compressed_texture_pvrtc"), u !== null) {
                                if (r === mi) return u.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (r === ki) return u.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (r === yr) return u.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (r === Ur) return u.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            } else return null;
                            if (r === Cn || r === Ai || r === _r) if (u = e.get("WEBGL_compressed_texture_etc"), u !== null) {
                                if (r === Cn || r === Ai) return y === mr ? u.COMPRESSED_SRGB8_ETC2 : u.COMPRESSED_RGB8_ETC2;
                                if (r === _r) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : u.COMPRESSED_RGBA8_ETC2_EAC
                            } else return null;
                            if (r === ri || r === $ || r === re || r === Ae || r === xe || r === Oe || r === Ze || r === at || r === wt || r === kt || r === et || r === _t || r === ce || r === de) if (u = e.get("WEBGL_compressed_texture_astc"), u !== null) {
                                if (r === ri) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : u.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (r === $) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : u.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (r === re) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : u.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (r === Ae) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : u.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (r === xe) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : u.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (r === Oe) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : u.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (r === Ze) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : u.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (r === at) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : u.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (r === wt) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : u.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (r === kt) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : u.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (r === et) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : u.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (r === _t) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : u.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (r === ce) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : u.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (r === de) return y === mr ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : u.COMPRESSED_RGBA_ASTC_12x12_KHR
                            } else return null;
                            if (r === we || r === Ee || r === Me) if (u = e.get("EXT_texture_compression_bptc"), u !== null) {
                                if (r === we) return y === mr ? u.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : u.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                if (r === Ee) return u.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                if (r === Me) return u.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                            } else return null;
                            if (r === st || r === ut || r === Vt || r === Ft) if (u = e.get("EXT_texture_compression_rgtc"), u !== null) {
                                if (r === we) return u.COMPRESSED_RED_RGTC1_EXT;
                                if (r === ut) return u.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                if (r === Vt) return u.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                if (r === Ft) return u.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                            } else return null;
                            return r === xo ? d.UNSIGNED_INT_24_8 : d[r] !== void 0 ? d[r] : null
                        }

                        return {convert: n}
                    }

                    class mh extends or {
                        constructor() {
                            super(), this.isGroup = !0, this.type = "Group"
                        }
                    }

                    class pv extends ns {
                        constructor(e = []) {
                            super(), this.isArrayCamera = !0, this.cameras = e
                        }
                    }

                    var eE = new Ne, tE = new Ne;

                    function u_(d, e, n) {
                        eE.setFromMatrixPosition(e.matrixWorld), tE.setFromMatrixPosition(n.matrixWorld);
                        var r = eE.distanceTo(tE), a = e.projectionMatrix.elements, u = n.projectionMatrix.elements,
                            y = a[14] / (a[10] - 1), S = a[14] / (a[10] + 1), D = (a[9] + 1) / a[5],
                            P = (a[9] - 1) / a[5], z = (a[8] - 1) / a[0], Q = (u[8] + 1) / u[0], K = y * z, q = y * Q,
                            te = r / (-z + Q), le = te * -z;
                        e.matrixWorld.decompose(d.position, d.quaternion, d.scale), d.translateX(le), d.translateZ(te), d.matrixWorld.compose(d.position, d.quaternion, d.scale), d.matrixWorldInverse.copy(d.matrixWorld).invert();
                        var ne = y + te, J = S + te, Ce = K - le, ye = q + (r - le), ge = D * S / J * ne,
                            $e = P * S / J * ne;
                        d.projectionMatrix.makePerspective(Ce, ye, ge, $e, ne, J)
                    }

                    function nE(d) {
                        var e, n, r = this, a = null, u = null, y = null, S = [], D = new Mn, P = new Mn, z = 1,
                            Q = "local-floor";
                        typeof window < "u" && "VRFrameData" in window && (u = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", ge, !1));
                        var K = new Mn, q = new $i, te = new Ne, le = new ns;
                        le.viewport = new ar, le.layers.enable(1);
                        var ne = new ns;
                        ne.viewport = new ar, ne.layers.enable(2);
                        var J = new pv([le, ne]);
                        J.layers.enable(1), J.layers.enable(2);
                        var Ce = new zt, ye;

                        function ge() {
                            var Je = r.isPresenting = a !== null && a.isPresenting === !0;
                            if (Je) {
                                var ht = a.getEyeParameters("left");
                                e = 2 * ht.renderWidth * z, n = ht.renderHeight * z, ye = d.getPixelRatio(), d.getSize(Ce), d.setDrawingBufferSize(e, n, 1), le.viewport.set(0, 0, e / 2, n), ne.viewport.set(e / 2, 0, e / 2, n), Te.start(), r.dispatchEvent({type: "sessionstart"})
                            } else r.enabled && d.setDrawingBufferSize(Ce.width, Ce.height, ye), Te.stop(), r.dispatchEvent({type: "sessionend"})
                        }

                        var $e = [], ze = [];

                        function We(Je) {
                            for (var ht = navigator.getGamepads && navigator.getGamepads(), lt = 0, pt = ht.length; lt < pt; lt++) {
                                var Mt = ht[lt];
                                if (Mt && (Mt.id === "Daydream Controller" || Mt.id === "Gear VR Controller" || Mt.id === "Oculus Go Controller" || Mt.id === "OpenVR Gamepad" || Mt.id.startsWith("Oculus Touch") || Mt.id.startsWith("HTC Vive Focus") || Mt.id.startsWith("Spatial Controller"))) {
                                    var Ut = Mt.hand;
                                    if (Je === 0 && (Ut === "" || Ut === "right") || Je === 1 && Ut === "left") return Mt
                                }
                            }
                        }

                        function qe() {
                            for (var Je = 0; Je < S.length; Je++) {
                                var ht = S[Je], lt = We(Je);
                                if (lt !== void 0 && lt.pose !== void 0) {
                                    if (lt.pose === null) return;
                                    var pt = lt.pose;
                                    pt.hasPosition === !1 && ht.position.set(.2, -.6, -.05), pt.position !== null && ht.position.fromArray(pt.position), pt.orientation !== null && ht.quaternion.fromArray(pt.orientation), ht.matrix.compose(ht.position, ht.quaternion, ht.scale), ht.matrix.premultiply(D), ht.matrix.decompose(ht.position, ht.quaternion, ht.scale), ht.matrixWorldNeedsUpdate = !0, ht.visible = !0;
                                    var Mt = lt.id === "Daydream Controller" ? 0 : 1;
                                    $e[Je] === void 0 && ($e[Je] = !1), $e[Je] !== lt.buttons[Mt].pressed && ($e[Je] = lt.buttons[Mt].pressed, $e[Je] === !0 ? ht.dispatchEvent({type: "selectstart"}) : (ht.dispatchEvent({type: "selectend"}), ht.dispatchEvent({type: "select"}))), Mt = 2, ze[Je] === void 0 && (ze[Je] = !1), lt.buttons[Mt] !== void 0 && ze[Je] !== lt.buttons[Mt].pressed && (ze[Je] = lt.buttons[Mt].pressed, ze[Je] === !0 ? ht.dispatchEvent({type: "squeezestart"}) : (ht.dispatchEvent({type: "squeezeend"}), ht.dispatchEvent({type: "squeeze"})))
                                } else ht.visible = !1
                            }
                        }

                        function Pe(Je, ht) {
                            ht !== null && ht.length === 4 && Je.set(ht[0] * e, ht[1] * n, ht[2] * e, ht[3] * n)
                        }

                        this.enabled = !1, this.getController = function (Je) {
                            var ht = S[Je];
                            return ht === void 0 && (ht = new mh, ht.matrixAutoUpdate = !1, ht.visible = !1, S[Je] = ht), ht
                        }, this.getDevice = function () {
                            return a
                        }, this.setDevice = function (Je) {
                            Je !== void 0 && (a = Je), Te.setContext(Je)
                        }, this.setFramebufferScaleFactor = function (Je) {
                            z = Je
                        }, this.setReferenceSpaceType = function (Je) {
                            Q = Je
                        }, this.setPoseTarget = function (Je) {
                            Je !== void 0 && (y = Je)
                        }, this.cameraAutoUpdate = !0, this.updateCamera = function (Je) {
                            var ht = Q === "local-floor" ? 1.6 : 0;
                            if (a.depthNear = Je.near, a.depthFar = Je.far, a.getFrameData(u), Q === "local-floor") {
                                var lt = a.stageParameters;
                                lt ? D.fromArray(lt.sittingToStandingTransform) : D.makeTranslation(0, ht, 0)
                            }
                            var pt = u.pose, Mt = y !== null ? y : Je;
                            Mt.matrix.copy(D), Mt.matrix.decompose(Mt.position, Mt.quaternion, Mt.scale), pt.orientation !== null && (q.fromArray(pt.orientation), Mt.quaternion.multiply(q)), pt.position !== null && (q.setFromRotationMatrix(D), te.fromArray(pt.position), te.applyQuaternion(q), Mt.position.add(te)), Mt.updateMatrixWorld();
                            for (var Ut = Mt.children, mn = 0, Tt = Ut.length; mn < Tt; mn++) Ut[mn].updateMatrixWorld(!0);
                            le.near = Je.near, ne.near = Je.near, le.far = Je.far, ne.far = Je.far, le.matrixWorldInverse.fromArray(u.leftViewMatrix), ne.matrixWorldInverse.fromArray(u.rightViewMatrix), P.copy(D).invert(), Q === "local-floor" && (le.matrixWorldInverse.multiply(P), ne.matrixWorldInverse.multiply(P));
                            var dn = Mt.parent;
                            dn !== null && (K.copy(dn.matrixWorld).invert(), le.matrixWorldInverse.multiply(K), ne.matrixWorldInverse.multiply(K)), le.matrixWorld.copy(le.matrixWorldInverse).invert(), ne.matrixWorld.copy(ne.matrixWorldInverse).invert(), le.projectionMatrix.fromArray(u.leftProjectionMatrix), ne.projectionMatrix.fromArray(u.rightProjectionMatrix), u_(J, le, ne);
                            var fn = a.getLayers();
                            if (fn.length) {
                                var Kn = fn[0];
                                Pe(le.viewport, Kn.leftBounds), Pe(ne.viewport, Kn.rightBounds)
                            }
                            return qe(), J
                        }, this.getCamera = function () {
                            return J
                        }, this.getFoveation = function () {
                            return 1
                        }, this.setFoveation = function (Je) {
                            Je !== 1 && console.warn("THREE.WebVRManager: setFoveation() not used in WebVR.")
                        }, this.getEnvironmentBlendMode = function () {
                            if (r.isPresenting) return "opaque"
                        }, this.getStandingMatrix = function () {
                            return D
                        }, this.isPresenting = !1;
                        var Te = new hd;
                        this.setAnimationLoop = function (Je) {
                            Te.setAnimationLoop(Je), this.isPresenting && Te.start()
                        }, this.submitFrame = function () {
                            this.isPresenting && a.submitFrame()
                        }, this.dispose = function () {
                            typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", ge)
                        }, this.setFrameOfReferenceType = function () {
                            console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
                        }
                    }

                    Object.assign(nE.prototype, {
                        addEventListener: Ss.prototype.addEventListener,
                        hasEventListener: Ss.prototype.hasEventListener,
                        removeEventListener: Ss.prototype.removeEventListener,
                        dispatchEvent: Ss.prototype.dispatchEvent
                    });

                    class iE extends os {
                        constructor(e, n, r, a = {}) {
                            super(e, n, a), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = r
                        }

                        copy(e) {
                            return super.copy(e), this.numViews = e.numViews, this
                        }
                    }

                    iE.prototype.isWebGLMultiviewRenderTarget = !0;
                    const h_ = {type: "move"};

                    class mv {
                        constructor() {
                            this._targetRay = null, this._grip = null, this._hand = null
                        }

                        getHandSpace() {
                            return this._hand === null && (this._hand = new mh, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {pinching: !1}), this._hand
                        }

                        getTargetRaySpace() {
                            return this._targetRay === null && (this._targetRay = new mh, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Ne, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Ne), this._targetRay
                        }

                        getGripSpace() {
                            return this._grip === null && (this._grip = new mh, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Ne, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Ne), this._grip
                        }

                        dispatchEvent(e) {
                            return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
                        }

                        connect(e) {
                            if (e && e.hand) {
                                const n = this._hand;
                                if (n) for (const r of e.hand.values()) this._getHandJoint(n, r)
                            }
                            return this.dispatchEvent({type: "connected", data: e}), this
                        }

                        disconnect(e) {
                            return this.dispatchEvent({
                                type: "disconnected",
                                data: e
                            }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
                        }

                        update(e, n, r) {
                            let a = null, u = null, y = null;
                            const S = this._targetRay, D = this._grip, P = this._hand;
                            if (e && n.session.visibilityState !== "visible-blurred") {
                                if (P && e.hand) {
                                    y = !0;
                                    for (const le of e.hand.values()) {
                                        const ne = n.getJointPose(le, r), J = this._getHandJoint(P, le);
                                        ne !== null && (J.matrix.fromArray(ne.transform.matrix), J.matrix.decompose(J.position, J.rotation, J.scale), J.matrixWorldNeedsUpdate = !0, J.jointRadius = ne.radius), J.visible = ne !== null
                                    }
                                    const z = P.joints["index-finger-tip"], Q = P.joints["thumb-tip"],
                                        K = z.position.distanceTo(Q.position), q = .02, te = .005;
                                    P.inputState.pinching && K > q + te ? (P.inputState.pinching = !1, this.dispatchEvent({
                                        type: "pinchend",
                                        handedness: e.handedness,
                                        target: this
                                    })) : !P.inputState.pinching && K <= q - te && (P.inputState.pinching = !0, this.dispatchEvent({
                                        type: "pinchstart",
                                        handedness: e.handedness,
                                        target: this
                                    }))
                                } else D !== null && e.gripSpace && (u = n.getPose(e.gripSpace, r), u !== null && (D.matrix.fromArray(u.transform.matrix), D.matrix.decompose(D.position, D.rotation, D.scale), D.matrixWorldNeedsUpdate = !0, u.linearVelocity ? (D.hasLinearVelocity = !0, D.linearVelocity.copy(u.linearVelocity)) : D.hasLinearVelocity = !1, u.angularVelocity ? (D.hasAngularVelocity = !0, D.angularVelocity.copy(u.angularVelocity)) : D.hasAngularVelocity = !1));
                                S !== null && (a = n.getPose(e.targetRaySpace, r), a === null && u !== null && (a = u), a !== null && (S.matrix.fromArray(a.transform.matrix), S.matrix.decompose(S.position, S.rotation, S.scale), S.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (S.hasLinearVelocity = !0, S.linearVelocity.copy(a.linearVelocity)) : S.hasLinearVelocity = !1, a.angularVelocity ? (S.hasAngularVelocity = !0, S.angularVelocity.copy(a.angularVelocity)) : S.hasAngularVelocity = !1, this.dispatchEvent(h_)))
                            }
                            return S !== null && (S.visible = a !== null), D !== null && (D.visible = u !== null), P !== null && (P.visible = y !== null), this
                        }

                        _getHandJoint(e, n) {
                            if (e.joints[n.jointName] === void 0) {
                                const r = new mh;
                                r.matrixAutoUpdate = !1, r.visible = !1, e.joints[n.jointName] = r, e.add(r)
                            }
                            return e.joints[n.jointName]
                        }
                    }

                    const d_ = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, f_ = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;

                    class p_ {
                        constructor() {
                            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
                        }

                        init(e, n, r) {
                            if (this.texture === null) {
                                const a = new Lr, u = e.properties.get(a);
                                u.__webglTexture = n.texture, (n.depthNear != r.depthNear || n.depthFar != r.depthFar) && (this.depthNear = n.depthNear, this.depthFar = n.depthFar), this.texture = a
                            }
                        }

                        render(e, n) {
                            if (this.texture !== null) {
                                if (this.mesh === null) {
                                    const r = n.cameras[0].viewport, a = new ta({
                                        vertexShader: d_,
                                        fragmentShader: f_,
                                        uniforms: {
                                            depthColor: {value: this.texture},
                                            depthWidth: {value: r.z},
                                            depthHeight: {value: r.w}
                                        }
                                    });
                                    this.mesh = new Wr(new xc(20, 20), a)
                                }
                                e.render(this.mesh, n)
                            }
                        }

                        reset() {
                            this.texture = null, this.mesh = null
                        }
                    }

                    class m_ extends Ss {
                        constructor(e, n, r, a) {
                            super();
                            const u = this;
                            let y = null, S = 1;
                            var D = null;
                            let P = null, z = "local-floor", Q = 1, K = null, q = null;
                            var te = [];
                            let le = null, ne = null, J = null, Ce = null;
                            const ye = new p_, ge = n.getContextAttributes();
                            let $e = null, ze = null;
                            const We = [], qe = [], Pe = new zt;
                            let Te = null;
                            const Je = new ns;
                            Je.layers.enable(1), Je.viewport = new ar;
                            const ht = new ns;
                            ht.layers.enable(2), ht.viewport = new ar;
                            const lt = [Je, ht], pt = new pv;
                            pt.layers.enable(1), pt.layers.enable(2);
                            let Mt = null, Ut = null;
                            this.cameraAutoUpdate = !0, this.layersEnabled = !1, this.enabled = !1, this.isPresenting = !1, this.isMultiview = !1, this.getCameraPose = function () {
                                return q
                            }, this.getController = function (Ht) {
                                let vn = We[Ht];
                                return vn === void 0 && (vn = new mv, We[Ht] = vn), vn.getTargetRaySpace()
                            }, this.getControllerGrip = function (Ht) {
                                let vn = We[Ht];
                                return vn === void 0 && (vn = new mv, We[Ht] = vn), vn.getGripSpace()
                            }, this.getHand = function (Ht) {
                                let vn = We[Ht];
                                return vn === void 0 && (vn = new mv, We[Ht] = vn), vn.getHandSpace()
                            };

                            function mn(Ht) {
                                const vn = qe.indexOf(Ht.inputSource);
                                if (vn === -1) return;
                                const bn = We[vn];
                                bn !== void 0 && (bn.update(Ht.inputSource, Ht.frame, K || P), bn.dispatchEvent({
                                    type: Ht.type,
                                    data: Ht.inputSource
                                }))
                            }

                            function Tt() {
                                y.removeEventListener("select", mn), y.removeEventListener("selectstart", mn), y.removeEventListener("selectend", mn), y.removeEventListener("squeeze", mn), y.removeEventListener("squeezestart", mn), y.removeEventListener("squeezeend", mn), y.removeEventListener("end", Tt), y.removeEventListener("inputsourceschange", dn);
                                for (let Ht = 0; Ht < We.length; Ht++) {
                                    const vn = qe[Ht];
                                    vn !== null && (qe[Ht] = null, We[Ht].disconnect(vn))
                                }
                                Mt = null, Ut = null, ye.reset(), e.setRenderTarget($e), J = null, ne = null, le = null, y = null, ze = null, Jn.stop(), u.isPresenting = !1, e.setPixelRatio(Te), e.setSize(Pe.width, Pe.height, !1), u.dispatchEvent({type: "sessionend"})
                            }

                            this.setFramebufferScaleFactor = function (Ht) {
                                S = Ht, u.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                            }, this.setReferenceSpaceType = function (Ht) {
                                z = Ht, u.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                            }, this.getReferenceSpace = function () {
                                return K || P
                            }, this.setReferenceSpace = function (Ht) {
                                K = Ht
                            }, this.getBaseLayer = function () {
                                return ne !== null ? ne : J
                            }, this.getBinding = function () {
                                return le
                            }, this.getFrame = function () {
                                return Ce
                            }, this.getSession = function () {
                                return y
                            }, this.setSession = async function (Ht) {
                                if (y = Ht, y !== null) {
                                    if ($e = e.getRenderTarget(), y.addEventListener("select", mn), y.addEventListener("selectstart", mn), y.addEventListener("selectend", mn), y.addEventListener("squeeze", mn), y.addEventListener("squeezestart", mn), y.addEventListener("squeezeend", mn), y.addEventListener("end", Tt), y.addEventListener("inputsourceschange", dn), ge.xrCompatible !== !0 && await n.makeXRCompatible(), Te = e.getPixelRatio(), e.getSize(Pe), y.renderState.layers === void 0) {
                                        const vn = {
                                            antialias: ge.antialias,
                                            alpha: !0,
                                            depth: ge.depth,
                                            stencil: ge.stencil,
                                            framebufferScaleFactor: S
                                        };
                                        J = new XRWebGLLayer(y, n, vn), y.updateRenderState({baseLayer: J}), e.setPixelRatio(1), e.setSize(J.framebufferWidth, J.framebufferHeight, !1), ze = new os(J.framebufferWidth, J.framebufferHeight, {
                                            format: Ke,
                                            type: pr,
                                            colorSpace: e.outputColorSpace,
                                            stencilBuffer: ge.stencil
                                        })
                                    } else {
                                        let vn = null, bn = null, mt = null;
                                        ge.depth && (mt = ge.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, vn = ge.stencil ? Lt : dt, bn = ge.stencil ? xo : bs), u.isMultiview = a && r.has("OCULUS_multiview");
                                        const Qt = {colorFormat: n.RGBA8, depthFormat: mt, scaleFactor: S};
                                        u.isMultiview && (Qt.textureType = "texture-array"), le = new XRWebGLBinding(y, n), ne = le.createProjectionLayer(Qt), y.updateRenderState({layers: [ne]}), e.setPixelRatio(1), e.setSize(ne.textureWidth, ne.textureHeight, !1);
                                        const Ot = {
                                            format: Ke,
                                            type: pr,
                                            depthTexture: new uh(ne.textureWidth, ne.textureHeight, bn, void 0, void 0, void 0, void 0, void 0, void 0, vn),
                                            stencilBuffer: ge.stencil,
                                            colorSpace: e.outputColorSpace,
                                            samples: ge.antialias ? 4 : 0,
                                            resolveDepthBuffer: ne.ignoreDepthValues === !1
                                        };
                                        if (u.isMultiview) {
                                            const ln = r.get("OCULUS_multiview");
                                            this.maxNumViews = n.getParameter(ln.MAX_VIEWS_OVR), ze = new iE(ne.textureWidth, ne.textureHeight, 2, Ot)
                                        } else ze = new os(ne.textureWidth, ne.textureHeight, Ot)
                                    }
                                    ze.isXRRenderTarget = !0, this.setFoveation(Q), K = null, P = await y.requestReferenceSpace(z), Jn.setContext(y), Jn.start(), u.isPresenting = !0, u.dispatchEvent({type: "sessionstart"})
                                }
                            }, this.getEnvironmentBlendMode = function () {
                                if (y !== null) return y.environmentBlendMode
                            }, this.addLayer = function (Ht) {
                                !window.XRWebGLBinding || !this.layersEnabled || !y || (te.push(Ht), this.updateLayers())
                            }, this.removeLayer = function (Ht) {
                                te.splice(te.indexOf(Ht), 1), !(!window.XRWebGLBinding || !this.layersEnabled || !y) && this.updateLayers()
                            }, this.updateLayers = function () {
                                var Ht = te.map(function (vn) {
                                    return vn
                                });
                                Ht.unshift(y.renderState.layers[0]), y.updateRenderState({layers: Ht})
                            };

                            function dn(Ht) {
                                for (let vn = 0; vn < Ht.removed.length; vn++) {
                                    const bn = Ht.removed[vn], mt = qe.indexOf(bn);
                                    mt >= 0 && (qe[mt] = null, We[mt].disconnect(bn))
                                }
                                for (let vn = 0; vn < Ht.added.length; vn++) {
                                    const bn = Ht.added[vn];
                                    let mt = qe.indexOf(bn);
                                    if (mt === -1) {
                                        for (let Ot = 0; Ot < We.length; Ot++) if (Ot >= qe.length) {
                                            qe.push(bn), mt = Ot;
                                            break
                                        } else if (qe[Ot] === null) {
                                            qe[Ot] = bn, mt = Ot;
                                            break
                                        }
                                        if (mt === -1) break
                                    }
                                    const Qt = We[mt];
                                    Qt && Qt.connect(bn)
                                }
                            }

                            const fn = new Ne, Kn = new Ne;

                            function Qi(Ht, vn, bn) {
                                fn.setFromMatrixPosition(vn.matrixWorld), Kn.setFromMatrixPosition(bn.matrixWorld);
                                const mt = fn.distanceTo(Kn), Qt = vn.projectionMatrix.elements,
                                    Ot = bn.projectionMatrix.elements, ln = Qt[14] / (Qt[10] - 1),
                                    on = Qt[14] / (Qt[10] + 1), tn = (Qt[9] + 1) / Qt[5], Tn = (Qt[9] - 1) / Qt[5],
                                    Fn = (Qt[8] - 1) / Qt[0], Bi = (Ot[8] + 1) / Ot[0], Di = ln * Fn, wr = ln * Bi,
                                    ds = mt / (-Fn + Bi), Xr = ds * -Fn;
                                vn.matrixWorld.decompose(Ht.position, Ht.quaternion, Ht.scale), Ht.translateX(Xr), Ht.translateZ(ds), Ht.matrixWorld.compose(Ht.position, Ht.quaternion, Ht.scale), Ht.matrixWorldInverse.copy(Ht.matrixWorld).invert();
                                const Ye = ln + ds, Ie = on + ds, It = Di - Xr, Gt = wr + (mt - Xr),
                                    Xt = tn * on / Ie * Ye, Wt = Tn * on / Ie * Ye;
                                Ht.projectionMatrix.makePerspective(It, Gt, Xt, Wt, Ye, Ie), Ht.projectionMatrixInverse.copy(Ht.projectionMatrix).invert()
                            }

                            function Tr(Ht, vn) {
                                vn === null ? Ht.matrixWorld.copy(Ht.matrix) : Ht.matrixWorld.multiplyMatrices(vn.matrixWorld, Ht.matrix), Ht.matrixWorldInverse.copy(Ht.matrixWorld).invert()
                            }

                            this.setPoseTarget = function (Ht) {
                                Ht !== void 0 && (D = Ht)
                            }, this.updateCamera = function (Ht) {
                                if (y === null) return;
                                ye.texture !== null && (Ht.near = ye.depthNear, Ht.far = ye.depthFar), pt.near = ht.near = Je.near = Ht.near, pt.far = ht.far = Je.far = Ht.far, (Mt !== pt.near || Ut !== pt.far) && (y.updateRenderState({
                                    depthNear: pt.near,
                                    depthFar: pt.far
                                }), Mt = pt.near, Ut = pt.far, Je.near = Mt, Je.far = Ut, ht.near = Mt, ht.far = Ut, Je.updateProjectionMatrix(), ht.updateProjectionMatrix(), Ht.updateProjectionMatrix());
                                const vn = pt.cameras;
                                var bn = D || Ht;
                                const mt = bn.parent;
                                Tr(pt, mt);
                                for (let Qt = 0; Qt < vn.length; Qt++) Tr(vn[Qt], mt);
                                vn.length === 2 ? Qi(pt, Je, ht) : pt.projectionMatrix.copy(Je.projectionMatrix), Kr(Ht, pt, bn)
                            };

                            function Kr(Ht, vn, bn) {
                                vn.matrixWorld.decompose(vn.position, vn.quaternion, vn.scale), bn.parent === null ? bn.matrix.copy(vn.matrixWorld) : (bn.matrix.copy(bn.parent.matrixWorld), bn.matrix.invert(), bn.matrix.multiply(vn.matrixWorld)), bn.matrix.decompose(bn.position, bn.quaternion, bn.scale), bn.updateMatrixWorld(!0), Ht.projectionMatrix.copy(vn.projectionMatrix), Ht.projectionMatrixInverse.copy(vn.projectionMatrixInverse), Ht.isPerspectiveCamera && (Ht.fov = ol * 2 * Math.atan(1 / Ht.projectionMatrix.elements[5]), Ht.zoom = 1)
                            }

                            this.getCamera = function () {
                                return pt
                            }, this.getFoveation = function () {
                                if (!(ne === null && J === null)) return Q
                            }, this.setFoveation = function (Ht) {
                                Q = Ht, ne !== null && (ne.fixedFoveation = Ht), J !== null && J.fixedFoveation !== void 0 && (J.fixedFoveation = Ht)
                            }, this.hasDepthSensing = function () {
                                return ye.texture !== null
                            };
                            let Cr = null;

                            function Vr(Ht, vn) {
                                if (q = vn.getViewerPose(K || P), Ce = vn, q !== null) {
                                    const bn = q.views;
                                    J !== null && (e.setRenderTargetFramebuffer(ze, J.framebuffer), e.setRenderTarget(ze));
                                    let mt = !1;
                                    bn.length !== pt.cameras.length && (pt.cameras.length = 0, mt = !0);
                                    for (let Ot = 0; Ot < bn.length; Ot++) {
                                        const ln = bn[Ot];
                                        let on = null;
                                        if (J !== null) on = J.getViewport(ln); else {
                                            const Tn = le.getViewSubImage(ne, ln);
                                            on = Tn.viewport, Ot === 0 && (e.setRenderTargetTextures(ze, Tn.colorTexture, ne.ignoreDepthValues ? void 0 : Tn.depthStencilTexture), e.setRenderTarget(ze))
                                        }
                                        let tn = lt[Ot];
                                        tn === void 0 && (tn = new ns, tn.layers.enable(Ot), tn.viewport = new ar, lt[Ot] = tn), tn.matrix.fromArray(ln.transform.matrix), tn.matrix.decompose(tn.position, tn.quaternion, tn.scale), tn.projectionMatrix.fromArray(ln.projectionMatrix), tn.projectionMatrixInverse.copy(tn.projectionMatrix).invert(), tn.viewport.set(on.x, on.y, on.width, on.height), Ot === 0 && (pt.matrix.copy(tn.matrix), pt.matrix.decompose(pt.position, pt.quaternion, pt.scale)), mt === !0 && pt.cameras.push(tn)
                                    }
                                    const Qt = y.enabledFeatures;
                                    if (Qt && Qt.includes("depth-sensing")) {
                                        const Ot = le.getDepthInformation(bn[0]);
                                        Ot && Ot.isValid && Ot.texture && ye.init(e, Ot, y.renderState)
                                    }
                                }
                                for (let bn = 0; bn < We.length; bn++) {
                                    const mt = qe[bn], Qt = We[bn];
                                    mt !== null && Qt !== void 0 && Qt.update(mt, vn, K || P)
                                }
                                ye.render(e, pt), Cr && Cr(Ht, vn), vn.detectedPlanes && u.dispatchEvent({
                                    type: "planesdetected",
                                    data: vn
                                }), Ce = null
                            }

                            const Jn = new hd;
                            Jn.setAnimationLoop(Vr), this.setAnimationLoop = function (Ht) {
                                Cr = Ht
                            }, this.dispose = function () {
                            }
                        }
                    }

                    const Ah = new bo, A_ = new Mn;

                    function g_(d, e) {
                        function n(ne, J) {
                            ne.matrixAutoUpdate === !0 && ne.updateMatrix(), J.value.copy(ne.matrix)
                        }

                        function r(ne, J) {
                            J.color.getRGB(ne.fogColor.value, $u(d)), J.isFog ? (ne.fogNear.value = J.near, ne.fogFar.value = J.far) : J.isFogExp2 && (ne.fogDensity.value = J.density)
                        }

                        function a(ne, J, Ce, ye, ge) {
                            J.isMeshBasicMaterial || J.isMeshLambertMaterial ? u(ne, J) : J.isMeshToonMaterial ? (u(ne, J), Q(ne, J)) : J.isMeshPhongMaterial ? (u(ne, J), z(ne, J)) : J.isMeshStandardMaterial ? (u(ne, J), K(ne, J), J.isMeshPhysicalMaterial && q(ne, J, ge)) : J.isMeshMatcapMaterial ? (u(ne, J), te(ne, J)) : J.isMeshDepthMaterial ? u(ne, J) : J.isMeshDistanceMaterial ? (u(ne, J), le(ne, J)) : J.isMeshNormalMaterial ? u(ne, J) : J.isLineBasicMaterial ? (y(ne, J), J.isLineDashedMaterial && S(ne, J)) : J.isPointsMaterial ? D(ne, J, Ce, ye) : J.isSpriteMaterial ? P(ne, J) : J.isShadowMaterial ? (ne.color.value.copy(J.color), ne.opacity.value = J.opacity) : J.isShaderMaterial && (J.uniformsNeedUpdate = !1)
                        }

                        function u(ne, J) {
                            ne.opacity.value = J.opacity, J.color && ne.diffuse.value.copy(J.color), J.emissive && ne.emissive.value.copy(J.emissive).multiplyScalar(J.emissiveIntensity), J.map && (ne.map.value = J.map, n(J.map, ne.mapTransform)), J.alphaMap && (ne.alphaMap.value = J.alphaMap, n(J.alphaMap, ne.alphaMapTransform)), J.bumpMap && (ne.bumpMap.value = J.bumpMap, n(J.bumpMap, ne.bumpMapTransform), ne.bumpScale.value = J.bumpScale, J.side === O && (ne.bumpScale.value *= -1)), J.normalMap && (ne.normalMap.value = J.normalMap, n(J.normalMap, ne.normalMapTransform), ne.normalScale.value.copy(J.normalScale), J.side === O && ne.normalScale.value.negate()), J.displacementMap && (ne.displacementMap.value = J.displacementMap, n(J.displacementMap, ne.displacementMapTransform), ne.displacementScale.value = J.displacementScale, ne.displacementBias.value = J.displacementBias), J.emissiveMap && (ne.emissiveMap.value = J.emissiveMap, n(J.emissiveMap, ne.emissiveMapTransform)), J.specularMap && (ne.specularMap.value = J.specularMap, n(J.specularMap, ne.specularMapTransform)), J.alphaTest > 0 && (ne.alphaTest.value = J.alphaTest);
                            const Ce = e.get(J), ye = Ce.envMap, ge = Ce.envMapRotation;
                            if (ye && (ne.envMap.value = ye, Ah.copy(ge), Ah.x *= -1, Ah.y *= -1, Ah.z *= -1, ye.isCubeTexture && ye.isRenderTargetTexture === !1 && (Ah.y *= -1, Ah.z *= -1), ne.envMapRotation.value.setFromMatrix4(A_.makeRotationFromEuler(Ah)), ne.flipEnvMap.value = ye.isCubeTexture && ye.isRenderTargetTexture === !1 ? -1 : 1, ne.reflectivity.value = J.reflectivity, ne.ior.value = J.ior, ne.refractionRatio.value = J.refractionRatio), J.lightMap) {
                                ne.lightMap.value = J.lightMap;
                                const $e = d._useLegacyLights === !0 ? Math.PI : 1;
                                ne.lightMapIntensity.value = J.lightMapIntensity * $e, n(J.lightMap, ne.lightMapTransform)
                            }
                            J.aoMap && (ne.aoMap.value = J.aoMap, ne.aoMapIntensity.value = J.aoMapIntensity, n(J.aoMap, ne.aoMapTransform))
                        }

                        function y(ne, J) {
                            ne.diffuse.value.copy(J.color), ne.opacity.value = J.opacity, J.map && (ne.map.value = J.map, n(J.map, ne.mapTransform))
                        }

                        function S(ne, J) {
                            ne.dashSize.value = J.dashSize, ne.totalSize.value = J.dashSize + J.gapSize, ne.scale.value = J.scale
                        }

                        function D(ne, J, Ce, ye) {
                            ne.diffuse.value.copy(J.color), ne.opacity.value = J.opacity, ne.size.value = J.size * Ce, ne.scale.value = ye * .5, J.map && (ne.map.value = J.map, n(J.map, ne.uvTransform)), J.alphaMap && (ne.alphaMap.value = J.alphaMap, n(J.alphaMap, ne.alphaMapTransform)), J.alphaTest > 0 && (ne.alphaTest.value = J.alphaTest)
                        }

                        function P(ne, J) {
                            ne.diffuse.value.copy(J.color), ne.opacity.value = J.opacity, ne.rotation.value = J.rotation, J.map && (ne.map.value = J.map, n(J.map, ne.mapTransform)), J.alphaMap && (ne.alphaMap.value = J.alphaMap, n(J.alphaMap, ne.alphaMapTransform)), J.alphaTest > 0 && (ne.alphaTest.value = J.alphaTest)
                        }

                        function z(ne, J) {
                            ne.specular.value.copy(J.specular), ne.shininess.value = Math.max(J.shininess, 1e-4)
                        }

                        function Q(ne, J) {
                            J.gradientMap && (ne.gradientMap.value = J.gradientMap)
                        }

                        function K(ne, J) {
                            ne.metalness.value = J.metalness, J.metalnessMap && (ne.metalnessMap.value = J.metalnessMap, n(J.metalnessMap, ne.metalnessMapTransform)), ne.roughness.value = J.roughness, J.roughnessMap && (ne.roughnessMap.value = J.roughnessMap, n(J.roughnessMap, ne.roughnessMapTransform)), J.envMap && (ne.envMapIntensity.value = J.envMapIntensity)
                        }

                        function q(ne, J, Ce) {
                            ne.ior.value = J.ior, J.sheen > 0 && (ne.sheenColor.value.copy(J.sheenColor).multiplyScalar(J.sheen), ne.sheenRoughness.value = J.sheenRoughness, J.sheenColorMap && (ne.sheenColorMap.value = J.sheenColorMap, n(J.sheenColorMap, ne.sheenColorMapTransform)), J.sheenRoughnessMap && (ne.sheenRoughnessMap.value = J.sheenRoughnessMap, n(J.sheenRoughnessMap, ne.sheenRoughnessMapTransform))), J.clearcoat > 0 && (ne.clearcoat.value = J.clearcoat, ne.clearcoatRoughness.value = J.clearcoatRoughness, J.clearcoatMap && (ne.clearcoatMap.value = J.clearcoatMap, n(J.clearcoatMap, ne.clearcoatMapTransform)), J.clearcoatRoughnessMap && (ne.clearcoatRoughnessMap.value = J.clearcoatRoughnessMap, n(J.clearcoatRoughnessMap, ne.clearcoatRoughnessMapTransform)), J.clearcoatNormalMap && (ne.clearcoatNormalMap.value = J.clearcoatNormalMap, n(J.clearcoatNormalMap, ne.clearcoatNormalMapTransform), ne.clearcoatNormalScale.value.copy(J.clearcoatNormalScale), J.side === O && ne.clearcoatNormalScale.value.negate())), J.dispersion > 0 && (ne.dispersion.value = J.dispersion), J.iridescence > 0 && (ne.iridescence.value = J.iridescence, ne.iridescenceIOR.value = J.iridescenceIOR, ne.iridescenceThicknessMinimum.value = J.iridescenceThicknessRange[0], ne.iridescenceThicknessMaximum.value = J.iridescenceThicknessRange[1], J.iridescenceMap && (ne.iridescenceMap.value = J.iridescenceMap, n(J.iridescenceMap, ne.iridescenceMapTransform)), J.iridescenceThicknessMap && (ne.iridescenceThicknessMap.value = J.iridescenceThicknessMap, n(J.iridescenceThicknessMap, ne.iridescenceThicknessMapTransform))), J.transmission > 0 && (ne.transmission.value = J.transmission, ne.transmissionSamplerMap.value = Ce.texture, ne.transmissionSamplerSize.value.set(Ce.width, Ce.height), J.transmissionMap && (ne.transmissionMap.value = J.transmissionMap, n(J.transmissionMap, ne.transmissionMapTransform)), ne.thickness.value = J.thickness, J.thicknessMap && (ne.thicknessMap.value = J.thicknessMap, n(J.thicknessMap, ne.thicknessMapTransform)), ne.attenuationDistance.value = J.attenuationDistance, ne.attenuationColor.value.copy(J.attenuationColor)), J.anisotropy > 0 && (ne.anisotropyVector.value.set(J.anisotropy * Math.cos(J.anisotropyRotation), J.anisotropy * Math.sin(J.anisotropyRotation)), J.anisotropyMap && (ne.anisotropyMap.value = J.anisotropyMap, n(J.anisotropyMap, ne.anisotropyMapTransform))), ne.specularIntensity.value = J.specularIntensity, ne.specularColor.value.copy(J.specularColor), J.specularColorMap && (ne.specularColorMap.value = J.specularColorMap, n(J.specularColorMap, ne.specularColorMapTransform)), J.specularIntensityMap && (ne.specularIntensityMap.value = J.specularIntensityMap, n(J.specularIntensityMap, ne.specularIntensityMapTransform))
                        }

                        function te(ne, J) {
                            J.matcap && (ne.matcap.value = J.matcap)
                        }

                        function le(ne, J) {
                            const Ce = e.get(J).light;
                            ne.referencePosition.value.setFromMatrixPosition(Ce.matrixWorld), ne.nearDistance.value = Ce.shadow.camera.near, ne.farDistance.value = Ce.shadow.camera.far
                        }

                        return {refreshFogUniforms: r, refreshMaterialUniforms: a}
                    }

                    function v_(d, e, n, r) {
                        let a = {}, u = {}, y = [];
                        const S = d.getParameter(d.MAX_UNIFORM_BUFFER_BINDINGS);

                        function D(Ce, ye) {
                            const ge = ye.program;
                            r.uniformBlockBinding(Ce, ge)
                        }

                        function P(Ce, ye) {
                            let ge = a[Ce.id];
                            ge === void 0 && (te(Ce), ge = z(Ce), a[Ce.id] = ge, Ce.addEventListener("dispose", ne));
                            const $e = ye.program;
                            r.updateUBOMapping(Ce, $e);
                            const ze = e.render.frame;
                            u[Ce.id] !== ze && (K(Ce), u[Ce.id] = ze)
                        }

                        function z(Ce) {
                            const ye = Q();
                            Ce.__bindingPointIndex = ye;
                            const ge = d.createBuffer(), $e = Ce.__size, ze = Ce.usage;
                            return d.bindBuffer(d.UNIFORM_BUFFER, ge), d.bufferData(d.UNIFORM_BUFFER, $e, ze), d.bindBuffer(d.UNIFORM_BUFFER, null), d.bindBufferBase(d.UNIFORM_BUFFER, ye, ge), ge
                        }

                        function Q() {
                            for (let Ce = 0; Ce < S; Ce++) if (y.indexOf(Ce) === -1) return y.push(Ce), Ce;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                        }

                        function K(Ce) {
                            const ye = a[Ce.id], ge = Ce.uniforms, $e = Ce.__cache;
                            d.bindBuffer(d.UNIFORM_BUFFER, ye);
                            for (let ze = 0, We = ge.length; ze < We; ze++) {
                                const qe = Array.isArray(ge[ze]) ? ge[ze] : [ge[ze]];
                                for (let Pe = 0, Te = qe.length; Pe < Te; Pe++) {
                                    const Je = qe[Pe];
                                    if (q(Je, ze, Pe, $e) === !0) {
                                        const ht = Je.__offset, lt = Array.isArray(Je.value) ? Je.value : [Je.value];
                                        let pt = 0;
                                        for (let Mt = 0; Mt < lt.length; Mt++) {
                                            const Ut = lt[Mt], mn = le(Ut);
                                            typeof Ut == "number" || typeof Ut == "boolean" ? (Je.__data[0] = Ut, d.bufferSubData(d.UNIFORM_BUFFER, ht + pt, Je.__data)) : Ut.isMatrix3 ? (Je.__data[0] = Ut.elements[0], Je.__data[1] = Ut.elements[1], Je.__data[2] = Ut.elements[2], Je.__data[3] = 0, Je.__data[4] = Ut.elements[3], Je.__data[5] = Ut.elements[4], Je.__data[6] = Ut.elements[5], Je.__data[7] = 0, Je.__data[8] = Ut.elements[6], Je.__data[9] = Ut.elements[7], Je.__data[10] = Ut.elements[8], Je.__data[11] = 0) : (Ut.toArray(Je.__data, pt), pt += mn.storage / Float32Array.BYTES_PER_ELEMENT)
                                        }
                                        d.bufferSubData(d.UNIFORM_BUFFER, ht, Je.__data)
                                    }
                                }
                            }
                            d.bindBuffer(d.UNIFORM_BUFFER, null)
                        }

                        function q(Ce, ye, ge, $e) {
                            const ze = Ce.value, We = ye + "_" + ge;
                            if ($e[We] === void 0) return typeof ze == "number" || typeof ze == "boolean" ? $e[We] = ze : $e[We] = ze.clone(), !0;
                            {
                                const qe = $e[We];
                                if (typeof ze == "number" || typeof ze == "boolean") {
                                    if (qe !== ze) return $e[We] = ze, !0
                                } else if (qe.equals(ze) === !1) return qe.copy(ze), !0
                            }
                            return !1
                        }

                        function te(Ce) {
                            const ye = Ce.uniforms;
                            let ge = 0;
                            const $e = 16;
                            for (let We = 0, qe = ye.length; We < qe; We++) {
                                const Pe = Array.isArray(ye[We]) ? ye[We] : [ye[We]];
                                for (let Te = 0, Je = Pe.length; Te < Je; Te++) {
                                    const ht = Pe[Te], lt = Array.isArray(ht.value) ? ht.value : [ht.value];
                                    for (let pt = 0, Mt = lt.length; pt < Mt; pt++) {
                                        const Ut = lt[pt], mn = le(Ut), Tt = ge % $e;
                                        Tt !== 0 && $e - Tt < mn.boundary && (ge += $e - Tt), ht.__data = new Float32Array(mn.storage / Float32Array.BYTES_PER_ELEMENT), ht.__offset = ge, ge += mn.storage
                                    }
                                }
                            }
                            const ze = ge % $e;
                            return ze > 0 && (ge += $e - ze), Ce.__size = ge, Ce.__cache = {}, this
                        }

                        function le(Ce) {
                            const ye = {boundary: 0, storage: 0};
                            return typeof Ce == "number" || typeof Ce == "boolean" ? (ye.boundary = 4, ye.storage = 4) : Ce.isVector2 ? (ye.boundary = 8, ye.storage = 8) : Ce.isVector3 || Ce.isColor ? (ye.boundary = 16, ye.storage = 12) : Ce.isVector4 ? (ye.boundary = 16, ye.storage = 16) : Ce.isMatrix3 ? (ye.boundary = 48, ye.storage = 48) : Ce.isMatrix4 ? (ye.boundary = 64, ye.storage = 64) : Ce.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", Ce), ye
                        }

                        function ne(Ce) {
                            const ye = Ce.target;
                            ye.removeEventListener("dispose", ne);
                            const ge = y.indexOf(ye.__bindingPointIndex);
                            y.splice(ge, 1), d.deleteBuffer(a[ye.id]), delete a[ye.id], delete u[ye.id]
                        }

                        function J() {
                            for (const Ce in a) d.deleteBuffer(a[Ce]);
                            y = [], a = {}, u = {}
                        }

                        return {bind: D, update: P, dispose: J}
                    }

                    class y_ {
                        constructor(e = {}) {
                            const {
                                canvas: n = Kc(),
                                context: r = null,
                                depth: a = !0,
                                stencil: u = !1,
                                alpha: y = !1,
                                antialias: S = !1,
                                premultipliedAlpha: D = !0,
                                preserveDrawingBuffer: P = !1,
                                powerPreference: z = "default",
                                failIfMajorPerformanceCaveat: Q = !1,
                                multiviewStereo: K = !1
                            } = e;
                            this.isWebGLRenderer = !0;
                            let q;
                            if (r !== null) {
                                if (typeof WebGLRenderingContext < "u" && r instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                                q = r.getContextAttributes().alpha
                            } else q = y;
                            const te = new Uint32Array(4), le = new Int32Array(4);
                            let ne = null, J = null;
                            const Ce = [], ye = [];
                            this.domElement = n, this.debug = {
                                checkShaderErrors: !0,
                                onShaderError: null
                            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = rr, this._useLegacyLights = !1, this.toneMapping = cr, this.toneMappingExposure = 1;
                            const ge = this;
                            let $e = !1, ze = 0, We = 0, qe = null, Pe = -1, Te = null;
                            const Je = new ar, ht = new ar;
                            let lt = null;
                            const pt = new Bn(0);
                            let Mt = 0, Ut = n.width, mn = n.height, Tt = 1, dn = null, fn = null;
                            const Kn = new ar(0, 0, Ut, mn), Qi = new ar(0, 0, Ut, mn);
                            let Tr = !1;
                            const Kr = new Ec;
                            let Cr = !1, Vr = !1;
                            const Jn = new Mn, Ht = new Ne, vn = {
                                background: null,
                                fog: null,
                                environment: null,
                                overrideMaterial: null,
                                isScene: !0
                            };

                            function bn() {
                                return qe === null ? Tt : 1
                            }

                            let mt = r;

                            function Qt(Fe, At) {
                                return n.getContext(Fe, At)
                            }

                            try {
                                const Fe = {
                                    alpha: !0,
                                    depth: a,
                                    stencil: u,
                                    antialias: S,
                                    premultipliedAlpha: D,
                                    preserveDrawingBuffer: P,
                                    powerPreference: z,
                                    failIfMajorPerformanceCaveat: Q
                                };
                                if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${g}`), n.addEventListener("webglcontextlost", pn, !1), n.addEventListener("webglcontextrestored", ti, !1), n.addEventListener("webglcontextcreationerror", On, !1), mt === null) {
                                    const At = "webgl2";
                                    if (mt = Qt(At, Fe), mt === null) throw Qt(At) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                                }
                            } catch (Fe) {
                                throw console.error("THREE.WebGLRenderer: " + Fe.message), Fe
                            }
                            let Ot, ln, on, tn, Tn, Fn, Bi, Di, wr, ds, Xr, Ye, Ie, It, Gt, Xt, Wt, ei, An, zn, Pr, Gn,
                                ni, Ui, vi;

                            function it() {
                                Ot = new Vl(mt), Ot.init(), ni = new $1(mt, Ot), ln = new pp(mt, Ot, e, ni), on = new l_(mt), tn = new Md(mt), Tn = new qb, Fn = new c_(mt, Ot, on, Tn, ln, ni, tn), Bi = new RA(ge), Di = new rv(ge), wr = new Sm(mt), Ui = new fp(mt, wr), ds = new _d(mt, wr, tn, Ui), Xr = new sv(mt, ds, wr, tn), zn = new vp(mt, ln, Fn), Xt = new Sc(Tn), Ye = new Yb(ge, Bi, Di, Ot, ln, Ui, Xt), Ie = new g_(ge, Tn), It = new Zb, Gt = new r_(Ot), An = new IA(ge, Bi, Di, on, Xr, q, D), ei = new yp(ge, Ot, mt), Wt = new a_(ge, Xr, ln), vi = new v_(mt, tn, ln, on), Pr = new Mc(mt, Ot, tn), Gn = new Ic(mt, Ot, tn), tn.programs = Ye.programs, ge.capabilities = ln, ge.extensions = Ot, ge.properties = Tn, ge.renderLists = It, ge.shadowMap = Wt, ge.state = on, ge.info = tn
                            }

                            it();
                            const nn = typeof navigator < "u" && "xr" in navigator ? new m_(ge, mt, Ot, K) : new nE(ge);
                            this.xr = nn, this.getContext = function () {
                                return mt
                            }, this.getContextAttributes = function () {
                                return mt.getContextAttributes()
                            }, this.forceContextLoss = function () {
                                const Fe = Ot.get("WEBGL_lose_context");
                                Fe && Fe.loseContext()
                            }, this.forceContextRestore = function () {
                                const Fe = Ot.get("WEBGL_lose_context");
                                Fe && Fe.restoreContext()
                            }, this.getPixelRatio = function () {
                                return Tt
                            }, this.setPixelRatio = function (Fe) {
                                Fe !== void 0 && (Tt = Fe, this.setSize(Ut, mn, !1))
                            }, this.getSize = function (Fe) {
                                return Fe.set(Ut, mn)
                            }, this.setSize = function (Fe, At, St = !0) {
                                if (nn.isPresenting) {
                                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                                    return
                                }
                                Ut = Fe, mn = At, n.width = Math.floor(Fe * Tt), n.height = Math.floor(At * Tt), St === !0 && (n.style.width = Fe + "px", n.style.height = At + "px"), this.setViewport(0, 0, Fe, At)
                            }, this.getDrawingBufferSize = function (Fe) {
                                return Fe.set(Ut * Tt, mn * Tt).floor()
                            }, this.setDrawingBufferSize = function (Fe, At, St) {
                                Ut = Fe, mn = At, Tt = St, n.width = Math.floor(Fe * St), n.height = Math.floor(At * St), this.setViewport(0, 0, Fe, At)
                            }, this.getCurrentViewport = function (Fe) {
                                return Fe.copy(Je)
                            }, this.getViewport = function (Fe) {
                                return Fe.copy(Kn)
                            }, this.setViewport = function (Fe, At, St, xt) {
                                Fe.isVector4 ? Kn.set(Fe.x, Fe.y, Fe.z, Fe.w) : Kn.set(Fe, At, St, xt), on.viewport(Je.copy(Kn).multiplyScalar(Tt).round())
                            }, this.getScissor = function (Fe) {
                                return Fe.copy(Qi)
                            }, this.setScissor = function (Fe, At, St, xt) {
                                Fe.isVector4 ? Qi.set(Fe.x, Fe.y, Fe.z, Fe.w) : Qi.set(Fe, At, St, xt), on.scissor(ht.copy(Qi).multiplyScalar(Tt).round())
                            }, this.getScissorTest = function () {
                                return Tr
                            }, this.setScissorTest = function (Fe) {
                                on.setScissorTest(Tr = Fe)
                            }, this.setOpaqueSort = function (Fe) {
                                dn = Fe
                            }, this.setTransparentSort = function (Fe) {
                                fn = Fe
                            }, this.getClearColor = function (Fe) {
                                return Fe.copy(An.getClearColor())
                            }, this.setClearColor = function () {
                                An.setClearColor.apply(An, arguments)
                            }, this.getClearAlpha = function () {
                                return An.getClearAlpha()
                            }, this.setClearAlpha = function () {
                                An.setClearAlpha.apply(An, arguments)
                            }, this.clear = function (Fe = !0, At = !0, St = !0) {
                                let xt = 0;
                                if (Fe) {
                                    let bt = !1;
                                    if (qe !== null) {
                                        const Dn = qe.texture.format;
                                        bt = Dn === Hn || Dn === Dt || Dn === Rn
                                    }
                                    if (bt) {
                                        const Dn = qe.texture.type,
                                            si = Dn === pr || Dn === bs || Dn === ws || Dn === xo || Dn === Qr || Dn === ua,
                                            ui = An.getClearColor(), wi = An.getClearAlpha(), Fi = ui.r, ji = ui.g,
                                            er = ui.b;
                                        si ? (te[0] = Fi, te[1] = ji, te[2] = er, te[3] = wi, mt.clearBufferuiv(mt.COLOR, 0, te)) : (le[0] = Fi, le[1] = ji, le[2] = er, le[3] = wi, mt.clearBufferiv(mt.COLOR, 0, le))
                                    } else xt |= mt.COLOR_BUFFER_BIT
                                }
                                At && (xt |= mt.DEPTH_BUFFER_BIT), St && (xt |= mt.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), mt.clear(xt)
                            }, this.clearColor = function () {
                                this.clear(!0, !1, !1)
                            }, this.clearDepth = function () {
                                this.clear(!1, !0, !1)
                            }, this.clearStencil = function () {
                                this.clear(!1, !1, !0)
                            }, this.dispose = function () {
                                n.removeEventListener("webglcontextlost", pn, !1), n.removeEventListener("webglcontextrestored", ti, !1), n.removeEventListener("webglcontextcreationerror", On, !1), It.dispose(), Gt.dispose(), Tn.dispose(), Bi.dispose(), Di.dispose(), Xr.dispose(), Ui.dispose(), vi.dispose(), Ye.dispose(), nn.dispose(), nn.removeEventListener("sessionstart", Wl), nn.removeEventListener("sessionend", Qx), Ih.stop()
                            };

                            function pn(Fe) {
                                Fe.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), $e = !0
                            }

                            function ti() {
                                console.log("THREE.WebGLRenderer: Context Restored."), $e = !1;
                                const Fe = tn.autoReset, At = Wt.enabled, St = Wt.autoUpdate, xt = Wt.needsUpdate,
                                    bt = Wt.type;
                                it(), tn.autoReset = Fe, Wt.enabled = At, Wt.autoUpdate = St, Wt.needsUpdate = xt, Wt.type = bt
                            }

                            function On(Fe) {
                                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", Fe.statusMessage)
                            }

                            function zi(Fe) {
                                const At = Fe.target;
                                At.removeEventListener("dispose", zi), kn(At)
                            }

                            function kn(Fe) {
                                In(Fe), Tn.remove(Fe)
                            }

                            function In(Fe) {
                                const At = Tn.get(Fe).programs;
                                At !== void 0 && (At.forEach(function (St) {
                                    Ye.releaseProgram(St)
                                }), Fe.isShaderMaterial && Ye.releaseShaderCache(Fe))
                            }

                            this.renderBufferDirect = function (Fe, At, St, xt, bt, Dn) {
                                At === null && (At = vn);
                                const si = bt.isMesh && bt.matrixWorld.determinant() < 0, ui = f3(Fe, At, St, xt, bt);
                                on.setMaterial(xt, si);
                                let wi = St.index, Fi = 1;
                                if (xt.wireframe === !0) {
                                    if (wi = ds.getWireframeAttribute(St), wi === void 0) return;
                                    Fi = 2
                                }
                                const ji = St.drawRange, er = St.attributes.position;
                                let Ys = ji.start * Fi, zo = (ji.start + ji.count) * Fi;
                                Dn !== null && (Ys = Math.max(Ys, Dn.start * Fi), zo = Math.min(zo, (Dn.start + Dn.count) * Fi)), wi !== null ? (Ys = Math.max(Ys, 0), zo = Math.min(zo, wi.count)) : er != null && (Ys = Math.max(Ys, 0), zo = Math.min(zo, er.count));
                                const Da = zo - Ys;
                                if (Da < 0 || Da === 1 / 0) return;
                                Ui.setup(bt, xt, ui, St, wi);
                                let Au, Ir = Pr;
                                if (wi !== null && (Au = wr.get(wi), Ir = Gn, Ir.setIndex(Au)), bt.isMesh) xt.wireframe === !0 ? (on.setLineWidth(xt.wireframeLinewidth * bn()), Ir.setMode(mt.LINES)) : Ir.setMode(mt.TRIANGLES); else if (bt.isLine) {
                                    let Dc = xt.linewidth;
                                    Dc === void 0 && (Dc = 1), on.setLineWidth(Dc * bn()), bt.isLineSegments ? Ir.setMode(mt.LINES) : bt.isLineLoop ? Ir.setMode(mt.LINE_LOOP) : Ir.setMode(mt.LINE_STRIP)
                                } else bt.isPoints ? Ir.setMode(mt.POINTS) : bt.isSprite && Ir.setMode(mt.TRIANGLES);
                                if (bt.isBatchedMesh) bt._multiDrawInstances !== null ? Ir.renderMultiDrawInstances(bt._multiDrawStarts, bt._multiDrawCounts, bt._multiDrawCount, bt._multiDrawInstances) : Ir.renderMultiDraw(bt._multiDrawStarts, bt._multiDrawCounts, bt._multiDrawCount); else if (bt.isInstancedMesh) Ir.renderInstances(Ys, Da, bt.count); else if (St.isInstancedBufferGeometry) {
                                    const Dc = St._maxInstanceCount !== void 0 ? St._maxInstanceCount : 1 / 0,
                                        Yi = Math.min(St.instanceCount, Dc);
                                    Ir.renderInstances(Ys, Da, Yi)
                                } else Ir.render(Ys, Da)
                            };

                            function Xi(Fe, At, St) {
                                Fe.transparent === !0 && Fe.side === N && Fe.forceSinglePass === !1 ? (Fe.side = O, Fe.needsUpdate = !0, Dg(Fe, At, St), Fe.side = L, Fe.needsUpdate = !0, Dg(Fe, At, St), Fe.side = N) : Dg(Fe, At, St)
                            }

                            this.compile = function (Fe, At, St = null) {
                                St === null && (St = Fe), J = Gt.get(St), J.init(At), ye.push(J), St.traverseVisible(function (bt) {
                                    bt.isLight && bt.layers.test(At.layers) && (J.pushLight(bt), bt.castShadow && J.pushShadow(bt))
                                }), Fe !== St && Fe.traverseVisible(function (bt) {
                                    bt.isLight && bt.layers.test(At.layers) && (J.pushLight(bt), bt.castShadow && J.pushShadow(bt))
                                }), J.setupLights(ge._useLegacyLights);
                                const xt = new Set;
                                return Fe.traverse(function (bt) {
                                    const Dn = bt.material;
                                    if (Dn) if (Array.isArray(Dn)) for (let si = 0; si < Dn.length; si++) {
                                        const ui = Dn[si];
                                        Xi(ui, St, bt), xt.add(ui)
                                    } else Xi(Dn, St, bt), xt.add(Dn)
                                }), ye.pop(), J = null, xt
                            }, this.compileAsync = function (Fe, At, St = null) {
                                const xt = this.compile(Fe, At, St);
                                return new Promise(bt => {
                                    function Dn() {
                                        if (xt.forEach(function (si) {
                                            Tn.get(si).currentProgram.isReady() && xt.delete(si)
                                        }), xt.size === 0) {
                                            bt(Fe);
                                            return
                                        }
                                        setTimeout(Dn, 10)
                                    }

                                    Ot.get("KHR_parallel_shader_compile") !== null ? Dn() : setTimeout(Dn, 10)
                                })
                            };
                            let Ci = null;

                            function so(Fe) {
                                Ci && Ci(Fe)
                            }

                            function Wl() {
                                Ih.stop()
                            }

                            function Qx() {
                                Ih.start()
                            }

                            const Ih = new hd;
                            Ih.setAnimationLoop(so), typeof self < "u" && Ih.setContext(self), this.setAnimationLoop = function (Fe) {
                                Ci = Fe, nn.setAnimationLoop(Fe), Fe === null ? Ih.stop() : Ih.start()
                            }, nn.addEventListener("sessionstart", Wl), nn.addEventListener("sessionend", Qx), this.render = function (Fe, At) {
                                if (At !== void 0 && At.isCamera !== !0) {
                                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                                    return
                                }
                                if ($e === !0) return;
                                Fe.matrixWorldAutoUpdate === !0 && Fe.updateMatrixWorld(), At.parent === null && At.matrixWorldAutoUpdate === !0 && At.updateMatrixWorld(), nn.enabled === !0 && nn.isPresenting === !0 && (nn.cameraAutoUpdate === !0 && nn.updateCamera(At), At = nn.getCamera()), Fe.isScene === !0 && Fe.onBeforeRender(ge, Fe, At, qe), J = Gt.get(Fe, ye.length), J.init(At), ye.push(J), Jn.multiplyMatrices(At.projectionMatrix, At.matrixWorldInverse), Kr.setFromProjectionMatrix(Jn), Vr = this.localClippingEnabled, Cr = Xt.init(this.clippingPlanes, Vr), ne = It.get(Fe, Ce.length), ne.init(), Ce.push(ne), jx(Fe, At, 0, ge.sortObjects), ne.finish(), ge.sortObjects === !0 && ne.sort(dn, fn);
                                const St = nn.enabled === !1 || nn.isPresenting === !1 || nn.hasDepthSensing() === !1;
                                St && An.addToRenderList(ne, Fe), this.info.render.frame++, Cr === !0 && Xt.beginShadows();
                                const xt = J.state.shadowsArray;
                                Wt.render(xt, Fe, At), Cr === !0 && Xt.endShadows(), this.info.autoReset === !0 && this.info.reset();
                                const bt = ne.opaque, Dn = ne.transmissive;
                                if (J.setupLights(ge._useLegacyLights), At.isArrayCamera) {
                                    const si = At.cameras;
                                    if (Dn.length > 0) for (let ui = 0, wi = si.length; ui < wi; ui++) {
                                        const Fi = si[ui];
                                        Wx(bt, Dn, Fe, Fi)
                                    }
                                    if (St && An.render(Fe), nn.enabled && nn.isMultiview) Fn.setDeferTextureUploads(!0), ty(ne, Fe, At, At.cameras[0].viewport); else for (let ui = 0, wi = si.length; ui < wi; ui++) {
                                        const Fi = si[ui];
                                        ty(ne, Fe, Fi, Fi.viewport)
                                    }
                                } else Dn.length > 0 && Wx(bt, Dn, Fe, At), St && An.render(Fe), ty(ne, Fe, At);
                                qe !== null && (Fn.updateMultisampleRenderTarget(qe), Fn.updateRenderTargetMipmap(qe)), Fe.isScene === !0 && Fe.onAfterRender(ge, Fe, At), Fn.runDeferredUploads(), nn.enabled && nn.submitFrame && nn.submitFrame(), Ui.resetDefaultState(), Pe = -1, Te = null, ye.pop(), ye.length > 0 ? (J = ye[ye.length - 1], Cr === !0 && Xt.setGlobalState(ge.clippingPlanes, J.state.camera)) : J = null, Ce.pop(), Ce.length > 0 ? ne = Ce[Ce.length - 1] : ne = null
                            };

                            function jx(Fe, At, St, xt) {
                                if (Fe.visible === !1) return;
                                if (Fe.layers.test(At.layers)) {
                                    if (Fe.isGroup) St = Fe.renderOrder; else if (Fe.isLOD) Fe.autoUpdate === !0 && Fe.update(At); else if (Fe.isLight) J.pushLight(Fe), Fe.castShadow && J.pushShadow(Fe); else if (Fe.isSprite) {
                                        if (!Fe.frustumCulled || Kr.intersectsSprite(Fe)) {
                                            xt && Ht.setFromMatrixPosition(Fe.matrixWorld).applyMatrix4(Jn);
                                            const si = Xr.update(Fe), ui = Fe.material;
                                            ui.visible && ne.push(Fe, si, ui, St, Ht.z, null)
                                        }
                                    } else if ((Fe.isMesh || Fe.isLine || Fe.isPoints) && (!Fe.frustumCulled || Kr.intersectsObject(Fe))) {
                                        const si = Xr.update(Fe), ui = Fe.material;
                                        if (xt && (Fe.boundingSphere !== void 0 ? (Fe.boundingSphere === null && Fe.computeBoundingSphere(), Ht.copy(Fe.boundingSphere.center)) : (si.boundingSphere === null && si.computeBoundingSphere(), Ht.copy(si.boundingSphere.center)), Ht.applyMatrix4(Fe.matrixWorld).applyMatrix4(Jn)), Array.isArray(ui)) {
                                            const wi = si.groups;
                                            for (let Fi = 0, ji = wi.length; Fi < ji; Fi++) {
                                                const er = wi[Fi], Ys = ui[er.materialIndex];
                                                Ys && Ys.visible && ne.push(Fe, si, Ys, St, Ht.z, er)
                                            }
                                        } else ui.visible && ne.push(Fe, si, ui, St, Ht.z, null)
                                    }
                                }
                                const Dn = Fe.children;
                                for (let si = 0, ui = Dn.length; si < ui; si++) jx(Dn[si], At, St, xt)
                            }

                            function ty(Fe, At, St, xt) {
                                const bt = Fe.opaque, Dn = Fe.transmissive, si = Fe.transparent;
                                J.setupLightsView(St), Cr === !0 && Xt.setGlobalState(ge.clippingPlanes, St), xt && on.viewport(Je.copy(xt)), bt.length > 0 && Lg(bt, At, St), Dn.length > 0 && Lg(Dn, At, St), si.length > 0 && Lg(si, At, St), on.buffers.depth.setTest(!0), on.buffers.depth.setMask(!0), on.buffers.color.setMask(!0), on.setPolygonOffset(!1)
                            }

                            function Wx(Fe, At, St, xt) {
                                if ((St.isScene === !0 ? St.overrideMaterial : null) !== null) return;
                                J.state.transmissionRenderTarget[xt.id] === void 0 && (J.state.transmissionRenderTarget[xt.id] = new os(1, 1, {
                                    generateMipmaps: !0,
                                    type: Ot.has("EXT_color_buffer_half_float") || Ot.has("EXT_color_buffer_float") ? Hi : pr,
                                    minFilter: Zi,
                                    samples: 4,
                                    stencilBuffer: u,
                                    resolveDepthBuffer: !1,
                                    resolveStencilBuffer: !1
                                }));
                                const Dn = J.state.transmissionRenderTarget[xt.id], si = xt.viewport || Je;
                                Dn.setSize(si.z, si.w);
                                const ui = ge.getRenderTarget();
                                ge.setRenderTarget(Dn), ge.getClearColor(pt), Mt = ge.getClearAlpha(), Mt < 1 && ge.setClearColor(16777215, .5), ge.clear();
                                const wi = ge.toneMapping;
                                ge.toneMapping = cr;
                                const Fi = xt.viewport;
                                if (xt.viewport !== void 0 && (xt.viewport = void 0), J.setupLightsView(xt), Cr === !0 && Xt.setGlobalState(ge.clippingPlanes, xt), Lg(Fe, St, xt), Fn.updateMultisampleRenderTarget(Dn), Fn.updateRenderTargetMipmap(Dn), Ot.has("WEBGL_multisampled_render_to_texture") === !1) {
                                    let ji = !1;
                                    for (let er = 0, Ys = At.length; er < Ys; er++) {
                                        const zo = At[er], Da = zo.object, Au = zo.geometry, Ir = zo.material,
                                            Dc = zo.group;
                                        if (Ir.side === N && Da.layers.test(xt.layers)) {
                                            const Yi = Ir.side;
                                            Ir.side = O, Ir.needsUpdate = !0, Kx(Da, St, xt, Au, Ir, Dc), Ir.side = Yi, Ir.needsUpdate = !0, ji = !0
                                        }
                                    }
                                    ji === !0 && (Fn.updateMultisampleRenderTarget(Dn), Fn.updateRenderTargetMipmap(Dn))
                                }
                                ge.setRenderTarget(ui), ge.setClearColor(pt, Mt), Fi !== void 0 && (xt.viewport = Fi), ge.toneMapping = wi
                            }

                            function Lg(Fe, At, St) {
                                const xt = At.isScene === !0 ? At.overrideMaterial : null;
                                for (let bt = 0, Dn = Fe.length; bt < Dn; bt++) {
                                    const si = Fe[bt], ui = si.object, wi = si.geometry,
                                        Fi = xt === null ? si.material : xt, ji = si.group;
                                    ui.layers.test(St.layers) && Kx(ui, At, St, wi, Fi, ji)
                                }
                            }

                            function Kx(Fe, At, St, xt, bt, Dn) {
                                Fe.onBeforeRender(ge, At, St, xt, bt, Dn), Fe.modelViewMatrix.multiplyMatrices(St.matrixWorldInverse, Fe.matrixWorld), Fe.normalMatrix.getNormalMatrix(Fe.modelViewMatrix), bt.onBeforeRender(ge, At, St, xt, Fe, Dn), bt.transparent === !0 && bt.side === N && bt.forceSinglePass === !1 ? (bt.side = O, bt.needsUpdate = !0, ge.renderBufferDirect(St, At, xt, bt, Fe, Dn), bt.side = L, bt.needsUpdate = !0, ge.renderBufferDirect(St, At, xt, bt, Fe, Dn), bt.side = N) : ge.renderBufferDirect(St, At, xt, bt, Fe, Dn), Fe.onAfterRender(ge, At, St, xt, bt, Dn)
                            }

                            function Dg(Fe, At, St) {
                                At.isScene !== !0 && (At = vn);
                                const xt = Tn.get(Fe), bt = J.state.lights, Dn = J.state.shadowsArray,
                                    si = bt.state.version, ui = Ye.getParameters(Fe, bt.state, Dn, At, St),
                                    wi = Ye.getProgramCacheKey(ui);
                                let Fi = xt.programs;
                                xt.environment = Fe.isMeshStandardMaterial ? At.environment : null, xt.fog = At.fog, xt.envMap = (Fe.isMeshStandardMaterial ? Di : Bi).get(Fe.envMap || xt.environment), xt.envMapRotation = xt.environment !== null && Fe.envMap === null ? At.environmentRotation : Fe.envMapRotation, Fi === void 0 && (Fe.addEventListener("dispose", zi), Fi = new Map, xt.programs = Fi);
                                let ji = Fi.get(wi);
                                if (ji !== void 0) {
                                    if (xt.currentProgram === ji && xt.lightsStateVersion === si) return Yx(Fe, ui), ji
                                } else ui.uniforms = Ye.getUniforms(Fe), Fe.onBuild(St, ui, ge), Fe.onBeforeCompile(ui, ge), ji = Ye.acquireProgram(ui, wi), Fi.set(wi, ji), xt.uniforms = ui.uniforms;
                                const er = xt.uniforms;
                                return (!Fe.isShaderMaterial && !Fe.isRawShaderMaterial || Fe.clipping === !0) && (er.clippingPlanes = Xt.uniform), Yx(Fe, ui), xt.needsLights = m3(Fe), xt.lightsStateVersion = si, xt.needsLights && (er.ambientLightColor.value = bt.state.ambient, er.lightProbe.value = bt.state.probe, er.directionalLights.value = bt.state.directional, er.directionalLightShadows.value = bt.state.directionalShadow, er.spotLights.value = bt.state.spot, er.spotLightShadows.value = bt.state.spotShadow, er.rectAreaLights.value = bt.state.rectArea, er.ltc_1.value = bt.state.rectAreaLTC1, er.ltc_2.value = bt.state.rectAreaLTC2, er.pointLights.value = bt.state.point, er.pointLightShadows.value = bt.state.pointShadow, er.hemisphereLights.value = bt.state.hemi, er.directionalShadowMap.value = bt.state.directionalShadowMap, er.directionalShadowMatrix.value = bt.state.directionalShadowMatrix, er.spotShadowMap.value = bt.state.spotShadowMap, er.spotLightMatrix.value = bt.state.spotLightMatrix, er.spotLightMap.value = bt.state.spotLightMap, er.pointShadowMap.value = bt.state.pointShadowMap, er.pointShadowMatrix.value = bt.state.pointShadowMatrix), xt.currentProgram = ji, xt.uniformsList = null, ji
                            }

                            function Xx(Fe) {
                                if (Fe.uniformsList === null) {
                                    const At = Fe.currentProgram.getUniforms();
                                    Fe.uniformsList = FA.seqWithValue(At.seq, Fe.uniforms)
                                }
                                return Fe.uniformsList
                            }

                            function Yx(Fe, At) {
                                const St = Tn.get(Fe);
                                St.outputColorSpace = At.outputColorSpace, St.batching = At.batching, St.instancing = At.instancing, St.instancingColor = At.instancingColor, St.instancingMorph = At.instancingMorph, St.skinning = At.skinning, St.morphTargets = At.morphTargets, St.morphNormals = At.morphNormals, St.morphColors = At.morphColors, St.morphTargetsCount = At.morphTargetsCount, St.numClippingPlanes = At.numClippingPlanes, St.numIntersection = At.numClipIntersection, St.vertexAlphas = At.vertexAlphas, St.vertexTangents = At.vertexTangents, St.toneMapping = At.toneMapping, St.numMultiviewViews = At.numMultiviewViews
                            }

                            function f3(Fe, At, St, xt, bt) {
                                At.isScene !== !0 && (At = vn), Fn.resetTextureUnits();
                                const Dn = At.fog, si = xt.isMeshStandardMaterial ? At.environment : null,
                                    ui = qe === null ? ge.outputColorSpace : qe.isXRRenderTarget === !0 ? qe.texture.colorSpace : Gs,
                                    wi = (xt.isMeshStandardMaterial ? Di : Bi).get(xt.envMap || si),
                                    Fi = xt.vertexColors === !0 && !!St.attributes.color && St.attributes.color.itemSize === 4,
                                    ji = !!St.attributes.tangent && (!!xt.normalMap || xt.anisotropy > 0),
                                    er = !!St.morphAttributes.position, Ys = !!St.morphAttributes.normal,
                                    zo = !!St.morphAttributes.color;
                                let Da = cr;
                                xt.toneMapped && (qe === null || qe.isXRRenderTarget === !0) && (Da = ge.toneMapping);
                                const Au = qe && qe.isWebGLMultiviewRenderTarget ? qe.numViews : 0,
                                    Ir = St.morphAttributes.position || St.morphAttributes.normal || St.morphAttributes.color,
                                    Dc = Ir !== void 0 ? Ir.length : 0, Yi = Tn.get(xt), A3 = J.state.lights;
                                if (Cr === !0 && (Vr === !0 || Fe !== Te)) {
                                    const el = Fe === Te && xt.id === Pe;
                                    Xt.setState(xt, Fe, el)
                                }
                                let Zr = !1;
                                xt.version === Yi.__version ? (Yi.needsLights && Yi.lightsStateVersion !== A3.state.version || Yi.outputColorSpace !== ui || bt.isBatchedMesh && Yi.batching === !1 || !bt.isBatchedMesh && Yi.batching === !0 || bt.isInstancedMesh && Yi.instancing === !1 || !bt.isInstancedMesh && Yi.instancing === !0 || bt.isSkinnedMesh && Yi.skinning === !1 || !bt.isSkinnedMesh && Yi.skinning === !0 || bt.isInstancedMesh && Yi.instancingColor === !0 && bt.instanceColor === null || bt.isInstancedMesh && Yi.instancingColor === !1 && bt.instanceColor !== null || bt.isInstancedMesh && Yi.instancingMorph === !0 && bt.morphTexture === null || bt.isInstancedMesh && Yi.instancingMorph === !1 && bt.morphTexture !== null || Yi.envMap !== wi || xt.fog === !0 && Yi.fog !== Dn || Yi.numClippingPlanes !== void 0 && (Yi.numClippingPlanes !== Xt.numPlanes || Yi.numIntersection !== Xt.numIntersection) || Yi.vertexAlphas !== Fi || Yi.vertexTangents !== ji || Yi.morphTargets !== er || Yi.morphNormals !== Ys || Yi.morphColors !== zo || Yi.toneMapping !== Da || Yi.morphTargetsCount !== Dc || Yi.numMultiviewViews !== Au) && (Zr = !0) : (Zr = !0, Yi.__version = xt.version);
                                let Pc = Yi.currentProgram;
                                Zr === !0 && (Pc = Dg(xt, At, bt));
                                let qx = !1, Kp = !1, ny = !1;
                                const oo = Pc.getUniforms(), gu = Yi.uniforms;
                                if (on.useProgram(Pc.program) && (qx = !0, Kp = !0, ny = !0), xt.id !== Pe && (Pe = xt.id, Kp = !0), qx || Te !== Fe) {
                                    Pc.numMultiviewViews > 0 ? (ei.updateCameraProjectionMatricesUniform(Fe, oo), ei.updateCameraViewMatricesUniform(Fe, oo)) : (oo.setValue(mt, "projectionMatrix", Fe.projectionMatrix), oo.setValue(mt, "viewMatrix", Fe.matrixWorldInverse));
                                    const el = oo.map.cameraPosition;
                                    el !== void 0 && el.setValue(mt, Ht.setFromMatrixPosition(Fe.matrixWorld)), ln.logarithmicDepthBuffer && oo.setValue(mt, "logDepthBufFC", 2 / (Math.log(Fe.far + 1) / Math.LN2)), (xt.isMeshPhongMaterial || xt.isMeshToonMaterial || xt.isMeshLambertMaterial || xt.isMeshBasicMaterial || xt.isMeshStandardMaterial || xt.isShaderMaterial) && oo.setValue(mt, "isOrthographic", Fe.isOrthographicCamera === !0), Te !== Fe && (Te = Fe, Kp = !0, ny = !0)
                                }
                                if (bt.isSkinnedMesh) {
                                    oo.setOptional(mt, bt, "bindMatrix"), oo.setOptional(mt, bt, "bindMatrixInverse");
                                    const el = bt.skeleton;
                                    el && (el.boneTexture === null && el.computeBoneTexture(), oo.setValue(mt, "boneTexture", el.boneTexture, Fn))
                                }
                                bt.isBatchedMesh && (oo.setOptional(mt, bt, "batchingTexture"), oo.setValue(mt, "batchingTexture", bt._matricesTexture, Fn));
                                const iy = St.morphAttributes;
                                if ((iy.position !== void 0 || iy.normal !== void 0 || iy.color !== void 0) && zn.update(bt, St, Pc), (Kp || Yi.receiveShadow !== bt.receiveShadow) && (Yi.receiveShadow = bt.receiveShadow, oo.setValue(mt, "receiveShadow", bt.receiveShadow)), xt.isMeshGouraudMaterial && xt.envMap !== null && (gu.envMap.value = wi, gu.flipEnvMap.value = wi.isCubeTexture && wi.isRenderTargetTexture === !1 ? -1 : 1), xt.isMeshStandardMaterial && xt.envMap === null && At.environment !== null && (gu.envMapIntensity.value = At.environmentIntensity), Kp && (oo.setValue(mt, "toneMappingExposure", ge.toneMappingExposure), Yi.needsLights && p3(gu, ny), Dn && xt.fog === !0 && Ie.refreshFogUniforms(gu, Dn), Ie.refreshMaterialUniforms(gu, xt, Tt, mn, J.state.transmissionRenderTarget[Fe.id]), FA.upload(mt, Xx(Yi), gu, Fn)), xt.isShaderMaterial && xt.uniformsNeedUpdate === !0 && (FA.upload(mt, Xx(Yi), gu, Fn), xt.uniformsNeedUpdate = !1), xt.isSpriteMaterial && oo.setValue(mt, "center", bt.center), Pc.numMultiviewViews > 0 ? ei.updateObjectMatricesUniforms(bt, Fe, oo) : (oo.setValue(mt, "modelViewMatrix", bt.modelViewMatrix), oo.setValue(mt, "normalMatrix", bt.normalMatrix)), oo.setValue(mt, "modelMatrix", bt.matrixWorld), xt.isShaderMaterial || xt.isRawShaderMaterial) {
                                    const el = xt.uniformsGroups;
                                    for (let ry = 0, g3 = el.length; ry < g3; ry++) {
                                        const Jx = el[ry];
                                        vi.update(Jx, Pc), vi.bind(Jx, Pc)
                                    }
                                }
                                return Pc
                            }

                            function p3(Fe, At) {
                                Fe.ambientLightColor.needsUpdate = At, Fe.lightProbe.needsUpdate = At, Fe.directionalLights.needsUpdate = At, Fe.directionalLightShadows.needsUpdate = At, Fe.pointLights.needsUpdate = At, Fe.pointLightShadows.needsUpdate = At, Fe.spotLights.needsUpdate = At, Fe.spotLightShadows.needsUpdate = At, Fe.rectAreaLights.needsUpdate = At, Fe.hemisphereLights.needsUpdate = At
                            }

                            function m3(Fe) {
                                return Fe.isMeshLambertMaterial || Fe.isMeshToonMaterial || Fe.isMeshPhongMaterial || Fe.isMeshStandardMaterial || Fe.isShadowMaterial || Fe.isShaderMaterial && Fe.lights === !0
                            }

                            this.setTexture2D = function () {
                                var Fe = !1;
                                return function (St, xt) {
                                    St && St.isWebGLRenderTarget && (Fe || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), Fe = !0), St = St.texture), Fn.setTexture2D(St, xt)
                                }
                            }(), this.getActiveCubeFace = function () {
                                return ze
                            }, this.getActiveMipmapLevel = function () {
                                return We
                            }, this.getRenderTarget = function () {
                                return qe
                            }, this.setRenderTargetTextures = function (Fe, At, St) {
                                Tn.get(Fe.texture).__webglTexture = At, Tn.get(Fe.depthTexture).__webglTexture = St;
                                const xt = Tn.get(Fe);
                                xt.__hasExternalTextures = !0, xt.__autoAllocateDepthBuffer = St === void 0, !xt.__autoAllocateDepthBuffer && (!qe || !qe.isWebGLMultiviewRenderTarget) && Ot.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), xt.__useRenderToTexture = !1)
                            }, this.setRenderTargetFramebuffer = function (Fe, At) {
                                const St = Tn.get(Fe);
                                St.__webglFramebuffer = At, St.__useDefaultFramebuffer = At === void 0
                            }, this.setRenderTarget = function (Fe, At = 0, St = 0) {
                                qe = Fe, ze = At, We = St;
                                let xt = !0, bt = null, Dn = !1, si = !1;
                                if (Fe) {
                                    const wi = Tn.get(Fe);
                                    wi.__useDefaultFramebuffer !== void 0 ? (on.bindFramebuffer(mt.FRAMEBUFFER, null), xt = !1) : wi.__webglFramebuffer === void 0 ? Fn.setupRenderTarget(Fe) : wi.__hasExternalTextures && Fn.rebindTextures(Fe, Tn.get(Fe.texture).__webglTexture, Tn.get(Fe.depthTexture).__webglTexture);
                                    const Fi = Fe.texture;
                                    (Fi.isData3DTexture || Fi.isDataArrayTexture || Fi.isCompressedArrayTexture) && (si = !0);
                                    const ji = Tn.get(Fe).__webglFramebuffer;
                                    Fe.isWebGLCubeRenderTarget ? (Array.isArray(ji[At]) ? bt = ji[At][St] : bt = ji[At], Dn = !0) : Fe.samples > 0 && Fn.useMultisampledRTT(Fe) === !1 ? bt = Tn.get(Fe).__webglMultisampledFramebuffer : Array.isArray(ji) ? bt = ji[St] : bt = ji, Je.copy(Fe.viewport), ht.copy(Fe.scissor), lt = Fe.scissorTest
                                } else Je.copy(Kn).multiplyScalar(Tt).floor(), ht.copy(Qi).multiplyScalar(Tt).floor(), lt = Tr;
                                if (on.bindFramebuffer(mt.FRAMEBUFFER, bt) && xt && on.drawBuffers(Fe, bt), on.viewport(Je), on.scissor(ht), on.setScissorTest(lt), Dn) {
                                    const wi = Tn.get(Fe.texture);
                                    mt.framebufferTexture2D(mt.FRAMEBUFFER, mt.COLOR_ATTACHMENT0, mt.TEXTURE_CUBE_MAP_POSITIVE_X + At, wi.__webglTexture, St)
                                } else if (si) {
                                    const wi = Tn.get(Fe.texture), Fi = At || 0;
                                    mt.framebufferTextureLayer(mt.FRAMEBUFFER, mt.COLOR_ATTACHMENT0, wi.__webglTexture, St || 0, Fi)
                                }
                                Pe = -1
                            }, this.readRenderTargetPixels = function (Fe, At, St, xt, bt, Dn, si) {
                                if (!(Fe && Fe.isWebGLRenderTarget)) {
                                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                    return
                                }
                                let ui = Tn.get(Fe).__webglFramebuffer;
                                if (Fe.isWebGLCubeRenderTarget && si !== void 0 && (ui = ui[si]), ui) {
                                    on.bindFramebuffer(mt.FRAMEBUFFER, ui);
                                    try {
                                        const wi = Fe.texture, Fi = wi.format, ji = wi.type;
                                        if (!ln.textureFormatReadable(Fi)) {
                                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                            return
                                        }
                                        if (!ln.textureTypeReadable(ji)) {
                                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                            return
                                        }
                                        At >= 0 && At <= Fe.width - xt && St >= 0 && St <= Fe.height - bt && mt.readPixels(At, St, xt, bt, ni.convert(Fi), ni.convert(ji), Dn)
                                    } finally {
                                        const wi = qe !== null ? Tn.get(qe).__webglFramebuffer : null;
                                        on.bindFramebuffer(mt.FRAMEBUFFER, wi)
                                    }
                                }
                            }, this.copyFramebufferToTexture = function (Fe, At, St = 0) {
                                const xt = Math.pow(2, -St), bt = Math.floor(At.image.width * xt),
                                    Dn = Math.floor(At.image.height * xt);
                                Fn.setTexture2D(At, 0), mt.copyTexSubImage2D(mt.TEXTURE_2D, St, 0, 0, Fe.x, Fe.y, bt, Dn), on.unbindTexture()
                            }, this.copyTextureToTexture = function (Fe, At, St, xt = 0) {
                                const bt = At.image.width, Dn = At.image.height, si = ni.convert(St.format),
                                    ui = ni.convert(St.type);
                                Fn.setTexture2D(St, 0), mt.pixelStorei(mt.UNPACK_FLIP_Y_WEBGL, St.flipY), mt.pixelStorei(mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, St.premultiplyAlpha), mt.pixelStorei(mt.UNPACK_ALIGNMENT, St.unpackAlignment), At.isDataTexture ? mt.texSubImage2D(mt.TEXTURE_2D, xt, Fe.x, Fe.y, bt, Dn, si, ui, At.image.data) : At.isCompressedTexture ? mt.compressedTexSubImage2D(mt.TEXTURE_2D, xt, Fe.x, Fe.y, At.mipmaps[0].width, At.mipmaps[0].height, si, At.mipmaps[0].data) : mt.texSubImage2D(mt.TEXTURE_2D, xt, Fe.x, Fe.y, si, ui, At.image), xt === 0 && St.generateMipmaps && mt.generateMipmap(mt.TEXTURE_2D), on.unbindTexture()
                            }, this.copyTextureToTexture3D = function (Fe, At, St, xt, bt = 0) {
                                const Dn = Fe.max.x - Fe.min.x, si = Fe.max.y - Fe.min.y, ui = Fe.max.z - Fe.min.z,
                                    wi = ni.convert(xt.format), Fi = ni.convert(xt.type);
                                let ji;
                                if (xt.isData3DTexture) Fn.setTexture3D(xt, 0), ji = mt.TEXTURE_3D; else if (xt.isDataArrayTexture || xt.isCompressedArrayTexture) Fn.setTexture2DArray(xt, 0), ji = mt.TEXTURE_2D_ARRAY; else {
                                    console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                                    return
                                }
                                mt.pixelStorei(mt.UNPACK_FLIP_Y_WEBGL, xt.flipY), mt.pixelStorei(mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, xt.premultiplyAlpha), mt.pixelStorei(mt.UNPACK_ALIGNMENT, xt.unpackAlignment);
                                const er = mt.getParameter(mt.UNPACK_ROW_LENGTH),
                                    Ys = mt.getParameter(mt.UNPACK_IMAGE_HEIGHT),
                                    zo = mt.getParameter(mt.UNPACK_SKIP_PIXELS),
                                    Da = mt.getParameter(mt.UNPACK_SKIP_ROWS),
                                    Au = mt.getParameter(mt.UNPACK_SKIP_IMAGES),
                                    Ir = St.isCompressedTexture ? St.mipmaps[bt] : St.image;
                                mt.pixelStorei(mt.UNPACK_ROW_LENGTH, Ir.width), mt.pixelStorei(mt.UNPACK_IMAGE_HEIGHT, Ir.height), mt.pixelStorei(mt.UNPACK_SKIP_PIXELS, Fe.min.x), mt.pixelStorei(mt.UNPACK_SKIP_ROWS, Fe.min.y), mt.pixelStorei(mt.UNPACK_SKIP_IMAGES, Fe.min.z), St.isDataTexture || St.isData3DTexture ? mt.texSubImage3D(ji, bt, At.x, At.y, At.z, Dn, si, ui, wi, Fi, Ir.data) : xt.isCompressedArrayTexture ? mt.compressedTexSubImage3D(ji, bt, At.x, At.y, At.z, Dn, si, ui, wi, Ir.data) : mt.texSubImage3D(ji, bt, At.x, At.y, At.z, Dn, si, ui, wi, Fi, Ir), mt.pixelStorei(mt.UNPACK_ROW_LENGTH, er), mt.pixelStorei(mt.UNPACK_IMAGE_HEIGHT, Ys), mt.pixelStorei(mt.UNPACK_SKIP_PIXELS, zo), mt.pixelStorei(mt.UNPACK_SKIP_ROWS, Da), mt.pixelStorei(mt.UNPACK_SKIP_IMAGES, Au), bt === 0 && xt.generateMipmaps && mt.generateMipmap(ji), on.unbindTexture()
                            }, this.initTexture = function (Fe) {
                                Fe.isCubeTexture ? Fn.setTextureCube(Fe, 0) : Fe.isData3DTexture ? Fn.setTexture3D(Fe, 0) : Fe.isDataArrayTexture || Fe.isCompressedArrayTexture ? Fn.setTexture2DArray(Fe, 0) : Fn.setTexture2D(Fe, 0), on.unbindTexture()
                            }, this.resetState = function () {
                                ze = 0, We = 0, qe = null, on.reset(), Ui.reset()
                            }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
                        }

                        get coordinateSystem() {
                            return da
                        }

                        get outputColorSpace() {
                            return this._outputColorSpace
                        }

                        set outputColorSpace(e) {
                            this._outputColorSpace = e;
                            const n = this.getContext();
                            n.drawingBufferColorSpace = e === bl ? "display-p3" : "srgb", n.unpackColorSpace = ur.workingColorSpace === ka ? "display-p3" : "srgb"
                        }

                        get useLegacyLights() {
                            return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
                        }

                        set useLegacyLights(e) {
                            console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e
                        }
                    }

                    class NA {
                        constructor(e, n = 25e-5) {
                            this.isFogExp2 = !0, this.name = "", this.color = new Bn(e), this.density = n
                        }

                        clone() {
                            return new NA(this.color, this.density)
                        }

                        toJSON() {
                            return {type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density}
                        }
                    }

                    class UA {
                        constructor(e, n = 1, r = 1e3) {
                            this.isFog = !0, this.name = "", this.color = new Bn(e), this.near = n, this.far = r
                        }

                        clone() {
                            return new UA(this.color, this.near, this.far)
                        }

                        toJSON() {
                            return {
                                type: "Fog",
                                name: this.name,
                                color: this.color.getHex(),
                                near: this.near,
                                far: this.far
                            }
                        }
                    }

                    class rE extends or {
                        constructor() {
                            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new bo, this.environmentIntensity = 1, this.environmentRotation = new bo, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
                        }

                        copy(e, n) {
                            return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n
                        }
                    }

                    class zA {
                        constructor(e, n) {
                            this.isInterleavedBuffer = !0, this.array = e, this.stride = n, this.count = e !== void 0 ? e.length / n : 0, this.usage = rl, this._updateRange = {
                                offset: 0,
                                count: -1
                            }, this.updateRanges = [], this.version = 0, this.uuid = uo()
                        }

                        onUploadCallback() {
                        }

                        set needsUpdate(e) {
                            e === !0 && this.version++
                        }

                        get updateRange() {
                            return nd("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
                        }

                        setUsage(e) {
                            return this.usage = e, this
                        }

                        addUpdateRange(e, n) {
                            this.updateRanges.push({start: e, count: n})
                        }

                        clearUpdateRanges() {
                            this.updateRanges.length = 0
                        }

                        copy(e) {
                            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                        }

                        copyAt(e, n, r) {
                            e *= this.stride, r *= n.stride;
                            for (let a = 0, u = this.stride; a < u; a++) this.array[e + a] = n.array[r + a];
                            return this
                        }

                        set(e, n = 0) {
                            return this.array.set(e, n), this
                        }

                        clone(e) {
                            e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = uo()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                            const n = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                                r = new this.constructor(n, this.stride);
                            return r.setUsage(this.usage), r
                        }

                        onUpload(e) {
                            return this.onUploadCallback = e, this
                        }

                        toJSON(e) {
                            return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = uo()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                                uuid: this.uuid,
                                buffer: this.array.buffer._uuid,
                                type: this.array.constructor.name,
                                stride: this.stride
                            }
                        }
                    }

                    const sa = new Ne;

                    class gh {
                        constructor(e, n, r, a = !1) {
                            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = n, this.offset = r, this.normalized = a
                        }

                        get count() {
                            return this.data.count
                        }

                        get array() {
                            return this.data.array
                        }

                        set needsUpdate(e) {
                            this.data.needsUpdate = e
                        }

                        applyMatrix4(e) {
                            for (let n = 0, r = this.data.count; n < r; n++) sa.fromBufferAttribute(this, n), sa.applyMatrix4(e), this.setXYZ(n, sa.x, sa.y, sa.z);
                            return this
                        }

                        applyNormalMatrix(e) {
                            for (let n = 0, r = this.count; n < r; n++) sa.fromBufferAttribute(this, n), sa.applyNormalMatrix(e), this.setXYZ(n, sa.x, sa.y, sa.z);
                            return this
                        }

                        transformDirection(e) {
                            for (let n = 0, r = this.count; n < r; n++) sa.fromBufferAttribute(this, n), sa.transformDirection(e), this.setXYZ(n, sa.x, sa.y, sa.z);
                            return this
                        }

                        getComponent(e, n) {
                            let r = this.array[e * this.data.stride + this.offset + n];
                            return this.normalized && (r = eo(r, this.array)), r
                        }

                        setComponent(e, n, r) {
                            return this.normalized && (r = Ri(r, this.array)), this.data.array[e * this.data.stride + this.offset + n] = r, this
                        }

                        setX(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.data.array[e * this.data.stride + this.offset] = n, this
                        }

                        setY(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = n, this
                        }

                        setZ(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = n, this
                        }

                        setW(e, n) {
                            return this.normalized && (n = Ri(n, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = n, this
                        }

                        getX(e) {
                            let n = this.data.array[e * this.data.stride + this.offset];
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        getY(e) {
                            let n = this.data.array[e * this.data.stride + this.offset + 1];
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        getZ(e) {
                            let n = this.data.array[e * this.data.stride + this.offset + 2];
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        getW(e) {
                            let n = this.data.array[e * this.data.stride + this.offset + 3];
                            return this.normalized && (n = eo(n, this.array)), n
                        }

                        setXY(e, n, r) {
                            return e = e * this.data.stride + this.offset, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this
                        }

                        setXYZ(e, n, r, a) {
                            return e = e * this.data.stride + this.offset, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array), a = Ri(a, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this.data.array[e + 2] = a, this
                        }

                        setXYZW(e, n, r, a, u) {
                            return e = e * this.data.stride + this.offset, this.normalized && (n = Ri(n, this.array), r = Ri(r, this.array), a = Ri(a, this.array), u = Ri(u, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this.data.array[e + 2] = a, this.data.array[e + 3] = u, this
                        }

                        clone(e) {
                            if (e === void 0) {
                                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                                const n = [];
                                for (let r = 0; r < this.count; r++) {
                                    const a = r * this.data.stride + this.offset;
                                    for (let u = 0; u < this.itemSize; u++) n.push(this.data.array[a + u])
                                }
                                return new Er(new this.array.constructor(n), this.itemSize, this.normalized)
                            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new gh(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                        }

                        toJSON(e) {
                            if (e === void 0) {
                                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                                const n = [];
                                for (let r = 0; r < this.count; r++) {
                                    const a = r * this.data.stride + this.offset;
                                    for (let u = 0; u < this.itemSize; u++) n.push(this.data.array[a + u])
                                }
                                return {
                                    itemSize: this.itemSize,
                                    type: this.array.constructor.name,
                                    array: n,
                                    normalized: this.normalized
                                }
                            } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                        }
                    }

                    class Av extends Dr {
                        constructor(e) {
                            super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Bn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                        }
                    }

                    let Bd;
                    const _p = new Ne, Ld = new Ne, Dd = new Ne, Pd = new zt, Mp = new zt, sE = new Mn, GA = new Ne,
                        Sp = new Ne, VA = new Ne, oE = new zt, gv = new zt, aE = new zt;

                    class lE extends or {
                        constructor(e = new Av) {
                            if (super(), this.isSprite = !0, this.type = "Sprite", Bd === void 0) {
                                Bd = new Ti;
                                const n = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                                    r = new zA(n, 5);
                                Bd.setIndex([0, 1, 2, 0, 2, 3]), Bd.setAttribute("position", new gh(r, 3, 0, !1)), Bd.setAttribute("uv", new gh(r, 2, 3, !1))
                            }
                            this.geometry = Bd, this.material = e, this.center = new zt(.5, .5)
                        }

                        raycast(e, n) {
                            e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ld.setFromMatrixScale(this.matrixWorld), sE.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Dd.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Ld.multiplyScalar(-Dd.z);
                            const r = this.material.rotation;
                            let a, u;
                            r !== 0 && (u = Math.cos(r), a = Math.sin(r));
                            const y = this.center;
                            HA(GA.set(-.5, -.5, 0), Dd, y, Ld, a, u), HA(Sp.set(.5, -.5, 0), Dd, y, Ld, a, u), HA(VA.set(.5, .5, 0), Dd, y, Ld, a, u), oE.set(0, 0), gv.set(1, 0), aE.set(1, 1);
                            let S = e.ray.intersectTriangle(GA, Sp, VA, !1, _p);
                            if (S === null && (HA(Sp.set(-.5, .5, 0), Dd, y, Ld, a, u), gv.set(0, 1), S = e.ray.intersectTriangle(GA, VA, Sp, !1, _p), S === null)) return;
                            const D = e.ray.origin.distanceTo(_p);
                            D < e.near || D > e.far || n.push({
                                distance: D,
                                point: _p.clone(),
                                uv: Bs.getInterpolation(_p, GA, Sp, VA, oE, gv, aE, new zt),
                                face: null,
                                object: this
                            })
                        }

                        copy(e, n) {
                            return super.copy(e, n), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
                        }
                    }

                    function HA(d, e, n, r, a, u) {
                        Pd.subVectors(d, n).addScalar(.5).multiply(r), a !== void 0 ? (Mp.x = u * Pd.x - a * Pd.y, Mp.y = a * Pd.x + u * Pd.y) : Mp.copy(Pd), d.copy(e), d.x += Mp.x, d.y += Mp.y, d.applyMatrix4(sE)
                    }

                    const QA = new Ne, cE = new Ne;

                    class uE extends or {
                        constructor() {
                            super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                                levels: {
                                    enumerable: !0,
                                    value: []
                                }, isLOD: {value: !0}
                            }), this.autoUpdate = !0
                        }

                        copy(e) {
                            super.copy(e, !1);
                            const n = e.levels;
                            for (let r = 0, a = n.length; r < a; r++) {
                                const u = n[r];
                                this.addLevel(u.object.clone(), u.distance, u.hysteresis)
                            }
                            return this.autoUpdate = e.autoUpdate, this
                        }

                        addLevel(e, n = 0, r = 0) {
                            n = Math.abs(n);
                            const a = this.levels;
                            let u;
                            for (u = 0; u < a.length && !(n < a[u].distance); u++) ;
                            return a.splice(u, 0, {distance: n, hysteresis: r, object: e}), this.add(e), this
                        }

                        getCurrentLevel() {
                            return this._currentLevel
                        }

                        getObjectForDistance(e) {
                            const n = this.levels;
                            if (n.length > 0) {
                                let r, a;
                                for (r = 1, a = n.length; r < a; r++) {
                                    let u = n[r].distance;
                                    if (n[r].object.visible && (u -= u * n[r].hysteresis), e < u) break
                                }
                                return n[r - 1].object
                            }
                            return null
                        }

                        raycast(e, n) {
                            if (this.levels.length > 0) {
                                QA.setFromMatrixPosition(this.matrixWorld);
                                const a = e.ray.origin.distanceTo(QA);
                                this.getObjectForDistance(a).raycast(e, n)
                            }
                        }

                        update(e) {
                            const n = this.levels;
                            if (n.length > 1) {
                                QA.setFromMatrixPosition(e.matrixWorld), cE.setFromMatrixPosition(this.matrixWorld);
                                const r = QA.distanceTo(cE) / e.zoom;
                                n[0].object.visible = !0;
                                let a, u;
                                for (a = 1, u = n.length; a < u; a++) {
                                    let y = n[a].distance;
                                    if (n[a].object.visible && (y -= y * n[a].hysteresis), r >= y) n[a - 1].object.visible = !1, n[a].object.visible = !0; else break
                                }
                                for (this._currentLevel = a - 1; a < u; a++) n[a].object.visible = !1
                            }
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            this.autoUpdate === !1 && (n.object.autoUpdate = !1), n.object.levels = [];
                            const r = this.levels;
                            for (let a = 0, u = r.length; a < u; a++) {
                                const y = r[a];
                                n.object.levels.push({
                                    object: y.object.uuid,
                                    distance: y.distance,
                                    hysteresis: y.hysteresis
                                })
                            }
                            return n
                        }
                    }

                    const hE = new Ne, dE = new ar, fE = new ar, E_ = new Ne, pE = new Mn, jA = new Ne, vv = new as,
                        mE = new Mn, yv = new jr;

                    class AE extends Wr {
                        constructor(e, n) {
                            super(e, n), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Le, this.bindMatrix = new Mn, this.bindMatrixInverse = new Mn, this.boundingBox = null, this.boundingSphere = null
                        }

                        computeBoundingBox() {
                            const e = this.geometry;
                            this.boundingBox === null && (this.boundingBox = new Ei), this.boundingBox.makeEmpty();
                            const n = e.getAttribute("position");
                            for (let r = 0; r < n.count; r++) this.getVertexPosition(r, jA), this.boundingBox.expandByPoint(jA)
                        }

                        computeBoundingSphere() {
                            const e = this.geometry;
                            this.boundingSphere === null && (this.boundingSphere = new as), this.boundingSphere.makeEmpty();
                            const n = e.getAttribute("position");
                            for (let r = 0; r < n.count; r++) this.getVertexPosition(r, jA), this.boundingSphere.expandByPoint(jA)
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
                        }

                        raycast(e, n) {
                            const r = this.material, a = this.matrixWorld;
                            r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), vv.copy(this.boundingSphere), vv.applyMatrix4(a), e.ray.intersectsSphere(vv) !== !1 && (mE.copy(a).invert(), yv.copy(e.ray).applyMatrix4(mE), !(this.boundingBox !== null && yv.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, n, yv)))
                        }

                        getVertexPosition(e, n) {
                            return super.getVertexPosition(e, n), this.applyBoneTransform(e, n), n
                        }

                        bind(e, n) {
                            this.skeleton = e, n === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), n = this.matrixWorld), this.bindMatrix.copy(n), this.bindMatrixInverse.copy(n).invert()
                        }

                        pose() {
                            this.skeleton.pose()
                        }

                        normalizeSkinWeights() {
                            const e = new ar, n = this.geometry.attributes.skinWeight;
                            for (let r = 0, a = n.count; r < a; r++) {
                                e.fromBufferAttribute(n, r);
                                const u = 1 / e.manhattanLength();
                                u !== 1 / 0 ? e.multiplyScalar(u) : e.set(1, 0, 0, 0), n.setXYZW(r, e.x, e.y, e.z, e.w)
                            }
                        }

                        updateMatrixWorld(e) {
                            super.updateMatrixWorld(e), this.bindMode === Le ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Ue ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                        }

                        applyBoneTransform(e, n) {
                            const r = this.skeleton, a = this.geometry;
                            dE.fromBufferAttribute(a.attributes.skinIndex, e), fE.fromBufferAttribute(a.attributes.skinWeight, e), hE.copy(n).applyMatrix4(this.bindMatrix), n.set(0, 0, 0);
                            for (let u = 0; u < 4; u++) {
                                const y = fE.getComponent(u);
                                if (y !== 0) {
                                    const S = dE.getComponent(u);
                                    pE.multiplyMatrices(r.bones[S].matrixWorld, r.boneInverses[S]), n.addScaledVector(E_.copy(hE).applyMatrix4(pE), y)
                                }
                            }
                            return n.applyMatrix4(this.bindMatrixInverse)
                        }
                    }

                    class Ev extends or {
                        constructor() {
                            super(), this.isBone = !0, this.type = "Bone"
                        }
                    }

                    class uu extends Lr {
                        constructor(e = null, n = 1, r = 1, a, u, y, S, D, P = cn, z = cn, Q, K) {
                            super(null, y, S, D, P, z, a, u, Q, K), this.isDataTexture = !0, this.image = {
                                data: e,
                                width: n,
                                height: r
                            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                        }
                    }

                    const gE = new Mn, x_ = new Mn;

                    class WA {
                        constructor(e = [], n = []) {
                            this.uuid = uo(), this.bones = e.slice(0), this.boneInverses = n, this.boneMatrices = null, this.boneTexture = null, this.init()
                        }

                        init() {
                            const e = this.bones, n = this.boneInverses;
                            if (this.boneMatrices = new Float32Array(e.length * 16), n.length === 0) this.calculateInverses(); else if (e.length !== n.length) {
                                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                                for (let r = 0, a = this.bones.length; r < a; r++) this.boneInverses.push(new Mn)
                            }
                        }

                        calculateInverses() {
                            this.boneInverses.length = 0;
                            for (let e = 0, n = this.bones.length; e < n; e++) {
                                const r = new Mn;
                                this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r)
                            }
                        }

                        pose() {
                            for (let e = 0, n = this.bones.length; e < n; e++) {
                                const r = this.bones[e];
                                r && r.matrixWorld.copy(this.boneInverses[e]).invert()
                            }
                            for (let e = 0, n = this.bones.length; e < n; e++) {
                                const r = this.bones[e];
                                r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale))
                            }
                        }

                        update() {
                            const e = this.bones, n = this.boneInverses, r = this.boneMatrices, a = this.boneTexture;
                            for (let u = 0, y = e.length; u < y; u++) {
                                const S = e[u] ? e[u].matrixWorld : x_;
                                gE.multiplyMatrices(S, n[u]), gE.toArray(r, u * 16)
                            }
                            a !== null && (a.needsUpdate = !0)
                        }

                        clone() {
                            return new WA(this.bones, this.boneInverses)
                        }

                        computeBoneTexture() {
                            let e = Math.sqrt(this.bones.length * 4);
                            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
                            const n = new Float32Array(e * e * 4);
                            n.set(this.boneMatrices);
                            const r = new uu(n, e, e, Ke, kr);
                            return r.needsUpdate = !0, this.boneMatrices = n, this.boneTexture = r, this
                        }

                        getBoneByName(e) {
                            for (let n = 0, r = this.bones.length; n < r; n++) {
                                const a = this.bones[n];
                                if (a.name === e) return a
                            }
                        }

                        dispose() {
                            this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
                        }

                        fromJSON(e, n) {
                            this.uuid = e.uuid;
                            for (let r = 0, a = e.bones.length; r < a; r++) {
                                const u = e.bones[r];
                                let y = n[u];
                                y === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", u), y = new Ev), this.bones.push(y), this.boneInverses.push(new Mn().fromArray(e.boneInverses[r]))
                            }
                            return this.init(), this
                        }

                        toJSON() {
                            const e = {
                                metadata: {version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON"},
                                bones: [],
                                boneInverses: []
                            };
                            e.uuid = this.uuid;
                            const n = this.bones, r = this.boneInverses;
                            for (let a = 0, u = n.length; a < u; a++) {
                                const y = n[a];
                                e.bones.push(y.uuid);
                                const S = r[a];
                                e.boneInverses.push(S.toArray())
                            }
                            return e
                        }
                    }

                    class Od extends Er {
                        constructor(e, n, r, a = 1) {
                            super(e, n, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = a
                        }

                        copy(e) {
                            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                        }
                    }

                    const kd = new Mn, vE = new Mn, KA = [], yE = new Ei, C_ = new Mn, Tp = new Wr, Ip = new as;

                    class EE extends Wr {
                        constructor(e, n, r) {
                            super(e, n), this.isInstancedMesh = !0, this.instanceMatrix = new Od(new Float32Array(r * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = r, this.boundingBox = null, this.boundingSphere = null;
                            for (let a = 0; a < r; a++) this.setMatrixAt(a, C_)
                        }

                        computeBoundingBox() {
                            const e = this.geometry, n = this.count;
                            this.boundingBox === null && (this.boundingBox = new Ei), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                            for (let r = 0; r < n; r++) this.getMatrixAt(r, kd), yE.copy(e.boundingBox).applyMatrix4(kd), this.boundingBox.union(yE)
                        }

                        computeBoundingSphere() {
                            const e = this.geometry, n = this.count;
                            this.boundingSphere === null && (this.boundingSphere = new as), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                            for (let r = 0; r < n; r++) this.getMatrixAt(r, kd), Ip.copy(e.boundingSphere).applyMatrix4(kd), this.boundingSphere.union(Ip)
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
                        }

                        getColorAt(e, n) {
                            n.fromArray(this.instanceColor.array, e * 3)
                        }

                        getMatrixAt(e, n) {
                            n.fromArray(this.instanceMatrix.array, e * 16)
                        }

                        getMorphAt(e, n) {
                            const r = n.morphTargetInfluences, a = this.morphTexture.source.data.data, u = r.length + 1,
                                y = e * u + 1;
                            for (let S = 0; S < r.length; S++) r[S] = a[y + S]
                        }

                        raycast(e, n) {
                            const r = this.matrixWorld, a = this.count;
                            if (Tp.geometry = this.geometry, Tp.material = this.material, Tp.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ip.copy(this.boundingSphere), Ip.applyMatrix4(r), e.ray.intersectsSphere(Ip) !== !1)) for (let u = 0; u < a; u++) {
                                this.getMatrixAt(u, kd), vE.multiplyMatrices(r, kd), Tp.matrixWorld = vE, Tp.raycast(e, KA);
                                for (let y = 0, S = KA.length; y < S; y++) {
                                    const D = KA[y];
                                    D.instanceId = u, D.object = this, n.push(D)
                                }
                                KA.length = 0
                            }
                        }

                        setColorAt(e, n) {
                            this.instanceColor === null && (this.instanceColor = new Od(new Float32Array(this.instanceMatrix.count * 3), 3)), n.toArray(this.instanceColor.array, e * 3)
                        }

                        setMatrixAt(e, n) {
                            n.toArray(this.instanceMatrix.array, e * 16)
                        }

                        setMorphAt(e, n) {
                            const r = n.morphTargetInfluences, a = r.length + 1;
                            this.morphTexture === null && (this.morphTexture = new uu(new Float32Array(a * this.count), a, this.count, Kt, kr));
                            const u = this.morphTexture.source.data.data;
                            let y = 0;
                            for (let P = 0; P < r.length; P++) y += r[P];
                            const S = this.geometry.morphTargetsRelative ? 1 : 1 - y, D = a * e;
                            u[D] = S, u.set(r, D + 1)
                        }

                        updateMorphTargets() {
                        }

                        dispose() {
                            return this.dispatchEvent({type: "dispose"}), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this
                        }
                    }

                    function w_(d, e) {
                        return d.z - e.z
                    }

                    function b_(d, e) {
                        return e.z - d.z
                    }

                    class __ {
                        constructor() {
                            this.index = 0, this.pool = [], this.list = []
                        }

                        push(e, n) {
                            const r = this.pool, a = this.list;
                            this.index >= r.length && r.push({start: -1, count: -1, z: -1});
                            const u = r[this.index];
                            a.push(u), this.index++, u.start = e.start, u.count = e.count, u.z = n
                        }

                        reset() {
                            this.list.length = 0, this.index = 0
                        }
                    }

                    const Fd = "batchId", hu = new Mn, xE = new Mn, M_ = new Mn, CE = new Mn, xv = new Ec, XA = new Ei,
                        vh = new as, Rp = new Ne, Cv = new __, Uo = new Wr, YA = [];

                    function S_(d, e, n = 0) {
                        const r = e.itemSize;
                        if (d.isInterleavedBufferAttribute || d.array.constructor !== e.array.constructor) {
                            const a = d.count;
                            for (let u = 0; u < a; u++) for (let y = 0; y < r; y++) e.setComponent(u + n, y, d.getComponent(u, y))
                        } else e.array.set(d.array, n * r);
                        e.needsUpdate = !0
                    }

                    class wE extends Wr {
                        get maxGeometryCount() {
                            return this._maxGeometryCount
                        }

                        constructor(e, n, r = n * 2, a) {
                            super(new Ti, a), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = n, this._maxIndexCount = r, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture()
                        }

                        _initMatricesTexture() {
                            let e = Math.sqrt(this._maxGeometryCount * 4);
                            e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
                            const n = new Float32Array(e * e * 4), r = new uu(n, e, e, Ke, kr);
                            this._matricesTexture = r
                        }

                        _initializeGeometry(e) {
                            const n = this.geometry, r = this._maxVertexCount, a = this._maxGeometryCount,
                                u = this._maxIndexCount;
                            if (this._geometryInitialized === !1) {
                                for (const S in e.attributes) {
                                    const D = e.getAttribute(S), {array: P, itemSize: z, normalized: Q} = D,
                                        K = new P.constructor(r * z), q = new Er(K, z, Q);
                                    n.setAttribute(S, q)
                                }
                                if (e.getIndex() !== null) {
                                    const S = r > 65536 ? new Uint32Array(u) : new Uint16Array(u);
                                    n.setIndex(new Er(S, 1))
                                }
                                const y = a > 65536 ? new Uint32Array(r) : new Uint16Array(r);
                                n.setAttribute(Fd, new Er(y, 1)), this._geometryInitialized = !0
                            }
                        }

                        _validateGeometry(e) {
                            if (e.getAttribute(Fd)) throw new Error(`BatchedMesh: Geometry cannot use attribute "${Fd}"`);
                            const n = this.geometry;
                            if (!!e.getIndex() != !!n.getIndex()) throw new Error('BatchedMesh: All geometries must consistently have "index".');
                            for (const r in n.attributes) {
                                if (r === Fd) continue;
                                if (!e.hasAttribute(r)) throw new Error(`BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`);
                                const a = e.getAttribute(r), u = n.getAttribute(r);
                                if (a.itemSize !== u.itemSize || a.normalized !== u.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                            }
                        }

                        setCustomSort(e) {
                            return this.customSort = e, this
                        }

                        computeBoundingBox() {
                            this.boundingBox === null && (this.boundingBox = new Ei);
                            const e = this._geometryCount, n = this.boundingBox, r = this._active;
                            n.makeEmpty();
                            for (let a = 0; a < e; a++) r[a] !== !1 && (this.getMatrixAt(a, hu), this.getBoundingBoxAt(a, XA).applyMatrix4(hu), n.union(XA))
                        }

                        computeBoundingSphere() {
                            this.boundingSphere === null && (this.boundingSphere = new as);
                            const e = this._geometryCount, n = this.boundingSphere, r = this._active;
                            n.makeEmpty();
                            for (let a = 0; a < e; a++) r[a] !== !1 && (this.getMatrixAt(a, hu), this.getBoundingSphereAt(a, vh).applyMatrix4(hu), n.union(vh))
                        }

                        addGeometry(e, n = -1, r = -1) {
                            if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
                            const a = {vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1};
                            let u = null;
                            const y = this._reservedRanges, S = this._drawRanges, D = this._bounds;
                            this._geometryCount !== 0 && (u = y[y.length - 1]), n === -1 ? a.vertexCount = e.getAttribute("position").count : a.vertexCount = n, u === null ? a.vertexStart = 0 : a.vertexStart = u.vertexStart + u.vertexCount;
                            const P = e.getIndex(), z = P !== null;
                            if (z && (r === -1 ? a.indexCount = P.count : a.indexCount = r, u === null ? a.indexStart = 0 : a.indexStart = u.indexStart + u.indexCount), a.indexStart !== -1 && a.indexStart + a.indexCount > this._maxIndexCount || a.vertexStart + a.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                            const Q = this._visibility, K = this._active, q = this._matricesTexture,
                                te = this._matricesTexture.image.data;
                            Q.push(!0), K.push(!0);
                            const le = this._geometryCount;
                            this._geometryCount++, M_.toArray(te, le * 16), q.needsUpdate = !0, y.push(a), S.push({
                                start: z ? a.indexStart : a.vertexStart,
                                count: -1
                            }), D.push({boxInitialized: !1, box: new Ei, sphereInitialized: !1, sphere: new as});
                            const ne = this.geometry.getAttribute(Fd);
                            for (let J = 0; J < a.vertexCount; J++) ne.setX(a.vertexStart + J, le);
                            return ne.needsUpdate = !0, this.setGeometryAt(le, e), le
                        }

                        setGeometryAt(e, n) {
                            if (e >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
                            this._validateGeometry(n);
                            const r = this.geometry, a = r.getIndex() !== null, u = r.getIndex(), y = n.getIndex(),
                                S = this._reservedRanges[e];
                            if (a && y.count > S.indexCount || n.attributes.position.count > S.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
                            const D = S.vertexStart, P = S.vertexCount;
                            for (const q in r.attributes) {
                                if (q === Fd) continue;
                                const te = n.getAttribute(q), le = r.getAttribute(q);
                                S_(te, le, D);
                                const ne = te.itemSize;
                                for (let J = te.count, Ce = P; J < Ce; J++) {
                                    const ye = D + J;
                                    for (let ge = 0; ge < ne; ge++) le.setComponent(ye, ge, 0)
                                }
                                le.needsUpdate = !0, le.addUpdateRange(D * ne, P * ne)
                            }
                            if (a) {
                                const q = S.indexStart;
                                for (let te = 0; te < y.count; te++) u.setX(q + te, D + y.getX(te));
                                for (let te = y.count, le = S.indexCount; te < le; te++) u.setX(q + te, D);
                                u.needsUpdate = !0, u.addUpdateRange(q, S.indexCount)
                            }
                            const z = this._bounds[e];
                            n.boundingBox !== null ? (z.box.copy(n.boundingBox), z.boxInitialized = !0) : z.boxInitialized = !1, n.boundingSphere !== null ? (z.sphere.copy(n.boundingSphere), z.sphereInitialized = !0) : z.sphereInitialized = !1;
                            const Q = this._drawRanges[e], K = n.getAttribute("position");
                            return Q.count = a ? y.count : K.count, this._visibilityChanged = !0, e
                        }

                        deleteGeometry(e) {
                            const n = this._active;
                            return e >= n.length || n[e] === !1 ? this : (n[e] = !1, this._visibilityChanged = !0, this)
                        }

                        getInstanceCountAt(e) {
                            return this._multiDrawInstances === null ? null : this._multiDrawInstances[e]
                        }

                        setInstanceCountAt(e, n) {
                            return this._multiDrawInstances === null && (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(1)), this._multiDrawInstances[e] = n, e
                        }

                        getBoundingBoxAt(e, n) {
                            if (this._active[e] === !1) return null;
                            const a = this._bounds[e], u = a.box, y = this.geometry;
                            if (a.boxInitialized === !1) {
                                u.makeEmpty();
                                const S = y.index, D = y.attributes.position, P = this._drawRanges[e];
                                for (let z = P.start, Q = P.start + P.count; z < Q; z++) {
                                    let K = z;
                                    S && (K = S.getX(K)), u.expandByPoint(Rp.fromBufferAttribute(D, K))
                                }
                                a.boxInitialized = !0
                            }
                            return n.copy(u), n
                        }

                        getBoundingSphereAt(e, n) {
                            if (this._active[e] === !1) return null;
                            const a = this._bounds[e], u = a.sphere, y = this.geometry;
                            if (a.sphereInitialized === !1) {
                                u.makeEmpty(), this.getBoundingBoxAt(e, XA), XA.getCenter(u.center);
                                const S = y.index, D = y.attributes.position, P = this._drawRanges[e];
                                let z = 0;
                                for (let Q = P.start, K = P.start + P.count; Q < K; Q++) {
                                    let q = Q;
                                    S && (q = S.getX(q)), Rp.fromBufferAttribute(D, q), z = Math.max(z, u.center.distanceToSquared(Rp))
                                }
                                u.radius = Math.sqrt(z), a.sphereInitialized = !0
                            }
                            return n.copy(u), n
                        }

                        setMatrixAt(e, n) {
                            const r = this._active, a = this._matricesTexture, u = this._matricesTexture.image.data,
                                y = this._geometryCount;
                            return e >= y || r[e] === !1 ? this : (n.toArray(u, e * 16), a.needsUpdate = !0, this)
                        }

                        getMatrixAt(e, n) {
                            const r = this._active, a = this._matricesTexture.image.data, u = this._geometryCount;
                            return e >= u || r[e] === !1 ? null : n.fromArray(a, e * 16)
                        }

                        setVisibleAt(e, n) {
                            const r = this._visibility, a = this._active, u = this._geometryCount;
                            return e >= u || a[e] === !1 || r[e] === n ? this : (r[e] = n, this._visibilityChanged = !0, this)
                        }

                        getVisibleAt(e) {
                            const n = this._visibility, r = this._active, a = this._geometryCount;
                            return e >= a || r[e] === !1 ? !1 : n[e]
                        }

                        raycast(e, n) {
                            const r = this._visibility, a = this._active, u = this._drawRanges, y = this._geometryCount,
                                S = this.matrixWorld, D = this.geometry;
                            Uo.material = this.material, Uo.geometry.index = D.index, Uo.geometry.attributes = D.attributes, Uo.geometry.boundingBox === null && (Uo.geometry.boundingBox = new Ei), Uo.geometry.boundingSphere === null && (Uo.geometry.boundingSphere = new as);
                            for (let P = 0; P < y; P++) {
                                if (!r[P] || !a[P]) continue;
                                const z = u[P];
                                Uo.geometry.setDrawRange(z.start, z.count), this.getMatrixAt(P, Uo.matrixWorld).premultiply(S), this.getBoundingBoxAt(P, Uo.geometry.boundingBox), this.getBoundingSphereAt(P, Uo.geometry.boundingSphere), Uo.raycast(e, YA);
                                for (let Q = 0, K = YA.length; Q < K; Q++) {
                                    const q = YA[Q];
                                    q.object = this, q.batchId = P, n.push(q)
                                }
                                YA.length = 0
                            }
                            Uo.material = null, Uo.geometry.index = null, Uo.geometry.attributes = {}, Uo.geometry.setDrawRange(0, 1 / 0)
                        }

                        copy(e) {
                            return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map(n => ({...n})), this._reservedRanges = e._reservedRanges.map(n => ({...n})), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map(n => ({
                                boxInitialized: n.boxInitialized,
                                box: n.box.clone(),
                                sphereInitialized: n.sphereInitialized,
                                sphere: n.sphere.clone()
                            })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this
                        }

                        dispose() {
                            return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this
                        }

                        onBeforeRender(e, n, r, a, u) {
                            if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
                            const y = a.getIndex(), S = y === null ? 1 : y.array.BYTES_PER_ELEMENT, D = this._active,
                                P = this._visibility, z = this._multiDrawStarts, Q = this._multiDrawCounts,
                                K = this._drawRanges, q = this.perObjectFrustumCulled;
                            q && (CE.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse).multiply(this.matrixWorld), xv.setFromProjectionMatrix(CE, e.coordinateSystem));
                            let te = 0;
                            if (this.sortObjects) {
                                xE.copy(this.matrixWorld).invert(), Rp.setFromMatrixPosition(r.matrixWorld).applyMatrix4(xE);
                                for (let J = 0, Ce = P.length; J < Ce; J++) if (P[J] && D[J]) {
                                    this.getMatrixAt(J, hu), this.getBoundingSphereAt(J, vh).applyMatrix4(hu);
                                    let ye = !1;
                                    if (q && (ye = !xv.intersectsSphere(vh)), !ye) {
                                        const ge = Rp.distanceTo(vh.center);
                                        Cv.push(K[J], ge)
                                    }
                                }
                                const le = Cv.list, ne = this.customSort;
                                ne === null ? le.sort(u.transparent ? b_ : w_) : ne.call(this, le, r);
                                for (let J = 0, Ce = le.length; J < Ce; J++) {
                                    const ye = le[J];
                                    z[te] = ye.start * S, Q[te] = ye.count, te++
                                }
                                Cv.reset()
                            } else for (let le = 0, ne = P.length; le < ne; le++) if (P[le] && D[le]) {
                                let J = !1;
                                if (q && (this.getMatrixAt(le, hu), this.getBoundingSphereAt(le, vh).applyMatrix4(hu), J = !xv.intersectsSphere(vh)), !J) {
                                    const Ce = K[le];
                                    z[te] = Ce.start * S, Q[te] = Ce.count, te++
                                }
                            }
                            this._multiDrawCount = te, this._visibilityChanged = !1
                        }

                        onBeforeShadow(e, n, r, a, u, y) {
                            this.onBeforeRender(e, null, a, u, y)
                        }
                    }

                    class oa extends Dr {
                        constructor(e) {
                            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Bn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
                        }
                    }

                    const qA = new Ne, JA = new Ne, bE = new Mn, Bp = new jr, ZA = new as, wv = new Ne, _E = new Ne;

                    class du extends or {
                        constructor(e = new Ti, n = new oa) {
                            super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets()
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                        }

                        computeLineDistances() {
                            const e = this.geometry;
                            if (e.index === null) {
                                const n = e.attributes.position, r = [0];
                                for (let a = 1, u = n.count; a < u; a++) qA.fromBufferAttribute(n, a - 1), JA.fromBufferAttribute(n, a), r[a] = r[a - 1], r[a] += qA.distanceTo(JA);
                                e.setAttribute("lineDistance", new Xn(r, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }

                        raycast(e, n) {
                            const r = this.geometry, a = this.matrixWorld, u = e.params.Line.threshold, y = r.drawRange;
                            if (r.boundingSphere === null && r.computeBoundingSphere(), ZA.copy(r.boundingSphere), ZA.applyMatrix4(a), ZA.radius += u, e.ray.intersectsSphere(ZA) === !1) return;
                            bE.copy(a).invert(), Bp.copy(e.ray).applyMatrix4(bE);
                            const S = u / ((this.scale.x + this.scale.y + this.scale.z) / 3), D = S * S,
                                P = this.isLineSegments ? 2 : 1, z = r.index, K = r.attributes.position;
                            if (z !== null) {
                                const q = Math.max(0, y.start), te = Math.min(z.count, y.start + y.count);
                                for (let le = q, ne = te - 1; le < ne; le += P) {
                                    const J = z.getX(le), Ce = z.getX(le + 1), ye = $A(this, e, Bp, D, J, Ce);
                                    ye && n.push(ye)
                                }
                                if (this.isLineLoop) {
                                    const le = z.getX(te - 1), ne = z.getX(q), J = $A(this, e, Bp, D, le, ne);
                                    J && n.push(J)
                                }
                            } else {
                                const q = Math.max(0, y.start), te = Math.min(K.count, y.start + y.count);
                                for (let le = q, ne = te - 1; le < ne; le += P) {
                                    const J = $A(this, e, Bp, D, le, le + 1);
                                    J && n.push(J)
                                }
                                if (this.isLineLoop) {
                                    const le = $A(this, e, Bp, D, te - 1, q);
                                    le && n.push(le)
                                }
                            }
                        }

                        updateMorphTargets() {
                            const n = this.geometry.morphAttributes, r = Object.keys(n);
                            if (r.length > 0) {
                                const a = n[r[0]];
                                if (a !== void 0) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let u = 0, y = a.length; u < y; u++) {
                                        const S = a[u].name || String(u);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[S] = u
                                    }
                                }
                            }
                        }
                    }

                    function $A(d, e, n, r, a, u) {
                        const y = d.geometry.attributes.position;
                        if (qA.fromBufferAttribute(y, a), JA.fromBufferAttribute(y, u), n.distanceSqToSegment(qA, JA, wv, _E) > r) return;
                        wv.applyMatrix4(d.matrixWorld);
                        const D = e.ray.origin.distanceTo(wv);
                        if (!(D < e.near || D > e.far)) return {
                            distance: D,
                            point: _E.clone().applyMatrix4(d.matrixWorld),
                            index: a,
                            face: null,
                            faceIndex: null,
                            object: d
                        }
                    }

                    const ME = new Ne, SE = new Ne;

                    class Ql extends du {
                        constructor(e, n) {
                            super(e, n), this.isLineSegments = !0, this.type = "LineSegments"
                        }

                        computeLineDistances() {
                            const e = this.geometry;
                            if (e.index === null) {
                                const n = e.attributes.position, r = [];
                                for (let a = 0, u = n.count; a < u; a += 2) ME.fromBufferAttribute(n, a), SE.fromBufferAttribute(n, a + 1), r[a] = a === 0 ? 0 : r[a - 1], r[a + 1] = r[a] + ME.distanceTo(SE);
                                e.setAttribute("lineDistance", new Xn(r, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }
                    }

                    class TE extends du {
                        constructor(e, n) {
                            super(e, n), this.isLineLoop = !0, this.type = "LineLoop"
                        }
                    }

                    class bv extends Dr {
                        constructor(e) {
                            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Bn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                        }
                    }

                    const IE = new Mn, _v = new jr, eg = new as, tg = new Ne;

                    class RE extends or {
                        constructor(e = new Ti, n = new bv) {
                            super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = n, this.updateMorphTargets()
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
                        }

                        raycast(e, n) {
                            const r = this.geometry, a = this.matrixWorld, u = e.params.Points.threshold,
                                y = r.drawRange;
                            if (r.boundingSphere === null && r.computeBoundingSphere(), eg.copy(r.boundingSphere), eg.applyMatrix4(a), eg.radius += u, e.ray.intersectsSphere(eg) === !1) return;
                            IE.copy(a).invert(), _v.copy(e.ray).applyMatrix4(IE);
                            const S = u / ((this.scale.x + this.scale.y + this.scale.z) / 3), D = S * S, P = r.index,
                                Q = r.attributes.position;
                            if (P !== null) {
                                const K = Math.max(0, y.start), q = Math.min(P.count, y.start + y.count);
                                for (let te = K, le = q; te < le; te++) {
                                    const ne = P.getX(te);
                                    tg.fromBufferAttribute(Q, ne), BE(tg, ne, D, a, e, n, this)
                                }
                            } else {
                                const K = Math.max(0, y.start), q = Math.min(Q.count, y.start + y.count);
                                for (let te = K, le = q; te < le; te++) tg.fromBufferAttribute(Q, te), BE(tg, te, D, a, e, n, this)
                            }
                        }

                        updateMorphTargets() {
                            const n = this.geometry.morphAttributes, r = Object.keys(n);
                            if (r.length > 0) {
                                const a = n[r[0]];
                                if (a !== void 0) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let u = 0, y = a.length; u < y; u++) {
                                        const S = a[u].name || String(u);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[S] = u
                                    }
                                }
                            }
                        }
                    }

                    function BE(d, e, n, r, a, u, y) {
                        const S = _v.distanceSqToPoint(d);
                        if (S < n) {
                            const D = new Ne;
                            _v.closestPointToPoint(d, D), D.applyMatrix4(r);
                            const P = a.ray.origin.distanceTo(D);
                            if (P < a.near || P > a.far) return;
                            u.push({
                                distance: P,
                                distanceToRay: Math.sqrt(S),
                                point: D,
                                index: e,
                                face: null,
                                object: y
                            })
                        }
                    }

                    class T_ extends Lr {
                        constructor(e, n, r, a, u, y, S, D, P) {
                            super(e, n, r, a, u, y, S, D, P), this.isVideoTexture = !0, this.minFilter = y !== void 0 ? y : qn, this.magFilter = u !== void 0 ? u : qn, this.generateMipmaps = !1;
                            const z = this;

                            function Q() {
                                z.needsUpdate = !0, e.requestVideoFrameCallback(Q)
                            }

                            "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(Q)
                        }

                        clone() {
                            return new this.constructor(this.image).copy(this)
                        }

                        update() {
                            const e = this.image;
                            "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                        }
                    }

                    class I_ extends Lr {
                        constructor(e, n) {
                            super({
                                width: e,
                                height: n
                            }), this.isFramebufferTexture = !0, this.magFilter = cn, this.minFilter = cn, this.generateMipmaps = !1, this.needsUpdate = !0
                        }
                    }

                    class ng extends Lr {
                        constructor(e, n, r, a, u, y, S, D, P, z, Q, K) {
                            super(null, y, S, D, P, z, a, u, Q, K), this.isCompressedTexture = !0, this.image = {
                                width: n,
                                height: r
                            }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
                        }
                    }

                    class R_ extends ng {
                        constructor(e, n, r, a, u, y) {
                            super(e, n, r, u, y), this.isCompressedArrayTexture = !0, this.image.depth = a, this.wrapR = tt
                        }
                    }

                    class B_ extends ng {
                        constructor(e, n, r) {
                            super(void 0, e[0].width, e[0].height, n, r, oe), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
                        }
                    }

                    class L_ extends Lr {
                        constructor(e, n, r, a, u, y, S, D, P) {
                            super(e, n, r, a, u, y, S, D, P), this.isCanvasTexture = !0, this.needsUpdate = !0
                        }
                    }

                    class ml {
                        constructor() {
                            this.type = "Curve", this.arcLengthDivisions = 200
                        }

                        getPoint() {
                            return console.warn("THREE.Curve: .getPoint() not implemented."), null
                        }

                        getPointAt(e, n) {
                            const r = this.getUtoTmapping(e);
                            return this.getPoint(r, n)
                        }

                        getPoints(e = 5) {
                            const n = [];
                            for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
                            return n
                        }

                        getSpacedPoints(e = 5) {
                            const n = [];
                            for (let r = 0; r <= e; r++) n.push(this.getPointAt(r / e));
                            return n
                        }

                        getLength() {
                            const e = this.getLengths();
                            return e[e.length - 1]
                        }

                        getLengths(e = this.arcLengthDivisions) {
                            if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                            this.needsUpdate = !1;
                            const n = [];
                            let r, a = this.getPoint(0), u = 0;
                            n.push(0);
                            for (let y = 1; y <= e; y++) r = this.getPoint(y / e), u += r.distanceTo(a), n.push(u), a = r;
                            return this.cacheArcLengths = n, n
                        }

                        updateArcLengths() {
                            this.needsUpdate = !0, this.getLengths()
                        }

                        getUtoTmapping(e, n) {
                            const r = this.getLengths();
                            let a = 0;
                            const u = r.length;
                            let y;
                            n ? y = n : y = e * r[u - 1];
                            let S = 0, D = u - 1, P;
                            for (; S <= D;) if (a = Math.floor(S + (D - S) / 2), P = r[a] - y, P < 0) S = a + 1; else if (P > 0) D = a - 1; else {
                                D = a;
                                break
                            }
                            if (a = D, r[a] === y) return a / (u - 1);
                            const z = r[a], K = r[a + 1] - z, q = (y - z) / K;
                            return (a + q) / (u - 1)
                        }

                        getTangent(e, n) {
                            let a = e - 1e-4, u = e + 1e-4;
                            a < 0 && (a = 0), u > 1 && (u = 1);
                            const y = this.getPoint(a), S = this.getPoint(u), D = n || (y.isVector2 ? new zt : new Ne);
                            return D.copy(S).sub(y).normalize(), D
                        }

                        getTangentAt(e, n) {
                            const r = this.getUtoTmapping(e);
                            return this.getTangent(r, n)
                        }

                        computeFrenetFrames(e, n) {
                            const r = new Ne, a = [], u = [], y = [], S = new Ne, D = new Mn;
                            for (let q = 0; q <= e; q++) {
                                const te = q / e;
                                a[q] = this.getTangentAt(te, new Ne)
                            }
                            u[0] = new Ne, y[0] = new Ne;
                            let P = Number.MAX_VALUE;
                            const z = Math.abs(a[0].x), Q = Math.abs(a[0].y), K = Math.abs(a[0].z);
                            z <= P && (P = z, r.set(1, 0, 0)), Q <= P && (P = Q, r.set(0, 1, 0)), K <= P && r.set(0, 0, 1), S.crossVectors(a[0], r).normalize(), u[0].crossVectors(a[0], S), y[0].crossVectors(a[0], u[0]);
                            for (let q = 1; q <= e; q++) {
                                if (u[q] = u[q - 1].clone(), y[q] = y[q - 1].clone(), S.crossVectors(a[q - 1], a[q]), S.length() > Number.EPSILON) {
                                    S.normalize();
                                    const te = Math.acos(Hr(a[q - 1].dot(a[q]), -1, 1));
                                    u[q].applyMatrix4(D.makeRotationAxis(S, te))
                                }
                                y[q].crossVectors(a[q], u[q])
                            }
                            if (n === !0) {
                                let q = Math.acos(Hr(u[0].dot(u[e]), -1, 1));
                                q /= e, a[0].dot(S.crossVectors(u[0], u[e])) > 0 && (q = -q);
                                for (let te = 1; te <= e; te++) u[te].applyMatrix4(D.makeRotationAxis(a[te], q * te)), y[te].crossVectors(a[te], u[te])
                            }
                            return {tangents: a, normals: u, binormals: y}
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        copy(e) {
                            return this.arcLengthDivisions = e.arcLengthDivisions, this
                        }

                        toJSON() {
                            const e = {metadata: {version: 4.6, type: "Curve", generator: "Curve.toJSON"}};
                            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                        }

                        fromJSON(e) {
                            return this.arcLengthDivisions = e.arcLengthDivisions, this
                        }
                    }

                    class ig extends ml {
                        constructor(e = 0, n = 0, r = 1, a = 1, u = 0, y = Math.PI * 2, S = !1, D = 0) {
                            super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = r, this.yRadius = a, this.aStartAngle = u, this.aEndAngle = y, this.aClockwise = S, this.aRotation = D
                        }

                        getPoint(e, n = new zt) {
                            const r = n, a = Math.PI * 2;
                            let u = this.aEndAngle - this.aStartAngle;
                            const y = Math.abs(u) < Number.EPSILON;
                            for (; u < 0;) u += a;
                            for (; u > a;) u -= a;
                            u < Number.EPSILON && (y ? u = 0 : u = a), this.aClockwise === !0 && !y && (u === a ? u = -a : u = u - a);
                            const S = this.aStartAngle + e * u;
                            let D = this.aX + this.xRadius * Math.cos(S), P = this.aY + this.yRadius * Math.sin(S);
                            if (this.aRotation !== 0) {
                                const z = Math.cos(this.aRotation), Q = Math.sin(this.aRotation), K = D - this.aX,
                                    q = P - this.aY;
                                D = K * z - q * Q + this.aX, P = K * Q + q * z + this.aY
                            }
                            return r.set(D, P)
                        }

                        copy(e) {
                            return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
                        }

                        fromJSON(e) {
                            return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                        }
                    }

                    class LE extends ig {
                        constructor(e, n, r, a, u, y) {
                            super(e, n, r, r, a, u, y), this.isArcCurve = !0, this.type = "ArcCurve"
                        }
                    }

                    function Mv() {
                        let d = 0, e = 0, n = 0, r = 0;

                        function a(u, y, S, D) {
                            d = u, e = S, n = -3 * u + 3 * y - 2 * S - D, r = 2 * u - 2 * y + S + D
                        }

                        return {
                            initCatmullRom: function (u, y, S, D, P) {
                                a(y, S, P * (S - u), P * (D - y))
                            }, initNonuniformCatmullRom: function (u, y, S, D, P, z, Q) {
                                let K = (y - u) / P - (S - u) / (P + z) + (S - y) / z,
                                    q = (S - y) / z - (D - y) / (z + Q) + (D - S) / Q;
                                K *= z, q *= z, a(y, S, K, q)
                            }, calc: function (u) {
                                const y = u * u, S = y * u;
                                return d + e * u + n * y + r * S
                            }
                        }
                    }

                    const rg = new Ne, Sv = new Mv, Tv = new Mv, Iv = new Mv;

                    class DE extends ml {
                        constructor(e = [], n = !1, r = "centripetal", a = .5) {
                            super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = r, this.tension = a
                        }

                        getPoint(e, n = new Ne) {
                            const r = n, a = this.points, u = a.length, y = (u - (this.closed ? 0 : 1)) * e;
                            let S = Math.floor(y), D = y - S;
                            this.closed ? S += S > 0 ? 0 : (Math.floor(Math.abs(S) / u) + 1) * u : D === 0 && S === u - 1 && (S = u - 2, D = 1);
                            let P, z;
                            this.closed || S > 0 ? P = a[(S - 1) % u] : (rg.subVectors(a[0], a[1]).add(a[0]), P = rg);
                            const Q = a[S % u], K = a[(S + 1) % u];
                            if (this.closed || S + 2 < u ? z = a[(S + 2) % u] : (rg.subVectors(a[u - 1], a[u - 2]).add(a[u - 1]), z = rg), this.curveType === "centripetal" || this.curveType === "chordal") {
                                const q = this.curveType === "chordal" ? .5 : .25;
                                let te = Math.pow(P.distanceToSquared(Q), q), le = Math.pow(Q.distanceToSquared(K), q),
                                    ne = Math.pow(K.distanceToSquared(z), q);
                                le < 1e-4 && (le = 1), te < 1e-4 && (te = le), ne < 1e-4 && (ne = le), Sv.initNonuniformCatmullRom(P.x, Q.x, K.x, z.x, te, le, ne), Tv.initNonuniformCatmullRom(P.y, Q.y, K.y, z.y, te, le, ne), Iv.initNonuniformCatmullRom(P.z, Q.z, K.z, z.z, te, le, ne)
                            } else this.curveType === "catmullrom" && (Sv.initCatmullRom(P.x, Q.x, K.x, z.x, this.tension), Tv.initCatmullRom(P.y, Q.y, K.y, z.y, this.tension), Iv.initCatmullRom(P.z, Q.z, K.z, z.z, this.tension));
                            return r.set(Sv.calc(D), Tv.calc(D), Iv.calc(D)), r
                        }

                        copy(e) {
                            super.copy(e), this.points = [];
                            for (let n = 0, r = e.points.length; n < r; n++) {
                                const a = e.points[n];
                                this.points.push(a.clone())
                            }
                            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            e.points = [];
                            for (let n = 0, r = this.points.length; n < r; n++) {
                                const a = this.points[n];
                                e.points.push(a.toArray())
                            }
                            return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                        }

                        fromJSON(e) {
                            super.fromJSON(e), this.points = [];
                            for (let n = 0, r = e.points.length; n < r; n++) {
                                const a = e.points[n];
                                this.points.push(new Ne().fromArray(a))
                            }
                            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                        }
                    }

                    function PE(d, e, n, r, a) {
                        const u = (r - e) * .5, y = (a - n) * .5, S = d * d, D = d * S;
                        return (2 * n - 2 * r + u + y) * D + (-3 * n + 3 * r - 2 * u - y) * S + u * d + n
                    }

                    function D_(d, e) {
                        const n = 1 - d;
                        return n * n * e
                    }

                    function P_(d, e) {
                        return 2 * (1 - d) * d * e
                    }

                    function O_(d, e) {
                        return d * d * e
                    }

                    function Lp(d, e, n, r) {
                        return D_(d, e) + P_(d, n) + O_(d, r)
                    }

                    function k_(d, e) {
                        const n = 1 - d;
                        return n * n * n * e
                    }

                    function F_(d, e) {
                        const n = 1 - d;
                        return 3 * n * n * d * e
                    }

                    function N_(d, e) {
                        return 3 * (1 - d) * d * d * e
                    }

                    function U_(d, e) {
                        return d * d * d * e
                    }

                    function Dp(d, e, n, r, a) {
                        return k_(d, e) + F_(d, n) + N_(d, r) + U_(d, a)
                    }

                    class Rv extends ml {
                        constructor(e = new zt, n = new zt, r = new zt, a = new zt) {
                            super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = r, this.v3 = a
                        }

                        getPoint(e, n = new zt) {
                            const r = n, a = this.v0, u = this.v1, y = this.v2, S = this.v3;
                            return r.set(Dp(e, a.x, u.x, y.x, S.x), Dp(e, a.y, u.y, y.y, S.y)), r
                        }

                        copy(e) {
                            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                        }

                        fromJSON(e) {
                            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                        }
                    }

                    class OE extends ml {
                        constructor(e = new Ne, n = new Ne, r = new Ne, a = new Ne) {
                            super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = r, this.v3 = a
                        }

                        getPoint(e, n = new Ne) {
                            const r = n, a = this.v0, u = this.v1, y = this.v2, S = this.v3;
                            return r.set(Dp(e, a.x, u.x, y.x, S.x), Dp(e, a.y, u.y, y.y, S.y), Dp(e, a.z, u.z, y.z, S.z)), r
                        }

                        copy(e) {
                            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                        }

                        fromJSON(e) {
                            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                        }
                    }

                    class Bv extends ml {
                        constructor(e = new zt, n = new zt) {
                            super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n
                        }

                        getPoint(e, n = new zt) {
                            const r = n;
                            return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r
                        }

                        getPointAt(e, n) {
                            return this.getPoint(e, n)
                        }

                        getTangent(e, n = new zt) {
                            return n.subVectors(this.v2, this.v1).normalize()
                        }

                        getTangentAt(e, n) {
                            return this.getTangent(e, n)
                        }

                        copy(e) {
                            return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                        }

                        fromJSON(e) {
                            return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                        }
                    }

                    class kE extends ml {
                        constructor(e = new Ne, n = new Ne) {
                            super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n
                        }

                        getPoint(e, n = new Ne) {
                            const r = n;
                            return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r
                        }

                        getPointAt(e, n) {
                            return this.getPoint(e, n)
                        }

                        getTangent(e, n = new Ne) {
                            return n.subVectors(this.v2, this.v1).normalize()
                        }

                        getTangentAt(e, n) {
                            return this.getTangent(e, n)
                        }

                        copy(e) {
                            return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                        }

                        fromJSON(e) {
                            return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                        }
                    }

                    class Lv extends ml {
                        constructor(e = new zt, n = new zt, r = new zt) {
                            super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = r
                        }

                        getPoint(e, n = new zt) {
                            const r = n, a = this.v0, u = this.v1, y = this.v2;
                            return r.set(Lp(e, a.x, u.x, y.x), Lp(e, a.y, u.y, y.y)), r
                        }

                        copy(e) {
                            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                        }

                        fromJSON(e) {
                            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                        }
                    }

                    class Dv extends ml {
                        constructor(e = new Ne, n = new Ne, r = new Ne) {
                            super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = r
                        }

                        getPoint(e, n = new Ne) {
                            const r = n, a = this.v0, u = this.v1, y = this.v2;
                            return r.set(Lp(e, a.x, u.x, y.x), Lp(e, a.y, u.y, y.y), Lp(e, a.z, u.z, y.z)), r
                        }

                        copy(e) {
                            return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                        }

                        fromJSON(e) {
                            return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                        }
                    }

                    class Pv extends ml {
                        constructor(e = []) {
                            super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
                        }

                        getPoint(e, n = new zt) {
                            const r = n, a = this.points, u = (a.length - 1) * e, y = Math.floor(u), S = u - y,
                                D = a[y === 0 ? y : y - 1], P = a[y], z = a[y > a.length - 2 ? a.length - 1 : y + 1],
                                Q = a[y > a.length - 3 ? a.length - 1 : y + 2];
                            return r.set(PE(S, D.x, P.x, z.x, Q.x), PE(S, D.y, P.y, z.y, Q.y)), r
                        }

                        copy(e) {
                            super.copy(e), this.points = [];
                            for (let n = 0, r = e.points.length; n < r; n++) {
                                const a = e.points[n];
                                this.points.push(a.clone())
                            }
                            return this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            e.points = [];
                            for (let n = 0, r = this.points.length; n < r; n++) {
                                const a = this.points[n];
                                e.points.push(a.toArray())
                            }
                            return e
                        }

                        fromJSON(e) {
                            super.fromJSON(e), this.points = [];
                            for (let n = 0, r = e.points.length; n < r; n++) {
                                const a = e.points[n];
                                this.points.push(new zt().fromArray(a))
                            }
                            return this
                        }
                    }

                    var sg = Object.freeze({
                        __proto__: null,
                        ArcCurve: LE,
                        CatmullRomCurve3: DE,
                        CubicBezierCurve: Rv,
                        CubicBezierCurve3: OE,
                        EllipseCurve: ig,
                        LineCurve: Bv,
                        LineCurve3: kE,
                        QuadraticBezierCurve: Lv,
                        QuadraticBezierCurve3: Dv,
                        SplineCurve: Pv
                    });

                    class FE extends ml {
                        constructor() {
                            super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                        }

                        add(e) {
                            this.curves.push(e)
                        }

                        closePath() {
                            const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1);
                            if (!e.equals(n)) {
                                const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                                this.curves.push(new sg[r](n, e))
                            }
                            return this
                        }

                        getPoint(e, n) {
                            const r = e * this.getLength(), a = this.getCurveLengths();
                            let u = 0;
                            for (; u < a.length;) {
                                if (a[u] >= r) {
                                    const y = a[u] - r, S = this.curves[u], D = S.getLength(),
                                        P = D === 0 ? 0 : 1 - y / D;
                                    return S.getPointAt(P, n)
                                }
                                u++
                            }
                            return null
                        }

                        getLength() {
                            const e = this.getCurveLengths();
                            return e[e.length - 1]
                        }

                        updateArcLengths() {
                            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                        }

                        getCurveLengths() {
                            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                            const e = [];
                            let n = 0;
                            for (let r = 0, a = this.curves.length; r < a; r++) n += this.curves[r].getLength(), e.push(n);
                            return this.cacheLengths = e, e
                        }

                        getSpacedPoints(e = 40) {
                            const n = [];
                            for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
                            return this.autoClose && n.push(n[0]), n
                        }

                        getPoints(e = 12) {
                            const n = [];
                            let r;
                            for (let a = 0, u = this.curves; a < u.length; a++) {
                                const y = u[a],
                                    S = y.isEllipseCurve ? e * 2 : y.isLineCurve || y.isLineCurve3 ? 1 : y.isSplineCurve ? e * y.points.length : e,
                                    D = y.getPoints(S);
                                for (let P = 0; P < D.length; P++) {
                                    const z = D[P];
                                    r && r.equals(z) || (n.push(z), r = z)
                                }
                            }
                            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                        }

                        copy(e) {
                            super.copy(e), this.curves = [];
                            for (let n = 0, r = e.curves.length; n < r; n++) {
                                const a = e.curves[n];
                                this.curves.push(a.clone())
                            }
                            return this.autoClose = e.autoClose, this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            e.autoClose = this.autoClose, e.curves = [];
                            for (let n = 0, r = this.curves.length; n < r; n++) {
                                const a = this.curves[n];
                                e.curves.push(a.toJSON())
                            }
                            return e
                        }

                        fromJSON(e) {
                            super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                            for (let n = 0, r = e.curves.length; n < r; n++) {
                                const a = e.curves[n];
                                this.curves.push(new sg[a.type]().fromJSON(a))
                            }
                            return this
                        }
                    }

                    class Pp extends FE {
                        constructor(e) {
                            super(), this.type = "Path", this.currentPoint = new zt, e && this.setFromPoints(e)
                        }

                        setFromPoints(e) {
                            this.moveTo(e[0].x, e[0].y);
                            for (let n = 1, r = e.length; n < r; n++) this.lineTo(e[n].x, e[n].y);
                            return this
                        }

                        moveTo(e, n) {
                            return this.currentPoint.set(e, n), this
                        }

                        lineTo(e, n) {
                            const r = new Bv(this.currentPoint.clone(), new zt(e, n));
                            return this.curves.push(r), this.currentPoint.set(e, n), this
                        }

                        quadraticCurveTo(e, n, r, a) {
                            const u = new Lv(this.currentPoint.clone(), new zt(e, n), new zt(r, a));
                            return this.curves.push(u), this.currentPoint.set(r, a), this
                        }

                        bezierCurveTo(e, n, r, a, u, y) {
                            const S = new Rv(this.currentPoint.clone(), new zt(e, n), new zt(r, a), new zt(u, y));
                            return this.curves.push(S), this.currentPoint.set(u, y), this
                        }

                        splineThru(e) {
                            const n = [this.currentPoint.clone()].concat(e), r = new Pv(n);
                            return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this
                        }

                        arc(e, n, r, a, u, y) {
                            const S = this.currentPoint.x, D = this.currentPoint.y;
                            return this.absarc(e + S, n + D, r, a, u, y), this
                        }

                        absarc(e, n, r, a, u, y) {
                            return this.absellipse(e, n, r, r, a, u, y), this
                        }

                        ellipse(e, n, r, a, u, y, S, D) {
                            const P = this.currentPoint.x, z = this.currentPoint.y;
                            return this.absellipse(e + P, n + z, r, a, u, y, S, D), this
                        }

                        absellipse(e, n, r, a, u, y, S, D) {
                            const P = new ig(e, n, r, a, u, y, S, D);
                            if (this.curves.length > 0) {
                                const Q = P.getPoint(0);
                                Q.equals(this.currentPoint) || this.lineTo(Q.x, Q.y)
                            }
                            this.curves.push(P);
                            const z = P.getPoint(1);
                            return this.currentPoint.copy(z), this
                        }

                        copy(e) {
                            return super.copy(e), this.currentPoint.copy(e.currentPoint), this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.currentPoint = this.currentPoint.toArray(), e
                        }

                        fromJSON(e) {
                            return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
                        }
                    }

                    class Op extends Ti {
                        constructor(e = [new zt(0, -.5), new zt(.5, 0), new zt(0, .5)], n = 12, r = 0, a = Math.PI * 2) {
                            super(), this.type = "LatheGeometry", this.parameters = {
                                points: e,
                                segments: n,
                                phiStart: r,
                                phiLength: a
                            }, n = Math.floor(n), a = Hr(a, 0, Math.PI * 2);
                            const u = [], y = [], S = [], D = [], P = [], z = 1 / n, Q = new Ne, K = new zt, q = new Ne,
                                te = new Ne, le = new Ne;
                            let ne = 0, J = 0;
                            for (let Ce = 0; Ce <= e.length - 1; Ce++) switch (Ce) {
                                case 0:
                                    ne = e[Ce + 1].x - e[Ce].x, J = e[Ce + 1].y - e[Ce].y, q.x = J * 1, q.y = -ne, q.z = J * 0, le.copy(q), q.normalize(), D.push(q.x, q.y, q.z);
                                    break;
                                case e.length - 1:
                                    D.push(le.x, le.y, le.z);
                                    break;
                                default:
                                    ne = e[Ce + 1].x - e[Ce].x, J = e[Ce + 1].y - e[Ce].y, q.x = J * 1, q.y = -ne, q.z = J * 0, te.copy(q), q.x += le.x, q.y += le.y, q.z += le.z, q.normalize(), D.push(q.x, q.y, q.z), le.copy(te)
                            }
                            for (let Ce = 0; Ce <= n; Ce++) {
                                const ye = r + Ce * z * a, ge = Math.sin(ye), $e = Math.cos(ye);
                                for (let ze = 0; ze <= e.length - 1; ze++) {
                                    Q.x = e[ze].x * ge, Q.y = e[ze].y, Q.z = e[ze].x * $e, y.push(Q.x, Q.y, Q.z), K.x = Ce / n, K.y = ze / (e.length - 1), S.push(K.x, K.y);
                                    const We = D[3 * ze + 0] * ge, qe = D[3 * ze + 1], Pe = D[3 * ze + 0] * $e;
                                    P.push(We, qe, Pe)
                                }
                            }
                            for (let Ce = 0; Ce < n; Ce++) for (let ye = 0; ye < e.length - 1; ye++) {
                                const ge = ye + Ce * e.length, $e = ge, ze = ge + e.length, We = ge + e.length + 1,
                                    qe = ge + 1;
                                u.push($e, ze, qe), u.push(We, qe, ze)
                            }
                            this.setIndex(u), this.setAttribute("position", new Xn(y, 3)), this.setAttribute("uv", new Xn(S, 2)), this.setAttribute("normal", new Xn(P, 3))
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new Op(e.points, e.segments, e.phiStart, e.phiLength)
                        }
                    }

                    class og extends Op {
                        constructor(e = 1, n = 1, r = 4, a = 8) {
                            const u = new Pp;
                            u.absarc(0, -n / 2, e, Math.PI * 1.5, 0), u.absarc(0, n / 2, e, 0, Math.PI * .5), super(u.getPoints(r), a), this.type = "CapsuleGeometry", this.parameters = {
                                radius: e,
                                length: n,
                                capSegments: r,
                                radialSegments: a
                            }
                        }

                        static fromJSON(e) {
                            return new og(e.radius, e.length, e.capSegments, e.radialSegments)
                        }
                    }

                    class ag extends Ti {
                        constructor(e = 1, n = 32, r = 0, a = Math.PI * 2) {
                            super(), this.type = "CircleGeometry", this.parameters = {
                                radius: e,
                                segments: n,
                                thetaStart: r,
                                thetaLength: a
                            }, n = Math.max(3, n);
                            const u = [], y = [], S = [], D = [], P = new Ne, z = new zt;
                            y.push(0, 0, 0), S.push(0, 0, 1), D.push(.5, .5);
                            for (let Q = 0, K = 3; Q <= n; Q++, K += 3) {
                                const q = r + Q / n * a;
                                P.x = e * Math.cos(q), P.y = e * Math.sin(q), y.push(P.x, P.y, P.z), S.push(0, 0, 1), z.x = (y[K] / e + 1) / 2, z.y = (y[K + 1] / e + 1) / 2, D.push(z.x, z.y)
                            }
                            for (let Q = 1; Q <= n; Q++) u.push(Q, Q + 1, 0);
                            this.setIndex(u), this.setAttribute("position", new Xn(y, 3)), this.setAttribute("normal", new Xn(S, 3)), this.setAttribute("uv", new Xn(D, 2))
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new ag(e.radius, e.segments, e.thetaStart, e.thetaLength)
                        }
                    }

                    class Nd extends Ti {
                        constructor(e = 1, n = 1, r = 1, a = 32, u = 1, y = !1, S = 0, D = Math.PI * 2) {
                            super(), this.type = "CylinderGeometry", this.parameters = {
                                radiusTop: e,
                                radiusBottom: n,
                                height: r,
                                radialSegments: a,
                                heightSegments: u,
                                openEnded: y,
                                thetaStart: S,
                                thetaLength: D
                            };
                            const P = this;
                            a = Math.floor(a), u = Math.floor(u);
                            const z = [], Q = [], K = [], q = [];
                            let te = 0;
                            const le = [], ne = r / 2;
                            let J = 0;
                            Ce(), y === !1 && (e > 0 && ye(!0), n > 0 && ye(!1)), this.setIndex(z), this.setAttribute("position", new Xn(Q, 3)), this.setAttribute("normal", new Xn(K, 3)), this.setAttribute("uv", new Xn(q, 2));

                            function Ce() {
                                const ge = new Ne, $e = new Ne;
                                let ze = 0;
                                const We = (n - e) / r;
                                for (let qe = 0; qe <= u; qe++) {
                                    const Pe = [], Te = qe / u, Je = Te * (n - e) + e;
                                    for (let ht = 0; ht <= a; ht++) {
                                        const lt = ht / a, pt = lt * D + S, Mt = Math.sin(pt), Ut = Math.cos(pt);
                                        $e.x = Je * Mt, $e.y = -Te * r + ne, $e.z = Je * Ut, Q.push($e.x, $e.y, $e.z), ge.set(Mt, We, Ut).normalize(), K.push(ge.x, ge.y, ge.z), q.push(lt, 1 - Te), Pe.push(te++)
                                    }
                                    le.push(Pe)
                                }
                                for (let qe = 0; qe < a; qe++) for (let Pe = 0; Pe < u; Pe++) {
                                    const Te = le[Pe][qe], Je = le[Pe + 1][qe], ht = le[Pe + 1][qe + 1],
                                        lt = le[Pe][qe + 1];
                                    z.push(Te, Je, lt), z.push(Je, ht, lt), ze += 6
                                }
                                P.addGroup(J, ze, 0), J += ze
                            }

                            function ye(ge) {
                                const $e = te, ze = new zt, We = new Ne;
                                let qe = 0;
                                const Pe = ge === !0 ? e : n, Te = ge === !0 ? 1 : -1;
                                for (let ht = 1; ht <= a; ht++) Q.push(0, ne * Te, 0), K.push(0, Te, 0), q.push(.5, .5), te++;
                                const Je = te;
                                for (let ht = 0; ht <= a; ht++) {
                                    const pt = ht / a * D + S, Mt = Math.cos(pt), Ut = Math.sin(pt);
                                    We.x = Pe * Ut, We.y = ne * Te, We.z = Pe * Mt, Q.push(We.x, We.y, We.z), K.push(0, Te, 0), ze.x = Mt * .5 + .5, ze.y = Ut * .5 * Te + .5, q.push(ze.x, ze.y), te++
                                }
                                for (let ht = 0; ht < a; ht++) {
                                    const lt = $e + ht, pt = Je + ht;
                                    ge === !0 ? z.push(pt, pt + 1, lt) : z.push(pt + 1, pt, lt), qe += 3
                                }
                                P.addGroup(J, qe, ge === !0 ? 1 : 2), J += qe
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new Nd(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                        }
                    }

                    class lg extends Nd {
                        constructor(e = 1, n = 1, r = 32, a = 1, u = !1, y = 0, S = Math.PI * 2) {
                            super(0, e, n, r, a, u, y, S), this.type = "ConeGeometry", this.parameters = {
                                radius: e,
                                height: n,
                                radialSegments: r,
                                heightSegments: a,
                                openEnded: u,
                                thetaStart: y,
                                thetaLength: S
                            }
                        }

                        static fromJSON(e) {
                            return new lg(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                        }
                    }

                    class fu extends Ti {
                        constructor(e = [], n = [], r = 1, a = 0) {
                            super(), this.type = "PolyhedronGeometry", this.parameters = {
                                vertices: e,
                                indices: n,
                                radius: r,
                                detail: a
                            };
                            const u = [], y = [];
                            S(a), P(r), z(), this.setAttribute("position", new Xn(u, 3)), this.setAttribute("normal", new Xn(u.slice(), 3)), this.setAttribute("uv", new Xn(y, 2)), a === 0 ? this.computeVertexNormals() : this.normalizeNormals();

                            function S(Ce) {
                                const ye = new Ne, ge = new Ne, $e = new Ne;
                                for (let ze = 0; ze < n.length; ze += 3) q(n[ze + 0], ye), q(n[ze + 1], ge), q(n[ze + 2], $e), D(ye, ge, $e, Ce)
                            }

                            function D(Ce, ye, ge, $e) {
                                const ze = $e + 1, We = [];
                                for (let qe = 0; qe <= ze; qe++) {
                                    We[qe] = [];
                                    const Pe = Ce.clone().lerp(ge, qe / ze), Te = ye.clone().lerp(ge, qe / ze),
                                        Je = ze - qe;
                                    for (let ht = 0; ht <= Je; ht++) ht === 0 && qe === ze ? We[qe][ht] = Pe : We[qe][ht] = Pe.clone().lerp(Te, ht / Je)
                                }
                                for (let qe = 0; qe < ze; qe++) for (let Pe = 0; Pe < 2 * (ze - qe) - 1; Pe++) {
                                    const Te = Math.floor(Pe / 2);
                                    Pe % 2 === 0 ? (K(We[qe][Te + 1]), K(We[qe + 1][Te]), K(We[qe][Te])) : (K(We[qe][Te + 1]), K(We[qe + 1][Te + 1]), K(We[qe + 1][Te]))
                                }
                            }

                            function P(Ce) {
                                const ye = new Ne;
                                for (let ge = 0; ge < u.length; ge += 3) ye.x = u[ge + 0], ye.y = u[ge + 1], ye.z = u[ge + 2], ye.normalize().multiplyScalar(Ce), u[ge + 0] = ye.x, u[ge + 1] = ye.y, u[ge + 2] = ye.z
                            }

                            function z() {
                                const Ce = new Ne;
                                for (let ye = 0; ye < u.length; ye += 3) {
                                    Ce.x = u[ye + 0], Ce.y = u[ye + 1], Ce.z = u[ye + 2];
                                    const ge = ne(Ce) / 2 / Math.PI + .5, $e = J(Ce) / Math.PI + .5;
                                    y.push(ge, 1 - $e)
                                }
                                te(), Q()
                            }

                            function Q() {
                                for (let Ce = 0; Ce < y.length; Ce += 6) {
                                    const ye = y[Ce + 0], ge = y[Ce + 2], $e = y[Ce + 4], ze = Math.max(ye, ge, $e),
                                        We = Math.min(ye, ge, $e);
                                    ze > .9 && We < .1 && (ye < .2 && (y[Ce + 0] += 1), ge < .2 && (y[Ce + 2] += 1), $e < .2 && (y[Ce + 4] += 1))
                                }
                            }

                            function K(Ce) {
                                u.push(Ce.x, Ce.y, Ce.z)
                            }

                            function q(Ce, ye) {
                                const ge = Ce * 3;
                                ye.x = e[ge + 0], ye.y = e[ge + 1], ye.z = e[ge + 2]
                            }

                            function te() {
                                const Ce = new Ne, ye = new Ne, ge = new Ne, $e = new Ne, ze = new zt, We = new zt,
                                    qe = new zt;
                                for (let Pe = 0, Te = 0; Pe < u.length; Pe += 9, Te += 6) {
                                    Ce.set(u[Pe + 0], u[Pe + 1], u[Pe + 2]), ye.set(u[Pe + 3], u[Pe + 4], u[Pe + 5]), ge.set(u[Pe + 6], u[Pe + 7], u[Pe + 8]), ze.set(y[Te + 0], y[Te + 1]), We.set(y[Te + 2], y[Te + 3]), qe.set(y[Te + 4], y[Te + 5]), $e.copy(Ce).add(ye).add(ge).divideScalar(3);
                                    const Je = ne($e);
                                    le(ze, Te + 0, Ce, Je), le(We, Te + 2, ye, Je), le(qe, Te + 4, ge, Je)
                                }
                            }

                            function le(Ce, ye, ge, $e) {
                                $e < 0 && Ce.x === 1 && (y[ye] = Ce.x - 1), ge.x === 0 && ge.z === 0 && (y[ye] = $e / 2 / Math.PI + .5)
                            }

                            function ne(Ce) {
                                return Math.atan2(Ce.z, -Ce.x)
                            }

                            function J(Ce) {
                                return Math.atan2(-Ce.y, Math.sqrt(Ce.x * Ce.x + Ce.z * Ce.z))
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new fu(e.vertices, e.indices, e.radius, e.details)
                        }
                    }

                    class cg extends fu {
                        constructor(e = 1, n = 0) {
                            const r = (1 + Math.sqrt(5)) / 2, a = 1 / r,
                                u = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -a, -r, 0, -a, r, 0, a, -r, 0, a, r, -a, -r, 0, -a, r, 0, a, -r, 0, a, r, 0, -r, 0, -a, r, 0, -a, -r, 0, a, r, 0, a],
                                y = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                            super(u, y, e, n), this.type = "DodecahedronGeometry", this.parameters = {
                                radius: e,
                                detail: n
                            }
                        }

                        static fromJSON(e) {
                            return new cg(e.radius, e.detail)
                        }
                    }

                    const ug = new Ne, hg = new Ne, Ov = new Ne, dg = new Bs;

                    class NE extends Ti {
                        constructor(e = null, n = 1) {
                            if (super(), this.type = "EdgesGeometry", this.parameters = {
                                geometry: e,
                                thresholdAngle: n
                            }, e !== null) {
                                const a = Math.pow(10, 4), u = Math.cos(Na * n), y = e.getIndex(),
                                    S = e.getAttribute("position"), D = y ? y.count : S.count, P = [0, 0, 0],
                                    z = ["a", "b", "c"], Q = new Array(3), K = {}, q = [];
                                for (let te = 0; te < D; te += 3) {
                                    y ? (P[0] = y.getX(te), P[1] = y.getX(te + 1), P[2] = y.getX(te + 2)) : (P[0] = te, P[1] = te + 1, P[2] = te + 2);
                                    const {a: le, b: ne, c: J} = dg;
                                    if (le.fromBufferAttribute(S, P[0]), ne.fromBufferAttribute(S, P[1]), J.fromBufferAttribute(S, P[2]), dg.getNormal(Ov), Q[0] = `${Math.round(le.x * a)},${Math.round(le.y * a)},${Math.round(le.z * a)}`, Q[1] = `${Math.round(ne.x * a)},${Math.round(ne.y * a)},${Math.round(ne.z * a)}`, Q[2] = `${Math.round(J.x * a)},${Math.round(J.y * a)},${Math.round(J.z * a)}`, !(Q[0] === Q[1] || Q[1] === Q[2] || Q[2] === Q[0])) for (let Ce = 0; Ce < 3; Ce++) {
                                        const ye = (Ce + 1) % 3, ge = Q[Ce], $e = Q[ye], ze = dg[z[Ce]], We = dg[z[ye]],
                                            qe = `${ge}_${$e}`, Pe = `${$e}_${ge}`;
                                        Pe in K && K[Pe] ? (Ov.dot(K[Pe].normal) <= u && (q.push(ze.x, ze.y, ze.z), q.push(We.x, We.y, We.z)), K[Pe] = null) : qe in K || (K[qe] = {
                                            index0: P[Ce],
                                            index1: P[ye],
                                            normal: Ov.clone()
                                        })
                                    }
                                }
                                for (const te in K) if (K[te]) {
                                    const {index0: le, index1: ne} = K[te];
                                    ug.fromBufferAttribute(S, le), hg.fromBufferAttribute(S, ne), q.push(ug.x, ug.y, ug.z), q.push(hg.x, hg.y, hg.z)
                                }
                                this.setAttribute("position", new Xn(q, 3))
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }
                    }

                    class yh extends Pp {
                        constructor(e) {
                            super(e), this.uuid = uo(), this.type = "Shape", this.holes = []
                        }

                        getPointsHoles(e) {
                            const n = [];
                            for (let r = 0, a = this.holes.length; r < a; r++) n[r] = this.holes[r].getPoints(e);
                            return n
                        }

                        extractPoints(e) {
                            return {shape: this.getPoints(e), holes: this.getPointsHoles(e)}
                        }

                        copy(e) {
                            super.copy(e), this.holes = [];
                            for (let n = 0, r = e.holes.length; n < r; n++) {
                                const a = e.holes[n];
                                this.holes.push(a.clone())
                            }
                            return this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            e.uuid = this.uuid, e.holes = [];
                            for (let n = 0, r = this.holes.length; n < r; n++) {
                                const a = this.holes[n];
                                e.holes.push(a.toJSON())
                            }
                            return e
                        }

                        fromJSON(e) {
                            super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                            for (let n = 0, r = e.holes.length; n < r; n++) {
                                const a = e.holes[n];
                                this.holes.push(new Pp().fromJSON(a))
                            }
                            return this
                        }
                    }

                    const z_ = {
                        triangulate: function (d, e, n = 2) {
                            const r = e && e.length, a = r ? e[0] * n : d.length;
                            let u = UE(d, 0, a, n, !0);
                            const y = [];
                            if (!u || u.next === u.prev) return y;
                            let S, D, P, z, Q, K, q;
                            if (r && (u = j_(d, e, u, n)), d.length > 80 * n) {
                                S = P = d[0], D = z = d[1];
                                for (let te = n; te < a; te += n) Q = d[te], K = d[te + 1], Q < S && (S = Q), K < D && (D = K), Q > P && (P = Q), K > z && (z = K);
                                q = Math.max(P - S, z - D), q = q !== 0 ? 32767 / q : 0
                            }
                            return kp(u, y, n, S, D, q, 0), y
                        }
                    };

                    function UE(d, e, n, r, a) {
                        let u, y;
                        if (a === nM(d, e, n, r) > 0) for (u = e; u < n; u += r) y = VE(u, d[u], d[u + 1], y); else for (u = n - r; u >= e; u -= r) y = VE(u, d[u], d[u + 1], y);
                        return y && fg(y, y.next) && (Np(y), y = y.next), y
                    }

                    function Eh(d, e) {
                        if (!d) return d;
                        e || (e = d);
                        let n = d, r;
                        do if (r = !1, !n.steiner && (fg(n, n.next) || hs(n.prev, n, n.next) === 0)) {
                            if (Np(n), n = e = n.prev, n === n.next) break;
                            r = !0
                        } else n = n.next; while (r || n !== e);
                        return e
                    }

                    function kp(d, e, n, r, a, u, y) {
                        if (!d) return;
                        !y && u && q_(d, r, a, u);
                        let S = d, D, P;
                        for (; d.prev !== d.next;) {
                            if (D = d.prev, P = d.next, u ? V_(d, r, a, u) : G_(d)) {
                                e.push(D.i / n | 0), e.push(d.i / n | 0), e.push(P.i / n | 0), Np(d), d = P.next, S = P.next;
                                continue
                            }
                            if (d = P, d === S) {
                                y ? y === 1 ? (d = H_(Eh(d), e, n), kp(d, e, n, r, a, u, 2)) : y === 2 && Q_(d, e, n, r, a, u) : kp(Eh(d), e, n, r, a, u, 1);
                                break
                            }
                        }
                    }

                    function G_(d) {
                        const e = d.prev, n = d, r = d.next;
                        if (hs(e, n, r) >= 0) return !1;
                        const a = e.x, u = n.x, y = r.x, S = e.y, D = n.y, P = r.y,
                            z = a < u ? a < y ? a : y : u < y ? u : y, Q = S < D ? S < P ? S : P : D < P ? D : P,
                            K = a > u ? a > y ? a : y : u > y ? u : y, q = S > D ? S > P ? S : P : D > P ? D : P;
                        let te = r.next;
                        for (; te !== e;) {
                            if (te.x >= z && te.x <= K && te.y >= Q && te.y <= q && Ud(a, S, u, D, y, P, te.x, te.y) && hs(te.prev, te, te.next) >= 0) return !1;
                            te = te.next
                        }
                        return !0
                    }

                    function V_(d, e, n, r) {
                        const a = d.prev, u = d, y = d.next;
                        if (hs(a, u, y) >= 0) return !1;
                        const S = a.x, D = u.x, P = y.x, z = a.y, Q = u.y, K = y.y,
                            q = S < D ? S < P ? S : P : D < P ? D : P, te = z < Q ? z < K ? z : K : Q < K ? Q : K,
                            le = S > D ? S > P ? S : P : D > P ? D : P, ne = z > Q ? z > K ? z : K : Q > K ? Q : K,
                            J = kv(q, te, e, n, r), Ce = kv(le, ne, e, n, r);
                        let ye = d.prevZ, ge = d.nextZ;
                        for (; ye && ye.z >= J && ge && ge.z <= Ce;) {
                            if (ye.x >= q && ye.x <= le && ye.y >= te && ye.y <= ne && ye !== a && ye !== y && Ud(S, z, D, Q, P, K, ye.x, ye.y) && hs(ye.prev, ye, ye.next) >= 0 || (ye = ye.prevZ, ge.x >= q && ge.x <= le && ge.y >= te && ge.y <= ne && ge !== a && ge !== y && Ud(S, z, D, Q, P, K, ge.x, ge.y) && hs(ge.prev, ge, ge.next) >= 0)) return !1;
                            ge = ge.nextZ
                        }
                        for (; ye && ye.z >= J;) {
                            if (ye.x >= q && ye.x <= le && ye.y >= te && ye.y <= ne && ye !== a && ye !== y && Ud(S, z, D, Q, P, K, ye.x, ye.y) && hs(ye.prev, ye, ye.next) >= 0) return !1;
                            ye = ye.prevZ
                        }
                        for (; ge && ge.z <= Ce;) {
                            if (ge.x >= q && ge.x <= le && ge.y >= te && ge.y <= ne && ge !== a && ge !== y && Ud(S, z, D, Q, P, K, ge.x, ge.y) && hs(ge.prev, ge, ge.next) >= 0) return !1;
                            ge = ge.nextZ
                        }
                        return !0
                    }

                    function H_(d, e, n) {
                        let r = d;
                        do {
                            const a = r.prev, u = r.next.next;
                            !fg(a, u) && zE(a, r, r.next, u) && Fp(a, u) && Fp(u, a) && (e.push(a.i / n | 0), e.push(r.i / n | 0), e.push(u.i / n | 0), Np(r), Np(r.next), r = d = u), r = r.next
                        } while (r !== d);
                        return Eh(r)
                    }

                    function Q_(d, e, n, r, a, u) {
                        let y = d;
                        do {
                            let S = y.next.next;
                            for (; S !== y.prev;) {
                                if (y.i !== S.i && $_(y, S)) {
                                    let D = GE(y, S);
                                    y = Eh(y, y.next), D = Eh(D, D.next), kp(y, e, n, r, a, u, 0), kp(D, e, n, r, a, u, 0);
                                    return
                                }
                                S = S.next
                            }
                            y = y.next
                        } while (y !== d)
                    }

                    function j_(d, e, n, r) {
                        const a = [];
                        let u, y, S, D, P;
                        for (u = 0, y = e.length; u < y; u++) S = e[u] * r, D = u < y - 1 ? e[u + 1] * r : d.length, P = UE(d, S, D, r, !1), P === P.next && (P.steiner = !0), a.push(Z_(P));
                        for (a.sort(W_), u = 0; u < a.length; u++) n = K_(a[u], n);
                        return n
                    }

                    function W_(d, e) {
                        return d.x - e.x
                    }

                    function K_(d, e) {
                        const n = X_(d, e);
                        if (!n) return e;
                        const r = GE(n, d);
                        return Eh(r, r.next), Eh(n, n.next)
                    }

                    function X_(d, e) {
                        let n = e, r = -1 / 0, a;
                        const u = d.x, y = d.y;
                        do {
                            if (y <= n.y && y >= n.next.y && n.next.y !== n.y) {
                                const K = n.x + (y - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (K <= u && K > r && (r = K, a = n.x < n.next.x ? n : n.next, K === u)) return a
                            }
                            n = n.next
                        } while (n !== e);
                        if (!a) return null;
                        const S = a, D = a.x, P = a.y;
                        let z = 1 / 0, Q;
                        n = a;
                        do u >= n.x && n.x >= D && u !== n.x && Ud(y < P ? u : r, y, D, P, y < P ? r : u, y, n.x, n.y) && (Q = Math.abs(y - n.y) / (u - n.x), Fp(n, d) && (Q < z || Q === z && (n.x > a.x || n.x === a.x && Y_(a, n))) && (a = n, z = Q)), n = n.next; while (n !== S);
                        return a
                    }

                    function Y_(d, e) {
                        return hs(d.prev, d, e.prev) < 0 && hs(e.next, d, d.next) < 0
                    }

                    function q_(d, e, n, r) {
                        let a = d;
                        do a.z === 0 && (a.z = kv(a.x, a.y, e, n, r)), a.prevZ = a.prev, a.nextZ = a.next, a = a.next; while (a !== d);
                        a.prevZ.nextZ = null, a.prevZ = null, J_(a)
                    }

                    function J_(d) {
                        let e, n, r, a, u, y, S, D, P = 1;
                        do {
                            for (n = d, d = null, u = null, y = 0; n;) {
                                for (y++, r = n, S = 0, e = 0; e < P && (S++, r = r.nextZ, !!r); e++) ;
                                for (D = P; S > 0 || D > 0 && r;) S !== 0 && (D === 0 || !r || n.z <= r.z) ? (a = n, n = n.nextZ, S--) : (a = r, r = r.nextZ, D--), u ? u.nextZ = a : d = a, a.prevZ = u, u = a;
                                n = r
                            }
                            u.nextZ = null, P *= 2
                        } while (y > 1);
                        return d
                    }

                    function kv(d, e, n, r, a) {
                        return d = (d - n) * a | 0, e = (e - r) * a | 0, d = (d | d << 8) & 16711935, d = (d | d << 4) & 252645135, d = (d | d << 2) & 858993459, d = (d | d << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, d | e << 1
                    }

                    function Z_(d) {
                        let e = d, n = d;
                        do (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next; while (e !== d);
                        return n
                    }

                    function Ud(d, e, n, r, a, u, y, S) {
                        return (a - y) * (e - S) >= (d - y) * (u - S) && (d - y) * (r - S) >= (n - y) * (e - S) && (n - y) * (u - S) >= (a - y) * (r - S)
                    }

                    function $_(d, e) {
                        return d.next.i !== e.i && d.prev.i !== e.i && !eM(d, e) && (Fp(d, e) && Fp(e, d) && tM(d, e) && (hs(d.prev, d, e.prev) || hs(d, e.prev, e)) || fg(d, e) && hs(d.prev, d, d.next) > 0 && hs(e.prev, e, e.next) > 0)
                    }

                    function hs(d, e, n) {
                        return (e.y - d.y) * (n.x - e.x) - (e.x - d.x) * (n.y - e.y)
                    }

                    function fg(d, e) {
                        return d.x === e.x && d.y === e.y
                    }

                    function zE(d, e, n, r) {
                        const a = mg(hs(d, e, n)), u = mg(hs(d, e, r)), y = mg(hs(n, r, d)), S = mg(hs(n, r, e));
                        return !!(a !== u && y !== S || a === 0 && pg(d, n, e) || u === 0 && pg(d, r, e) || y === 0 && pg(n, d, r) || S === 0 && pg(n, e, r))
                    }

                    function pg(d, e, n) {
                        return e.x <= Math.max(d.x, n.x) && e.x >= Math.min(d.x, n.x) && e.y <= Math.max(d.y, n.y) && e.y >= Math.min(d.y, n.y)
                    }

                    function mg(d) {
                        return d > 0 ? 1 : d < 0 ? -1 : 0
                    }

                    function eM(d, e) {
                        let n = d;
                        do {
                            if (n.i !== d.i && n.next.i !== d.i && n.i !== e.i && n.next.i !== e.i && zE(n, n.next, d, e)) return !0;
                            n = n.next
                        } while (n !== d);
                        return !1
                    }

                    function Fp(d, e) {
                        return hs(d.prev, d, d.next) < 0 ? hs(d, e, d.next) >= 0 && hs(d, d.prev, e) >= 0 : hs(d, e, d.prev) < 0 || hs(d, d.next, e) < 0
                    }

                    function tM(d, e) {
                        let n = d, r = !1;
                        const a = (d.x + e.x) / 2, u = (d.y + e.y) / 2;
                        do n.y > u != n.next.y > u && n.next.y !== n.y && a < (n.next.x - n.x) * (u - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== d);
                        return r
                    }

                    function GE(d, e) {
                        const n = new Fv(d.i, d.x, d.y), r = new Fv(e.i, e.x, e.y), a = d.next, u = e.prev;
                        return d.next = e, e.prev = d, n.next = a, a.prev = n, r.next = n, n.prev = r, u.next = r, r.prev = u, r
                    }

                    function VE(d, e, n, r) {
                        const a = new Fv(d, e, n);
                        return r ? (a.next = r.next, a.prev = r, r.next.prev = a, r.next = a) : (a.prev = a, a.next = a), a
                    }

                    function Np(d) {
                        d.next.prev = d.prev, d.prev.next = d.next, d.prevZ && (d.prevZ.nextZ = d.nextZ), d.nextZ && (d.nextZ.prevZ = d.prevZ)
                    }

                    function Fv(d, e, n) {
                        this.i = d, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
                    }

                    function nM(d, e, n, r) {
                        let a = 0;
                        for (let u = e, y = n - r; u < n; u += r) a += (d[y] - d[u]) * (d[u + 1] + d[y + 1]), y = u;
                        return a
                    }

                    class jl {
                        static area(e) {
                            const n = e.length;
                            let r = 0;
                            for (let a = n - 1, u = 0; u < n; a = u++) r += e[a].x * e[u].y - e[u].x * e[a].y;
                            return r * .5
                        }

                        static isClockWise(e) {
                            return jl.area(e) < 0
                        }

                        static triangulateShape(e, n) {
                            const r = [], a = [], u = [];
                            HE(e), QE(r, e);
                            let y = e.length;
                            n.forEach(HE);
                            for (let D = 0; D < n.length; D++) a.push(y), y += n[D].length, QE(r, n[D]);
                            const S = z_.triangulate(r, a);
                            for (let D = 0; D < S.length; D += 3) u.push(S.slice(D, D + 3));
                            return u
                        }
                    }

                    function HE(d) {
                        const e = d.length;
                        e > 2 && d[e - 1].equals(d[0]) && d.pop()
                    }

                    function QE(d, e) {
                        for (let n = 0; n < e.length; n++) d.push(e[n].x), d.push(e[n].y)
                    }

                    class Ag extends Ti {
                        constructor(e = new yh([new zt(.5, .5), new zt(-.5, .5), new zt(-.5, -.5), new zt(.5, -.5)]), n = {}) {
                            super(), this.type = "ExtrudeGeometry", this.parameters = {
                                shapes: e,
                                options: n
                            }, e = Array.isArray(e) ? e : [e];
                            const r = this, a = [], u = [];
                            for (let S = 0, D = e.length; S < D; S++) {
                                const P = e[S];
                                y(P)
                            }
                            this.setAttribute("position", new Xn(a, 3)), this.setAttribute("uv", new Xn(u, 2)), this.computeVertexNormals();

                            function y(S) {
                                const D = [], P = n.curveSegments !== void 0 ? n.curveSegments : 12,
                                    z = n.steps !== void 0 ? n.steps : 1, Q = n.depth !== void 0 ? n.depth : 1;
                                let K = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0,
                                    q = n.bevelThickness !== void 0 ? n.bevelThickness : .2,
                                    te = n.bevelSize !== void 0 ? n.bevelSize : q - .1,
                                    le = n.bevelOffset !== void 0 ? n.bevelOffset : 0,
                                    ne = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
                                const J = n.extrudePath, Ce = n.UVGenerator !== void 0 ? n.UVGenerator : iM;
                                let ye, ge = !1, $e, ze, We, qe;
                                J && (ye = J.getSpacedPoints(z), ge = !0, K = !1, $e = J.computeFrenetFrames(z, !1), ze = new Ne, We = new Ne, qe = new Ne), K || (ne = 0, q = 0, te = 0, le = 0);
                                const Pe = S.extractPoints(P);
                                let Te = Pe.shape;
                                const Je = Pe.holes;
                                if (!jl.isClockWise(Te)) {
                                    Te = Te.reverse();
                                    for (let Qt = 0, Ot = Je.length; Qt < Ot; Qt++) {
                                        const ln = Je[Qt];
                                        jl.isClockWise(ln) && (Je[Qt] = ln.reverse())
                                    }
                                }
                                const lt = jl.triangulateShape(Te, Je), pt = Te;
                                for (let Qt = 0, Ot = Je.length; Qt < Ot; Qt++) {
                                    const ln = Je[Qt];
                                    Te = Te.concat(ln)
                                }

                                function Mt(Qt, Ot, ln) {
                                    return Ot || console.error("THREE.ExtrudeGeometry: vec does not exist"), Qt.clone().addScaledVector(Ot, ln)
                                }

                                const Ut = Te.length, mn = lt.length;

                                function Tt(Qt, Ot, ln) {
                                    let on, tn, Tn;
                                    const Fn = Qt.x - Ot.x, Bi = Qt.y - Ot.y, Di = ln.x - Qt.x, wr = ln.y - Qt.y,
                                        ds = Fn * Fn + Bi * Bi, Xr = Fn * wr - Bi * Di;
                                    if (Math.abs(Xr) > Number.EPSILON) {
                                        const Ye = Math.sqrt(ds), Ie = Math.sqrt(Di * Di + wr * wr),
                                            It = Ot.x - Bi / Ye, Gt = Ot.y + Fn / Ye, Xt = ln.x - wr / Ie,
                                            Wt = ln.y + Di / Ie,
                                            ei = ((Xt - It) * wr - (Wt - Gt) * Di) / (Fn * wr - Bi * Di);
                                        on = It + Fn * ei - Qt.x, tn = Gt + Bi * ei - Qt.y;
                                        const An = on * on + tn * tn;
                                        if (An <= 2) return new zt(on, tn);
                                        Tn = Math.sqrt(An / 2)
                                    } else {
                                        let Ye = !1;
                                        Fn > Number.EPSILON ? Di > Number.EPSILON && (Ye = !0) : Fn < -Number.EPSILON ? Di < -Number.EPSILON && (Ye = !0) : Math.sign(Bi) === Math.sign(wr) && (Ye = !0), Ye ? (on = -Bi, tn = Fn, Tn = Math.sqrt(ds)) : (on = Fn, tn = Bi, Tn = Math.sqrt(ds / 2))
                                    }
                                    return new zt(on / Tn, tn / Tn)
                                }

                                const dn = [];
                                for (let Qt = 0, Ot = pt.length, ln = Ot - 1, on = Qt + 1; Qt < Ot; Qt++, ln++, on++) ln === Ot && (ln = 0), on === Ot && (on = 0), dn[Qt] = Tt(pt[Qt], pt[ln], pt[on]);
                                const fn = [];
                                let Kn, Qi = dn.concat();
                                for (let Qt = 0, Ot = Je.length; Qt < Ot; Qt++) {
                                    const ln = Je[Qt];
                                    Kn = [];
                                    for (let on = 0, tn = ln.length, Tn = tn - 1, Fn = on + 1; on < tn; on++, Tn++, Fn++) Tn === tn && (Tn = 0), Fn === tn && (Fn = 0), Kn[on] = Tt(ln[on], ln[Tn], ln[Fn]);
                                    fn.push(Kn), Qi = Qi.concat(Kn)
                                }
                                for (let Qt = 0; Qt < ne; Qt++) {
                                    const Ot = Qt / ne, ln = q * Math.cos(Ot * Math.PI / 2),
                                        on = te * Math.sin(Ot * Math.PI / 2) + le;
                                    for (let tn = 0, Tn = pt.length; tn < Tn; tn++) {
                                        const Fn = Mt(pt[tn], dn[tn], on);
                                        Jn(Fn.x, Fn.y, -ln)
                                    }
                                    for (let tn = 0, Tn = Je.length; tn < Tn; tn++) {
                                        const Fn = Je[tn];
                                        Kn = fn[tn];
                                        for (let Bi = 0, Di = Fn.length; Bi < Di; Bi++) {
                                            const wr = Mt(Fn[Bi], Kn[Bi], on);
                                            Jn(wr.x, wr.y, -ln)
                                        }
                                    }
                                }
                                const Tr = te + le;
                                for (let Qt = 0; Qt < Ut; Qt++) {
                                    const Ot = K ? Mt(Te[Qt], Qi[Qt], Tr) : Te[Qt];
                                    ge ? (We.copy($e.normals[0]).multiplyScalar(Ot.x), ze.copy($e.binormals[0]).multiplyScalar(Ot.y), qe.copy(ye[0]).add(We).add(ze), Jn(qe.x, qe.y, qe.z)) : Jn(Ot.x, Ot.y, 0)
                                }
                                for (let Qt = 1; Qt <= z; Qt++) for (let Ot = 0; Ot < Ut; Ot++) {
                                    const ln = K ? Mt(Te[Ot], Qi[Ot], Tr) : Te[Ot];
                                    ge ? (We.copy($e.normals[Qt]).multiplyScalar(ln.x), ze.copy($e.binormals[Qt]).multiplyScalar(ln.y), qe.copy(ye[Qt]).add(We).add(ze), Jn(qe.x, qe.y, qe.z)) : Jn(ln.x, ln.y, Q / z * Qt)
                                }
                                for (let Qt = ne - 1; Qt >= 0; Qt--) {
                                    const Ot = Qt / ne, ln = q * Math.cos(Ot * Math.PI / 2),
                                        on = te * Math.sin(Ot * Math.PI / 2) + le;
                                    for (let tn = 0, Tn = pt.length; tn < Tn; tn++) {
                                        const Fn = Mt(pt[tn], dn[tn], on);
                                        Jn(Fn.x, Fn.y, Q + ln)
                                    }
                                    for (let tn = 0, Tn = Je.length; tn < Tn; tn++) {
                                        const Fn = Je[tn];
                                        Kn = fn[tn];
                                        for (let Bi = 0, Di = Fn.length; Bi < Di; Bi++) {
                                            const wr = Mt(Fn[Bi], Kn[Bi], on);
                                            ge ? Jn(wr.x, wr.y + ye[z - 1].y, ye[z - 1].x + ln) : Jn(wr.x, wr.y, Q + ln)
                                        }
                                    }
                                }
                                Kr(), Cr();

                                function Kr() {
                                    const Qt = a.length / 3;
                                    if (K) {
                                        let Ot = 0, ln = Ut * Ot;
                                        for (let on = 0; on < mn; on++) {
                                            const tn = lt[on];
                                            Ht(tn[2] + ln, tn[1] + ln, tn[0] + ln)
                                        }
                                        Ot = z + ne * 2, ln = Ut * Ot;
                                        for (let on = 0; on < mn; on++) {
                                            const tn = lt[on];
                                            Ht(tn[0] + ln, tn[1] + ln, tn[2] + ln)
                                        }
                                    } else {
                                        for (let Ot = 0; Ot < mn; Ot++) {
                                            const ln = lt[Ot];
                                            Ht(ln[2], ln[1], ln[0])
                                        }
                                        for (let Ot = 0; Ot < mn; Ot++) {
                                            const ln = lt[Ot];
                                            Ht(ln[0] + Ut * z, ln[1] + Ut * z, ln[2] + Ut * z)
                                        }
                                    }
                                    r.addGroup(Qt, a.length / 3 - Qt, 0)
                                }

                                function Cr() {
                                    const Qt = a.length / 3;
                                    let Ot = 0;
                                    Vr(pt, Ot), Ot += pt.length;
                                    for (let ln = 0, on = Je.length; ln < on; ln++) {
                                        const tn = Je[ln];
                                        Vr(tn, Ot), Ot += tn.length
                                    }
                                    r.addGroup(Qt, a.length / 3 - Qt, 1)
                                }

                                function Vr(Qt, Ot) {
                                    let ln = Qt.length;
                                    for (; --ln >= 0;) {
                                        const on = ln;
                                        let tn = ln - 1;
                                        tn < 0 && (tn = Qt.length - 1);
                                        for (let Tn = 0, Fn = z + ne * 2; Tn < Fn; Tn++) {
                                            const Bi = Ut * Tn, Di = Ut * (Tn + 1), wr = Ot + on + Bi,
                                                ds = Ot + tn + Bi, Xr = Ot + tn + Di, Ye = Ot + on + Di;
                                            vn(wr, ds, Xr, Ye)
                                        }
                                    }
                                }

                                function Jn(Qt, Ot, ln) {
                                    D.push(Qt), D.push(Ot), D.push(ln)
                                }

                                function Ht(Qt, Ot, ln) {
                                    bn(Qt), bn(Ot), bn(ln);
                                    const on = a.length / 3, tn = Ce.generateTopUV(r, a, on - 3, on - 2, on - 1);
                                    mt(tn[0]), mt(tn[1]), mt(tn[2])
                                }

                                function vn(Qt, Ot, ln, on) {
                                    bn(Qt), bn(Ot), bn(on), bn(Ot), bn(ln), bn(on);
                                    const tn = a.length / 3,
                                        Tn = Ce.generateSideWallUV(r, a, tn - 6, tn - 3, tn - 2, tn - 1);
                                    mt(Tn[0]), mt(Tn[1]), mt(Tn[3]), mt(Tn[1]), mt(Tn[2]), mt(Tn[3])
                                }

                                function bn(Qt) {
                                    a.push(D[Qt * 3 + 0]), a.push(D[Qt * 3 + 1]), a.push(D[Qt * 3 + 2])
                                }

                                function mt(Qt) {
                                    u.push(Qt.x), u.push(Qt.y)
                                }
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        toJSON() {
                            const e = super.toJSON(), n = this.parameters.shapes, r = this.parameters.options;
                            return rM(n, r, e)
                        }

                        static fromJSON(e, n) {
                            const r = [];
                            for (let u = 0, y = e.shapes.length; u < y; u++) {
                                const S = n[e.shapes[u]];
                                r.push(S)
                            }
                            const a = e.options.extrudePath;
                            return a !== void 0 && (e.options.extrudePath = new sg[a.type]().fromJSON(a)), new Ag(r, e.options)
                        }
                    }

                    const iM = {
                        generateTopUV: function (d, e, n, r, a) {
                            const u = e[n * 3], y = e[n * 3 + 1], S = e[r * 3], D = e[r * 3 + 1], P = e[a * 3],
                                z = e[a * 3 + 1];
                            return [new zt(u, y), new zt(S, D), new zt(P, z)]
                        }, generateSideWallUV: function (d, e, n, r, a, u) {
                            const y = e[n * 3], S = e[n * 3 + 1], D = e[n * 3 + 2], P = e[r * 3], z = e[r * 3 + 1],
                                Q = e[r * 3 + 2], K = e[a * 3], q = e[a * 3 + 1], te = e[a * 3 + 2], le = e[u * 3],
                                ne = e[u * 3 + 1], J = e[u * 3 + 2];
                            return Math.abs(S - z) < Math.abs(y - P) ? [new zt(y, 1 - D), new zt(P, 1 - Q), new zt(K, 1 - te), new zt(le, 1 - J)] : [new zt(S, 1 - D), new zt(z, 1 - Q), new zt(q, 1 - te), new zt(ne, 1 - J)]
                        }
                    };

                    function rM(d, e, n) {
                        if (n.shapes = [], Array.isArray(d)) for (let r = 0, a = d.length; r < a; r++) {
                            const u = d[r];
                            n.shapes.push(u.uuid)
                        } else n.shapes.push(d.uuid);
                        return n.options = Object.assign({}, e), e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n
                    }

                    class gg extends fu {
                        constructor(e = 1, n = 0) {
                            const r = (1 + Math.sqrt(5)) / 2,
                                a = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1],
                                u = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                            super(a, u, e, n), this.type = "IcosahedronGeometry", this.parameters = {
                                radius: e,
                                detail: n
                            }
                        }

                        static fromJSON(e) {
                            return new gg(e.radius, e.detail)
                        }
                    }

                    class Up extends fu {
                        constructor(e = 1, n = 0) {
                            const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                                a = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                            super(r, a, e, n), this.type = "OctahedronGeometry", this.parameters = {
                                radius: e,
                                detail: n
                            }
                        }

                        static fromJSON(e) {
                            return new Up(e.radius, e.detail)
                        }
                    }

                    class vg extends Ti {
                        constructor(e = .5, n = 1, r = 32, a = 1, u = 0, y = Math.PI * 2) {
                            super(), this.type = "RingGeometry", this.parameters = {
                                innerRadius: e,
                                outerRadius: n,
                                thetaSegments: r,
                                phiSegments: a,
                                thetaStart: u,
                                thetaLength: y
                            }, r = Math.max(3, r), a = Math.max(1, a);
                            const S = [], D = [], P = [], z = [];
                            let Q = e;
                            const K = (n - e) / a, q = new Ne, te = new zt;
                            for (let le = 0; le <= a; le++) {
                                for (let ne = 0; ne <= r; ne++) {
                                    const J = u + ne / r * y;
                                    q.x = Q * Math.cos(J), q.y = Q * Math.sin(J), D.push(q.x, q.y, q.z), P.push(0, 0, 1), te.x = (q.x / n + 1) / 2, te.y = (q.y / n + 1) / 2, z.push(te.x, te.y)
                                }
                                Q += K
                            }
                            for (let le = 0; le < a; le++) {
                                const ne = le * (r + 1);
                                for (let J = 0; J < r; J++) {
                                    const Ce = J + ne, ye = Ce, ge = Ce + r + 1, $e = Ce + r + 2, ze = Ce + 1;
                                    S.push(ye, ge, ze), S.push(ge, $e, ze)
                                }
                            }
                            this.setIndex(S), this.setAttribute("position", new Xn(D, 3)), this.setAttribute("normal", new Xn(P, 3)), this.setAttribute("uv", new Xn(z, 2))
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new vg(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
                        }
                    }

                    class yg extends Ti {
                        constructor(e = new yh([new zt(0, .5), new zt(-.5, -.5), new zt(.5, -.5)]), n = 12) {
                            super(), this.type = "ShapeGeometry", this.parameters = {shapes: e, curveSegments: n};
                            const r = [], a = [], u = [], y = [];
                            let S = 0, D = 0;
                            if (Array.isArray(e) === !1) P(e); else for (let z = 0; z < e.length; z++) P(e[z]), this.addGroup(S, D, z), S += D, D = 0;
                            this.setIndex(r), this.setAttribute("position", new Xn(a, 3)), this.setAttribute("normal", new Xn(u, 3)), this.setAttribute("uv", new Xn(y, 2));

                            function P(z) {
                                const Q = a.length / 3, K = z.extractPoints(n);
                                let q = K.shape;
                                const te = K.holes;
                                jl.isClockWise(q) === !1 && (q = q.reverse());
                                for (let ne = 0, J = te.length; ne < J; ne++) {
                                    const Ce = te[ne];
                                    jl.isClockWise(Ce) === !0 && (te[ne] = Ce.reverse())
                                }
                                const le = jl.triangulateShape(q, te);
                                for (let ne = 0, J = te.length; ne < J; ne++) {
                                    const Ce = te[ne];
                                    q = q.concat(Ce)
                                }
                                for (let ne = 0, J = q.length; ne < J; ne++) {
                                    const Ce = q[ne];
                                    a.push(Ce.x, Ce.y, 0), u.push(0, 0, 1), y.push(Ce.x, Ce.y)
                                }
                                for (let ne = 0, J = le.length; ne < J; ne++) {
                                    const Ce = le[ne], ye = Ce[0] + Q, ge = Ce[1] + Q, $e = Ce[2] + Q;
                                    r.push(ye, ge, $e), D += 3
                                }
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        toJSON() {
                            const e = super.toJSON(), n = this.parameters.shapes;
                            return sM(n, e)
                        }

                        static fromJSON(e, n) {
                            const r = [];
                            for (let a = 0, u = e.shapes.length; a < u; a++) {
                                const y = n[e.shapes[a]];
                                r.push(y)
                            }
                            return new yg(r, e.curveSegments)
                        }
                    }

                    function sM(d, e) {
                        if (e.shapes = [], Array.isArray(d)) for (let n = 0, r = d.length; n < r; n++) {
                            const a = d[n];
                            e.shapes.push(a.uuid)
                        } else e.shapes.push(d.uuid);
                        return e
                    }

                    class zp extends Ti {
                        constructor(e = 1, n = 32, r = 16, a = 0, u = Math.PI * 2, y = 0, S = Math.PI) {
                            super(), this.type = "SphereGeometry", this.parameters = {
                                radius: e,
                                widthSegments: n,
                                heightSegments: r,
                                phiStart: a,
                                phiLength: u,
                                thetaStart: y,
                                thetaLength: S
                            }, n = Math.max(3, Math.floor(n)), r = Math.max(2, Math.floor(r));
                            const D = Math.min(y + S, Math.PI);
                            let P = 0;
                            const z = [], Q = new Ne, K = new Ne, q = [], te = [], le = [], ne = [];
                            for (let J = 0; J <= r; J++) {
                                const Ce = [], ye = J / r;
                                let ge = 0;
                                J === 0 && y === 0 ? ge = .5 / n : J === r && D === Math.PI && (ge = -.5 / n);
                                for (let $e = 0; $e <= n; $e++) {
                                    const ze = $e / n;
                                    Q.x = -e * Math.cos(a + ze * u) * Math.sin(y + ye * S), Q.y = e * Math.cos(y + ye * S), Q.z = e * Math.sin(a + ze * u) * Math.sin(y + ye * S), te.push(Q.x, Q.y, Q.z), K.copy(Q).normalize(), le.push(K.x, K.y, K.z), ne.push(ze + ge, 1 - ye), Ce.push(P++)
                                }
                                z.push(Ce)
                            }
                            for (let J = 0; J < r; J++) for (let Ce = 0; Ce < n; Ce++) {
                                const ye = z[J][Ce + 1], ge = z[J][Ce], $e = z[J + 1][Ce], ze = z[J + 1][Ce + 1];
                                (J !== 0 || y > 0) && q.push(ye, ge, ze), (J !== r - 1 || D < Math.PI) && q.push(ge, $e, ze)
                            }
                            this.setIndex(q), this.setAttribute("position", new Xn(te, 3)), this.setAttribute("normal", new Xn(le, 3)), this.setAttribute("uv", new Xn(ne, 2))
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new zp(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
                        }
                    }

                    class Eg extends fu {
                        constructor(e = 1, n = 0) {
                            const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                                a = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                            super(r, a, e, n), this.type = "TetrahedronGeometry", this.parameters = {
                                radius: e,
                                detail: n
                            }
                        }

                        static fromJSON(e) {
                            return new Eg(e.radius, e.detail)
                        }
                    }

                    class xg extends Ti {
                        constructor(e = 1, n = .4, r = 12, a = 48, u = Math.PI * 2) {
                            super(), this.type = "TorusGeometry", this.parameters = {
                                radius: e,
                                tube: n,
                                radialSegments: r,
                                tubularSegments: a,
                                arc: u
                            }, r = Math.floor(r), a = Math.floor(a);
                            const y = [], S = [], D = [], P = [], z = new Ne, Q = new Ne, K = new Ne;
                            for (let q = 0; q <= r; q++) for (let te = 0; te <= a; te++) {
                                const le = te / a * u, ne = q / r * Math.PI * 2;
                                Q.x = (e + n * Math.cos(ne)) * Math.cos(le), Q.y = (e + n * Math.cos(ne)) * Math.sin(le), Q.z = n * Math.sin(ne), S.push(Q.x, Q.y, Q.z), z.x = e * Math.cos(le), z.y = e * Math.sin(le), K.subVectors(Q, z).normalize(), D.push(K.x, K.y, K.z), P.push(te / a), P.push(q / r)
                            }
                            for (let q = 1; q <= r; q++) for (let te = 1; te <= a; te++) {
                                const le = (a + 1) * q + te - 1, ne = (a + 1) * (q - 1) + te - 1,
                                    J = (a + 1) * (q - 1) + te, Ce = (a + 1) * q + te;
                                y.push(le, ne, Ce), y.push(ne, J, Ce)
                            }
                            this.setIndex(y), this.setAttribute("position", new Xn(S, 3)), this.setAttribute("normal", new Xn(D, 3)), this.setAttribute("uv", new Xn(P, 2))
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new xg(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
                        }
                    }

                    class Cg extends Ti {
                        constructor(e = 1, n = .4, r = 64, a = 8, u = 2, y = 3) {
                            super(), this.type = "TorusKnotGeometry", this.parameters = {
                                radius: e,
                                tube: n,
                                tubularSegments: r,
                                radialSegments: a,
                                p: u,
                                q: y
                            }, r = Math.floor(r), a = Math.floor(a);
                            const S = [], D = [], P = [], z = [], Q = new Ne, K = new Ne, q = new Ne, te = new Ne,
                                le = new Ne, ne = new Ne, J = new Ne;
                            for (let ye = 0; ye <= r; ++ye) {
                                const ge = ye / r * u * Math.PI * 2;
                                Ce(ge, u, y, e, q), Ce(ge + .01, u, y, e, te), ne.subVectors(te, q), J.addVectors(te, q), le.crossVectors(ne, J), J.crossVectors(le, ne), le.normalize(), J.normalize();
                                for (let $e = 0; $e <= a; ++$e) {
                                    const ze = $e / a * Math.PI * 2, We = -n * Math.cos(ze), qe = n * Math.sin(ze);
                                    Q.x = q.x + (We * J.x + qe * le.x), Q.y = q.y + (We * J.y + qe * le.y), Q.z = q.z + (We * J.z + qe * le.z), D.push(Q.x, Q.y, Q.z), K.subVectors(Q, q).normalize(), P.push(K.x, K.y, K.z), z.push(ye / r), z.push($e / a)
                                }
                            }
                            for (let ye = 1; ye <= r; ye++) for (let ge = 1; ge <= a; ge++) {
                                const $e = (a + 1) * (ye - 1) + (ge - 1), ze = (a + 1) * ye + (ge - 1),
                                    We = (a + 1) * ye + ge, qe = (a + 1) * (ye - 1) + ge;
                                S.push($e, ze, qe), S.push(ze, We, qe)
                            }
                            this.setIndex(S), this.setAttribute("position", new Xn(D, 3)), this.setAttribute("normal", new Xn(P, 3)), this.setAttribute("uv", new Xn(z, 2));

                            function Ce(ye, ge, $e, ze, We) {
                                const qe = Math.cos(ye), Pe = Math.sin(ye), Te = $e / ge * ye, Je = Math.cos(Te);
                                We.x = ze * (2 + Je) * .5 * qe, We.y = ze * (2 + Je) * Pe * .5, We.z = ze * Math.sin(Te) * .5
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        static fromJSON(e) {
                            return new Cg(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
                        }
                    }

                    class wg extends Ti {
                        constructor(e = new Dv(new Ne(-1, -1, 0), new Ne(-1, 1, 0), new Ne(1, 1, 0)), n = 64, r = 1, a = 8, u = !1) {
                            super(), this.type = "TubeGeometry", this.parameters = {
                                path: e,
                                tubularSegments: n,
                                radius: r,
                                radialSegments: a,
                                closed: u
                            };
                            const y = e.computeFrenetFrames(n, u);
                            this.tangents = y.tangents, this.normals = y.normals, this.binormals = y.binormals;
                            const S = new Ne, D = new Ne, P = new zt;
                            let z = new Ne;
                            const Q = [], K = [], q = [], te = [];
                            le(), this.setIndex(te), this.setAttribute("position", new Xn(Q, 3)), this.setAttribute("normal", new Xn(K, 3)), this.setAttribute("uv", new Xn(q, 2));

                            function le() {
                                for (let ye = 0; ye < n; ye++) ne(ye);
                                ne(u === !1 ? n : 0), Ce(), J()
                            }

                            function ne(ye) {
                                z = e.getPointAt(ye / n, z);
                                const ge = y.normals[ye], $e = y.binormals[ye];
                                for (let ze = 0; ze <= a; ze++) {
                                    const We = ze / a * Math.PI * 2, qe = Math.sin(We), Pe = -Math.cos(We);
                                    D.x = Pe * ge.x + qe * $e.x, D.y = Pe * ge.y + qe * $e.y, D.z = Pe * ge.z + qe * $e.z, D.normalize(), K.push(D.x, D.y, D.z), S.x = z.x + r * D.x, S.y = z.y + r * D.y, S.z = z.z + r * D.z, Q.push(S.x, S.y, S.z)
                                }
                            }

                            function J() {
                                for (let ye = 1; ye <= n; ye++) for (let ge = 1; ge <= a; ge++) {
                                    const $e = (a + 1) * (ye - 1) + (ge - 1), ze = (a + 1) * ye + (ge - 1),
                                        We = (a + 1) * ye + ge, qe = (a + 1) * (ye - 1) + ge;
                                    te.push($e, ze, qe), te.push(ze, We, qe)
                                }
                            }

                            function Ce() {
                                for (let ye = 0; ye <= n; ye++) for (let ge = 0; ge <= a; ge++) P.x = ye / n, P.y = ge / a, q.push(P.x, P.y)
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.path = this.parameters.path.toJSON(), e
                        }

                        static fromJSON(e) {
                            return new wg(new sg[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
                        }
                    }

                    class jE extends Ti {
                        constructor(e = null) {
                            if (super(), this.type = "WireframeGeometry", this.parameters = {geometry: e}, e !== null) {
                                const n = [], r = new Set, a = new Ne, u = new Ne;
                                if (e.index !== null) {
                                    const y = e.attributes.position, S = e.index;
                                    let D = e.groups;
                                    D.length === 0 && (D = [{start: 0, count: S.count, materialIndex: 0}]);
                                    for (let P = 0, z = D.length; P < z; ++P) {
                                        const Q = D[P], K = Q.start, q = Q.count;
                                        for (let te = K, le = K + q; te < le; te += 3) for (let ne = 0; ne < 3; ne++) {
                                            const J = S.getX(te + ne), Ce = S.getX(te + (ne + 1) % 3);
                                            a.fromBufferAttribute(y, J), u.fromBufferAttribute(y, Ce), WE(a, u, r) === !0 && (n.push(a.x, a.y, a.z), n.push(u.x, u.y, u.z))
                                        }
                                    }
                                } else {
                                    const y = e.attributes.position;
                                    for (let S = 0, D = y.count / 3; S < D; S++) for (let P = 0; P < 3; P++) {
                                        const z = 3 * S + P, Q = 3 * S + (P + 1) % 3;
                                        a.fromBufferAttribute(y, z), u.fromBufferAttribute(y, Q), WE(a, u, r) === !0 && (n.push(a.x, a.y, a.z), n.push(u.x, u.y, u.z))
                                    }
                                }
                                this.setAttribute("position", new Xn(n, 3))
                            }
                        }

                        copy(e) {
                            return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
                        }
                    }

                    function WE(d, e, n) {
                        const r = `${d.x},${d.y},${d.z}-${e.x},${e.y},${e.z}`,
                            a = `${e.x},${e.y},${e.z}-${d.x},${d.y},${d.z}`;
                        return n.has(r) === !0 || n.has(a) === !0 ? !1 : (n.add(r), n.add(a), !0)
                    }

                    var KE = Object.freeze({
                        __proto__: null,
                        BoxGeometry: ma,
                        CapsuleGeometry: og,
                        CircleGeometry: ag,
                        ConeGeometry: lg,
                        CylinderGeometry: Nd,
                        DodecahedronGeometry: cg,
                        EdgesGeometry: NE,
                        ExtrudeGeometry: Ag,
                        IcosahedronGeometry: gg,
                        LatheGeometry: Op,
                        OctahedronGeometry: Up,
                        PlaneGeometry: xc,
                        PolyhedronGeometry: fu,
                        RingGeometry: vg,
                        ShapeGeometry: yg,
                        SphereGeometry: zp,
                        TetrahedronGeometry: Eg,
                        TorusGeometry: xg,
                        TorusKnotGeometry: Cg,
                        TubeGeometry: wg,
                        WireframeGeometry: jE
                    });

                    class XE extends Dr {
                        constructor(e) {
                            super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Bn(0), this.transparent = !0, this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
                        }
                    }

                    class YE extends ta {
                        constructor(e) {
                            super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
                        }
                    }

                    class Nv extends Dr {
                        constructor(e) {
                            super(), this.isMeshStandardMaterial = !0, this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new Bn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Bn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zs, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bo, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.defines = {STANDARD: ""}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                        }
                    }

                    class qE extends Nv {
                        constructor(e) {
                            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                                STANDARD: "",
                                PHYSICAL: ""
                            }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new zt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                                get: function () {
                                    return Hr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                                }, set: function (n) {
                                    this.ior = (1 + .4 * n) / (1 - .4 * n)
                                }
                            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Bn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Bn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Bn(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
                        }

                        get anisotropy() {
                            return this._anisotropy
                        }

                        set anisotropy(e) {
                            this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
                        }

                        get clearcoat() {
                            return this._clearcoat
                        }

                        set clearcoat(e) {
                            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                        }

                        get iridescence() {
                            return this._iridescence
                        }

                        set iridescence(e) {
                            this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
                        }

                        get dispersion() {
                            return this._dispersion
                        }

                        set dispersion(e) {
                            this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
                        }

                        get sheen() {
                            return this._sheen
                        }

                        set sheen(e) {
                            this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                        }

                        get transmission() {
                            return this._transmission
                        }

                        set transmission(e) {
                            this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                        }

                        copy(e) {
                            return super.copy(e), this.defines = {
                                STANDARD: "",
                                PHYSICAL: ""
                            }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                        }
                    }

                    class JE extends Dr {
                        constructor(e) {
                            super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Bn(16777215), this.specular = new Bn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Bn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zs, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bo, this.combine = Ji, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                        }
                    }

                    class ZE extends Dr {
                        constructor(e) {
                            super(), this.isMeshToonMaterial = !0, this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.color = new Bn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Bn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zs, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                        }
                    }

                    class $E extends Dr {
                        constructor(e) {
                            super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zs, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
                        }
                    }

                    class ex extends Dr {
                        constructor(e) {
                            super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Bn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Bn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zs, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bo, this.combine = Ji, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                        }
                    }

                    class tx extends Dr {
                        constructor(e) {
                            super(), this.isMeshMatcapMaterial = !0, this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new Bn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zs, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.defines = {MATCAP: ""}, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
                        }
                    }

                    class nx extends oa {
                        constructor(e) {
                            super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
                        }

                        copy(e) {
                            return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
                        }
                    }

                    function xh(d, e, n) {
                        return !d || !n && d.constructor === e ? d : typeof e.BYTES_PER_ELEMENT == "number" ? new e(d) : Array.prototype.slice.call(d)
                    }

                    function ix(d) {
                        return ArrayBuffer.isView(d) && !(d instanceof DataView)
                    }

                    function rx(d) {
                        function e(a, u) {
                            return d[a] - d[u]
                        }

                        const n = d.length, r = new Array(n);
                        for (let a = 0; a !== n; ++a) r[a] = a;
                        return r.sort(e), r
                    }

                    function Uv(d, e, n) {
                        const r = d.length, a = new d.constructor(r);
                        for (let u = 0, y = 0; y !== r; ++u) {
                            const S = n[u] * e;
                            for (let D = 0; D !== e; ++D) a[y++] = d[S + D]
                        }
                        return a
                    }

                    function zv(d, e, n, r) {
                        let a = 1, u = d[0];
                        for (; u !== void 0 && u[r] === void 0;) u = d[a++];
                        if (u === void 0) return;
                        let y = u[r];
                        if (y !== void 0) if (Array.isArray(y)) do y = u[r], y !== void 0 && (e.push(u.time), n.push.apply(n, y)), u = d[a++]; while (u !== void 0); else if (y.toArray !== void 0) do y = u[r], y !== void 0 && (e.push(u.time), y.toArray(n, n.length)), u = d[a++]; while (u !== void 0); else do y = u[r], y !== void 0 && (e.push(u.time), n.push(y)), u = d[a++]; while (u !== void 0)
                    }

                    function oM(d, e, n, r, a = 30) {
                        const u = d.clone();
                        u.name = e;
                        const y = [];
                        for (let D = 0; D < u.tracks.length; ++D) {
                            const P = u.tracks[D], z = P.getValueSize(), Q = [], K = [];
                            for (let q = 0; q < P.times.length; ++q) {
                                const te = P.times[q] * a;
                                if (!(te < n || te >= r)) {
                                    Q.push(P.times[q]);
                                    for (let le = 0; le < z; ++le) K.push(P.values[q * z + le])
                                }
                            }
                            Q.length !== 0 && (P.times = xh(Q, P.times.constructor), P.values = xh(K, P.values.constructor), y.push(P))
                        }
                        u.tracks = y;
                        let S = 1 / 0;
                        for (let D = 0; D < u.tracks.length; ++D) S > u.tracks[D].times[0] && (S = u.tracks[D].times[0]);
                        for (let D = 0; D < u.tracks.length; ++D) u.tracks[D].shift(-1 * S);
                        return u.resetDuration(), u
                    }

                    function aM(d, e = 0, n = d, r = 30) {
                        r <= 0 && (r = 30);
                        const a = n.tracks.length, u = e / r;
                        for (let y = 0; y < a; ++y) {
                            const S = n.tracks[y], D = S.ValueTypeName;
                            if (D === "bool" || D === "string") continue;
                            const P = d.tracks.find(function (J) {
                                return J.name === S.name && J.ValueTypeName === D
                            });
                            if (P === void 0) continue;
                            let z = 0;
                            const Q = S.getValueSize();
                            S.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (z = Q / 3);
                            let K = 0;
                            const q = P.getValueSize();
                            P.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (K = q / 3);
                            const te = S.times.length - 1;
                            let le;
                            if (u <= S.times[0]) {
                                const J = z, Ce = Q - z;
                                le = S.values.slice(J, Ce)
                            } else if (u >= S.times[te]) {
                                const J = te * Q + z, Ce = J + Q - z;
                                le = S.values.slice(J, Ce)
                            } else {
                                const J = S.createInterpolant(), Ce = z, ye = Q - z;
                                J.evaluate(u), le = J.resultBuffer.slice(Ce, ye)
                            }
                            D === "quaternion" && new $i().fromArray(le).normalize().conjugate().toArray(le);
                            const ne = P.times.length;
                            for (let J = 0; J < ne; ++J) {
                                const Ce = J * q + K;
                                if (D === "quaternion") $i.multiplyQuaternionsFlat(P.values, Ce, le, 0, P.values, Ce); else {
                                    const ye = q - K * 2;
                                    for (let ge = 0; ge < ye; ++ge) P.values[Ce + ge] -= le[ge]
                                }
                            }
                        }
                        return d.blendMode = gi, d
                    }

                    const lM = {
                        convertArray: xh,
                        isTypedArray: ix,
                        getKeyframeOrder: rx,
                        sortedArray: Uv,
                        flattenJSON: zv,
                        subclip: oM,
                        makeClipAdditive: aM
                    };

                    class Gp {
                        constructor(e, n, r, a) {
                            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = a !== void 0 ? a : new n.constructor(r), this.sampleValues = n, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {}
                        }

                        evaluate(e) {
                            const n = this.parameterPositions;
                            let r = this._cachedIndex, a = n[r], u = n[r - 1];
                            e:{
                                t:{
                                    let y;
                                    n:{
                                        i:if (!(e < a)) {
                                            for (let S = r + 2; ;) {
                                                if (a === void 0) {
                                                    if (e < u) break i;
                                                    return r = n.length, this._cachedIndex = r, this.copySampleValue_(r - 1)
                                                }
                                                if (r === S) break;
                                                if (u = a, a = n[++r], e < a) break t
                                            }
                                            y = n.length;
                                            break n
                                        }
                                        if (!(e >= u)) {
                                            const S = n[1];
                                            e < S && (r = 2, u = S);
                                            for (let D = r - 2; ;) {
                                                if (u === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                                                if (r === D) break;
                                                if (a = u, u = n[--r - 1], e >= u) break t
                                            }
                                            y = r, r = 0;
                                            break n
                                        }
                                        break e
                                    }
                                    for (; r < y;) {
                                        const S = r + y >>> 1;
                                        e < n[S] ? y = S : r = S + 1
                                    }
                                    if (a = n[r], u = n[r - 1], u === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (a === void 0) return r = n.length, this._cachedIndex = r, this.copySampleValue_(r - 1)
                                }
                                this._cachedIndex = r, this.intervalChanged_(r, u, a)
                            }
                            return this.interpolate_(r, u, e, a)
                        }

                        getSettings_() {
                            return this.settings || this.DefaultSettings_
                        }

                        copySampleValue_(e) {
                            const n = this.resultBuffer, r = this.sampleValues, a = this.valueSize, u = e * a;
                            for (let y = 0; y !== a; ++y) n[y] = r[u + y];
                            return n
                        }

                        interpolate_() {
                            throw new Error("call to abstract method")
                        }

                        intervalChanged_() {
                        }
                    }

                    class sx extends Gp {
                        constructor(e, n, r, a) {
                            super(e, n, r, a), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                                endingStart: yn,
                                endingEnd: yn
                            }
                        }

                        intervalChanged_(e, n, r) {
                            const a = this.parameterPositions;
                            let u = e - 2, y = e + 1, S = a[u], D = a[y];
                            if (S === void 0) switch (this.getSettings_().endingStart) {
                                case bi:
                                    u = e, S = 2 * n - r;
                                    break;
                                case Ii:
                                    u = a.length - 2, S = n + a[u] - a[u + 1];
                                    break;
                                default:
                                    u = e, S = r
                            }
                            if (D === void 0) switch (this.getSettings_().endingEnd) {
                                case bi:
                                    y = e, D = 2 * r - n;
                                    break;
                                case Ii:
                                    y = 1, D = r + a[1] - a[0];
                                    break;
                                default:
                                    y = e - 1, D = n
                            }
                            const P = (r - n) * .5, z = this.valueSize;
                            this._weightPrev = P / (n - S), this._weightNext = P / (D - r), this._offsetPrev = u * z, this._offsetNext = y * z
                        }

                        interpolate_(e, n, r, a) {
                            const u = this.resultBuffer, y = this.sampleValues, S = this.valueSize, D = e * S,
                                P = D - S, z = this._offsetPrev, Q = this._offsetNext, K = this._weightPrev,
                                q = this._weightNext, te = (r - n) / (a - n), le = te * te, ne = le * te,
                                J = -K * ne + 2 * K * le - K * te,
                                Ce = (1 + K) * ne + (-1.5 - 2 * K) * le + (-.5 + K) * te + 1,
                                ye = (-1 - q) * ne + (1.5 + q) * le + .5 * te, ge = q * ne - q * le;
                            for (let $e = 0; $e !== S; ++$e) u[$e] = J * y[z + $e] + Ce * y[P + $e] + ye * y[D + $e] + ge * y[Q + $e];
                            return u
                        }
                    }

                    class Gv extends Gp {
                        constructor(e, n, r, a) {
                            super(e, n, r, a)
                        }

                        interpolate_(e, n, r, a) {
                            const u = this.resultBuffer, y = this.sampleValues, S = this.valueSize, D = e * S,
                                P = D - S, z = (r - n) / (a - n), Q = 1 - z;
                            for (let K = 0; K !== S; ++K) u[K] = y[P + K] * Q + y[D + K] * z;
                            return u
                        }
                    }

                    class ox extends Gp {
                        constructor(e, n, r, a) {
                            super(e, n, r, a)
                        }

                        interpolate_(e) {
                            return this.copySampleValue_(e - 1)
                        }
                    }

                    class Al {
                        constructor(e, n, r, a) {
                            if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
                            if (n === void 0 || n.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                            this.name = e, this.times = xh(n, this.TimeBufferType), this.values = xh(r, this.ValueBufferType), this.setInterpolation(a || this.DefaultInterpolation)
                        }

                        static toJSON(e) {
                            const n = e.constructor;
                            let r;
                            if (n.toJSON !== this.toJSON) r = n.toJSON(e); else {
                                r = {name: e.name, times: xh(e.times, Array), values: xh(e.values, Array)};
                                const a = e.getInterpolation();
                                a !== e.DefaultInterpolation && (r.interpolation = a)
                            }
                            return r.type = e.ValueTypeName, r
                        }

                        InterpolantFactoryMethodDiscrete(e) {
                            return new ox(this.times, this.values, this.getValueSize(), e)
                        }

                        InterpolantFactoryMethodLinear(e) {
                            return new Gv(this.times, this.values, this.getValueSize(), e)
                        }

                        InterpolantFactoryMethodSmooth(e) {
                            return new sx(this.times, this.values, this.getValueSize(), e)
                        }

                        setInterpolation(e) {
                            let n;
                            switch (e) {
                                case gn:
                                    n = this.InterpolantFactoryMethodDiscrete;
                                    break;
                                case un:
                                    n = this.InterpolantFactoryMethodLinear;
                                    break;
                                case _n:
                                    n = this.InterpolantFactoryMethodSmooth;
                                    break
                            }
                            if (n === void 0) {
                                const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                                if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(r);
                                return console.warn("THREE.KeyframeTrack:", r), this
                            }
                            return this.createInterpolant = n, this
                        }

                        getInterpolation() {
                            switch (this.createInterpolant) {
                                case this.InterpolantFactoryMethodDiscrete:
                                    return gn;
                                case this.InterpolantFactoryMethodLinear:
                                    return un;
                                case this.InterpolantFactoryMethodSmooth:
                                    return _n
                            }
                        }

                        getValueSize() {
                            return this.values.length / this.times.length
                        }

                        shift(e) {
                            if (e !== 0) {
                                const n = this.times;
                                for (let r = 0, a = n.length; r !== a; ++r) n[r] += e
                            }
                            return this
                        }

                        scale(e) {
                            if (e !== 1) {
                                const n = this.times;
                                for (let r = 0, a = n.length; r !== a; ++r) n[r] *= e
                            }
                            return this
                        }

                        trim(e, n) {
                            const r = this.times, a = r.length;
                            let u = 0, y = a - 1;
                            for (; u !== a && r[u] < e;) ++u;
                            for (; y !== -1 && r[y] > n;) --y;
                            if (++y, u !== 0 || y !== a) {
                                u >= y && (y = Math.max(y, 1), u = y - 1);
                                const S = this.getValueSize();
                                this.times = r.slice(u, y), this.values = this.values.slice(u * S, y * S)
                            }
                            return this
                        }

                        validate() {
                            let e = !0;
                            const n = this.getValueSize();
                            n - Math.floor(n) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                            const r = this.times, a = this.values, u = r.length;
                            u === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                            let y = null;
                            for (let S = 0; S !== u; S++) {
                                const D = r[S];
                                if (typeof D == "number" && isNaN(D)) {
                                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, S, D), e = !1;
                                    break
                                }
                                if (y !== null && y > D) {
                                    console.error("THREE.KeyframeTrack: Out of order keys.", this, S, D, y), e = !1;
                                    break
                                }
                                y = D
                            }
                            if (a !== void 0 && ix(a)) for (let S = 0, D = a.length; S !== D; ++S) {
                                const P = a[S];
                                if (isNaN(P)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, S, P), e = !1;
                                    break
                                }
                            }
                            return e
                        }

                        optimize() {
                            const e = this.times.slice(), n = this.values.slice(), r = this.getValueSize(),
                                a = this.getInterpolation() === _n, u = e.length - 1;
                            let y = 1;
                            for (let S = 1; S < u; ++S) {
                                let D = !1;
                                const P = e[S], z = e[S + 1];
                                if (P !== z && (S !== 1 || P !== e[0])) if (a) D = !0; else {
                                    const Q = S * r, K = Q - r, q = Q + r;
                                    for (let te = 0; te !== r; ++te) {
                                        const le = n[Q + te];
                                        if (le !== n[K + te] || le !== n[q + te]) {
                                            D = !0;
                                            break
                                        }
                                    }
                                }
                                if (D) {
                                    if (S !== y) {
                                        e[y] = e[S];
                                        const Q = S * r, K = y * r;
                                        for (let q = 0; q !== r; ++q) n[K + q] = n[Q + q]
                                    }
                                    ++y
                                }
                            }
                            if (u > 0) {
                                e[y] = e[u];
                                for (let S = u * r, D = y * r, P = 0; P !== r; ++P) n[D + P] = n[S + P];
                                ++y
                            }
                            return y !== e.length ? (this.times = e.slice(0, y), this.values = n.slice(0, y * r)) : (this.times = e, this.values = n), this
                        }

                        clone() {
                            const e = this.times.slice(), n = this.values.slice(), r = this.constructor,
                                a = new r(this.name, e, n);
                            return a.createInterpolant = this.createInterpolant, a
                        }
                    }

                    Al.prototype.TimeBufferType = Float32Array, Al.prototype.ValueBufferType = Float32Array, Al.prototype.DefaultInterpolation = un;

                    class Ch extends Al {
                    }

                    Ch.prototype.ValueTypeName = "bool", Ch.prototype.ValueBufferType = Array, Ch.prototype.DefaultInterpolation = gn, Ch.prototype.InterpolantFactoryMethodLinear = void 0, Ch.prototype.InterpolantFactoryMethodSmooth = void 0;

                    class Vv extends Al {
                    }

                    Vv.prototype.ValueTypeName = "color";

                    class Vp extends Al {
                    }

                    Vp.prototype.ValueTypeName = "number";

                    class ax extends Gp {
                        constructor(e, n, r, a) {
                            super(e, n, r, a)
                        }

                        interpolate_(e, n, r, a) {
                            const u = this.resultBuffer, y = this.sampleValues, S = this.valueSize,
                                D = (r - n) / (a - n);
                            let P = e * S;
                            for (let z = P + S; P !== z; P += 4) $i.slerpFlat(u, 0, y, P - S, y, P, D);
                            return u
                        }
                    }

                    class zd extends Al {
                        InterpolantFactoryMethodLinear(e) {
                            return new ax(this.times, this.values, this.getValueSize(), e)
                        }
                    }

                    zd.prototype.ValueTypeName = "quaternion", zd.prototype.DefaultInterpolation = un, zd.prototype.InterpolantFactoryMethodSmooth = void 0;

                    class wh extends Al {
                    }

                    wh.prototype.ValueTypeName = "string", wh.prototype.ValueBufferType = Array, wh.prototype.DefaultInterpolation = gn, wh.prototype.InterpolantFactoryMethodLinear = void 0, wh.prototype.InterpolantFactoryMethodSmooth = void 0;

                    class Hp extends Al {
                    }

                    Hp.prototype.ValueTypeName = "vector";

                    class Qp {
                        constructor(e = "", n = -1, r = [], a = _i) {
                            this.name = e, this.tracks = r, this.duration = n, this.blendMode = a, this.uuid = uo(), this.duration < 0 && this.resetDuration()
                        }

                        static parse(e) {
                            const n = [], r = e.tracks, a = 1 / (e.fps || 1);
                            for (let y = 0, S = r.length; y !== S; ++y) n.push(uM(r[y]).scale(a));
                            const u = new this(e.name, e.duration, n, e.blendMode);
                            return u.uuid = e.uuid, u
                        }

                        static toJSON(e) {
                            const n = [], r = e.tracks, a = {
                                name: e.name,
                                duration: e.duration,
                                tracks: n,
                                uuid: e.uuid,
                                blendMode: e.blendMode
                            };
                            for (let u = 0, y = r.length; u !== y; ++u) n.push(Al.toJSON(r[u]));
                            return a
                        }

                        static CreateFromMorphTargetSequence(e, n, r, a) {
                            const u = n.length, y = [];
                            for (let S = 0; S < u; S++) {
                                let D = [], P = [];
                                D.push((S + u - 1) % u, S, (S + 1) % u), P.push(0, 1, 0);
                                const z = rx(D);
                                D = Uv(D, 1, z), P = Uv(P, 1, z), !a && D[0] === 0 && (D.push(u), P.push(P[0])), y.push(new Vp(".morphTargetInfluences[" + n[S].name + "]", D, P).scale(1 / r))
                            }
                            return new this(e, -1, y)
                        }

                        static findByName(e, n) {
                            let r = e;
                            if (!Array.isArray(e)) {
                                const a = e;
                                r = a.geometry && a.geometry.animations || a.animations
                            }
                            for (let a = 0; a < r.length; a++) if (r[a].name === n) return r[a];
                            return null
                        }

                        static CreateClipsFromMorphTargetSequences(e, n, r) {
                            const a = {}, u = /^([\w-]*?)([\d]+)$/;
                            for (let S = 0, D = e.length; S < D; S++) {
                                const P = e[S], z = P.name.match(u);
                                if (z && z.length > 1) {
                                    const Q = z[1];
                                    let K = a[Q];
                                    K || (a[Q] = K = []), K.push(P)
                                }
                            }
                            const y = [];
                            for (const S in a) y.push(this.CreateFromMorphTargetSequence(S, a[S], n, r));
                            return y
                        }

                        static parseAnimation(e, n) {
                            if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                            const r = function (Q, K, q, te, le) {
                                if (q.length !== 0) {
                                    const ne = [], J = [];
                                    zv(q, ne, J, te), ne.length !== 0 && le.push(new Q(K, ne, J))
                                }
                            }, a = [], u = e.name || "default", y = e.fps || 30, S = e.blendMode;
                            let D = e.length || -1;
                            const P = e.hierarchy || [];
                            for (let Q = 0; Q < P.length; Q++) {
                                const K = P[Q].keys;
                                if (!(!K || K.length === 0)) if (K[0].morphTargets) {
                                    const q = {};
                                    let te;
                                    for (te = 0; te < K.length; te++) if (K[te].morphTargets) for (let le = 0; le < K[te].morphTargets.length; le++) q[K[te].morphTargets[le]] = -1;
                                    for (const le in q) {
                                        const ne = [], J = [];
                                        for (let Ce = 0; Ce !== K[te].morphTargets.length; ++Ce) {
                                            const ye = K[te];
                                            ne.push(ye.time), J.push(ye.morphTarget === le ? 1 : 0)
                                        }
                                        a.push(new Vp(".morphTargetInfluence[" + le + "]", ne, J))
                                    }
                                    D = q.length * y
                                } else {
                                    const q = ".bones[" + n[Q].name + "]";
                                    r(Hp, q + ".position", K, "pos", a), r(zd, q + ".quaternion", K, "rot", a), r(Hp, q + ".scale", K, "scl", a)
                                }
                            }
                            return a.length === 0 ? null : new this(u, D, a, S)
                        }

                        resetDuration() {
                            const e = this.tracks;
                            let n = 0;
                            for (let r = 0, a = e.length; r !== a; ++r) {
                                const u = this.tracks[r];
                                n = Math.max(n, u.times[u.times.length - 1])
                            }
                            return this.duration = n, this
                        }

                        trim() {
                            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                            return this
                        }

                        validate() {
                            let e = !0;
                            for (let n = 0; n < this.tracks.length; n++) e = e && this.tracks[n].validate();
                            return e
                        }

                        optimize() {
                            for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                            return this
                        }

                        clone() {
                            const e = [];
                            for (let n = 0; n < this.tracks.length; n++) e.push(this.tracks[n].clone());
                            return new this.constructor(this.name, this.duration, e, this.blendMode)
                        }

                        toJSON() {
                            return this.constructor.toJSON(this)
                        }
                    }

                    function cM(d) {
                        switch (d.toLowerCase()) {
                            case"scalar":
                            case"double":
                            case"float":
                            case"number":
                            case"integer":
                                return Vp;
                            case"vector":
                            case"vector2":
                            case"vector3":
                            case"vector4":
                                return Hp;
                            case"color":
                                return Vv;
                            case"quaternion":
                                return zd;
                            case"bool":
                            case"boolean":
                                return Ch;
                            case"string":
                                return wh
                        }
                        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + d)
                    }

                    function uM(d) {
                        if (d.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                        const e = cM(d.type);
                        if (d.times === void 0) {
                            const n = [], r = [];
                            zv(d.keys, n, r, "value"), d.times = n, d.values = r
                        }
                        return e.parse !== void 0 ? e.parse(d) : new e(d.name, d.times, d.values, d.interpolation)
                    }

                    const Rc = {
                        enabled: !1, files: {}, add: function (d, e) {
                            this.enabled !== !1 && (this.files[d] = e)
                        }, get: function (d) {
                            if (this.enabled !== !1) return this.files[d]
                        }, remove: function (d) {
                            delete this.files[d]
                        }, clear: function () {
                            this.files = {}
                        }
                    };

                    class Hv {
                        constructor(e, n, r) {
                            const a = this;
                            let u = !1, y = 0, S = 0, D;
                            const P = [];
                            this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = r, this.itemStart = function (z) {
                                S++, u === !1 && a.onStart !== void 0 && a.onStart(z, y, S), u = !0
                            }, this.itemEnd = function (z) {
                                y++, a.onProgress !== void 0 && a.onProgress(z, y, S), y === S && (u = !1, a.onLoad !== void 0 && a.onLoad())
                            }, this.itemError = function (z) {
                                a.onError !== void 0 && a.onError(z)
                            }, this.resolveURL = function (z) {
                                return D ? D(z) : z
                            }, this.setURLModifier = function (z) {
                                return D = z, this
                            }, this.addHandler = function (z, Q) {
                                return P.push(z, Q), this
                            }, this.removeHandler = function (z) {
                                const Q = P.indexOf(z);
                                return Q !== -1 && P.splice(Q, 2), this
                            }, this.getHandler = function (z) {
                                for (let Q = 0, K = P.length; Q < K; Q += 2) {
                                    const q = P[Q], te = P[Q + 1];
                                    if (q.global && (q.lastIndex = 0), q.test(z)) return te
                                }
                                return null
                            }
                        }
                    }

                    const lx = new Hv;

                    class ga {
                        constructor(e) {
                            this.manager = e !== void 0 ? e : lx, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                        }

                        load() {
                        }

                        loadAsync(e, n) {
                            const r = this;
                            return new Promise(function (a, u) {
                                r.load(e, a, n, u)
                            })
                        }

                        parse() {
                        }

                        setCrossOrigin(e) {
                            return this.crossOrigin = e, this
                        }

                        setWithCredentials(e) {
                            return this.withCredentials = e, this
                        }

                        setPath(e) {
                            return this.path = e, this
                        }

                        setResourcePath(e) {
                            return this.resourcePath = e, this
                        }

                        setRequestHeader(e) {
                            return this.requestHeader = e, this
                        }
                    }

                    ga.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                    const Bc = {};

                    class hM extends Error {
                        constructor(e, n) {
                            super(e), this.response = n
                        }
                    }

                    class Lc extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                            const u = Rc.get(e);
                            if (u !== void 0) return this.manager.itemStart(e), setTimeout(() => {
                                n && n(u), this.manager.itemEnd(e)
                            }, 0), u;
                            if (Bc[e] !== void 0) {
                                Bc[e].push({onLoad: n, onProgress: r, onError: a});
                                return
                            }
                            Bc[e] = [], Bc[e].push({onLoad: n, onProgress: r, onError: a});
                            const y = new Request(e, {
                                headers: new Headers(this.requestHeader),
                                credentials: this.withCredentials ? "include" : "same-origin"
                            }), S = this.mimeType, D = this.responseType;
                            fetch(y).then(P => {
                                if (P.status === 200 || P.status === 0) {
                                    if (P.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || P.body === void 0 || P.body.getReader === void 0) return P;
                                    const z = Bc[e], Q = P.body.getReader(),
                                        K = P.headers.get("X-File-Size") || P.headers.get("Content-Length"),
                                        q = K ? parseInt(K) : 0, te = q !== 0;
                                    let le = 0;
                                    const ne = new ReadableStream({
                                        start(J) {
                                            Ce();

                                            function Ce() {
                                                Q.read().then(({done: ye, value: ge}) => {
                                                    if (ye) J.close(); else {
                                                        le += ge.byteLength;
                                                        const $e = new ProgressEvent("progress", {
                                                            lengthComputable: te,
                                                            loaded: le,
                                                            total: q
                                                        });
                                                        for (let ze = 0, We = z.length; ze < We; ze++) {
                                                            const qe = z[ze];
                                                            qe.onProgress && qe.onProgress($e)
                                                        }
                                                        J.enqueue(ge), Ce()
                                                    }
                                                })
                                            }
                                        }
                                    });
                                    return new Response(ne)
                                } else throw new hM(`fetch for "${P.url}" responded with ${P.status}: ${P.statusText}`, P)
                            }).then(P => {
                                switch (D) {
                                    case"arraybuffer":
                                        return P.arrayBuffer();
                                    case"blob":
                                        return P.blob();
                                    case"document":
                                        return P.text().then(z => new DOMParser().parseFromString(z, S));
                                    case"json":
                                        return P.json();
                                    default:
                                        if (S === void 0) return P.text();
                                    {
                                        const Q = /charset="?([^;"\s]*)"?/i.exec(S),
                                            K = Q && Q[1] ? Q[1].toLowerCase() : void 0, q = new TextDecoder(K);
                                        return P.arrayBuffer().then(te => q.decode(te))
                                    }
                                }
                            }).then(P => {
                                Rc.add(e, P);
                                const z = Bc[e];
                                delete Bc[e];
                                for (let Q = 0, K = z.length; Q < K; Q++) {
                                    const q = z[Q];
                                    q.onLoad && q.onLoad(P)
                                }
                            }).catch(P => {
                                const z = Bc[e];
                                if (z === void 0) throw this.manager.itemError(e), P;
                                delete Bc[e];
                                for (let Q = 0, K = z.length; Q < K; Q++) {
                                    const q = z[Q];
                                    q.onError && q.onError(P)
                                }
                                this.manager.itemError(e)
                            }).finally(() => {
                                this.manager.itemEnd(e)
                            }), this.manager.itemStart(e)
                        }

                        setResponseType(e) {
                            return this.responseType = e, this
                        }

                        setMimeType(e) {
                            return this.mimeType = e, this
                        }
                    }

                    class dM extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            const u = this, y = new Lc(this.manager);
                            y.setPath(this.path), y.setRequestHeader(this.requestHeader), y.setWithCredentials(this.withCredentials), y.load(e, function (S) {
                                try {
                                    n(u.parse(JSON.parse(S)))
                                } catch (D) {
                                    a ? a(D) : console.error(D), u.manager.itemError(e)
                                }
                            }, r, a)
                        }

                        parse(e) {
                            const n = [];
                            for (let r = 0; r < e.length; r++) {
                                const a = Qp.parse(e[r]);
                                n.push(a)
                            }
                            return n
                        }
                    }

                    class fM extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            const u = this, y = [], S = new ng, D = new Lc(this.manager);
                            D.setPath(this.path), D.setResponseType("arraybuffer"), D.setRequestHeader(this.requestHeader), D.setWithCredentials(u.withCredentials);
                            let P = 0;

                            function z(Q) {
                                D.load(e[Q], function (K) {
                                    const q = u.parse(K, !0);
                                    y[Q] = {
                                        width: q.width,
                                        height: q.height,
                                        format: q.format,
                                        mipmaps: q.mipmaps
                                    }, P += 1, P === 6 && (q.mipmapCount === 1 && (S.minFilter = qn), S.image = y, S.format = q.format, S.needsUpdate = !0, n && n(S))
                                }, r, a)
                            }

                            if (Array.isArray(e)) for (let Q = 0, K = e.length; Q < K; ++Q) z(Q); else D.load(e, function (Q) {
                                const K = u.parse(Q, !0);
                                if (K.isCubemap) {
                                    const q = K.mipmaps.length / K.mipmapCount;
                                    for (let te = 0; te < q; te++) {
                                        y[te] = {mipmaps: []};
                                        for (let le = 0; le < K.mipmapCount; le++) y[te].mipmaps.push(K.mipmaps[te * K.mipmapCount + le]), y[te].format = K.format, y[te].width = K.width, y[te].height = K.height
                                    }
                                    S.image = y
                                } else S.image.width = K.width, S.image.height = K.height, S.mipmaps = K.mipmaps;
                                K.mipmapCount === 1 && (S.minFilter = qn), S.format = K.format, S.needsUpdate = !0, n && n(S)
                            }, r, a);
                            return S
                        }
                    }

                    class jp extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                            const u = this, y = Rc.get(e);
                            if (y !== void 0) return u.manager.itemStart(e), setTimeout(function () {
                                n && n(y), u.manager.itemEnd(e)
                            }, 0), y;
                            const S = Sl("img");

                            function D() {
                                z(), Rc.add(e, this), n && n(this), u.manager.itemEnd(e)
                            }

                            function P(Q) {
                                z(), a && a(Q), u.manager.itemError(e), u.manager.itemEnd(e)
                            }

                            function z() {
                                S.removeEventListener("load", D, !1), S.removeEventListener("error", P, !1)
                            }

                            return S.addEventListener("load", D, !1), S.addEventListener("error", P, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (S.crossOrigin = this.crossOrigin), u.manager.itemStart(e), S.src = e, S
                        }
                    }

                    class pM extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            const u = new ys;
                            u.colorSpace = rr;
                            const y = new jp(this.manager);
                            y.setCrossOrigin(this.crossOrigin), y.setPath(this.path);
                            let S = 0;

                            function D(P) {
                                y.load(e[P], function (z) {
                                    u.images[P] = z, S++, S === 6 && (u.needsUpdate = !0, n && n(u))
                                }, void 0, a)
                            }

                            for (let P = 0; P < e.length; ++P) D(P);
                            return u
                        }
                    }

                    class mM extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            const u = this, y = new uu, S = new Lc(this.manager);
                            return S.setResponseType("arraybuffer"), S.setRequestHeader(this.requestHeader), S.setPath(this.path), S.setWithCredentials(u.withCredentials), S.load(e, function (D) {
                                let P;
                                try {
                                    P = u.parse(D)
                                } catch (z) {
                                    if (a !== void 0) a(z); else {
                                        console.error(z);
                                        return
                                    }
                                }
                                P.image !== void 0 ? y.image = P.image : P.data !== void 0 && (y.image.width = P.width, y.image.height = P.height, y.image.data = P.data), y.wrapS = P.wrapS !== void 0 ? P.wrapS : tt, y.wrapT = P.wrapT !== void 0 ? P.wrapT : tt, y.magFilter = P.magFilter !== void 0 ? P.magFilter : qn, y.minFilter = P.minFilter !== void 0 ? P.minFilter : qn, y.anisotropy = P.anisotropy !== void 0 ? P.anisotropy : 1, P.colorSpace !== void 0 && (y.colorSpace = P.colorSpace), P.flipY !== void 0 && (y.flipY = P.flipY), P.format !== void 0 && (y.format = P.format), P.type !== void 0 && (y.type = P.type), P.mipmaps !== void 0 && (y.mipmaps = P.mipmaps, y.minFilter = Zi), P.mipmapCount === 1 && (y.minFilter = qn), P.generateMipmaps !== void 0 && (y.generateMipmaps = P.generateMipmaps), y.needsUpdate = !0, n && n(y, P)
                            }, r, a), y
                        }
                    }

                    class AM extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            const u = new Lr, y = new jp(this.manager);
                            return y.setCrossOrigin(this.crossOrigin), y.setPath(this.path), y.load(e, function (S) {
                                u.image = S, u.needsUpdate = !0, n !== void 0 && n(u)
                            }, r, a), u
                        }
                    }

                    class pu extends or {
                        constructor(e, n = 1) {
                            super(), this.isLight = !0, this.type = "Light", this.color = new Bn(e), this.intensity = n
                        }

                        dispose() {
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), n
                        }
                    }

                    class cx extends pu {
                        constructor(e, n, r) {
                            super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(or.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Bn(n)
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.groundColor.copy(e.groundColor), this
                        }
                    }

                    const Qv = new Mn, ux = new Ne, hx = new Ne;

                    class jv {
                        constructor(e) {
                            this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new zt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Mn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ec, this._frameExtents = new zt(1, 1), this._viewportCount = 1, this._viewports = [new ar(0, 0, 1, 1)]
                        }

                        getViewportCount() {
                            return this._viewportCount
                        }

                        getFrustum() {
                            return this._frustum
                        }

                        updateMatrices(e) {
                            const n = this.camera, r = this.matrix;
                            ux.setFromMatrixPosition(e.matrixWorld), n.position.copy(ux), hx.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(hx), n.updateMatrixWorld(), Qv.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Qv), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(Qv)
                        }

                        getViewport(e) {
                            return this._viewports[e]
                        }

                        getFrameExtents() {
                            return this._frameExtents
                        }

                        dispose() {
                            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                        }

                        copy(e) {
                            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        toJSON() {
                            const e = {};
                            return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                        }
                    }

                    class gM extends jv {
                        constructor() {
                            super(new ns(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                        }

                        updateMatrices(e) {
                            const n = this.camera, r = ol * 2 * e.angle * this.focus,
                                a = this.mapSize.width / this.mapSize.height, u = e.distance || n.far;
                            (r !== n.fov || a !== n.aspect || u !== n.far) && (n.fov = r, n.aspect = a, n.far = u, n.updateProjectionMatrix()), super.updateMatrices(e)
                        }

                        copy(e) {
                            return super.copy(e), this.focus = e.focus, this
                        }
                    }

                    class dx extends pu {
                        constructor(e, n, r = 0, a = Math.PI / 3, u = 0, y = 2) {
                            super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(or.DEFAULT_UP), this.updateMatrix(), this.target = new or, this.distance = r, this.angle = a, this.penumbra = u, this.decay = y, this.map = null, this.shadow = new gM
                        }

                        get power() {
                            return this.intensity * Math.PI
                        }

                        set power(e) {
                            this.intensity = e / Math.PI
                        }

                        dispose() {
                            this.shadow.dispose()
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                        }
                    }

                    const fx = new Mn, Wp = new Ne, Wv = new Ne;

                    class vM extends jv {
                        constructor() {
                            super(new ns(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new zt(4, 2), this._viewportCount = 6, this._viewports = [new ar(2, 1, 1, 1), new ar(0, 1, 1, 1), new ar(3, 1, 1, 1), new ar(1, 1, 1, 1), new ar(3, 0, 1, 1), new ar(1, 0, 1, 1)], this._cubeDirections = [new Ne(1, 0, 0), new Ne(-1, 0, 0), new Ne(0, 0, 1), new Ne(0, 0, -1), new Ne(0, 1, 0), new Ne(0, -1, 0)], this._cubeUps = [new Ne(0, 1, 0), new Ne(0, 1, 0), new Ne(0, 1, 0), new Ne(0, 1, 0), new Ne(0, 0, 1), new Ne(0, 0, -1)]
                        }

                        updateMatrices(e, n = 0) {
                            const r = this.camera, a = this.matrix, u = e.distance || r.far;
                            u !== r.far && (r.far = u, r.updateProjectionMatrix()), Wp.setFromMatrixPosition(e.matrixWorld), r.position.copy(Wp), Wv.copy(r.position), Wv.add(this._cubeDirections[n]), r.up.copy(this._cubeUps[n]), r.lookAt(Wv), r.updateMatrixWorld(), a.makeTranslation(-Wp.x, -Wp.y, -Wp.z), fx.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(fx)
                        }
                    }

                    class px extends pu {
                        constructor(e, n, r = 0, a = 2) {
                            super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = a, this.shadow = new vM
                        }

                        get power() {
                            return this.intensity * 4 * Math.PI
                        }

                        set power(e) {
                            this.intensity = e / (4 * Math.PI)
                        }

                        dispose() {
                            this.shadow.dispose()
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                        }
                    }

                    class yM extends jv {
                        constructor() {
                            super(new oh(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                        }
                    }

                    class mx extends pu {
                        constructor(e, n) {
                            super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(or.DEFAULT_UP), this.updateMatrix(), this.target = new or, this.shadow = new yM
                        }

                        dispose() {
                            this.shadow.dispose()
                        }

                        copy(e) {
                            return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                        }
                    }

                    class Ax extends pu {
                        constructor(e, n) {
                            super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight"
                        }
                    }

                    class gx extends pu {
                        constructor(e, n, r = 10, a = 10) {
                            super(e, n), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = a
                        }

                        get power() {
                            return this.intensity * this.width * this.height * Math.PI
                        }

                        set power(e) {
                            this.intensity = e / (this.width * this.height * Math.PI)
                        }

                        copy(e) {
                            return super.copy(e), this.width = e.width, this.height = e.height, this
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            return n.object.width = this.width, n.object.height = this.height, n
                        }
                    }

                    class vx {
                        constructor() {
                            this.isSphericalHarmonics3 = !0, this.coefficients = [];
                            for (let e = 0; e < 9; e++) this.coefficients.push(new Ne)
                        }

                        set(e) {
                            for (let n = 0; n < 9; n++) this.coefficients[n].copy(e[n]);
                            return this
                        }

                        zero() {
                            for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                            return this
                        }

                        getAt(e, n) {
                            const r = e.x, a = e.y, u = e.z, y = this.coefficients;
                            return n.copy(y[0]).multiplyScalar(.282095), n.addScaledVector(y[1], .488603 * a), n.addScaledVector(y[2], .488603 * u), n.addScaledVector(y[3], .488603 * r), n.addScaledVector(y[4], 1.092548 * (r * a)), n.addScaledVector(y[5], 1.092548 * (a * u)), n.addScaledVector(y[6], .315392 * (3 * u * u - 1)), n.addScaledVector(y[7], 1.092548 * (r * u)), n.addScaledVector(y[8], .546274 * (r * r - a * a)), n
                        }

                        getIrradianceAt(e, n) {
                            const r = e.x, a = e.y, u = e.z, y = this.coefficients;
                            return n.copy(y[0]).multiplyScalar(.886227), n.addScaledVector(y[1], 1.023328 * a), n.addScaledVector(y[2], 1.023328 * u), n.addScaledVector(y[3], 1.023328 * r), n.addScaledVector(y[4], .858086 * r * a), n.addScaledVector(y[5], .858086 * a * u), n.addScaledVector(y[6], .743125 * u * u - .247708), n.addScaledVector(y[7], .858086 * r * u), n.addScaledVector(y[8], .429043 * (r * r - a * a)), n
                        }

                        add(e) {
                            for (let n = 0; n < 9; n++) this.coefficients[n].add(e.coefficients[n]);
                            return this
                        }

                        addScaledSH(e, n) {
                            for (let r = 0; r < 9; r++) this.coefficients[r].addScaledVector(e.coefficients[r], n);
                            return this
                        }

                        scale(e) {
                            for (let n = 0; n < 9; n++) this.coefficients[n].multiplyScalar(e);
                            return this
                        }

                        lerp(e, n) {
                            for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], n);
                            return this
                        }

                        equals(e) {
                            for (let n = 0; n < 9; n++) if (!this.coefficients[n].equals(e.coefficients[n])) return !1;
                            return !0
                        }

                        copy(e) {
                            return this.set(e.coefficients)
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        fromArray(e, n = 0) {
                            const r = this.coefficients;
                            for (let a = 0; a < 9; a++) r[a].fromArray(e, n + a * 3);
                            return this
                        }

                        toArray(e = [], n = 0) {
                            const r = this.coefficients;
                            for (let a = 0; a < 9; a++) r[a].toArray(e, n + a * 3);
                            return e
                        }

                        static getBasisAt(e, n) {
                            const r = e.x, a = e.y, u = e.z;
                            n[0] = .282095, n[1] = .488603 * a, n[2] = .488603 * u, n[3] = .488603 * r, n[4] = 1.092548 * r * a, n[5] = 1.092548 * a * u, n[6] = .315392 * (3 * u * u - 1), n[7] = 1.092548 * r * u, n[8] = .546274 * (r * r - a * a)
                        }
                    }

                    class yx extends pu {
                        constructor(e = new vx, n = 1) {
                            super(void 0, n), this.isLightProbe = !0, this.sh = e
                        }

                        copy(e) {
                            return super.copy(e), this.sh.copy(e.sh), this
                        }

                        fromJSON(e) {
                            return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            return n.object.sh = this.sh.toArray(), n
                        }
                    }

                    class bg extends ga {
                        constructor(e) {
                            super(e), this.textures = {}
                        }

                        load(e, n, r, a) {
                            const u = this, y = new Lc(u.manager);
                            y.setPath(u.path), y.setRequestHeader(u.requestHeader), y.setWithCredentials(u.withCredentials), y.load(e, function (S) {
                                try {
                                    n(u.parse(JSON.parse(S)))
                                } catch (D) {
                                    a ? a(D) : console.error(D), u.manager.itemError(e)
                                }
                            }, r, a)
                        }

                        parse(e) {
                            const n = this.textures;

                            function r(u) {
                                return n[u] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", u), n[u]
                            }

                            const a = bg.createMaterialFromType(e.type);
                            if (e.uuid !== void 0 && (a.uuid = e.uuid), e.name !== void 0 && (a.name = e.name), e.color !== void 0 && a.color !== void 0 && a.color.setHex(e.color), e.roughness !== void 0 && (a.roughness = e.roughness), e.metalness !== void 0 && (a.metalness = e.metalness), e.sheen !== void 0 && (a.sheen = e.sheen), e.sheenColor !== void 0 && (a.sheenColor = new Bn().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (a.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && a.emissive !== void 0 && a.emissive.setHex(e.emissive), e.specular !== void 0 && a.specular !== void 0 && a.specular.setHex(e.specular), e.specularIntensity !== void 0 && (a.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && a.specularColor !== void 0 && a.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (a.shininess = e.shininess), e.clearcoat !== void 0 && (a.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (a.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (a.dispersion = e.dispersion), e.iridescence !== void 0 && (a.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (a.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (a.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (a.transmission = e.transmission), e.thickness !== void 0 && (a.thickness = e.thickness), e.attenuationDistance !== void 0 && (a.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && a.attenuationColor !== void 0 && a.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (a.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (a.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (a.fog = e.fog), e.flatShading !== void 0 && (a.flatShading = e.flatShading), e.blending !== void 0 && (a.blending = e.blending), e.combine !== void 0 && (a.combine = e.combine), e.side !== void 0 && (a.side = e.side), e.shadowSide !== void 0 && (a.shadowSide = e.shadowSide), e.opacity !== void 0 && (a.opacity = e.opacity), e.transparent !== void 0 && (a.transparent = e.transparent), e.alphaTest !== void 0 && (a.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (a.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (a.depthFunc = e.depthFunc), e.depthTest !== void 0 && (a.depthTest = e.depthTest), e.depthWrite !== void 0 && (a.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (a.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (a.blendSrc = e.blendSrc), e.blendDst !== void 0 && (a.blendDst = e.blendDst), e.blendEquation !== void 0 && (a.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (a.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (a.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (a.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && a.blendColor !== void 0 && a.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (a.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (a.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (a.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (a.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (a.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (a.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (a.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (a.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (a.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (a.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (a.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (a.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (a.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (a.rotation = e.rotation), e.linewidth !== void 0 && (a.linewidth = e.linewidth), e.dashSize !== void 0 && (a.dashSize = e.dashSize), e.gapSize !== void 0 && (a.gapSize = e.gapSize), e.scale !== void 0 && (a.scale = e.scale), e.polygonOffset !== void 0 && (a.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (a.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (a.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (a.dithering = e.dithering), e.alphaToCoverage !== void 0 && (a.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (a.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (a.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (a.visible = e.visible), e.toneMapped !== void 0 && (a.toneMapped = e.toneMapped), e.userData !== void 0 && (a.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? a.vertexColors = e.vertexColors > 0 : a.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const u in e.uniforms) {
                                const y = e.uniforms[u];
                                switch (a.uniforms[u] = {}, y.type) {
                                    case"t":
                                        a.uniforms[u].value = r(y.value);
                                        break;
                                    case"c":
                                        a.uniforms[u].value = new Bn().setHex(y.value);
                                        break;
                                    case"v2":
                                        a.uniforms[u].value = new zt().fromArray(y.value);
                                        break;
                                    case"v3":
                                        a.uniforms[u].value = new Ne().fromArray(y.value);
                                        break;
                                    case"v4":
                                        a.uniforms[u].value = new ar().fromArray(y.value);
                                        break;
                                    case"m3":
                                        a.uniforms[u].value = new ai().fromArray(y.value);
                                        break;
                                    case"m4":
                                        a.uniforms[u].value = new Mn().fromArray(y.value);
                                        break;
                                    default:
                                        a.uniforms[u].value = y.value
                                }
                            }
                            if (e.defines !== void 0 && (a.defines = e.defines), e.vertexShader !== void 0 && (a.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (a.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (a.glslVersion = e.glslVersion), e.extensions !== void 0) for (const u in e.extensions) a.extensions[u] = e.extensions[u];
                            if (e.lights !== void 0 && (a.lights = e.lights), e.clipping !== void 0 && (a.clipping = e.clipping), e.size !== void 0 && (a.size = e.size), e.sizeAttenuation !== void 0 && (a.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (a.map = r(e.map)), e.matcap !== void 0 && (a.matcap = r(e.matcap)), e.alphaMap !== void 0 && (a.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (a.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (a.bumpScale = e.bumpScale), e.normalMap !== void 0 && (a.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (a.normalMapType = e.normalMapType), e.normalScale !== void 0) {
                                let u = e.normalScale;
                                Array.isArray(u) === !1 && (u = [u, u]), a.normalScale = new zt().fromArray(u)
                            }
                            return e.displacementMap !== void 0 && (a.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (a.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (a.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (a.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (a.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (a.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (a.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (a.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (a.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (a.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (a.envMap = r(e.envMap)), e.envMapRotation !== void 0 && a.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (a.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (a.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (a.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (a.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (a.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (a.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (a.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (a.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (a.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (a.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (a.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (a.clearcoatNormalScale = new zt().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (a.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (a.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (a.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (a.thicknessMap = r(e.thicknessMap)), e.anisotropyMap !== void 0 && (a.anisotropyMap = r(e.anisotropyMap)), e.sheenColorMap !== void 0 && (a.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (a.sheenRoughnessMap = r(e.sheenRoughnessMap)), a
                        }

                        setTextures(e) {
                            return this.textures = e, this
                        }

                        static createMaterialFromType(e) {
                            const n = {
                                ShadowMaterial: XE,
                                SpriteMaterial: Av,
                                RawShaderMaterial: YE,
                                ShaderMaterial: ta,
                                PointsMaterial: bv,
                                MeshPhysicalMaterial: qE,
                                MeshStandardMaterial: Nv,
                                MeshPhongMaterial: JE,
                                MeshToonMaterial: ZE,
                                MeshNormalMaterial: $E,
                                MeshLambertMaterial: ex,
                                MeshDepthMaterial: dv,
                                MeshDistanceMaterial: fv,
                                MeshBasicMaterial: gr,
                                MeshMatcapMaterial: tx,
                                LineDashedMaterial: nx,
                                LineBasicMaterial: oa,
                                Material: Dr
                            };
                            return new n[e]
                        }
                    }

                    class Kv {
                        static decodeText(e) {
                            if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
                            let n = "";
                            for (let r = 0, a = e.length; r < a; r++) n += String.fromCharCode(e[r]);
                            try {
                                return decodeURIComponent(escape(n))
                            } catch {
                                return n
                            }
                        }

                        static extractUrlBase(e) {
                            const n = e.lastIndexOf("/");
                            return n === -1 ? "./" : e.slice(0, n + 1)
                        }

                        static resolveURL(e, n) {
                            return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(n) && /^\//.test(e) && (n = n.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : n + e)
                        }
                    }

                    class Ex extends Ti {
                        constructor() {
                            super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                        }

                        copy(e) {
                            return super.copy(e), this.instanceCount = e.instanceCount, this
                        }

                        toJSON() {
                            const e = super.toJSON();
                            return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
                        }
                    }

                    class xx extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            const u = this, y = new Lc(u.manager);
                            y.setPath(u.path), y.setRequestHeader(u.requestHeader), y.setWithCredentials(u.withCredentials), y.load(e, function (S) {
                                try {
                                    n(u.parse(JSON.parse(S)))
                                } catch (D) {
                                    a ? a(D) : console.error(D), u.manager.itemError(e)
                                }
                            }, r, a)
                        }

                        parse(e) {
                            const n = {}, r = {};

                            function a(q, te) {
                                if (n[te] !== void 0) return n[te];
                                const ne = q.interleavedBuffers[te], J = u(q, ne.buffer), Ce = ll(ne.type, J),
                                    ye = new zA(Ce, ne.stride);
                                return ye.uuid = ne.uuid, n[te] = ye, ye
                            }

                            function u(q, te) {
                                if (r[te] !== void 0) return r[te];
                                const ne = q.arrayBuffers[te], J = new Uint32Array(ne).buffer;
                                return r[te] = J, J
                            }

                            const y = e.isInstancedBufferGeometry ? new Ex : new Ti, S = e.data.index;
                            if (S !== void 0) {
                                const q = ll(S.type, S.array);
                                y.setIndex(new Er(q, 1))
                            }
                            const D = e.data.attributes;
                            for (const q in D) {
                                const te = D[q];
                                let le;
                                if (te.isInterleavedBufferAttribute) {
                                    const ne = a(e.data, te.data);
                                    le = new gh(ne, te.itemSize, te.offset, te.normalized)
                                } else {
                                    const ne = ll(te.type, te.array), J = te.isInstancedBufferAttribute ? Od : Er;
                                    le = new J(ne, te.itemSize, te.normalized)
                                }
                                te.name !== void 0 && (le.name = te.name), te.usage !== void 0 && le.setUsage(te.usage), y.setAttribute(q, le)
                            }
                            const P = e.data.morphAttributes;
                            if (P) for (const q in P) {
                                const te = P[q], le = [];
                                for (let ne = 0, J = te.length; ne < J; ne++) {
                                    const Ce = te[ne];
                                    let ye;
                                    if (Ce.isInterleavedBufferAttribute) {
                                        const ge = a(e.data, Ce.data);
                                        ye = new gh(ge, Ce.itemSize, Ce.offset, Ce.normalized)
                                    } else {
                                        const ge = ll(Ce.type, Ce.array);
                                        ye = new Er(ge, Ce.itemSize, Ce.normalized)
                                    }
                                    Ce.name !== void 0 && (ye.name = Ce.name), le.push(ye)
                                }
                                y.morphAttributes[q] = le
                            }
                            e.data.morphTargetsRelative && (y.morphTargetsRelative = !0);
                            const Q = e.data.groups || e.data.drawcalls || e.data.offsets;
                            if (Q !== void 0) for (let q = 0, te = Q.length; q !== te; ++q) {
                                const le = Q[q];
                                y.addGroup(le.start, le.count, le.materialIndex)
                            }
                            const K = e.data.boundingSphere;
                            if (K !== void 0) {
                                const q = new Ne;
                                K.center !== void 0 && q.fromArray(K.center), y.boundingSphere = new as(q, K.radius)
                            }
                            return e.name && (y.name = e.name), e.userData && (y.userData = e.userData), y
                        }
                    }

                    class EM extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            const u = this, y = this.path === "" ? Kv.extractUrlBase(e) : this.path;
                            this.resourcePath = this.resourcePath || y;
                            const S = new Lc(this.manager);
                            S.setPath(this.path), S.setRequestHeader(this.requestHeader), S.setWithCredentials(this.withCredentials), S.load(e, function (D) {
                                let P = null;
                                try {
                                    P = JSON.parse(D)
                                } catch (Q) {
                                    a !== void 0 && a(Q), console.error("THREE:ObjectLoader: Can't parse " + e + ".", Q.message);
                                    return
                                }
                                const z = P.metadata;
                                if (z === void 0 || z.type === void 0 || z.type.toLowerCase() === "geometry") {
                                    a !== void 0 && a(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
                                    return
                                }
                                u.parse(P, n)
                            }, r, a)
                        }

                        async loadAsync(e, n) {
                            const r = this, a = this.path === "" ? Kv.extractUrlBase(e) : this.path;
                            this.resourcePath = this.resourcePath || a;
                            const u = new Lc(this.manager);
                            u.setPath(this.path), u.setRequestHeader(this.requestHeader), u.setWithCredentials(this.withCredentials);
                            const y = await u.loadAsync(e, n), S = JSON.parse(y), D = S.metadata;
                            if (D === void 0 || D.type === void 0 || D.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
                            return await r.parseAsync(S)
                        }

                        parse(e, n) {
                            const r = this.parseAnimations(e.animations), a = this.parseShapes(e.shapes),
                                u = this.parseGeometries(e.geometries, a), y = this.parseImages(e.images, function () {
                                    n !== void 0 && n(P)
                                }), S = this.parseTextures(e.textures, y), D = this.parseMaterials(e.materials, S),
                                P = this.parseObject(e.object, u, D, S, r), z = this.parseSkeletons(e.skeletons, P);
                            if (this.bindSkeletons(P, z), n !== void 0) {
                                let Q = !1;
                                for (const K in y) if (y[K].data instanceof HTMLImageElement) {
                                    Q = !0;
                                    break
                                }
                                Q === !1 && n(P)
                            }
                            return P
                        }

                        async parseAsync(e) {
                            const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes),
                                a = this.parseGeometries(e.geometries, r), u = await this.parseImagesAsync(e.images),
                                y = this.parseTextures(e.textures, u), S = this.parseMaterials(e.materials, y),
                                D = this.parseObject(e.object, a, S, y, n), P = this.parseSkeletons(e.skeletons, D);
                            return this.bindSkeletons(D, P), D
                        }

                        parseShapes(e) {
                            const n = {};
                            if (e !== void 0) for (let r = 0, a = e.length; r < a; r++) {
                                const u = new yh().fromJSON(e[r]);
                                n[u.uuid] = u
                            }
                            return n
                        }

                        parseSkeletons(e, n) {
                            const r = {}, a = {};
                            if (n.traverse(function (u) {
                                u.isBone && (a[u.uuid] = u)
                            }), e !== void 0) for (let u = 0, y = e.length; u < y; u++) {
                                const S = new WA().fromJSON(e[u], a);
                                r[S.uuid] = S
                            }
                            return r
                        }

                        parseGeometries(e, n) {
                            const r = {};
                            if (e !== void 0) {
                                const u = new xx;
                                for (let y = 0, S = e.length; y < S; y++) {
                                    let D;
                                    const P = e[y];
                                    switch (P.type) {
                                        case"BufferGeometry":
                                        case"InstancedBufferGeometry":
                                            D = u.parse(P);
                                            break;
                                        case"Geometry":
                                            if ("THREE" in window && "LegacyJSONLoader" in THREE) {
                                                var a = new THREE.LegacyJSONLoader;
                                                D = a.parse(P, this.resourcePath).geometry
                                            } else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                            break;
                                        default:
                                            P.type in KE ? D = KE[P.type].fromJSON(P, n) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${P.type}"`)
                                    }
                                    D.uuid = P.uuid, P.name !== void 0 && (D.name = P.name), P.userData !== void 0 && (D.userData = P.userData), r[P.uuid] = D
                                }
                            }
                            return r
                        }

                        parseMaterials(e, n) {
                            const r = {}, a = {};
                            if (e !== void 0) {
                                const u = new bg;
                                u.setTextures(n);
                                for (let y = 0, S = e.length; y < S; y++) {
                                    const D = e[y];
                                    r[D.uuid] === void 0 && (r[D.uuid] = u.parse(D)), a[D.uuid] = r[D.uuid]
                                }
                            }
                            return a
                        }

                        parseAnimations(e) {
                            const n = {};
                            if (e !== void 0) for (let r = 0; r < e.length; r++) {
                                const a = e[r], u = Qp.parse(a);
                                n[u.uuid] = u
                            }
                            return n
                        }

                        parseImages(e, n) {
                            const r = this, a = {};
                            let u;

                            function y(D) {
                                return r.manager.itemStart(D), u.load(D, function () {
                                    r.manager.itemEnd(D)
                                }, void 0, function () {
                                    r.manager.itemError(D), r.manager.itemEnd(D)
                                })
                            }

                            function S(D) {
                                if (typeof D == "string") {
                                    const P = D, z = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(P) ? P : r.resourcePath + P;
                                    return y(z)
                                } else return D.data ? {
                                    data: ll(D.type, D.data),
                                    width: D.width,
                                    height: D.height
                                } : null
                            }

                            if (e !== void 0 && e.length > 0) {
                                const D = new Hv(n);
                                u = new jp(D), u.setCrossOrigin(this.crossOrigin);
                                for (let P = 0, z = e.length; P < z; P++) {
                                    const Q = e[P], K = Q.url;
                                    if (Array.isArray(K)) {
                                        const q = [];
                                        for (let te = 0, le = K.length; te < le; te++) {
                                            const ne = K[te], J = S(ne);
                                            J !== null && (J instanceof HTMLImageElement ? q.push(J) : q.push(new uu(J.data, J.width, J.height)))
                                        }
                                        a[Q.uuid] = new zr(q)
                                    } else {
                                        const q = S(Q.url);
                                        a[Q.uuid] = new zr(q)
                                    }
                                }
                            }
                            return a
                        }

                        async parseImagesAsync(e) {
                            const n = this, r = {};
                            let a;

                            async function u(y) {
                                if (typeof y == "string") {
                                    const S = y, D = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(S) ? S : n.resourcePath + S;
                                    return await a.loadAsync(D)
                                } else return y.data ? {
                                    data: ll(y.type, y.data),
                                    width: y.width,
                                    height: y.height
                                } : null
                            }

                            if (e !== void 0 && e.length > 0) {
                                a = new jp(this.manager), a.setCrossOrigin(this.crossOrigin);
                                for (let y = 0, S = e.length; y < S; y++) {
                                    const D = e[y], P = D.url;
                                    if (Array.isArray(P)) {
                                        const z = [];
                                        for (let Q = 0, K = P.length; Q < K; Q++) {
                                            const q = P[Q], te = await u(q);
                                            te !== null && (te instanceof HTMLImageElement ? z.push(te) : z.push(new uu(te.data, te.width, te.height)))
                                        }
                                        r[D.uuid] = new zr(z)
                                    } else {
                                        const z = await u(D.url);
                                        r[D.uuid] = new zr(z)
                                    }
                                }
                            }
                            return r
                        }

                        parseTextures(e, n) {
                            function r(u, y) {
                                return typeof u == "number" ? u : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", u), y[u])
                            }

                            const a = {};
                            if (e !== void 0) for (let u = 0, y = e.length; u < y; u++) {
                                const S = e[u];
                                S.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', S.uuid), n[S.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", S.image);
                                const D = n[S.image], P = D.data;
                                let z;
                                Array.isArray(P) ? (z = new ys, P.length === 6 && (z.needsUpdate = !0)) : (P && P.data ? z = new uu : z = new Lr, P && (z.needsUpdate = !0)), z.source = D, z.uuid = S.uuid, S.name !== void 0 && (z.name = S.name), S.mapping !== void 0 && (z.mapping = r(S.mapping, xM)), S.channel !== void 0 && (z.channel = S.channel), S.offset !== void 0 && z.offset.fromArray(S.offset), S.repeat !== void 0 && z.repeat.fromArray(S.repeat), S.center !== void 0 && z.center.fromArray(S.center), S.rotation !== void 0 && (z.rotation = S.rotation), S.wrap !== void 0 && (z.wrapS = r(S.wrap[0], Cx), z.wrapT = r(S.wrap[1], Cx)), S.format !== void 0 && (z.format = S.format), S.internalFormat !== void 0 && (z.internalFormat = S.internalFormat), S.type !== void 0 && (z.type = S.type), S.colorSpace !== void 0 && (z.colorSpace = S.colorSpace), S.minFilter !== void 0 && (z.minFilter = r(S.minFilter, wx)), S.magFilter !== void 0 && (z.magFilter = r(S.magFilter, wx)), S.anisotropy !== void 0 && (z.anisotropy = S.anisotropy), S.flipY !== void 0 && (z.flipY = S.flipY), S.generateMipmaps !== void 0 && (z.generateMipmaps = S.generateMipmaps), S.premultiplyAlpha !== void 0 && (z.premultiplyAlpha = S.premultiplyAlpha), S.unpackAlignment !== void 0 && (z.unpackAlignment = S.unpackAlignment), S.compareFunction !== void 0 && (z.compareFunction = S.compareFunction), S.userData !== void 0 && (z.userData = S.userData), a[S.uuid] = z
                            }
                            return a
                        }

                        parseObject(e, n, r, a, u) {
                            let y;

                            function S(K) {
                                return n[K] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", K), n[K]
                            }

                            function D(K) {
                                if (K !== void 0) {
                                    if (Array.isArray(K)) {
                                        const q = [];
                                        for (let te = 0, le = K.length; te < le; te++) {
                                            const ne = K[te];
                                            r[ne] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", ne), q.push(r[ne])
                                        }
                                        return q
                                    }
                                    return r[K] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", K), r[K]
                                }
                            }

                            function P(K) {
                                return a[K] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", K), a[K]
                            }

                            let z, Q;
                            switch (e.type) {
                                case"Scene":
                                    y = new rE, e.background !== void 0 && (Number.isInteger(e.background) ? y.background = new Bn(e.background) : y.background = P(e.background)), e.environment !== void 0 && (y.environment = P(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? y.fog = new UA(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (y.fog = new NA(e.fog.color, e.fog.density)), e.fog.name !== "" && (y.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (y.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (y.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && y.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (y.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && y.environmentRotation.fromArray(e.environmentRotation);
                                    break;
                                case"PerspectiveCamera":
                                    y = new ns(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (y.focus = e.focus), e.zoom !== void 0 && (y.zoom = e.zoom), e.filmGauge !== void 0 && (y.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (y.filmOffset = e.filmOffset), e.view !== void 0 && (y.view = Object.assign({}, e.view));
                                    break;
                                case"OrthographicCamera":
                                    y = new oh(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (y.zoom = e.zoom), e.view !== void 0 && (y.view = Object.assign({}, e.view));
                                    break;
                                case"AmbientLight":
                                    y = new Ax(e.color, e.intensity);
                                    break;
                                case"DirectionalLight":
                                    y = new mx(e.color, e.intensity);
                                    break;
                                case"PointLight":
                                    y = new px(e.color, e.intensity, e.distance, e.decay);
                                    break;
                                case"RectAreaLight":
                                    y = new gx(e.color, e.intensity, e.width, e.height);
                                    break;
                                case"SpotLight":
                                    y = new dx(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                                    break;
                                case"HemisphereLight":
                                    y = new cx(e.color, e.groundColor, e.intensity);
                                    break;
                                case"LightProbe":
                                    y = new yx().fromJSON(e);
                                    break;
                                case"SkinnedMesh":
                                    z = S(e.geometry), Q = D(e.material), y = new AE(z, Q), e.bindMode !== void 0 && (y.bindMode = e.bindMode), e.bindMatrix !== void 0 && y.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (y.skeleton = e.skeleton);
                                    break;
                                case"Mesh":
                                    z = S(e.geometry), Q = D(e.material), y = new Wr(z, Q);
                                    break;
                                case"InstancedMesh":
                                    z = S(e.geometry), Q = D(e.material);
                                    const K = e.count, q = e.instanceMatrix, te = e.instanceColor;
                                    y = new EE(z, Q, K), y.instanceMatrix = new Od(new Float32Array(q.array), 16), te !== void 0 && (y.instanceColor = new Od(new Float32Array(te.array), te.itemSize));
                                    break;
                                case"BatchedMesh":
                                    z = S(e.geometry), Q = D(e.material), y = new wE(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, Q), y.geometry = z, y.perObjectFrustumCulled = e.perObjectFrustumCulled, y.sortObjects = e.sortObjects, y._drawRanges = e.drawRanges, y._reservedRanges = e.reservedRanges, y._visibility = e.visibility, y._active = e.active, y._bounds = e.bounds.map(le => {
                                        const ne = new Ei;
                                        ne.min.fromArray(le.boxMin), ne.max.fromArray(le.boxMax);
                                        const J = new as;
                                        return J.radius = le.sphereRadius, J.center.fromArray(le.sphereCenter), {
                                            boxInitialized: le.boxInitialized,
                                            box: ne,
                                            sphereInitialized: le.sphereInitialized,
                                            sphere: J
                                        }
                                    }), y._maxGeometryCount = e.maxGeometryCount, y._maxVertexCount = e.maxVertexCount, y._maxIndexCount = e.maxIndexCount, y._geometryInitialized = e.geometryInitialized, y._geometryCount = e.geometryCount, y._matricesTexture = P(e.matricesTexture.uuid);
                                    break;
                                case"LOD":
                                    y = new uE;
                                    break;
                                case"Line":
                                    y = new du(S(e.geometry), D(e.material));
                                    break;
                                case"LineLoop":
                                    y = new TE(S(e.geometry), D(e.material));
                                    break;
                                case"LineSegments":
                                    y = new Ql(S(e.geometry), D(e.material));
                                    break;
                                case"PointCloud":
                                case"Points":
                                    y = new RE(S(e.geometry), D(e.material));
                                    break;
                                case"Sprite":
                                    y = new lE(D(e.material));
                                    break;
                                case"Group":
                                    y = new mh;
                                    break;
                                case"Bone":
                                    y = new Ev;
                                    break;
                                default:
                                    y = new or
                            }
                            if (y.uuid = e.uuid, e.name !== void 0 && (y.name = e.name), e.matrix !== void 0 ? (y.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (y.matrixAutoUpdate = e.matrixAutoUpdate), y.matrixAutoUpdate && y.matrix.decompose(y.position, y.quaternion, y.scale)) : (e.position !== void 0 && y.position.fromArray(e.position), e.rotation !== void 0 && y.rotation.fromArray(e.rotation), e.quaternion !== void 0 && y.quaternion.fromArray(e.quaternion), e.scale !== void 0 && y.scale.fromArray(e.scale)), e.up !== void 0 && y.up.fromArray(e.up), e.castShadow !== void 0 && (y.castShadow = e.castShadow), e.receiveShadow !== void 0 && (y.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (y.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (y.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (y.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && y.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (y.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (y.visible = e.visible), e.frustumCulled !== void 0 && (y.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (y.renderOrder = e.renderOrder), e.userData !== void 0 && (y.userData = e.userData), e.layers !== void 0 && (y.layers.mask = e.layers), e.children !== void 0) {
                                const K = e.children;
                                for (let q = 0; q < K.length; q++) y.add(this.parseObject(K[q], n, r, a, u))
                            }
                            if (e.animations !== void 0) {
                                const K = e.animations;
                                for (let q = 0; q < K.length; q++) {
                                    const te = K[q];
                                    y.animations.push(u[te])
                                }
                            }
                            if (e.type === "LOD") {
                                e.autoUpdate !== void 0 && (y.autoUpdate = e.autoUpdate);
                                const K = e.levels;
                                for (let q = 0; q < K.length; q++) {
                                    const te = K[q], le = y.getObjectByProperty("uuid", te.object);
                                    le !== void 0 && y.addLevel(le, te.distance, te.hysteresis)
                                }
                            }
                            return y
                        }

                        bindSkeletons(e, n) {
                            Object.keys(n).length !== 0 && e.traverse(function (r) {
                                if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
                                    const a = n[r.skeleton];
                                    a === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(a, r.bindMatrix)
                                }
                            })
                        }
                    }

                    const xM = {
                        UVMapping: Qe,
                        CubeReflectionMapping: oe,
                        CubeRefractionMapping: G,
                        EquirectangularReflectionMapping: X,
                        EquirectangularRefractionMapping: ve,
                        CubeUVReflectionMapping: Be
                    }, Cx = {RepeatWrapping: je, ClampToEdgeWrapping: tt, MirroredRepeatWrapping: Yt}, wx = {
                        NearestFilter: cn,
                        NearestMipmapNearestFilter: $t,
                        NearestMipmapLinearFilter: Sn,
                        LinearFilter: qn,
                        LinearMipmapNearestFilter: fr,
                        LinearMipmapLinearFilter: Zi
                    };

                    class CM extends ga {
                        constructor(e) {
                            super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {premultiplyAlpha: "none"}
                        }

                        setOptions(e) {
                            return this.options = e, this
                        }

                        load(e, n, r, a) {
                            e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
                            const u = this, y = Rc.get(e);
                            if (y !== void 0) {
                                if (u.manager.itemStart(e), y.then) {
                                    y.then(P => {
                                        n && n(P), u.manager.itemEnd(e)
                                    }).catch(P => {
                                        a && a(P)
                                    });
                                    return
                                }
                                return setTimeout(function () {
                                    n && n(y), u.manager.itemEnd(e)
                                }, 0), y
                            }
                            const S = {};
                            S.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", S.headers = this.requestHeader;
                            const D = fetch(e, S).then(function (P) {
                                return P.blob()
                            }).then(function (P) {
                                return createImageBitmap(P, Object.assign(u.options, {colorSpaceConversion: "none"}))
                            }).then(function (P) {
                                return Rc.add(e, P), n && n(P), u.manager.itemEnd(e), P
                            }).catch(function (P) {
                                a && a(P), Rc.remove(e), u.manager.itemError(e), u.manager.itemEnd(e)
                            });
                            Rc.add(e, D), u.manager.itemStart(e)
                        }
                    }

                    let _g;

                    class Xv {
                        static getContext() {
                            return _g === void 0 && (_g = new (window.AudioContext || window.webkitAudioContext)), _g
                        }

                        static setContext(e) {
                            _g = e
                        }
                    }

                    class wM extends ga {
                        constructor(e) {
                            super(e)
                        }

                        load(e, n, r, a) {
                            const u = this, y = new Lc(this.manager);
                            y.setResponseType("arraybuffer"), y.setPath(this.path), y.setRequestHeader(this.requestHeader), y.setWithCredentials(this.withCredentials), y.load(e, function (D) {
                                try {
                                    const P = D.slice(0);
                                    Xv.getContext().decodeAudioData(P, function (Q) {
                                        n(Q)
                                    }).catch(S)
                                } catch (P) {
                                    S(P)
                                }
                            }, r, a);

                            function S(D) {
                                a ? a(D) : console.error(D), u.manager.itemError(e)
                            }
                        }
                    }

                    const bx = new Mn, _x = new Mn, bh = new Mn;

                    class bM {
                        constructor() {
                            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ns, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ns, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                                focus: null,
                                fov: null,
                                aspect: null,
                                near: null,
                                far: null,
                                zoom: null,
                                eyeSep: null
                            }
                        }

                        update(e) {
                            const n = this._cache;
                            if (n.focus !== e.focus || n.fov !== e.fov || n.aspect !== e.aspect * this.aspect || n.near !== e.near || n.far !== e.far || n.zoom !== e.zoom || n.eyeSep !== this.eyeSep) {
                                n.focus = e.focus, n.fov = e.fov, n.aspect = e.aspect * this.aspect, n.near = e.near, n.far = e.far, n.zoom = e.zoom, n.eyeSep = this.eyeSep, bh.copy(e.projectionMatrix);
                                const a = n.eyeSep / 2, u = a * n.near / n.focus,
                                    y = n.near * Math.tan(Na * n.fov * .5) / n.zoom;
                                let S, D;
                                _x.elements[12] = -a, bx.elements[12] = a, S = -y * n.aspect + u, D = y * n.aspect + u, bh.elements[0] = 2 * n.near / (D - S), bh.elements[8] = (D + S) / (D - S), this.cameraL.projectionMatrix.copy(bh), S = -y * n.aspect - u, D = y * n.aspect - u, bh.elements[0] = 2 * n.near / (D - S), bh.elements[8] = (D + S) / (D - S), this.cameraR.projectionMatrix.copy(bh)
                            }
                            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_x), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(bx)
                        }
                    }

                    class Mx {
                        constructor(e = !0) {
                            this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                        }

                        start() {
                            this.startTime = Sx(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                        }

                        stop() {
                            this.getElapsedTime(), this.running = !1, this.autoStart = !1
                        }

                        getElapsedTime() {
                            return this.getDelta(), this.elapsedTime
                        }

                        getDelta() {
                            let e = 0;
                            if (this.autoStart && !this.running) return this.start(), 0;
                            if (this.running) {
                                const n = Sx();
                                e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e
                            }
                            return e
                        }
                    }

                    function Sx() {
                        return (typeof performance > "u" ? Date : performance).now()
                    }

                    const _h = new Ne, Tx = new $i, _M = new Ne, Mh = new Ne;

                    class MM extends or {
                        constructor() {
                            super(), this.type = "AudioListener", this.context = Xv.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Mx
                        }

                        getInput() {
                            return this.gain
                        }

                        removeFilter() {
                            return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                        }

                        getFilter() {
                            return this.filter
                        }

                        setFilter(e) {
                            return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                        }

                        getMasterVolume() {
                            return this.gain.gain.value
                        }

                        setMasterVolume(e) {
                            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                        }

                        updateMatrixWorld(e) {
                            super.updateMatrixWorld(e);
                            const n = this.context.listener, r = this.up;
                            if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_h, Tx, _M), Mh.set(0, 0, -1).applyQuaternion(Tx), n.positionX) {
                                const a = this.context.currentTime + this.timeDelta;
                                n.positionX.linearRampToValueAtTime(_h.x, a), n.positionY.linearRampToValueAtTime(_h.y, a), n.positionZ.linearRampToValueAtTime(_h.z, a), n.forwardX.linearRampToValueAtTime(Mh.x, a), n.forwardY.linearRampToValueAtTime(Mh.y, a), n.forwardZ.linearRampToValueAtTime(Mh.z, a), n.upX.linearRampToValueAtTime(r.x, a), n.upY.linearRampToValueAtTime(r.y, a), n.upZ.linearRampToValueAtTime(r.z, a)
                            } else n.setPosition(_h.x, _h.y, _h.z), n.setOrientation(Mh.x, Mh.y, Mh.z, r.x, r.y, r.z)
                        }
                    }

                    class Ix extends or {
                        constructor(e) {
                            super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                        }

                        getOutput() {
                            return this.gain
                        }

                        setNodeSource(e) {
                            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                        }

                        setMediaElementSource(e) {
                            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                        }

                        setMediaStreamSource(e) {
                            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                        }

                        setBuffer(e) {
                            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                        }

                        play(e = 0) {
                            if (this.isPlaying === !0) {
                                console.warn("THREE.Audio: Audio is already playing.");
                                return
                            }
                            if (this.hasPlaybackControl === !1) {
                                console.warn("THREE.Audio: this Audio has no playback control.");
                                return
                            }
                            this._startedAt = this.context.currentTime + e;
                            const n = this.context.createBufferSource();
                            return n.buffer = this.buffer, n.loop = this.loop, n.loopStart = this.loopStart, n.loopEnd = this.loopEnd, n.onended = this.onEnded.bind(this), n.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = n, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                        }

                        pause() {
                            if (this.hasPlaybackControl === !1) {
                                console.warn("THREE.Audio: this Audio has no playback control.");
                                return
                            }
                            return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
                        }

                        stop() {
                            if (this.hasPlaybackControl === !1) {
                                console.warn("THREE.Audio: this Audio has no playback control.");
                                return
                            }
                            return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this
                        }

                        connect() {
                            if (this.filters.length > 0) {
                                this.source.connect(this.filters[0]);
                                for (let e = 1, n = this.filters.length; e < n; e++) this.filters[e - 1].connect(this.filters[e]);
                                this.filters[this.filters.length - 1].connect(this.getOutput())
                            } else this.source.connect(this.getOutput());
                            return this._connected = !0, this
                        }

                        disconnect() {
                            if (this._connected !== !1) {
                                if (this.filters.length > 0) {
                                    this.source.disconnect(this.filters[0]);
                                    for (let e = 1, n = this.filters.length; e < n; e++) this.filters[e - 1].disconnect(this.filters[e]);
                                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                                } else this.source.disconnect(this.getOutput());
                                return this._connected = !1, this
                            }
                        }

                        getFilters() {
                            return this.filters
                        }

                        setFilters(e) {
                            return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                        }

                        setDetune(e) {
                            return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                        }

                        getDetune() {
                            return this.detune
                        }

                        getFilter() {
                            return this.getFilters()[0]
                        }

                        setFilter(e) {
                            return this.setFilters(e ? [e] : [])
                        }

                        setPlaybackRate(e) {
                            if (this.hasPlaybackControl === !1) {
                                console.warn("THREE.Audio: this Audio has no playback control.");
                                return
                            }
                            return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
                        }

                        getPlaybackRate() {
                            return this.playbackRate
                        }

                        onEnded() {
                            this.isPlaying = !1
                        }

                        getLoop() {
                            return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                        }

                        setLoop(e) {
                            if (this.hasPlaybackControl === !1) {
                                console.warn("THREE.Audio: this Audio has no playback control.");
                                return
                            }
                            return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this
                        }

                        setLoopStart(e) {
                            return this.loopStart = e, this
                        }

                        setLoopEnd(e) {
                            return this.loopEnd = e, this
                        }

                        getVolume() {
                            return this.gain.gain.value
                        }

                        setVolume(e) {
                            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                        }
                    }

                    const Sh = new Ne, Rx = new $i, SM = new Ne, Th = new Ne;

                    class TM extends Ix {
                        constructor(e) {
                            super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                        }

                        connect() {
                            super.connect(), this.panner.connect(this.gain)
                        }

                        disconnect() {
                            super.disconnect(), this.panner.disconnect(this.gain)
                        }

                        getOutput() {
                            return this.panner
                        }

                        getRefDistance() {
                            return this.panner.refDistance
                        }

                        setRefDistance(e) {
                            return this.panner.refDistance = e, this
                        }

                        getRolloffFactor() {
                            return this.panner.rolloffFactor
                        }

                        setRolloffFactor(e) {
                            return this.panner.rolloffFactor = e, this
                        }

                        getDistanceModel() {
                            return this.panner.distanceModel
                        }

                        setDistanceModel(e) {
                            return this.panner.distanceModel = e, this
                        }

                        getMaxDistance() {
                            return this.panner.maxDistance
                        }

                        setMaxDistance(e) {
                            return this.panner.maxDistance = e, this
                        }

                        setDirectionalCone(e, n, r) {
                            return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = n, this.panner.coneOuterGain = r, this
                        }

                        updateMatrixWorld(e) {
                            if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
                            this.matrixWorld.decompose(Sh, Rx, SM), Th.set(0, 0, 1).applyQuaternion(Rx);
                            const n = this.panner;
                            if (n.positionX) {
                                const r = this.context.currentTime + this.listener.timeDelta;
                                n.positionX.linearRampToValueAtTime(Sh.x, r), n.positionY.linearRampToValueAtTime(Sh.y, r), n.positionZ.linearRampToValueAtTime(Sh.z, r), n.orientationX.linearRampToValueAtTime(Th.x, r), n.orientationY.linearRampToValueAtTime(Th.y, r), n.orientationZ.linearRampToValueAtTime(Th.z, r)
                            } else n.setPosition(Sh.x, Sh.y, Sh.z), n.setOrientation(Th.x, Th.y, Th.z)
                        }
                    }

                    class IM {
                        constructor(e, n = 2048) {
                            this.analyser = e.context.createAnalyser(), this.analyser.fftSize = n, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
                        }

                        getFrequencyData() {
                            return this.analyser.getByteFrequencyData(this.data), this.data
                        }

                        getAverageFrequency() {
                            let e = 0;
                            const n = this.getFrequencyData();
                            for (let r = 0; r < n.length; r++) e += n[r];
                            return e / n.length
                        }
                    }

                    class Bx {
                        constructor(e, n, r) {
                            this.binding = e, this.valueSize = r;
                            let a, u, y;
                            switch (n) {
                                case"quaternion":
                                    a = this._slerp, u = this._slerpAdditive, y = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
                                    break;
                                case"string":
                                case"bool":
                                    a = this._select, u = this._select, y = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
                                    break;
                                default:
                                    a = this._lerp, u = this._lerpAdditive, y = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5)
                            }
                            this._mixBufferRegion = a, this._mixBufferRegionAdditive = u, this._setIdentity = y, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                        }

                        accumulate(e, n) {
                            const r = this.buffer, a = this.valueSize, u = e * a + a;
                            let y = this.cumulativeWeight;
                            if (y === 0) {
                                for (let S = 0; S !== a; ++S) r[u + S] = r[S];
                                y = n
                            } else {
                                y += n;
                                const S = n / y;
                                this._mixBufferRegion(r, u, 0, S, a)
                            }
                            this.cumulativeWeight = y
                        }

                        accumulateAdditive(e) {
                            const n = this.buffer, r = this.valueSize, a = r * this._addIndex;
                            this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(n, a, 0, e, r), this.cumulativeWeightAdditive += e
                        }

                        apply(e) {
                            const n = this.valueSize, r = this.buffer, a = e * n + n, u = this.cumulativeWeight,
                                y = this.cumulativeWeightAdditive, S = this.binding;
                            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, u < 1) {
                                const D = n * this._origIndex;
                                this._mixBufferRegion(r, a, D, 1 - u, n)
                            }
                            y > 0 && this._mixBufferRegionAdditive(r, a, this._addIndex * n, 1, n);
                            for (let D = n, P = n + n; D !== P; ++D) if (r[D] !== r[D + n]) {
                                S.setValue(r, a);
                                break
                            }
                        }

                        saveOriginalState() {
                            const e = this.binding, n = this.buffer, r = this.valueSize, a = r * this._origIndex;
                            e.getValue(n, a);
                            for (let u = r, y = a; u !== y; ++u) n[u] = n[a + u % r];
                            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                        }

                        restoreOriginalState() {
                            const e = this.valueSize * 3;
                            this.binding.setValue(this.buffer, e)
                        }

                        _setAdditiveIdentityNumeric() {
                            const e = this._addIndex * this.valueSize, n = e + this.valueSize;
                            for (let r = e; r < n; r++) this.buffer[r] = 0
                        }

                        _setAdditiveIdentityQuaternion() {
                            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                        }

                        _setAdditiveIdentityOther() {
                            const e = this._origIndex * this.valueSize, n = this._addIndex * this.valueSize;
                            for (let r = 0; r < this.valueSize; r++) this.buffer[n + r] = this.buffer[e + r]
                        }

                        _select(e, n, r, a, u) {
                            if (a >= .5) for (let y = 0; y !== u; ++y) e[n + y] = e[r + y]
                        }

                        _slerp(e, n, r, a) {
                            $i.slerpFlat(e, n, e, n, e, r, a)
                        }

                        _slerpAdditive(e, n, r, a, u) {
                            const y = this._workIndex * u;
                            $i.multiplyQuaternionsFlat(e, y, e, n, e, r), $i.slerpFlat(e, n, e, n, e, y, a)
                        }

                        _lerp(e, n, r, a, u) {
                            const y = 1 - a;
                            for (let S = 0; S !== u; ++S) {
                                const D = n + S;
                                e[D] = e[D] * y + e[r + S] * a
                            }
                        }

                        _lerpAdditive(e, n, r, a, u) {
                            for (let y = 0; y !== u; ++y) {
                                const S = n + y;
                                e[S] = e[S] + e[r + y] * a
                            }
                        }
                    }

                    const Yv = "\\[\\]\\.:\\/", RM = new RegExp("[" + Yv + "]", "g"), qv = "[^" + Yv + "]",
                        BM = "[^" + Yv.replace("\\.", "") + "]", LM = /((?:WC+[\/:])*)/.source.replace("WC", qv),
                        DM = /(WCOD+)?/.source.replace("WCOD", BM),
                        PM = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", qv),
                        OM = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", qv),
                        kM = new RegExp("^" + LM + DM + PM + OM + "$"), FM = ["material", "materials", "bones", "map"];

                    class NM {
                        constructor(e, n, r) {
                            const a = r || vr.parseTrackName(n);
                            this._targetGroup = e, this._bindings = e.subscribe_(n, a)
                        }

                        getValue(e, n) {
                            this.bind();
                            const r = this._targetGroup.nCachedObjects_, a = this._bindings[r];
                            a !== void 0 && a.getValue(e, n)
                        }

                        setValue(e, n) {
                            const r = this._bindings;
                            for (let a = this._targetGroup.nCachedObjects_, u = r.length; a !== u; ++a) r[a].setValue(e, n)
                        }

                        bind() {
                            const e = this._bindings;
                            for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n) e[n].bind()
                        }

                        unbind() {
                            const e = this._bindings;
                            for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n) e[n].unbind()
                        }
                    }

                    class vr {
                        constructor(e, n, r) {
                            this.path = n, this.parsedPath = r || vr.parseTrackName(n), this.node = vr.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                        }

                        static create(e, n, r) {
                            return e && e.isAnimationObjectGroup ? new vr.Composite(e, n, r) : new vr(e, n, r)
                        }

                        static sanitizeNodeName(e) {
                            return e.replace(/\s/g, "_").replace(RM, "")
                        }

                        static parseTrackName(e) {
                            const n = kM.exec(e);
                            if (n === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                            const r = {
                                nodeName: n[2],
                                objectName: n[3],
                                objectIndex: n[4],
                                propertyName: n[5],
                                propertyIndex: n[6]
                            }, a = r.nodeName && r.nodeName.lastIndexOf(".");
                            if (a !== void 0 && a !== -1) {
                                const u = r.nodeName.substring(a + 1);
                                FM.indexOf(u) !== -1 && (r.nodeName = r.nodeName.substring(0, a), r.objectName = u)
                            }
                            if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                            return r
                        }

                        static findNode(e, n) {
                            if (n === void 0 || n === "" || n === "." || n === -1 || n === e.name || n === e.uuid) return e;
                            if (e.skeleton) {
                                const r = e.skeleton.getBoneByName(n);
                                if (r !== void 0) return r
                            }
                            if (e.children) {
                                const r = function (u) {
                                    for (let y = 0; y < u.length; y++) {
                                        const S = u[y];
                                        if (S.name === n || S.uuid === n) return S;
                                        const D = r(S.children);
                                        if (D) return D
                                    }
                                    return null
                                }, a = r(e.children);
                                if (a) return a
                            }
                            return null
                        }

                        _getValue_unavailable() {
                        }

                        _setValue_unavailable() {
                        }

                        _getValue_direct(e, n) {
                            e[n] = this.targetObject[this.propertyName]
                        }

                        _getValue_array(e, n) {
                            const r = this.resolvedProperty;
                            for (let a = 0, u = r.length; a !== u; ++a) e[n++] = r[a]
                        }

                        _getValue_arrayElement(e, n) {
                            e[n] = this.resolvedProperty[this.propertyIndex]
                        }

                        _getValue_toArray(e, n) {
                            this.resolvedProperty.toArray(e, n)
                        }

                        _setValue_direct(e, n) {
                            this.targetObject[this.propertyName] = e[n]
                        }

                        _setValue_direct_setNeedsUpdate(e, n) {
                            this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0
                        }

                        _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
                            this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0
                        }

                        _setValue_array(e, n) {
                            const r = this.resolvedProperty;
                            for (let a = 0, u = r.length; a !== u; ++a) r[a] = e[n++]
                        }

                        _setValue_array_setNeedsUpdate(e, n) {
                            const r = this.resolvedProperty;
                            for (let a = 0, u = r.length; a !== u; ++a) r[a] = e[n++];
                            this.targetObject.needsUpdate = !0
                        }

                        _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
                            const r = this.resolvedProperty;
                            for (let a = 0, u = r.length; a !== u; ++a) r[a] = e[n++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }

                        _setValue_arrayElement(e, n) {
                            this.resolvedProperty[this.propertyIndex] = e[n]
                        }

                        _setValue_arrayElement_setNeedsUpdate(e, n) {
                            this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0
                        }

                        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
                            this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0
                        }

                        _setValue_fromArray(e, n) {
                            this.resolvedProperty.fromArray(e, n)
                        }

                        _setValue_fromArray_setNeedsUpdate(e, n) {
                            this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0
                        }

                        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
                            this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0
                        }

                        _getValue_unbound(e, n) {
                            this.bind(), this.getValue(e, n)
                        }

                        _setValue_unbound(e, n) {
                            this.bind(), this.setValue(e, n)
                        }

                        bind() {
                            let e = this.node;
                            const n = this.parsedPath, r = n.objectName, a = n.propertyName;
                            let u = n.propertyIndex;
                            if (e || (e = vr.findNode(this.rootNode, n.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                                console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                                return
                            }
                            if (r) {
                                let P = n.objectIndex;
                                switch (r) {
                                    case"materials":
                                        if (!e.material) {
                                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                            return
                                        }
                                        if (!e.material.materials) {
                                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                            return
                                        }
                                        e = e.material.materials;
                                        break;
                                    case"bones":
                                        if (!e.skeleton) {
                                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                            return
                                        }
                                        e = e.skeleton.bones;
                                        for (let z = 0; z < e.length; z++) if (e[z].name === P) {
                                            P = z;
                                            break
                                        }
                                        break;
                                    case"map":
                                        if ("map" in e) {
                                            e = e.map;
                                            break
                                        }
                                        if (!e.material) {
                                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                            return
                                        }
                                        if (!e.material.map) {
                                            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                            return
                                        }
                                        e = e.material.map;
                                        break;
                                    default:
                                        if (e[r] === void 0) {
                                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                            return
                                        }
                                        e = e[r]
                                }
                                if (P !== void 0) {
                                    if (e[P] === void 0) {
                                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                        return
                                    }
                                    e = e[P]
                                }
                            }
                            const y = e[a];
                            if (y === void 0) {
                                const P = n.nodeName;
                                console.error("THREE.PropertyBinding: Trying to update property for track: " + P + "." + a + " but it wasn't found.", e);
                                return
                            }
                            let S = this.Versioning.None;
                            this.targetObject = e, e.needsUpdate !== void 0 ? S = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (S = this.Versioning.MatrixWorldNeedsUpdate);
                            let D = this.BindingType.Direct;
                            if (u !== void 0) {
                                if (a === "morphTargetInfluences") {
                                    if (!e.geometry) {
                                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                        return
                                    }
                                    if (!e.geometry.morphAttributes) {
                                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                        return
                                    }
                                    e.morphTargetDictionary[u] !== void 0 && (u = e.morphTargetDictionary[u])
                                }
                                D = this.BindingType.ArrayElement, this.resolvedProperty = y, this.propertyIndex = u
                            } else y.fromArray !== void 0 && y.toArray !== void 0 ? (D = this.BindingType.HasFromToArray, this.resolvedProperty = y) : Array.isArray(y) ? (D = this.BindingType.EntireArray, this.resolvedProperty = y) : this.propertyName = a;
                            this.getValue = this.GetterByBindingType[D], this.setValue = this.SetterByBindingTypeAndVersioning[D][S]
                        }

                        unbind() {
                            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                        }
                    }

                    vr.Composite = NM, vr.prototype.BindingType = {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    }, vr.prototype.Versioning = {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    }, vr.prototype.GetterByBindingType = [vr.prototype._getValue_direct, vr.prototype._getValue_array, vr.prototype._getValue_arrayElement, vr.prototype._getValue_toArray], vr.prototype.SetterByBindingTypeAndVersioning = [[vr.prototype._setValue_direct, vr.prototype._setValue_direct_setNeedsUpdate, vr.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [vr.prototype._setValue_array, vr.prototype._setValue_array_setNeedsUpdate, vr.prototype._setValue_array_setMatrixWorldNeedsUpdate], [vr.prototype._setValue_arrayElement, vr.prototype._setValue_arrayElement_setNeedsUpdate, vr.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [vr.prototype._setValue_fromArray, vr.prototype._setValue_fromArray_setNeedsUpdate, vr.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

                    class UM {
                        constructor() {
                            this.isAnimationObjectGroup = !0, this.uuid = uo(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                            const e = {};
                            this._indicesByUUID = e;
                            for (let r = 0, a = arguments.length; r !== a; ++r) e[arguments[r].uuid] = r;
                            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                            const n = this;
                            this.stats = {
                                objects: {
                                    get total() {
                                        return n._objects.length
                                    }, get inUse() {
                                        return this.total - n.nCachedObjects_
                                    }
                                }, get bindingsPerObject() {
                                    return n._bindings.length
                                }
                            }
                        }

                        add() {
                            const e = this._objects, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths,
                                u = this._bindings, y = u.length;
                            let S, D = e.length, P = this.nCachedObjects_;
                            for (let z = 0, Q = arguments.length; z !== Q; ++z) {
                                const K = arguments[z], q = K.uuid;
                                let te = n[q];
                                if (te === void 0) {
                                    te = D++, n[q] = te, e.push(K);
                                    for (let le = 0, ne = y; le !== ne; ++le) u[le].push(new vr(K, r[le], a[le]))
                                } else if (te < P) {
                                    S = e[te];
                                    const le = --P, ne = e[le];
                                    n[ne.uuid] = te, e[te] = ne, n[q] = le, e[le] = K;
                                    for (let J = 0, Ce = y; J !== Ce; ++J) {
                                        const ye = u[J], ge = ye[le];
                                        let $e = ye[te];
                                        ye[te] = ge, $e === void 0 && ($e = new vr(K, r[J], a[J])), ye[le] = $e
                                    }
                                } else e[te] !== S && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                            }
                            this.nCachedObjects_ = P
                        }

                        remove() {
                            const e = this._objects, n = this._indicesByUUID, r = this._bindings, a = r.length;
                            let u = this.nCachedObjects_;
                            for (let y = 0, S = arguments.length; y !== S; ++y) {
                                const D = arguments[y], P = D.uuid, z = n[P];
                                if (z !== void 0 && z >= u) {
                                    const Q = u++, K = e[Q];
                                    n[K.uuid] = z, e[z] = K, n[P] = Q, e[Q] = D;
                                    for (let q = 0, te = a; q !== te; ++q) {
                                        const le = r[q], ne = le[Q], J = le[z];
                                        le[z] = ne, le[Q] = J
                                    }
                                }
                            }
                            this.nCachedObjects_ = u
                        }

                        uncache() {
                            const e = this._objects, n = this._indicesByUUID, r = this._bindings, a = r.length;
                            let u = this.nCachedObjects_, y = e.length;
                            for (let S = 0, D = arguments.length; S !== D; ++S) {
                                const P = arguments[S], z = P.uuid, Q = n[z];
                                if (Q !== void 0) if (delete n[z], Q < u) {
                                    const K = --u, q = e[K], te = --y, le = e[te];
                                    n[q.uuid] = Q, e[Q] = q, n[le.uuid] = K, e[K] = le, e.pop();
                                    for (let ne = 0, J = a; ne !== J; ++ne) {
                                        const Ce = r[ne], ye = Ce[K], ge = Ce[te];
                                        Ce[Q] = ye, Ce[K] = ge, Ce.pop()
                                    }
                                } else {
                                    const K = --y, q = e[K];
                                    K > 0 && (n[q.uuid] = Q), e[Q] = q, e.pop();
                                    for (let te = 0, le = a; te !== le; ++te) {
                                        const ne = r[te];
                                        ne[Q] = ne[K], ne.pop()
                                    }
                                }
                            }
                            this.nCachedObjects_ = u
                        }

                        subscribe_(e, n) {
                            const r = this._bindingsIndicesByPath;
                            let a = r[e];
                            const u = this._bindings;
                            if (a !== void 0) return u[a];
                            const y = this._paths, S = this._parsedPaths, D = this._objects, P = D.length,
                                z = this.nCachedObjects_, Q = new Array(P);
                            a = u.length, r[e] = a, y.push(e), S.push(n), u.push(Q);
                            for (let K = z, q = D.length; K !== q; ++K) {
                                const te = D[K];
                                Q[K] = new vr(te, e, n)
                            }
                            return Q
                        }

                        unsubscribe_(e) {
                            const n = this._bindingsIndicesByPath, r = n[e];
                            if (r !== void 0) {
                                const a = this._paths, u = this._parsedPaths, y = this._bindings, S = y.length - 1,
                                    D = y[S], P = e[S];
                                n[P] = r, y[r] = D, y.pop(), u[r] = u[S], u.pop(), a[r] = a[S], a.pop()
                            }
                        }
                    }

                    class Lx {
                        constructor(e, n, r = null, a = n.blendMode) {
                            this._mixer = e, this._clip = n, this._localRoot = r, this.blendMode = a;
                            const u = n.tracks, y = u.length, S = new Array(y), D = {endingStart: yn, endingEnd: yn};
                            for (let P = 0; P !== y; ++P) {
                                const z = u[P].createInterpolant(null);
                                S[P] = z, z.settings = D
                            }
                            this._interpolantSettings = D, this._interpolants = S, this._propertyBindings = new Array(y), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = sn, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                        }

                        play() {
                            return this._mixer._activateAction(this), this
                        }

                        stop() {
                            return this._mixer._deactivateAction(this), this.reset()
                        }

                        reset() {
                            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                        }

                        isRunning() {
                            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
                        }

                        isScheduled() {
                            return this._mixer._isActiveAction(this)
                        }

                        startAt(e) {
                            return this._startTime = e, this
                        }

                        setLoop(e, n) {
                            return this.loop = e, this.repetitions = n, this
                        }

                        setEffectiveWeight(e) {
                            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                        }

                        getEffectiveWeight() {
                            return this._effectiveWeight
                        }

                        fadeIn(e) {
                            return this._scheduleFading(e, 0, 1)
                        }

                        fadeOut(e) {
                            return this._scheduleFading(e, 1, 0)
                        }

                        crossFadeFrom(e, n, r) {
                            if (e.fadeOut(n), this.fadeIn(n), r) {
                                const a = this._clip.duration, u = e._clip.duration, y = u / a, S = a / u;
                                e.warp(1, y, n), this.warp(S, 1, n)
                            }
                            return this
                        }

                        crossFadeTo(e, n, r) {
                            return e.crossFadeFrom(this, n, r)
                        }

                        stopFading() {
                            const e = this._weightInterpolant;
                            return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                        }

                        setEffectiveTimeScale(e) {
                            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                        }

                        getEffectiveTimeScale() {
                            return this._effectiveTimeScale
                        }

                        setDuration(e) {
                            return this.timeScale = this._clip.duration / e, this.stopWarping()
                        }

                        syncWith(e) {
                            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                        }

                        halt(e) {
                            return this.warp(this._effectiveTimeScale, 0, e)
                        }

                        warp(e, n, r) {
                            const a = this._mixer, u = a.time, y = this.timeScale;
                            let S = this._timeScaleInterpolant;
                            S === null && (S = a._lendControlInterpolant(), this._timeScaleInterpolant = S);
                            const D = S.parameterPositions, P = S.sampleValues;
                            return D[0] = u, D[1] = u + r, P[0] = e / y, P[1] = n / y, this
                        }

                        stopWarping() {
                            const e = this._timeScaleInterpolant;
                            return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                        }

                        getMixer() {
                            return this._mixer
                        }

                        getClip() {
                            return this._clip
                        }

                        getRoot() {
                            return this._localRoot || this._mixer._root
                        }

                        _update(e, n, r, a) {
                            if (!this.enabled) {
                                this._updateWeight(e);
                                return
                            }
                            const u = this._startTime;
                            if (u !== null) {
                                const D = (e - u) * r;
                                D < 0 || r === 0 ? n = 0 : (this._startTime = null, n = r * D)
                            }
                            n *= this._updateTimeScale(e);
                            const y = this._updateTime(n), S = this._updateWeight(e);
                            if (S > 0) {
                                const D = this._interpolants, P = this._propertyBindings;
                                switch (this.blendMode) {
                                    case gi:
                                        for (let z = 0, Q = D.length; z !== Q; ++z) D[z].evaluate(y), P[z].accumulateAdditive(S);
                                        break;
                                    case _i:
                                    default:
                                        for (let z = 0, Q = D.length; z !== Q; ++z) D[z].evaluate(y), P[z].accumulate(a, S)
                                }
                            }
                        }

                        _updateWeight(e) {
                            let n = 0;
                            if (this.enabled) {
                                n = this.weight;
                                const r = this._weightInterpolant;
                                if (r !== null) {
                                    const a = r.evaluate(e)[0];
                                    n *= a, e > r.parameterPositions[1] && (this.stopFading(), a === 0 && (this.enabled = !1))
                                }
                            }
                            return this._effectiveWeight = n, n
                        }

                        _updateTimeScale(e) {
                            let n = 0;
                            if (!this.paused) {
                                n = this.timeScale;
                                const r = this._timeScaleInterpolant;
                                if (r !== null) {
                                    const a = r.evaluate(e)[0];
                                    n *= a, e > r.parameterPositions[1] && (this.stopWarping(), n === 0 ? this.paused = !0 : this.timeScale = n)
                                }
                            }
                            return this._effectiveTimeScale = n, n
                        }

                        _updateTime(e) {
                            const n = this._clip.duration, r = this.loop;
                            let a = this.time + e, u = this._loopCount;
                            const y = r === Pt;
                            if (e === 0) return u === -1 ? a : y && (u & 1) === 1 ? n - a : a;
                            if (r === Jt) {
                                u === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                                e:{
                                    if (a >= n) a = n; else if (a < 0) a = 0; else {
                                        this.time = a;
                                        break e
                                    }
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = a, this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e < 0 ? -1 : 1
                                    })
                                }
                            } else {
                                if (u === -1 && (e >= 0 ? (u = 0, this._setEndings(!0, this.repetitions === 0, y)) : this._setEndings(this.repetitions === 0, !0, y)), a >= n || a < 0) {
                                    const S = Math.floor(a / n);
                                    a -= n * S, u += Math.abs(S);
                                    const D = this.repetitions - u;
                                    if (D <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, a = e > 0 ? n : 0, this.time = a, this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e > 0 ? 1 : -1
                                    }); else {
                                        if (D === 1) {
                                            const P = e < 0;
                                            this._setEndings(P, !P, y)
                                        } else this._setEndings(!1, !1, y);
                                        this._loopCount = u, this.time = a, this._mixer.dispatchEvent({
                                            type: "loop",
                                            action: this,
                                            loopDelta: S
                                        })
                                    }
                                } else this.time = a;
                                if (y && (u & 1) === 1) return n - a
                            }
                            return a
                        }

                        _setEndings(e, n, r) {
                            const a = this._interpolantSettings;
                            r ? (a.endingStart = bi, a.endingEnd = bi) : (e ? a.endingStart = this.zeroSlopeAtStart ? bi : yn : a.endingStart = Ii, n ? a.endingEnd = this.zeroSlopeAtEnd ? bi : yn : a.endingEnd = Ii)
                        }

                        _scheduleFading(e, n, r) {
                            const a = this._mixer, u = a.time;
                            let y = this._weightInterpolant;
                            y === null && (y = a._lendControlInterpolant(), this._weightInterpolant = y);
                            const S = y.parameterPositions, D = y.sampleValues;
                            return S[0] = u, D[0] = n, S[1] = u + e, D[1] = r, this
                        }
                    }

                    const zM = new Float32Array(1);

                    class GM extends Ss {
                        constructor(e) {
                            super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                        }

                        _bindAction(e, n) {
                            const r = e._localRoot || this._root, a = e._clip.tracks, u = a.length,
                                y = e._propertyBindings, S = e._interpolants, D = r.uuid,
                                P = this._bindingsByRootAndName;
                            let z = P[D];
                            z === void 0 && (z = {}, P[D] = z);
                            for (let Q = 0; Q !== u; ++Q) {
                                const K = a[Q], q = K.name;
                                let te = z[q];
                                if (te !== void 0) ++te.referenceCount, y[Q] = te; else {
                                    if (te = y[Q], te !== void 0) {
                                        te._cacheIndex === null && (++te.referenceCount, this._addInactiveBinding(te, D, q));
                                        continue
                                    }
                                    const le = n && n._propertyBindings[Q].binding.parsedPath;
                                    te = new Bx(vr.create(r, q, le), K.ValueTypeName, K.getValueSize()), ++te.referenceCount, this._addInactiveBinding(te, D, q), y[Q] = te
                                }
                                S[Q].resultBuffer = te.buffer
                            }
                        }

                        _activateAction(e) {
                            if (!this._isActiveAction(e)) {
                                if (e._cacheIndex === null) {
                                    const r = (e._localRoot || this._root).uuid, a = e._clip.uuid,
                                        u = this._actionsByClip[a];
                                    this._bindAction(e, u && u.knownActions[0]), this._addInactiveAction(e, a, r)
                                }
                                const n = e._propertyBindings;
                                for (let r = 0, a = n.length; r !== a; ++r) {
                                    const u = n[r];
                                    u.useCount++ === 0 && (this._lendBinding(u), u.saveOriginalState())
                                }
                                this._lendAction(e)
                            }
                        }

                        _deactivateAction(e) {
                            if (this._isActiveAction(e)) {
                                const n = e._propertyBindings;
                                for (let r = 0, a = n.length; r !== a; ++r) {
                                    const u = n[r];
                                    --u.useCount === 0 && (u.restoreOriginalState(), this._takeBackBinding(u))
                                }
                                this._takeBackAction(e)
                            }
                        }

                        _initMemoryManager() {
                            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                            const e = this;
                            this.stats = {
                                actions: {
                                    get total() {
                                        return e._actions.length
                                    }, get inUse() {
                                        return e._nActiveActions
                                    }
                                }, bindings: {
                                    get total() {
                                        return e._bindings.length
                                    }, get inUse() {
                                        return e._nActiveBindings
                                    }
                                }, controlInterpolants: {
                                    get total() {
                                        return e._controlInterpolants.length
                                    }, get inUse() {
                                        return e._nActiveControlInterpolants
                                    }
                                }
                            }
                        }

                        _isActiveAction(e) {
                            const n = e._cacheIndex;
                            return n !== null && n < this._nActiveActions
                        }

                        _addInactiveAction(e, n, r) {
                            const a = this._actions, u = this._actionsByClip;
                            let y = u[n];
                            if (y === void 0) y = {
                                knownActions: [e],
                                actionByRoot: {}
                            }, e._byClipCacheIndex = 0, u[n] = y; else {
                                const S = y.knownActions;
                                e._byClipCacheIndex = S.length, S.push(e)
                            }
                            e._cacheIndex = a.length, a.push(e), y.actionByRoot[r] = e
                        }

                        _removeInactiveAction(e) {
                            const n = this._actions, r = n[n.length - 1], a = e._cacheIndex;
                            r._cacheIndex = a, n[a] = r, n.pop(), e._cacheIndex = null;
                            const u = e._clip.uuid, y = this._actionsByClip, S = y[u], D = S.knownActions,
                                P = D[D.length - 1], z = e._byClipCacheIndex;
                            P._byClipCacheIndex = z, D[z] = P, D.pop(), e._byClipCacheIndex = null;
                            const Q = S.actionByRoot, K = (e._localRoot || this._root).uuid;
                            delete Q[K], D.length === 0 && delete y[u], this._removeInactiveBindingsForAction(e)
                        }

                        _removeInactiveBindingsForAction(e) {
                            const n = e._propertyBindings;
                            for (let r = 0, a = n.length; r !== a; ++r) {
                                const u = n[r];
                                --u.referenceCount === 0 && this._removeInactiveBinding(u)
                            }
                        }

                        _lendAction(e) {
                            const n = this._actions, r = e._cacheIndex, a = this._nActiveActions++, u = n[a];
                            e._cacheIndex = a, n[a] = e, u._cacheIndex = r, n[r] = u
                        }

                        _takeBackAction(e) {
                            const n = this._actions, r = e._cacheIndex, a = --this._nActiveActions, u = n[a];
                            e._cacheIndex = a, n[a] = e, u._cacheIndex = r, n[r] = u
                        }

                        _addInactiveBinding(e, n, r) {
                            const a = this._bindingsByRootAndName, u = this._bindings;
                            let y = a[n];
                            y === void 0 && (y = {}, a[n] = y), y[r] = e, e._cacheIndex = u.length, u.push(e)
                        }

                        _removeInactiveBinding(e) {
                            const n = this._bindings, r = e.binding, a = r.rootNode.uuid, u = r.path,
                                y = this._bindingsByRootAndName, S = y[a], D = n[n.length - 1], P = e._cacheIndex;
                            D._cacheIndex = P, n[P] = D, n.pop(), delete S[u], Object.keys(S).length === 0 && delete y[a]
                        }

                        _lendBinding(e) {
                            const n = this._bindings, r = e._cacheIndex, a = this._nActiveBindings++, u = n[a];
                            e._cacheIndex = a, n[a] = e, u._cacheIndex = r, n[r] = u
                        }

                        _takeBackBinding(e) {
                            const n = this._bindings, r = e._cacheIndex, a = --this._nActiveBindings, u = n[a];
                            e._cacheIndex = a, n[a] = e, u._cacheIndex = r, n[r] = u
                        }

                        _lendControlInterpolant() {
                            const e = this._controlInterpolants, n = this._nActiveControlInterpolants++;
                            let r = e[n];
                            return r === void 0 && (r = new Gv(new Float32Array(2), new Float32Array(2), 1, zM), r.__cacheIndex = n, e[n] = r), r
                        }

                        _takeBackControlInterpolant(e) {
                            const n = this._controlInterpolants, r = e.__cacheIndex,
                                a = --this._nActiveControlInterpolants, u = n[a];
                            e.__cacheIndex = a, n[a] = e, u.__cacheIndex = r, n[r] = u
                        }

                        clipAction(e, n, r) {
                            const a = n || this._root, u = a.uuid;
                            let y = typeof e == "string" ? Qp.findByName(a, e) : e;
                            const S = y !== null ? y.uuid : e, D = this._actionsByClip[S];
                            let P = null;
                            if (r === void 0 && (y !== null ? r = y.blendMode : r = _i), D !== void 0) {
                                const Q = D.actionByRoot[u];
                                if (Q !== void 0 && Q.blendMode === r) return Q;
                                P = D.knownActions[0], y === null && (y = P._clip)
                            }
                            if (y === null) return null;
                            const z = new Lx(this, y, n, r);
                            return this._bindAction(z, P), this._addInactiveAction(z, S, u), z
                        }

                        existingAction(e, n) {
                            const r = n || this._root, a = r.uuid, u = typeof e == "string" ? Qp.findByName(r, e) : e,
                                y = u ? u.uuid : e, S = this._actionsByClip[y];
                            return S !== void 0 && S.actionByRoot[a] || null
                        }

                        stopAllAction() {
                            const e = this._actions, n = this._nActiveActions;
                            for (let r = n - 1; r >= 0; --r) e[r].stop();
                            return this
                        }

                        update(e) {
                            e *= this.timeScale;
                            const n = this._actions, r = this._nActiveActions, a = this.time += e, u = Math.sign(e),
                                y = this._accuIndex ^= 1;
                            for (let P = 0; P !== r; ++P) n[P]._update(a, e, u, y);
                            const S = this._bindings, D = this._nActiveBindings;
                            for (let P = 0; P !== D; ++P) S[P].apply(y);
                            return this
                        }

                        setTime(e) {
                            this.time = 0;
                            for (let n = 0; n < this._actions.length; n++) this._actions[n].time = 0;
                            return this.update(e)
                        }

                        getRoot() {
                            return this._root
                        }

                        uncacheClip(e) {
                            const n = this._actions, r = e.uuid, a = this._actionsByClip, u = a[r];
                            if (u !== void 0) {
                                const y = u.knownActions;
                                for (let S = 0, D = y.length; S !== D; ++S) {
                                    const P = y[S];
                                    this._deactivateAction(P);
                                    const z = P._cacheIndex, Q = n[n.length - 1];
                                    P._cacheIndex = null, P._byClipCacheIndex = null, Q._cacheIndex = z, n[z] = Q, n.pop(), this._removeInactiveBindingsForAction(P)
                                }
                                delete a[r]
                            }
                        }

                        uncacheRoot(e) {
                            const n = e.uuid, r = this._actionsByClip;
                            for (const y in r) {
                                const S = r[y].actionByRoot, D = S[n];
                                D !== void 0 && (this._deactivateAction(D), this._removeInactiveAction(D))
                            }
                            const a = this._bindingsByRootAndName, u = a[n];
                            if (u !== void 0) for (const y in u) {
                                const S = u[y];
                                S.restoreOriginalState(), this._removeInactiveBinding(S)
                            }
                        }

                        uncacheAction(e, n) {
                            const r = this.existingAction(e, n);
                            r !== null && (this._deactivateAction(r), this._removeInactiveAction(r))
                        }
                    }

                    class Jv {
                        constructor(e) {
                            this.value = e
                        }

                        clone() {
                            return new Jv(this.value.clone === void 0 ? this.value : this.value.clone())
                        }
                    }

                    let VM = 0;

                    class HM extends Ss {
                        constructor() {
                            super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {value: VM++}), this.name = "", this.usage = rl, this.uniforms = []
                        }

                        add(e) {
                            return this.uniforms.push(e), this
                        }

                        remove(e) {
                            const n = this.uniforms.indexOf(e);
                            return n !== -1 && this.uniforms.splice(n, 1), this
                        }

                        setName(e) {
                            return this.name = e, this
                        }

                        setUsage(e) {
                            return this.usage = e, this
                        }

                        dispose() {
                            return this.dispatchEvent({type: "dispose"}), this
                        }

                        copy(e) {
                            this.name = e.name, this.usage = e.usage;
                            const n = e.uniforms;
                            this.uniforms.length = 0;
                            for (let r = 0, a = n.length; r < a; r++) {
                                const u = Array.isArray(n[r]) ? n[r] : [n[r]];
                                for (let y = 0; y < u.length; y++) this.uniforms.push(u[y].clone())
                            }
                            return this
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    class QM extends zA {
                        constructor(e, n, r = 1) {
                            super(e, n), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r
                        }

                        copy(e) {
                            return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                        }

                        clone(e) {
                            const n = super.clone(e);
                            return n.meshPerAttribute = this.meshPerAttribute, n
                        }

                        toJSON(e) {
                            const n = super.toJSON(e);
                            return n.isInstancedInterleavedBuffer = !0, n.meshPerAttribute = this.meshPerAttribute, n
                        }
                    }

                    class jM {
                        constructor(e, n, r, a, u) {
                            this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = n, this.itemSize = r, this.elementSize = a, this.count = u, this.version = 0
                        }

                        set needsUpdate(e) {
                            e === !0 && this.version++
                        }

                        setBuffer(e) {
                            return this.buffer = e, this
                        }

                        setType(e, n) {
                            return this.type = e, this.elementSize = n, this
                        }

                        setItemSize(e) {
                            return this.itemSize = e, this
                        }

                        setCount(e) {
                            return this.count = e, this
                        }
                    }

                    const Dx = new Mn;

                    class WM {
                        constructor(e, n, r = 0, a = 1 / 0) {
                            this.ray = new jr(e, n), this.near = r, this.far = a, this.camera = null, this.layers = new hl, this.params = {
                                Mesh: {},
                                Line: {threshold: 1},
                                LOD: {},
                                Points: {threshold: 1},
                                Sprite: {}
                            }
                        }

                        set(e, n) {
                            this.ray.set(e, n)
                        }

                        setFromCamera(e, n) {
                            n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type)
                        }

                        setFromXRController(e) {
                            return Dx.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Dx), this
                        }

                        intersectObject(e, n = !0, r = []) {
                            return Zv(e, this, r, n), r.sort(Px), r
                        }

                        intersectObjects(e, n = !0, r = []) {
                            for (let a = 0, u = e.length; a < u; a++) Zv(e[a], this, r, n);
                            return r.sort(Px), r
                        }
                    }

                    function Px(d, e) {
                        return d.distance - e.distance
                    }

                    function Zv(d, e, n, r) {
                        if (d.layers.test(e.layers) && d.raycast(e, n), r === !0) {
                            const a = d.children;
                            for (let u = 0, y = a.length; u < y; u++) Zv(a[u], e, n, !0)
                        }
                    }

                    class KM {
                        constructor(e = 1, n = 0, r = 0) {
                            return this.radius = e, this.phi = n, this.theta = r, this
                        }

                        set(e, n, r) {
                            return this.radius = e, this.phi = n, this.theta = r, this
                        }

                        copy(e) {
                            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                        }

                        makeSafe() {
                            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                        }

                        setFromVector3(e) {
                            return this.setFromCartesianCoords(e.x, e.y, e.z)
                        }

                        setFromCartesianCoords(e, n, r) {
                            return this.radius = Math.sqrt(e * e + n * n + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(Hr(n / this.radius, -1, 1))), this
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    class XM {
                        constructor(e = 1, n = 0, r = 0) {
                            return this.radius = e, this.theta = n, this.y = r, this
                        }

                        set(e, n, r) {
                            return this.radius = e, this.theta = n, this.y = r, this
                        }

                        copy(e) {
                            return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                        }

                        setFromVector3(e) {
                            return this.setFromCartesianCoords(e.x, e.y, e.z)
                        }

                        setFromCartesianCoords(e, n, r) {
                            return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = n, this
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    const Ox = new zt;

                    class YM {
                        constructor(e = new zt(1 / 0, 1 / 0), n = new zt(-1 / 0, -1 / 0)) {
                            this.isBox2 = !0, this.min = e, this.max = n
                        }

                        set(e, n) {
                            return this.min.copy(e), this.max.copy(n), this
                        }

                        setFromPoints(e) {
                            this.makeEmpty();
                            for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
                            return this
                        }

                        setFromCenterAndSize(e, n) {
                            const r = Ox.copy(n).multiplyScalar(.5);
                            return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        copy(e) {
                            return this.min.copy(e.min), this.max.copy(e.max), this
                        }

                        makeEmpty() {
                            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                        }

                        isEmpty() {
                            return this.max.x < this.min.x || this.max.y < this.min.y
                        }

                        getCenter(e) {
                            return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                        }

                        getSize(e) {
                            return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                        }

                        expandByPoint(e) {
                            return this.min.min(e), this.max.max(e), this
                        }

                        expandByVector(e) {
                            return this.min.sub(e), this.max.add(e), this
                        }

                        expandByScalar(e) {
                            return this.min.addScalar(-e), this.max.addScalar(e), this
                        }

                        containsPoint(e) {
                            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                        }

                        containsBox(e) {
                            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                        }

                        getParameter(e, n) {
                            return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                        }

                        intersectsBox(e) {
                            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                        }

                        clampPoint(e, n) {
                            return n.copy(e).clamp(this.min, this.max)
                        }

                        distanceToPoint(e) {
                            return this.clampPoint(e, Ox).distanceTo(e)
                        }

                        intersect(e) {
                            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                        }

                        union(e) {
                            return this.min.min(e.min), this.max.max(e.max), this
                        }

                        translate(e) {
                            return this.min.add(e), this.max.add(e), this
                        }

                        equals(e) {
                            return e.min.equals(this.min) && e.max.equals(this.max)
                        }
                    }

                    const kx = new Ne, Mg = new Ne;

                    class qM {
                        constructor(e = new Ne, n = new Ne) {
                            this.start = e, this.end = n
                        }

                        set(e, n) {
                            return this.start.copy(e), this.end.copy(n), this
                        }

                        copy(e) {
                            return this.start.copy(e.start), this.end.copy(e.end), this
                        }

                        getCenter(e) {
                            return e.addVectors(this.start, this.end).multiplyScalar(.5)
                        }

                        delta(e) {
                            return e.subVectors(this.end, this.start)
                        }

                        distanceSq() {
                            return this.start.distanceToSquared(this.end)
                        }

                        distance() {
                            return this.start.distanceTo(this.end)
                        }

                        at(e, n) {
                            return this.delta(n).multiplyScalar(e).add(this.start)
                        }

                        closestPointToPointParameter(e, n) {
                            kx.subVectors(e, this.start), Mg.subVectors(this.end, this.start);
                            const r = Mg.dot(Mg);
                            let u = Mg.dot(kx) / r;
                            return n && (u = Hr(u, 0, 1)), u
                        }

                        closestPointToPoint(e, n, r) {
                            const a = this.closestPointToPointParameter(e, n);
                            return this.delta(r).multiplyScalar(a).add(this.start)
                        }

                        applyMatrix4(e) {
                            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                        }

                        equals(e) {
                            return e.start.equals(this.start) && e.end.equals(this.end)
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }
                    }

                    const Fx = new Ne;

                    class JM extends or {
                        constructor(e, n) {
                            super(), this.light = e, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper";
                            const r = new Ti,
                                a = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                            for (let y = 0, S = 1, D = 32; y < D; y++, S++) {
                                const P = y / D * Math.PI * 2, z = S / D * Math.PI * 2;
                                a.push(Math.cos(P), Math.sin(P), 1, Math.cos(z), Math.sin(z), 1)
                            }
                            r.setAttribute("position", new Xn(a, 3));
                            const u = new oa({fog: !1, toneMapped: !1});
                            this.cone = new Ql(r, u), this.add(this.cone), this.update()
                        }

                        dispose() {
                            this.cone.geometry.dispose(), this.cone.material.dispose()
                        }

                        update() {
                            this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
                            const e = this.light.distance ? this.light.distance : 1e3,
                                n = e * Math.tan(this.light.angle);
                            this.cone.scale.set(n, n, e), Fx.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Fx), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                        }
                    }

                    const mu = new Ne, Sg = new Mn, $v = new Mn;

                    class ZM extends Ql {
                        constructor(e) {
                            const n = Nx(e), r = new Ti, a = [], u = [], y = new Bn(0, 0, 1), S = new Bn(0, 1, 0);
                            for (let P = 0; P < n.length; P++) {
                                const z = n[P];
                                z.parent && z.parent.isBone && (a.push(0, 0, 0), a.push(0, 0, 0), u.push(y.r, y.g, y.b), u.push(S.r, S.g, S.b))
                            }
                            r.setAttribute("position", new Xn(a, 3)), r.setAttribute("color", new Xn(u, 3));
                            const D = new oa({
                                vertexColors: !0,
                                depthTest: !1,
                                depthWrite: !1,
                                toneMapped: !1,
                                transparent: !0
                            });
                            super(r, D), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = n, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
                        }

                        updateMatrixWorld(e) {
                            const n = this.bones, r = this.geometry, a = r.getAttribute("position");
                            $v.copy(this.root.matrixWorld).invert();
                            for (let u = 0, y = 0; u < n.length; u++) {
                                const S = n[u];
                                S.parent && S.parent.isBone && (Sg.multiplyMatrices($v, S.matrixWorld), mu.setFromMatrixPosition(Sg), a.setXYZ(y, mu.x, mu.y, mu.z), Sg.multiplyMatrices($v, S.parent.matrixWorld), mu.setFromMatrixPosition(Sg), a.setXYZ(y + 1, mu.x, mu.y, mu.z), y += 2)
                            }
                            r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }

                    function Nx(d) {
                        const e = [];
                        d.isBone === !0 && e.push(d);
                        for (let n = 0; n < d.children.length; n++) e.push.apply(e, Nx(d.children[n]));
                        return e
                    }

                    class $M extends Wr {
                        constructor(e, n, r) {
                            const a = new zp(n, 4, 2), u = new gr({wireframe: !0, fog: !1, toneMapped: !1});
                            super(a, u), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }

                        update() {
                            this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                        }
                    }

                    const e3 = new Ne, Ux = new Bn, zx = new Bn;

                    class t3 extends or {
                        constructor(e, n, r) {
                            super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper";
                            const a = new Up(n);
                            a.rotateY(Math.PI * .5), this.material = new gr({
                                wireframe: !0,
                                fog: !1,
                                toneMapped: !1
                            }), this.color === void 0 && (this.material.vertexColors = !0);
                            const u = a.getAttribute("position"), y = new Float32Array(u.count * 3);
                            a.setAttribute("color", new Er(y, 3)), this.add(new Wr(a, this.material)), this.update()
                        }

                        dispose() {
                            this.children[0].geometry.dispose(), this.children[0].material.dispose()
                        }

                        update() {
                            const e = this.children[0];
                            if (this.color !== void 0) this.material.color.set(this.color); else {
                                const n = e.geometry.getAttribute("color");
                                Ux.copy(this.light.color), zx.copy(this.light.groundColor);
                                for (let r = 0, a = n.count; r < a; r++) {
                                    const u = r < a / 2 ? Ux : zx;
                                    n.setXYZ(r, u.r, u.g, u.b)
                                }
                                n.needsUpdate = !0
                            }
                            this.light.updateWorldMatrix(!0, !1), e.lookAt(e3.setFromMatrixPosition(this.light.matrixWorld).negate())
                        }
                    }

                    class n3 extends Ql {
                        constructor(e = 10, n = 10, r = 4473924, a = 8947848) {
                            r = new Bn(r), a = new Bn(a);
                            const u = n / 2, y = e / n, S = e / 2, D = [], P = [];
                            for (let K = 0, q = 0, te = -S; K <= n; K++, te += y) {
                                D.push(-S, 0, te, S, 0, te), D.push(te, 0, -S, te, 0, S);
                                const le = K === u ? r : a;
                                le.toArray(P, q), q += 3, le.toArray(P, q), q += 3, le.toArray(P, q), q += 3, le.toArray(P, q), q += 3
                            }
                            const z = new Ti;
                            z.setAttribute("position", new Xn(D, 3)), z.setAttribute("color", new Xn(P, 3));
                            const Q = new oa({vertexColors: !0, toneMapped: !1});
                            super(z, Q), this.type = "GridHelper"
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }

                    class i3 extends Ql {
                        constructor(e = 10, n = 16, r = 8, a = 64, u = 4473924, y = 8947848) {
                            u = new Bn(u), y = new Bn(y);
                            const S = [], D = [];
                            if (n > 1) for (let Q = 0; Q < n; Q++) {
                                const K = Q / n * (Math.PI * 2), q = Math.sin(K) * e, te = Math.cos(K) * e;
                                S.push(0, 0, 0), S.push(q, 0, te);
                                const le = Q & 1 ? u : y;
                                D.push(le.r, le.g, le.b), D.push(le.r, le.g, le.b)
                            }
                            for (let Q = 0; Q < r; Q++) {
                                const K = Q & 1 ? u : y, q = e - e / r * Q;
                                for (let te = 0; te < a; te++) {
                                    let le = te / a * (Math.PI * 2), ne = Math.sin(le) * q, J = Math.cos(le) * q;
                                    S.push(ne, 0, J), D.push(K.r, K.g, K.b), le = (te + 1) / a * (Math.PI * 2), ne = Math.sin(le) * q, J = Math.cos(le) * q, S.push(ne, 0, J), D.push(K.r, K.g, K.b)
                                }
                            }
                            const P = new Ti;
                            P.setAttribute("position", new Xn(S, 3)), P.setAttribute("color", new Xn(D, 3));
                            const z = new oa({vertexColors: !0, toneMapped: !1});
                            super(P, z), this.type = "PolarGridHelper"
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }

                    const Gx = new Ne, Tg = new Ne, Vx = new Ne;

                    class r3 extends or {
                        constructor(e, n, r) {
                            super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", n === void 0 && (n = 1);
                            let a = new Ti;
                            a.setAttribute("position", new Xn([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3));
                            const u = new oa({fog: !1, toneMapped: !1});
                            this.lightPlane = new du(a, u), this.add(this.lightPlane), a = new Ti, a.setAttribute("position", new Xn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new du(a, u), this.add(this.targetLine), this.update()
                        }

                        dispose() {
                            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                        }

                        update() {
                            this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Gx.setFromMatrixPosition(this.light.matrixWorld), Tg.setFromMatrixPosition(this.light.target.matrixWorld), Vx.subVectors(Tg, Gx), this.lightPlane.lookAt(Tg), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Tg), this.targetLine.scale.z = Vx.length()
                        }
                    }

                    const Ig = new Ne, Es = new Xa;

                    class s3 extends Ql {
                        constructor(e) {
                            const n = new Ti, r = new oa({color: 16777215, vertexColors: !0, toneMapped: !1}), a = [],
                                u = [], y = {};
                            S("n1", "n2"), S("n2", "n4"), S("n4", "n3"), S("n3", "n1"), S("f1", "f2"), S("f2", "f4"), S("f4", "f3"), S("f3", "f1"), S("n1", "f1"), S("n2", "f2"), S("n3", "f3"), S("n4", "f4"), S("p", "n1"), S("p", "n2"), S("p", "n3"), S("p", "n4"), S("u1", "u2"), S("u2", "u3"), S("u3", "u1"), S("c", "t"), S("p", "c"), S("cn1", "cn2"), S("cn3", "cn4"), S("cf1", "cf2"), S("cf3", "cf4");

                            function S(te, le) {
                                D(te), D(le)
                            }

                            function D(te) {
                                a.push(0, 0, 0), u.push(0, 0, 0), y[te] === void 0 && (y[te] = []), y[te].push(a.length / 3 - 1)
                            }

                            n.setAttribute("position", new Xn(a, 3)), n.setAttribute("color", new Xn(u, 3)), super(n, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = y, this.update();
                            const P = new Bn(16755200), z = new Bn(16711680), Q = new Bn(43775), K = new Bn(16777215),
                                q = new Bn(3355443);
                            this.setColors(P, z, Q, K, q)
                        }

                        setColors(e, n, r, a, u) {
                            const S = this.geometry.getAttribute("color");
                            S.setXYZ(0, e.r, e.g, e.b), S.setXYZ(1, e.r, e.g, e.b), S.setXYZ(2, e.r, e.g, e.b), S.setXYZ(3, e.r, e.g, e.b), S.setXYZ(4, e.r, e.g, e.b), S.setXYZ(5, e.r, e.g, e.b), S.setXYZ(6, e.r, e.g, e.b), S.setXYZ(7, e.r, e.g, e.b), S.setXYZ(8, e.r, e.g, e.b), S.setXYZ(9, e.r, e.g, e.b), S.setXYZ(10, e.r, e.g, e.b), S.setXYZ(11, e.r, e.g, e.b), S.setXYZ(12, e.r, e.g, e.b), S.setXYZ(13, e.r, e.g, e.b), S.setXYZ(14, e.r, e.g, e.b), S.setXYZ(15, e.r, e.g, e.b), S.setXYZ(16, e.r, e.g, e.b), S.setXYZ(17, e.r, e.g, e.b), S.setXYZ(18, e.r, e.g, e.b), S.setXYZ(19, e.r, e.g, e.b), S.setXYZ(20, e.r, e.g, e.b), S.setXYZ(21, e.r, e.g, e.b), S.setXYZ(22, e.r, e.g, e.b), S.setXYZ(23, e.r, e.g, e.b), S.setXYZ(24, n.r, n.g, n.b), S.setXYZ(25, n.r, n.g, n.b), S.setXYZ(26, n.r, n.g, n.b), S.setXYZ(27, n.r, n.g, n.b), S.setXYZ(28, n.r, n.g, n.b), S.setXYZ(29, n.r, n.g, n.b), S.setXYZ(30, n.r, n.g, n.b), S.setXYZ(31, n.r, n.g, n.b), S.setXYZ(32, r.r, r.g, r.b), S.setXYZ(33, r.r, r.g, r.b), S.setXYZ(34, r.r, r.g, r.b), S.setXYZ(35, r.r, r.g, r.b), S.setXYZ(36, r.r, r.g, r.b), S.setXYZ(37, r.r, r.g, r.b), S.setXYZ(38, a.r, a.g, a.b), S.setXYZ(39, a.r, a.g, a.b), S.setXYZ(40, u.r, u.g, u.b), S.setXYZ(41, u.r, u.g, u.b), S.setXYZ(42, u.r, u.g, u.b), S.setXYZ(43, u.r, u.g, u.b), S.setXYZ(44, u.r, u.g, u.b), S.setXYZ(45, u.r, u.g, u.b), S.setXYZ(46, u.r, u.g, u.b), S.setXYZ(47, u.r, u.g, u.b), S.setXYZ(48, u.r, u.g, u.b), S.setXYZ(49, u.r, u.g, u.b), S.needsUpdate = !0
                        }

                        update() {
                            const e = this.geometry, n = this.pointMap, r = 1, a = 1;
                            Es.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), ks("c", n, e, Es, 0, 0, -1), ks("t", n, e, Es, 0, 0, 1), ks("n1", n, e, Es, -r, -a, -1), ks("n2", n, e, Es, r, -a, -1), ks("n3", n, e, Es, -r, a, -1), ks("n4", n, e, Es, r, a, -1), ks("f1", n, e, Es, -r, -a, 1), ks("f2", n, e, Es, r, -a, 1), ks("f3", n, e, Es, -r, a, 1), ks("f4", n, e, Es, r, a, 1), ks("u1", n, e, Es, r * .7, a * 1.1, -1), ks("u2", n, e, Es, -r * .7, a * 1.1, -1), ks("u3", n, e, Es, 0, a * 2, -1), ks("cf1", n, e, Es, -r, 0, 1), ks("cf2", n, e, Es, r, 0, 1), ks("cf3", n, e, Es, 0, -a, 1), ks("cf4", n, e, Es, 0, a, 1), ks("cn1", n, e, Es, -r, 0, -1), ks("cn2", n, e, Es, r, 0, -1), ks("cn3", n, e, Es, 0, -a, -1), ks("cn4", n, e, Es, 0, a, -1), e.getAttribute("position").needsUpdate = !0
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }

                    function ks(d, e, n, r, a, u, y) {
                        Ig.set(a, u, y).unproject(r);
                        const S = e[d];
                        if (S !== void 0) {
                            const D = n.getAttribute("position");
                            for (let P = 0, z = S.length; P < z; P++) D.setXYZ(S[P], Ig.x, Ig.y, Ig.z)
                        }
                    }

                    const Rg = new Ei;

                    class o3 extends Ql {
                        constructor(e, n = 16776960) {
                            const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                                a = new Float32Array(8 * 3), u = new Ti;
                            u.setIndex(new Er(r, 1)), u.setAttribute("position", new Er(a, 3)), super(u, new oa({
                                color: n,
                                toneMapped: !1
                            })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                        }

                        update(e) {
                            if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Rg.setFromObject(this.object), Rg.isEmpty()) return;
                            const n = Rg.min, r = Rg.max, a = this.geometry.attributes.position, u = a.array;
                            u[0] = r.x, u[1] = r.y, u[2] = r.z, u[3] = n.x, u[4] = r.y, u[5] = r.z, u[6] = n.x, u[7] = n.y, u[8] = r.z, u[9] = r.x, u[10] = n.y, u[11] = r.z, u[12] = r.x, u[13] = r.y, u[14] = n.z, u[15] = n.x, u[16] = r.y, u[17] = n.z, u[18] = n.x, u[19] = n.y, u[20] = n.z, u[21] = r.x, u[22] = n.y, u[23] = n.z, a.needsUpdate = !0, this.geometry.computeBoundingSphere()
                        }

                        setFromObject(e) {
                            return this.object = e, this.update(), this
                        }

                        copy(e, n) {
                            return super.copy(e, n), this.object = e.object, this
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }

                    class a3 extends Ql {
                        constructor(e, n = 16776960) {
                            const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                                a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
                                u = new Ti;
                            u.setIndex(new Er(r, 1)), u.setAttribute("position", new Xn(a, 3)), super(u, new oa({
                                color: n,
                                toneMapped: !1
                            })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                        }

                        updateMatrixWorld(e) {
                            const n = this.box;
                            n.isEmpty() || (n.getCenter(this.position), n.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }

                    class l3 extends du {
                        constructor(e, n = 1, r = 16776960) {
                            const a = r,
                                u = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
                                y = new Ti;
                            y.setAttribute("position", new Xn(u, 3)), y.computeBoundingSphere(), super(y, new oa({
                                color: a,
                                toneMapped: !1
                            })), this.type = "PlaneHelper", this.plane = e, this.size = n;
                            const S = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], D = new Ti;
                            D.setAttribute("position", new Xn(S, 3)), D.computeBoundingSphere(), this.add(new Wr(D, new gr({
                                color: a,
                                opacity: .2,
                                transparent: !0,
                                depthWrite: !1,
                                toneMapped: !1
                            })))
                        }

                        updateMatrixWorld(e) {
                            this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
                        }
                    }

                    const Hx = new Ne;
                    let Bg, ey;

                    class c3 extends or {
                        constructor(e = new Ne(0, 0, 1), n = new Ne(0, 0, 0), r = 1, a = 16776960, u = r * .2, y = u * .2) {
                            super(), this.type = "ArrowHelper", Bg === void 0 && (Bg = new Ti, Bg.setAttribute("position", new Xn([0, 0, 0, 0, 1, 0], 3)), ey = new Nd(0, .5, 1, 5, 1), ey.translate(0, -.5, 0)), this.position.copy(n), this.line = new du(Bg, new oa({
                                color: a,
                                toneMapped: !1
                            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Wr(ey, new gr({
                                color: a,
                                toneMapped: !1
                            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, u, y)
                        }

                        setDirection(e) {
                            if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else {
                                Hx.set(e.z, 0, -e.x).normalize();
                                const n = Math.acos(e.y);
                                this.quaternion.setFromAxisAngle(Hx, n)
                            }
                        }

                        setLength(e, n = e * .2, r = n * .2) {
                            this.line.scale.set(1, Math.max(1e-4, e - n), 1), this.line.updateMatrix(), this.cone.scale.set(r, n, r), this.cone.position.y = e, this.cone.updateMatrix()
                        }

                        setColor(e) {
                            this.line.material.color.set(e), this.cone.material.color.set(e)
                        }

                        copy(e) {
                            return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
                        }

                        dispose() {
                            this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
                        }
                    }

                    class u3 extends Ql {
                        constructor(e = 1) {
                            const n = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                                r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], a = new Ti;
                            a.setAttribute("position", new Xn(n, 3)), a.setAttribute("color", new Xn(r, 3));
                            const u = new oa({vertexColors: !0, toneMapped: !1});
                            super(a, u), this.type = "AxesHelper"
                        }

                        setColors(e, n, r) {
                            const a = new Bn, u = this.geometry.attributes.color.array;
                            return a.set(e), a.toArray(u, 0), a.toArray(u, 3), a.set(n), a.toArray(u, 6), a.toArray(u, 9), a.set(r), a.toArray(u, 12), a.toArray(u, 15), this.geometry.attributes.color.needsUpdate = !0, this
                        }

                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }

                    class h3 {
                        constructor() {
                            this.type = "ShapePath", this.color = new Bn, this.subPaths = [], this.currentPath = null
                        }

                        moveTo(e, n) {
                            return this.currentPath = new Pp, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, n), this
                        }

                        lineTo(e, n) {
                            return this.currentPath.lineTo(e, n), this
                        }

                        quadraticCurveTo(e, n, r, a) {
                            return this.currentPath.quadraticCurveTo(e, n, r, a), this
                        }

                        bezierCurveTo(e, n, r, a, u, y) {
                            return this.currentPath.bezierCurveTo(e, n, r, a, u, y), this
                        }

                        splineThru(e) {
                            return this.currentPath.splineThru(e), this
                        }

                        toShapes(e) {
                            function n(J) {
                                const Ce = [];
                                for (let ye = 0, ge = J.length; ye < ge; ye++) {
                                    const $e = J[ye], ze = new yh;
                                    ze.curves = $e.curves, Ce.push(ze)
                                }
                                return Ce
                            }

                            function r(J, Ce) {
                                const ye = Ce.length;
                                let ge = !1;
                                for (let $e = ye - 1, ze = 0; ze < ye; $e = ze++) {
                                    let We = Ce[$e], qe = Ce[ze], Pe = qe.x - We.x, Te = qe.y - We.y;
                                    if (Math.abs(Te) > Number.EPSILON) {
                                        if (Te < 0 && (We = Ce[ze], Pe = -Pe, qe = Ce[$e], Te = -Te), J.y < We.y || J.y > qe.y) continue;
                                        if (J.y === We.y) {
                                            if (J.x === We.x) return !0
                                        } else {
                                            const Je = Te * (J.x - We.x) - Pe * (J.y - We.y);
                                            if (Je === 0) return !0;
                                            if (Je < 0) continue;
                                            ge = !ge
                                        }
                                    } else {
                                        if (J.y !== We.y) continue;
                                        if (qe.x <= J.x && J.x <= We.x || We.x <= J.x && J.x <= qe.x) return !0
                                    }
                                }
                                return ge
                            }

                            const a = jl.isClockWise, u = this.subPaths;
                            if (u.length === 0) return [];
                            let y, S, D;
                            const P = [];
                            if (u.length === 1) return S = u[0], D = new yh, D.curves = S.curves, P.push(D), P;
                            let z = !a(u[0].getPoints());
                            z = e ? !z : z;
                            const Q = [], K = [];
                            let q = [], te = 0, le;
                            K[te] = void 0, q[te] = [];
                            for (let J = 0, Ce = u.length; J < Ce; J++) S = u[J], le = S.getPoints(), y = a(le), y = e ? !y : y, y ? (!z && K[te] && te++, K[te] = {
                                s: new yh,
                                p: le
                            }, K[te].s.curves = S.curves, z && te++, q[te] = []) : q[te].push({h: S, p: le[0]});
                            if (!K[0]) return n(u);
                            if (K.length > 1) {
                                let J = !1, Ce = 0;
                                for (let ye = 0, ge = K.length; ye < ge; ye++) Q[ye] = [];
                                for (let ye = 0, ge = K.length; ye < ge; ye++) {
                                    const $e = q[ye];
                                    for (let ze = 0; ze < $e.length; ze++) {
                                        const We = $e[ze];
                                        let qe = !0;
                                        for (let Pe = 0; Pe < K.length; Pe++) r(We.p, K[Pe].p) && (ye !== Pe && Ce++, qe ? (qe = !1, Q[Pe].push(We)) : J = !0);
                                        qe && Q[ye].push(We)
                                    }
                                }
                                Ce > 0 && J === !1 && (q = Q)
                            }
                            let ne;
                            for (let J = 0, Ce = K.length; J < Ce; J++) {
                                D = K[J].s, P.push(D), ne = q[J];
                                for (let ye = 0, ge = ne.length; ye < ge; ye++) D.holes.push(ne[ye].h)
                            }
                            return P
                        }
                    }

                    class d3 extends os {
                        constructor(e = 1, n = 1, r = 1, a = {}) {
                            console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, n, {
                                ...a,
                                count: r
                            }), this.isWebGLMultipleRenderTargets = !0
                        }

                        get texture() {
                            return this.textures
                        }
                    }

                    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: g}})), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = g)
                },
                "./node_modules/three/examples/jsm/libs/ktx-parse.module.js": (m, x, h) => {
                    h.r(x), h.d(x, {
                        KHR_DF_CHANNEL_RGBSDA_ALPHA: () => ss,
                        KHR_DF_CHANNEL_RGBSDA_BLUE: () => Pi,
                        KHR_DF_CHANNEL_RGBSDA_DEPTH: () => cr,
                        KHR_DF_CHANNEL_RGBSDA_GREEN: () => Ji,
                        KHR_DF_CHANNEL_RGBSDA_RED: () => Rr,
                        KHR_DF_CHANNEL_RGBSDA_STENCIL: () => Br,
                        KHR_DF_FLAG_ALPHA_PREMULTIPLIED: () => V,
                        KHR_DF_FLAG_ALPHA_STRAIGHT: () => F,
                        KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT: () => C,
                        KHR_DF_MODEL_ASTC: () => O,
                        KHR_DF_MODEL_ETC1: () => I,
                        KHR_DF_MODEL_ETC1S: () => N,
                        KHR_DF_MODEL_ETC2: () => L,
                        KHR_DF_MODEL_RGBSDA: () => R,
                        KHR_DF_MODEL_UNSPECIFIED: () => B,
                        KHR_DF_PRIMARIES_ACES: () => pi,
                        KHR_DF_PRIMARIES_ACESCC: () => hi,
                        KHR_DF_PRIMARIES_ADOBERGB: () => Oi,
                        KHR_DF_PRIMARIES_BT2020: () => Nn,
                        KHR_DF_PRIMARIES_BT601_EBU: () => an,
                        KHR_DF_PRIMARIES_BT601_SMPTE: () => En,
                        KHR_DF_PRIMARIES_BT709: () => Rt,
                        KHR_DF_PRIMARIES_CIEXYZ: () => oi,
                        KHR_DF_PRIMARIES_DISPLAYP3: () => nr,
                        KHR_DF_PRIMARIES_NTSC1953: () => Vn,
                        KHR_DF_PRIMARIES_PAL525: () => yi,
                        KHR_DF_PRIMARIES_UNSPECIFIED: () => Bt,
                        KHR_DF_SAMPLE_DATATYPE_EXPONENT: () => jt,
                        KHR_DF_SAMPLE_DATATYPE_FLOAT: () => Nr,
                        KHR_DF_SAMPLE_DATATYPE_LINEAR: () => Se,
                        KHR_DF_SAMPLE_DATATYPE_SIGNED: () => ir,
                        KHR_DF_TRANSFER_ACESCC: () => He,
                        KHR_DF_TRANSFER_ACESCCT: () => ot,
                        KHR_DF_TRANSFER_ADOBERGB: () => gt,
                        KHR_DF_TRANSFER_BT1886: () => he,
                        KHR_DF_TRANSFER_DCIP3: () => me,
                        KHR_DF_TRANSFER_HLG_EOTF: () => H,
                        KHR_DF_TRANSFER_HLG_OETF: () => Z,
                        KHR_DF_TRANSFER_ITU: () => fe,
                        KHR_DF_TRANSFER_LINEAR: () => j,
                        KHR_DF_TRANSFER_NTSC: () => se,
                        KHR_DF_TRANSFER_PAL625_EOTF: () => ke,
                        KHR_DF_TRANSFER_PAL_OETF: () => Re,
                        KHR_DF_TRANSFER_PQ_EOTF: () => ae,
                        KHR_DF_TRANSFER_PQ_OETF: () => ee,
                        KHR_DF_TRANSFER_SLOG: () => pe,
                        KHR_DF_TRANSFER_SLOG2: () => ue,
                        KHR_DF_TRANSFER_SRGB: () => Y,
                        KHR_DF_TRANSFER_ST240: () => Ve,
                        KHR_DF_TRANSFER_UNSPECIFIED: () => U,
                        KHR_DF_VENDORID_KHRONOS: () => M,
                        KHR_DF_VERSION: () => b,
                        KHR_SUPERCOMPRESSION_BASISLZ: () => v,
                        KHR_SUPERCOMPRESSION_NONE: () => w,
                        KHR_SUPERCOMPRESSION_ZLIB: () => p,
                        KHR_SUPERCOMPRESSION_ZSTD: () => E,
                        KTX2Container: () => Ca,
                        VK_FORMAT_A1R5G5B5_UNORM_PACK16: () => ve,
                        VK_FORMAT_A2B10G10R10_SINT_PACK32: () => Hn,
                        VK_FORMAT_A2B10G10R10_SNORM_PACK32: () => xn,
                        VK_FORMAT_A2B10G10R10_UINT_PACK32: () => Dt,
                        VK_FORMAT_A2B10G10R10_UNORM_PACK32: () => Rn,
                        VK_FORMAT_A2R10G10B10_SINT_PACK32: () => Kt,
                        VK_FORMAT_A2R10G10B10_SNORM_PACK32: () => dt,
                        VK_FORMAT_A2R10G10B10_UINT_PACK32: () => Lt,
                        VK_FORMAT_A2R10G10B10_UNORM_PACK32: () => Ct,
                        VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: () => Ga,
                        VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: () => xa,
                        VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: () => za,
                        VK_FORMAT_ASTC_10x10_SRGB_BLOCK: () => Hr,
                        VK_FORMAT_ASTC_10x10_UNORM_BLOCK: () => uo,
                        VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: () => nd,
                        VK_FORMAT_ASTC_10x5_SRGB_BLOCK: () => Ss,
                        VK_FORMAT_ASTC_10x5_UNORM_BLOCK: () => sl,
                        VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: () => cl,
                        VK_FORMAT_ASTC_10x6_SRGB_BLOCK: () => Gu,
                        VK_FORMAT_ASTC_10x6_UNORM_BLOCK: () => Vs,
                        VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: () => Xc,
                        VK_FORMAT_ASTC_10x8_SRGB_BLOCK: () => ol,
                        VK_FORMAT_ASTC_10x8_UNORM_BLOCK: () => Na,
                        VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: () => ju,
                        VK_FORMAT_ASTC_12x10_SRGB_BLOCK: () => Sf,
                        VK_FORMAT_ASTC_12x10_UNORM_BLOCK: () => Ua,
                        VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: () => ur,
                        VK_FORMAT_ASTC_12x12_SRGB_BLOCK: () => ic,
                        VK_FORMAT_ASTC_12x12_UNORM_BLOCK: () => Tf,
                        VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: () => ai,
                        VK_FORMAT_ASTC_4x4_SRGB_BLOCK: () => Qh,
                        VK_FORMAT_ASTC_4x4_UNORM_BLOCK: () => Hh,
                        VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: () => al,
                        VK_FORMAT_ASTC_5x4_SRGB_BLOCK: () => Wh,
                        VK_FORMAT_ASTC_5x4_UNORM_BLOCK: () => jh,
                        VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: () => Qu,
                        VK_FORMAT_ASTC_5x5_SRGB_BLOCK: () => yf,
                        VK_FORMAT_ASTC_5x5_UNORM_BLOCK: () => rl,
                        VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: () => ed,
                        VK_FORMAT_ASTC_6x5_SRGB_BLOCK: () => xf,
                        VK_FORMAT_ASTC_6x5_UNORM_BLOCK: () => Ef,
                        VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: () => ll,
                        VK_FORMAT_ASTC_6x6_SRGB_BLOCK: () => Cf,
                        VK_FORMAT_ASTC_6x6_UNORM_BLOCK: () => Kh,
                        VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: () => Sl,
                        VK_FORMAT_ASTC_8x5_SRGB_BLOCK: () => bf,
                        VK_FORMAT_ASTC_8x5_UNORM_BLOCK: () => wf,
                        VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: () => Kc,
                        VK_FORMAT_ASTC_8x6_SRGB_BLOCK: () => Mf,
                        VK_FORMAT_ASTC_8x6_UNORM_BLOCK: () => _f,
                        VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: () => td,
                        VK_FORMAT_ASTC_8x8_SRGB_BLOCK: () => da,
                        VK_FORMAT_ASTC_8x8_UNORM_BLOCK: () => zu,
                        VK_FORMAT_B10G11R11_UFLOAT_PACK32: () => Mr,
                        VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: () => If,
                        VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: () => Hu,
                        VK_FORMAT_B4G4R4A4_UNORM_PACK16: () => Ue,
                        VK_FORMAT_B5G5R5A1_UNORM_PACK16: () => X,
                        VK_FORMAT_B5G6R5_UNORM_PACK16: () => oe,
                        VK_FORMAT_B8G8R8A8_SINT: () => Ke,
                        VK_FORMAT_B8G8R8A8_SNORM: () => Qo,
                        VK_FORMAT_B8G8R8A8_SRGB: () => rt,
                        VK_FORMAT_B8G8R8A8_UINT: () => De,
                        VK_FORMAT_B8G8R8A8_UNORM: () => Ea,
                        VK_FORMAT_B8G8R8_SINT: () => Eo,
                        VK_FORMAT_B8G8R8_SNORM: () => Or,
                        VK_FORMAT_B8G8R8_SRGB: () => bs,
                        VK_FORMAT_B8G8R8_UINT: () => ws,
                        VK_FORMAT_B8G8R8_UNORM: () => $s,
                        VK_FORMAT_BC1_RGBA_SRGB_BLOCK: () => mr,
                        VK_FORMAT_BC1_RGBA_UNORM_BLOCK: () => _l,
                        VK_FORMAT_BC1_RGB_SRGB_BLOCK: () => ka,
                        VK_FORMAT_BC1_RGB_UNORM_BLOCK: () => bl,
                        VK_FORMAT_BC2_SRGB_BLOCK: () => Ml,
                        VK_FORMAT_BC2_UNORM_BLOCK: () => Fa,
                        VK_FORMAT_BC3_SRGB_BLOCK: () => Bo,
                        VK_FORMAT_BC3_UNORM_BLOCK: () => Co,
                        VK_FORMAT_BC4_SNORM_BLOCK: () => tc,
                        VK_FORMAT_BC4_UNORM_BLOCK: () => Ou,
                        VK_FORMAT_BC5_SNORM_BLOCK: () => ku,
                        VK_FORMAT_BC5_UNORM_BLOCK: () => pf,
                        VK_FORMAT_BC6H_SFLOAT_BLOCK: () => nc,
                        VK_FORMAT_BC6H_UFLOAT_BLOCK: () => Fu,
                        VK_FORMAT_BC7_SRGB_BLOCK: () => Uh,
                        VK_FORMAT_BC7_UNORM_BLOCK: () => Qc,
                        VK_FORMAT_D16_UNORM: () => ha,
                        VK_FORMAT_D16_UNORM_S8_UINT: () => Ms,
                        VK_FORMAT_D24_UNORM_S8_UINT: () => rr,
                        VK_FORMAT_D32_SFLOAT: () => zs,
                        VK_FORMAT_D32_SFLOAT_S8_UINT: () => Gs,
                        VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: () => _s,
                        VK_FORMAT_EAC_R11G11_SNORM_BLOCK: () => jc,
                        VK_FORMAT_EAC_R11G11_UNORM_BLOCK: () => Vh,
                        VK_FORMAT_EAC_R11_SNORM_BLOCK: () => Gh,
                        VK_FORMAT_EAC_R11_UNORM_BLOCK: () => zh,
                        VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: () => Nu,
                        VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: () => gf,
                        VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: () => Uu,
                        VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: () => vf,
                        VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: () => Af,
                        VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: () => mf,
                        VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: () => sc,
                        VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: () => Vu,
                        VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: () => eo,
                        VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: () => Jh,
                        VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: () => Ri,
                        VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: () => Zh,
                        VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: () => Lf,
                        VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: () => $h,
                        VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: () => zt,
                        VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: () => Bf,
                        VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: () => rc,
                        VK_FORMAT_R10X6G10X6_UNORM_2PACK16: () => Yh,
                        VK_FORMAT_R10X6_UNORM_PACK16: () => Xh,
                        VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: () => qh,
                        VK_FORMAT_R12X4G12X4_UNORM_2PACK16: () => Rf,
                        VK_FORMAT_R12X4_UNORM_PACK16: () => Wc,
                        VK_FORMAT_R16G16B16A16_SFLOAT: () => wt,
                        VK_FORMAT_R16G16B16A16_SINT: () => at,
                        VK_FORMAT_R16G16B16A16_SNORM: () => Oe,
                        VK_FORMAT_R16G16B16A16_UINT: () => Ze,
                        VK_FORMAT_R16G16B16A16_UNORM: () => xe,
                        VK_FORMAT_R16G16B16_SFLOAT: () => Ae,
                        VK_FORMAT_R16G16B16_SINT: () => re,
                        VK_FORMAT_R16G16B16_SNORM: () => ri,
                        VK_FORMAT_R16G16B16_UINT: () => $,
                        VK_FORMAT_R16G16B16_UNORM: () => _r,
                        VK_FORMAT_R16G16_SFLOAT: () => Ai,
                        VK_FORMAT_R16G16_SINT: () => Cn,
                        VK_FORMAT_R16G16_SNORM: () => yr,
                        VK_FORMAT_R16G16_UINT: () => Ur,
                        VK_FORMAT_R16G16_UNORM: () => ki,
                        VK_FORMAT_R16_SFLOAT: () => mi,
                        VK_FORMAT_R16_SINT: () => li,
                        VK_FORMAT_R16_SNORM: () => Wn,
                        VK_FORMAT_R16_UINT: () => Wi,
                        VK_FORMAT_R16_UNORM: () => jn,
                        VK_FORMAT_R32G32B32A32_SFLOAT: () => Ft,
                        VK_FORMAT_R32G32B32A32_SINT: () => Vt,
                        VK_FORMAT_R32G32B32A32_UINT: () => ut,
                        VK_FORMAT_R32G32B32_SFLOAT: () => st,
                        VK_FORMAT_R32G32B32_SINT: () => Me,
                        VK_FORMAT_R32G32B32_UINT: () => Ee,
                        VK_FORMAT_R32G32_SFLOAT: () => we,
                        VK_FORMAT_R32G32_SINT: () => de,
                        VK_FORMAT_R32G32_UINT: () => ce,
                        VK_FORMAT_R32_SFLOAT: () => _t,
                        VK_FORMAT_R32_SINT: () => et,
                        VK_FORMAT_R32_UINT: () => kt,
                        VK_FORMAT_R4G4B4A4_UNORM_PACK16: () => Le,
                        VK_FORMAT_R4G4_UNORM_PACK8: () => Ge,
                        VK_FORMAT_R5G5B5A1_UNORM_PACK16: () => G,
                        VK_FORMAT_R5G6B5_UNORM_PACK16: () => Qe,
                        VK_FORMAT_R64G64B64A64_SFLOAT: () => Yr,
                        VK_FORMAT_R64G64B64A64_SINT: () => gi,
                        VK_FORMAT_R64G64B64A64_UINT: () => _i,
                        VK_FORMAT_R64G64B64_SFLOAT: () => Ii,
                        VK_FORMAT_R64G64B64_SINT: () => bi,
                        VK_FORMAT_R64G64B64_UINT: () => yn,
                        VK_FORMAT_R64G64_SFLOAT: () => _n,
                        VK_FORMAT_R64G64_SINT: () => un,
                        VK_FORMAT_R64G64_UINT: () => gn,
                        VK_FORMAT_R64_SFLOAT: () => Pt,
                        VK_FORMAT_R64_SINT: () => sn,
                        VK_FORMAT_R64_UINT: () => Jt,
                        VK_FORMAT_R8G8B8A8_SINT: () => ua,
                        VK_FORMAT_R8G8B8A8_SNORM: () => Hi,
                        VK_FORMAT_R8G8B8A8_SRGB: () => xo,
                        VK_FORMAT_R8G8B8A8_UINT: () => Qr,
                        VK_FORMAT_R8G8B8A8_UNORM: () => kr,
                        VK_FORMAT_R8G8B8_SINT: () => co,
                        VK_FORMAT_R8G8B8_SNORM: () => Vi,
                        VK_FORMAT_R8G8B8_SRGB: () => pr,
                        VK_FORMAT_R8G8B8_UINT: () => Zi,
                        VK_FORMAT_R8G8B8_UNORM: () => fr,
                        VK_FORMAT_R8G8_SINT: () => Gi,
                        VK_FORMAT_R8G8_SNORM: () => en,
                        VK_FORMAT_R8G8_SRGB: () => qn,
                        VK_FORMAT_R8G8_UINT: () => Sn,
                        VK_FORMAT_R8G8_UNORM: () => $t,
                        VK_FORMAT_R8_SINT: () => Yt,
                        VK_FORMAT_R8_SNORM: () => je,
                        VK_FORMAT_R8_SRGB: () => cn,
                        VK_FORMAT_R8_UINT: () => tt,
                        VK_FORMAT_R8_UNORM: () => Be,
                        VK_FORMAT_S8_UINT: () => Wo,
                        VK_FORMAT_UNDEFINED: () => _e,
                        VK_FORMAT_X8_D24_UNORM_PACK32: () => jo,
                        read: () => ar,
                        write: () => Tl
                    });
                    var g = h("./node_modules/buffer/index.js").Buffer;
                    const w = 0, v = 1, E = 2, p = 3, C = 0, M = 0, b = 2, B = 0, R = 1, I = 160, L = 161, O = 162,
                        N = 163, F = 0, V = 1, U = 0, j = 1, Y = 2, fe = 3, se = 4, pe = 5, ue = 6, he = 7, Z = 8,
                        H = 9, ae = 10, ee = 11, me = 12, Re = 13, ke = 14, Ve = 15, He = 16, ot = 17, gt = 18, Bt = 0,
                        Rt = 1, an = 2, En = 3, Nn = 4, oi = 5, pi = 6, hi = 7, Vn = 8, yi = 9, nr = 10, Oi = 11,
                        Rr = 0, Ji = 1, Pi = 2, Br = 13, cr = 14, ss = 15, Nr = 128, ir = 64, jt = 32, Se = 16, _e = 0,
                        Ge = 1, Le = 2, Ue = 3, Qe = 4, oe = 5, G = 6, X = 7, ve = 8, Be = 9, je = 10, tt = 13, Yt = 14,
                        cn = 15, $t = 16, en = 17, Sn = 20, Gi = 21, qn = 22, fr = 23, Vi = 24, Zi = 27, co = 28,
                        pr = 29, $s = 30, Or = 31, ws = 34, Eo = 35, bs = 36, kr = 37, Hi = 38, Qr = 41, ua = 42,
                        xo = 43, Ea = 44, Qo = 45, De = 48, Ke = 49, rt = 50, Ct = 58, dt = 59, Lt = 62, Kt = 63,
                        Rn = 64, xn = 65, Dt = 68, Hn = 69, jn = 70, Wn = 71, Wi = 74, li = 75, mi = 76, ki = 77,
                        yr = 78, Ur = 81, Cn = 82, Ai = 83, _r = 84, ri = 85, $ = 88, re = 89, Ae = 90, xe = 91,
                        Oe = 92, Ze = 95, at = 96, wt = 97, kt = 98, et = 99, _t = 100, ce = 101, de = 102, we = 103,
                        Ee = 104, Me = 105, st = 106, ut = 107, Vt = 108, Ft = 109, Jt = 110, sn = 111, Pt = 112,
                        gn = 113, un = 114, _n = 115, yn = 116, bi = 117, Ii = 118, _i = 119, gi = 120, Yr = 121,
                        Mr = 122, _s = 123, ha = 124, jo = 125, zs = 126, Wo = 127, Ms = 128, rr = 129, Gs = 130,
                        bl = 131, ka = 132, _l = 133, mr = 134, Fa = 135, Ml = 136, Co = 137, Bo = 138, Ou = 139,
                        tc = 140, pf = 141, ku = 142, Fu = 143, nc = 144, Qc = 145, Uh = 146, mf = 147, Af = 148,
                        gf = 149, Nu = 150, vf = 151, Uu = 152, zh = 153, Gh = 154, Vh = 155, jc = 156, Hh = 157,
                        Qh = 158, jh = 159, Wh = 160, rl = 161, yf = 162, Ef = 163, xf = 164, Kh = 165, Cf = 166,
                        wf = 167, bf = 168, _f = 169, Mf = 170, zu = 171, da = 172, sl = 173, Ss = 174, Vs = 175,
                        Gu = 176, Na = 177, ol = 178, uo = 179, Hr = 180, Ua = 181, Sf = 182, Tf = 183, ic = 184,
                        Xh = 1000156007, Yh = 1000156008, rc = 1000156009, sc = 1000156010, If = 1000156011,
                        Wc = 1000156017, Rf = 1000156018, qh = 1000156019, Vu = 1000156020, Hu = 1000156021,
                        Jh = 1000054e3, Zh = 1000054001, $h = 1000054002, Bf = 1000054003, eo = 1000054004,
                        Ri = 1000054005, Lf = 1000054006, zt = 1000054007, ai = 1000066e3, al = 1000066001,
                        Qu = 1000066002, ed = 1000066003, ll = 1000066004, Sl = 1000066005, Kc = 1000066006,
                        td = 1000066007, nd = 1000066008, cl = 1000066009, Xc = 1000066010, za = 1000066011,
                        ju = 1000066012, ur = 1000066013, xa = 100034e4, Ga = 1000340001;

                    class Ca {
                        constructor() {
                            this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                                vendorId: 0,
                                descriptorType: 0,
                                descriptorBlockSize: 0,
                                versionNumber: 2,
                                colorModel: 0,
                                colorPrimaries: 1,
                                transferFunction: 2,
                                flags: 0,
                                texelBlockDimension: [0, 0, 0, 0],
                                bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                                samples: []
                            }], this.keyValue = {}, this.globalData = null
                        }
                    }

                    class ul {
                        constructor(Mi, sr, $i, Ne) {
                            this._dataView = new DataView(Mi.buffer, Mi.byteOffset + sr, $i), this._littleEndian = Ne, this._offset = 0
                        }

                        _nextUint8() {
                            const Mi = this._dataView.getUint8(this._offset);
                            return this._offset += 1, Mi
                        }

                        _nextUint16() {
                            const Mi = this._dataView.getUint16(this._offset, this._littleEndian);
                            return this._offset += 2, Mi
                        }

                        _nextUint32() {
                            const Mi = this._dataView.getUint32(this._offset, this._littleEndian);
                            return this._offset += 4, Mi
                        }

                        _nextUint64() {
                            const Mi = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
                            return this._offset += 8, Mi
                        }

                        _nextInt32() {
                            const Mi = this._dataView.getInt32(this._offset, this._littleEndian);
                            return this._offset += 4, Mi
                        }

                        _skip(Mi) {
                            return this._offset += Mi, this
                        }

                        _scan(Mi, sr = 0) {
                            const $i = this._offset;
                            let Ne = 0;
                            for (; this._dataView.getUint8(this._offset) !== sr && Ne < Mi;) Ne++, this._offset++;
                            return Ne < Mi && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + $i, Ne)
                        }
                    }

                    const oc = new Uint8Array([0]), zr = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

                    function ac(Pn) {
                        return typeof TextEncoder < "u" ? new TextEncoder().encode(Pn) : g.from(Pn)
                    }

                    function Wu(Pn) {
                        return typeof TextDecoder < "u" ? new TextDecoder().decode(Pn) : g.from(Pn).toString("utf8")
                    }

                    function Lr(Pn) {
                        let Mi = 0;
                        for (const Ne of Pn) Mi += Ne.byteLength;
                        const sr = new Uint8Array(Mi);
                        let $i = 0;
                        for (const Ne of Pn) sr.set(new Uint8Array(Ne), $i), $i += Ne.byteLength;
                        return sr
                    }

                    function ar(Pn) {
                        const Mi = new Uint8Array(Pn.buffer, Pn.byteOffset, zr.length);
                        if (Mi[0] !== zr[0] || Mi[1] !== zr[1] || Mi[2] !== zr[2] || Mi[3] !== zr[3] || Mi[4] !== zr[4] || Mi[5] !== zr[5] || Mi[6] !== zr[6] || Mi[7] !== zr[7] || Mi[8] !== zr[8] || Mi[9] !== zr[9] || Mi[10] !== zr[10] || Mi[11] !== zr[11]) throw new Error("Missing KTX 2.0 identifier.");
                        const sr = new Ca, $i = 17 * Uint32Array.BYTES_PER_ELEMENT, Ne = new ul(Pn, zr.length, $i, !0);
                        sr.vkFormat = Ne._nextUint32(), sr.typeSize = Ne._nextUint32(), sr.pixelWidth = Ne._nextUint32(), sr.pixelHeight = Ne._nextUint32(), sr.pixelDepth = Ne._nextUint32(), sr.layerCount = Ne._nextUint32(), sr.faceCount = Ne._nextUint32();
                        const Lo = Ne._nextUint32();
                        sr.supercompressionScheme = Ne._nextUint32();
                        const qr = Ne._nextUint32(), Ei = Ne._nextUint32(), Ni = Ne._nextUint32(),
                            Ts = Ne._nextUint32(), Do = Ne._nextUint64(), wo = Ne._nextUint64(),
                            ms = new ul(Pn, zr.length + $i, 3 * Lo * 8, !0);
                        for (let jr = 0; jr < Lo; jr++) sr.levels.push({
                            levelData: new Uint8Array(Pn.buffer, Pn.byteOffset + ms._nextUint64(), ms._nextUint64()),
                            uncompressedByteLength: ms._nextUint64()
                        });
                        const Si = new ul(Pn, qr, Ei, !0), As = {
                            vendorId: Si._skip(4)._nextUint16(),
                            descriptorType: Si._nextUint16(),
                            versionNumber: Si._nextUint16(),
                            descriptorBlockSize: Si._nextUint16(),
                            colorModel: Si._nextUint8(),
                            colorPrimaries: Si._nextUint8(),
                            transferFunction: Si._nextUint8(),
                            flags: Si._nextUint8(),
                            texelBlockDimension: [Si._nextUint8(), Si._nextUint8(), Si._nextUint8(), Si._nextUint8()],
                            bytesPlane: [Si._nextUint8(), Si._nextUint8(), Si._nextUint8(), Si._nextUint8(), Si._nextUint8(), Si._nextUint8(), Si._nextUint8(), Si._nextUint8()],
                            samples: []
                        }, Hs = (As.descriptorBlockSize / 4 - 6) / 4;
                        for (let jr = 0; jr < Hs; jr++) {
                            const Mn = {
                                bitOffset: Si._nextUint16(),
                                bitLength: Si._nextUint8(),
                                channelType: Si._nextUint8(),
                                samplePosition: [Si._nextUint8(), Si._nextUint8(), Si._nextUint8(), Si._nextUint8()],
                                sampleLower: -1 / 0,
                                sampleUpper: 1 / 0
                            };
                            64 & Mn.channelType ? (Mn.sampleLower = Si._nextInt32(), Mn.sampleUpper = Si._nextInt32()) : (Mn.sampleLower = Si._nextUint32(), Mn.sampleUpper = Si._nextUint32()), As.samples[jr] = Mn
                        }
                        sr.dataFormatDescriptor.length = 0, sr.dataFormatDescriptor.push(As);
                        const Is = new ul(Pn, Ni, Ts, !0);
                        for (; Is._offset < Ts;) {
                            const jr = Is._nextUint32(), Mn = Is._scan(jr), Xo = Wu(Mn),
                                ts = Is._scan(jr - Mn.byteLength);
                            sr.keyValue[Xo] = Xo.match(/^ktx/i) ? Wu(ts) : ts, Is._offset % 4 && Is._skip(4 - Is._offset % 4)
                        }
                        if (wo <= 0) return sr;
                        const lr = new ul(Pn, Do, wo, !0), Sr = lr._nextUint16(), Li = lr._nextUint16(),
                            Ki = lr._nextUint32(), Qs = lr._nextUint32(), Va = lr._nextUint32(), wa = lr._nextUint32(),
                            Il = [];
                        for (let jr = 0; jr < Lo; jr++) Il.push({
                            imageFlags: lr._nextUint32(),
                            rgbSliceByteOffset: lr._nextUint32(),
                            rgbSliceByteLength: lr._nextUint32(),
                            alphaSliceByteOffset: lr._nextUint32(),
                            alphaSliceByteLength: lr._nextUint32()
                        });
                        const as = Do + lr._offset, fa = as + Ki, cc = fa + Qs, Yc = cc + Va,
                            Ha = new Uint8Array(Pn.buffer, Pn.byteOffset + as, Ki),
                            uc = new Uint8Array(Pn.buffer, Pn.byteOffset + fa, Qs),
                            Ko = new Uint8Array(Pn.buffer, Pn.byteOffset + cc, Va),
                            qc = new Uint8Array(Pn.buffer, Pn.byteOffset + Yc, wa);
                        return sr.globalData = {
                            endpointCount: Sr,
                            selectorCount: Li,
                            imageDescs: Il,
                            endpointsData: Ha,
                            selectorsData: uc,
                            tablesData: Ko,
                            extendedData: qc
                        }, sr
                    }

                    function lc() {
                        return (lc = Object.assign || function (Pn) {
                            for (var Mi = 1; Mi < arguments.length; Mi++) {
                                var sr = arguments[Mi];
                                for (var $i in sr) Object.prototype.hasOwnProperty.call(sr, $i) && (Pn[$i] = sr[$i])
                            }
                            return Pn
                        }).apply(this, arguments)
                    }

                    const os = {keepWriter: !1};

                    function Tl(Pn, Mi = {}) {
                        Mi = lc({}, os, Mi);
                        let sr = new ArrayBuffer(0);
                        if (Pn.globalData) {
                            const Sr = new ArrayBuffer(20 + 5 * Pn.globalData.imageDescs.length * 4),
                                Li = new DataView(Sr);
                            Li.setUint16(0, Pn.globalData.endpointCount, !0), Li.setUint16(2, Pn.globalData.selectorCount, !0), Li.setUint32(4, Pn.globalData.endpointsData.byteLength, !0), Li.setUint32(8, Pn.globalData.selectorsData.byteLength, !0), Li.setUint32(12, Pn.globalData.tablesData.byteLength, !0), Li.setUint32(16, Pn.globalData.extendedData.byteLength, !0);
                            for (let Ki = 0; Ki < Pn.globalData.imageDescs.length; Ki++) {
                                const Qs = Pn.globalData.imageDescs[Ki];
                                Li.setUint32(20 + 5 * Ki * 4 + 0, Qs.imageFlags, !0), Li.setUint32(20 + 5 * Ki * 4 + 4, Qs.rgbSliceByteOffset, !0), Li.setUint32(20 + 5 * Ki * 4 + 8, Qs.rgbSliceByteLength, !0), Li.setUint32(20 + 5 * Ki * 4 + 12, Qs.alphaSliceByteOffset, !0), Li.setUint32(20 + 5 * Ki * 4 + 16, Qs.alphaSliceByteLength, !0)
                            }
                            sr = Lr([Sr, Pn.globalData.endpointsData, Pn.globalData.selectorsData, Pn.globalData.tablesData, Pn.globalData.extendedData])
                        }
                        const $i = [];
                        let Ne = Pn.keyValue;
                        Mi.keepWriter || (Ne = lc({}, Pn.keyValue, {KTXwriter: "KTX-Parse v0.3.1"}));
                        for (const Sr in Ne) {
                            const Li = Ne[Sr], Ki = ac(Sr), Qs = typeof Li == "string" ? ac(Li) : Li,
                                Va = Ki.byteLength + 1 + Qs.byteLength + 1, wa = Va % 4 ? 4 - Va % 4 : 0;
                            $i.push(Lr([new Uint32Array([Va]), Ki, oc, Qs, oc, new Uint8Array(wa).fill(0)]))
                        }
                        const Lo = Lr($i);
                        if (Pn.dataFormatDescriptor.length !== 1 || Pn.dataFormatDescriptor[0].descriptorType !== 0) throw new Error("Only BASICFORMAT Data Format Descriptor output supported.");
                        const qr = Pn.dataFormatDescriptor[0], Ei = new ArrayBuffer(28 + 16 * qr.samples.length),
                            Ni = new DataView(Ei), Ts = 24 + 16 * qr.samples.length;
                        if (Ni.setUint32(0, Ei.byteLength, !0), Ni.setUint16(4, qr.vendorId, !0), Ni.setUint16(6, qr.descriptorType, !0), Ni.setUint16(8, qr.versionNumber, !0), Ni.setUint16(10, Ts, !0), Ni.setUint8(12, qr.colorModel), Ni.setUint8(13, qr.colorPrimaries), Ni.setUint8(14, qr.transferFunction), Ni.setUint8(15, qr.flags), !Array.isArray(qr.texelBlockDimension)) throw new Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
                        Ni.setUint8(16, qr.texelBlockDimension[0]), Ni.setUint8(17, qr.texelBlockDimension[1]), Ni.setUint8(18, qr.texelBlockDimension[2]), Ni.setUint8(19, qr.texelBlockDimension[3]);
                        for (let Sr = 0; Sr < 8; Sr++) Ni.setUint8(20 + Sr, qr.bytesPlane[Sr]);
                        for (let Sr = 0; Sr < qr.samples.length; Sr++) {
                            const Li = qr.samples[Sr], Ki = 28 + 16 * Sr;
                            if (Li.channelID) throw new Error("channelID has been renamed to channelType.");
                            Ni.setUint16(Ki + 0, Li.bitOffset, !0), Ni.setUint8(Ki + 2, Li.bitLength), Ni.setUint8(Ki + 3, Li.channelType), Ni.setUint8(Ki + 4, Li.samplePosition[0]), Ni.setUint8(Ki + 5, Li.samplePosition[1]), Ni.setUint8(Ki + 6, Li.samplePosition[2]), Ni.setUint8(Ki + 7, Li.samplePosition[3]), 64 & Li.channelType ? (Ni.setInt32(Ki + 8, Li.sampleLower, !0), Ni.setInt32(Ki + 12, Li.sampleUpper, !0)) : (Ni.setUint32(Ki + 8, Li.sampleLower, !0), Ni.setUint32(Ki + 12, Li.sampleUpper, !0))
                        }
                        const Do = zr.length + 68 + 3 * Pn.levels.length * 8, wo = Do + Ei.byteLength;
                        let ms = sr.byteLength > 0 ? wo + Lo.byteLength : 0;
                        ms % 8 && (ms += 8 - ms % 8);
                        const Si = [], As = new DataView(new ArrayBuffer(3 * Pn.levels.length * 8));
                        let Hs = (ms || wo + Lo.byteLength) + sr.byteLength;
                        for (let Sr = 0; Sr < Pn.levels.length; Sr++) {
                            const Li = Pn.levels[Sr];
                            Si.push(Li.levelData), As.setBigUint64(24 * Sr + 0, BigInt(Hs), !0), As.setBigUint64(24 * Sr + 8, BigInt(Li.levelData.byteLength), !0), As.setBigUint64(24 * Sr + 16, BigInt(Li.uncompressedByteLength), !0), Hs += Li.levelData.byteLength
                        }
                        const Is = new ArrayBuffer(68), lr = new DataView(Is);
                        return lr.setUint32(0, Pn.vkFormat, !0), lr.setUint32(4, Pn.typeSize, !0), lr.setUint32(8, Pn.pixelWidth, !0), lr.setUint32(12, Pn.pixelHeight, !0), lr.setUint32(16, Pn.pixelDepth, !0), lr.setUint32(20, Pn.layerCount, !0), lr.setUint32(24, Pn.faceCount, !0), lr.setUint32(28, Pn.levels.length, !0), lr.setUint32(32, Pn.supercompressionScheme, !0), lr.setUint32(36, Do, !0), lr.setUint32(40, Ei.byteLength, !0), lr.setUint32(44, wo, !0), lr.setUint32(48, Lo.byteLength, !0), lr.setBigUint64(52, BigInt(sr.byteLength > 0 ? ms : 0), !0), lr.setBigUint64(60, BigInt(sr.byteLength), !0), new Uint8Array(Lr([new Uint8Array(zr).buffer, Is, As.buffer, Ei, Lo, ms > 0 ? new ArrayBuffer(ms - (wo + Lo.byteLength)) : new ArrayBuffer(0), sr, ...Si]))
                    }
                },
                "./node_modules/three/examples/jsm/libs/zstddec.module.js": (m, x, h) => {
                    h.r(x), h.d(x, {ZSTDDecoder: () => C});
                    var g = h("./node_modules/buffer/index.js").Buffer;
                    let w, v, E;
                    const p = {
                        env: {
                            emscripten_notify_memory_growth: function (b) {
                                E = new Uint8Array(v.exports.memory.buffer)
                            }
                        }
                    };

                    class C {
                        init() {
                            return w || (w = typeof fetch < "u" ? fetch("data:application/wasm;base64," + M).then(B => B.arrayBuffer()).then(B => WebAssembly.instantiate(B, p)).then(this._init) : WebAssembly.instantiate(g.from(M, "base64"), p).then(this._init), w)
                        }

                        _init(B) {
                            v = B.instance, p.env.emscripten_notify_memory_growth(0)
                        }

                        decode(B, R = 0) {
                            if (!v) throw new Error("ZSTDDecoder: Await .init() before decoding.");
                            const I = B.byteLength, L = v.exports.malloc(I);
                            E.set(B, L), R = R || Number(v.exports.ZSTD_findDecompressedSize(L, I));
                            const O = v.exports.malloc(R), N = v.exports.ZSTD_decompress(O, R, L, I),
                                F = E.slice(O, O + N);
                            return v.exports.free(L), v.exports.free(O), F
                        }
                    }

                    const M = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ"
                },
                "./node_modules/three/examples/jsm/lights/LightProbeGenerator.js": (m, x, h) => {
                    h.r(x), h.d(x, {LightProbeGenerator: () => w});
                    var g = h("./node_modules/three/build/three.module.js");

                    class w {
                        static fromCubeTexture(p) {
                            let C = 0;
                            const M = new g.Vector3, b = new g.Vector3, B = new g.Color,
                                R = [0, 0, 0, 0, 0, 0, 0, 0, 0], I = new g.SphericalHarmonics3, L = I.coefficients;
                            for (let N = 0; N < 6; N++) {
                                const F = p.image[N], V = F.width, U = F.height, j = document.createElement("canvas");
                                j.width = V, j.height = U;
                                const Y = j.getContext("2d");
                                Y.drawImage(F, 0, 0, V, U);
                                const fe = Y.getImageData(0, 0, V, U), se = fe.data, pe = fe.width, ue = 2 / pe;
                                for (let he = 0, Z = se.length; he < Z; he += 4) {
                                    B.setRGB(se[he] / 255, se[he + 1] / 255, se[he + 2] / 255), v(B, p.colorSpace);
                                    const H = he / 4, ae = -1 + (H % pe + .5) * ue,
                                        ee = 1 - (Math.floor(H / pe) + .5) * ue;
                                    switch (N) {
                                        case 0:
                                            M.set(-1, ee, -ae);
                                            break;
                                        case 1:
                                            M.set(1, ee, ae);
                                            break;
                                        case 2:
                                            M.set(-ae, 1, -ee);
                                            break;
                                        case 3:
                                            M.set(-ae, -1, ee);
                                            break;
                                        case 4:
                                            M.set(-ae, ee, 1);
                                            break;
                                        case 5:
                                            M.set(ae, ee, -1);
                                            break
                                    }
                                    const me = M.lengthSq(), Re = 4 / (Math.sqrt(me) * me);
                                    C += Re, b.copy(M).normalize(), g.SphericalHarmonics3.getBasisAt(b, R);
                                    for (let ke = 0; ke < 9; ke++) L[ke].x += R[ke] * B.r * Re, L[ke].y += R[ke] * B.g * Re, L[ke].z += R[ke] * B.b * Re
                                }
                            }
                            const O = 4 * Math.PI / C;
                            for (let N = 0; N < 9; N++) L[N].x *= O, L[N].y *= O, L[N].z *= O;
                            return new g.LightProbe(I)
                        }

                        static fromCubeRenderTarget(p, C) {
                            let M = 0;
                            const b = new g.Vector3, B = new g.Vector3, R = new g.Color,
                                I = [0, 0, 0, 0, 0, 0, 0, 0, 0], L = new g.SphericalHarmonics3, O = L.coefficients,
                                N = C.texture.type;
                            for (let V = 0; V < 6; V++) {
                                const U = C.width;
                                let j;
                                N === g.HalfFloatType ? j = new Uint16Array(U * U * 4) : j = new Uint8Array(U * U * 4), p.readRenderTargetPixels(C, 0, 0, U, U, j, V);
                                const Y = 2 / U;
                                for (let fe = 0, se = j.length; fe < se; fe += 4) {
                                    let pe, ue, he;
                                    N === g.HalfFloatType ? (pe = g.DataUtils.fromHalfFloat(j[fe]), ue = g.DataUtils.fromHalfFloat(j[fe + 1]), he = g.DataUtils.fromHalfFloat(j[fe + 2])) : (pe = j[fe] / 255, ue = j[fe + 1] / 255, he = j[fe + 2] / 255), R.setRGB(pe, ue, he), v(R, C.texture.colorSpace);
                                    const Z = fe / 4, H = -1 + (Z % U + .5) * Y, ae = 1 - (Math.floor(Z / U) + .5) * Y;
                                    switch (V) {
                                        case 0:
                                            b.set(1, ae, -H);
                                            break;
                                        case 1:
                                            b.set(-1, ae, H);
                                            break;
                                        case 2:
                                            b.set(H, 1, -ae);
                                            break;
                                        case 3:
                                            b.set(H, -1, ae);
                                            break;
                                        case 4:
                                            b.set(H, ae, 1);
                                            break;
                                        case 5:
                                            b.set(-H, ae, -1);
                                            break
                                    }
                                    const ee = b.lengthSq(), me = 4 / (Math.sqrt(ee) * ee);
                                    M += me, B.copy(b).normalize(), g.SphericalHarmonics3.getBasisAt(B, I);
                                    for (let Re = 0; Re < 9; Re++) O[Re].x += I[Re] * R.r * me, O[Re].y += I[Re] * R.g * me, O[Re].z += I[Re] * R.b * me
                                }
                            }
                            const F = 4 * Math.PI / M;
                            for (let V = 0; V < 9; V++) O[V].x *= F, O[V].y *= F, O[V].z *= F;
                            return new g.LightProbe(L)
                        }
                    }

                    function v(E, p) {
                        switch (p) {
                            case g.SRGBColorSpace:
                                E.convertSRGBToLinear();
                                break;
                            case g.LinearSRGBColorSpace:
                            case g.NoColorSpace:
                                break;
                            default:
                                console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.");
                                break
                        }
                        return E
                    }
                },
                "./node_modules/three/examples/jsm/loaders/DRACOLoader.js": (m, x, h) => {
                    h.r(x), h.d(x, {DRACOLoader: () => v});
                    var g = h("./node_modules/three/build/three.module.js");
                    const w = new WeakMap;

                    class v extends g.Loader {
                        constructor(C) {
                            super(C), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                                position: "POSITION",
                                normal: "NORMAL",
                                color: "COLOR",
                                uv: "TEX_COORD"
                            }, this.defaultAttributeTypes = {
                                position: "Float32Array",
                                normal: "Float32Array",
                                color: "Float32Array",
                                uv: "Float32Array"
                            }
                        }

                        setDecoderPath(C) {
                            return this.decoderPath = C, this
                        }

                        setDecoderConfig(C) {
                            return this.decoderConfig = C, this
                        }

                        setWorkerLimit(C) {
                            return this.workerLimit = C, this
                        }

                        load(C, M, b, B) {
                            const R = new g.FileLoader(this.manager);
                            R.setPath(this.path), R.setResponseType("arraybuffer"), R.setRequestHeader(this.requestHeader), R.setWithCredentials(this.withCredentials), R.load(C, I => {
                                this.parse(I, M, B)
                            }, b, B)
                        }

                        parse(C, M, b = () => {
                        }) {
                            this.decodeDracoFile(C, M, null, null, g.SRGBColorSpace).catch(b)
                        }

                        decodeDracoFile(C, M, b, B, R = g.LinearSRGBColorSpace, I = () => {
                        }) {
                            const L = {
                                attributeIDs: b || this.defaultAttributeIDs,
                                attributeTypes: B || this.defaultAttributeTypes,
                                useUniqueIDs: !!b,
                                vertexColorSpace: R
                            };
                            return this.decodeGeometry(C, L).then(M).catch(I)
                        }

                        decodeGeometry(C, M) {
                            const b = JSON.stringify(M);
                            if (w.has(C)) {
                                const O = w.get(C);
                                if (O.key === b) return O.promise;
                                if (C.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                            }
                            let B;
                            const R = this.workerNextTaskID++, I = C.byteLength,
                                L = this._getWorker(R, I).then(O => (B = O, new Promise((N, F) => {
                                    B._callbacks[R] = {resolve: N, reject: F}, B.postMessage({
                                        type: "decode",
                                        id: R,
                                        taskConfig: M,
                                        buffer: C
                                    }, [C])
                                }))).then(O => this._createGeometry(O.geometry));
                            return L.catch(() => !0).then(() => {
                                B && R && this._releaseTask(B, R)
                            }), w.set(C, {key: b, promise: L}), L
                        }

                        _createGeometry(C) {
                            const M = new g.BufferGeometry;
                            C.index && M.setIndex(new g.BufferAttribute(C.index.array, 1));
                            for (let b = 0; b < C.attributes.length; b++) {
                                const B = C.attributes[b], R = B.name, I = B.array, L = B.itemSize,
                                    O = new g.BufferAttribute(I, L);
                                R === "color" && (this._assignVertexColorSpace(O, B.vertexColorSpace), O.normalized = !(I instanceof Float32Array)), M.setAttribute(R, O)
                            }
                            return M
                        }

                        _assignVertexColorSpace(C, M) {
                            if (M !== g.SRGBColorSpace) return;
                            const b = new g.Color;
                            for (let B = 0, R = C.count; B < R; B++) b.fromBufferAttribute(C, B).convertSRGBToLinear(), C.setXYZ(B, b.r, b.g, b.b)
                        }

                        _loadLibrary(C, M) {
                            const b = new g.FileLoader(this.manager);
                            return b.setPath(this.decoderPath), b.setResponseType(M), b.setWithCredentials(this.withCredentials), new Promise((B, R) => {
                                b.load(C, B, void 0, R)
                            })
                        }

                        preload() {
                            return this._initDecoder(), this
                        }

                        _initDecoder() {
                            if (this.decoderPending) return this.decoderPending;
                            const C = typeof WebAssembly != "object" || this.decoderConfig.type === "js", M = [];
                            return C ? M.push(this._loadLibrary("draco_decoder.js", "text")) : (M.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), M.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(M).then(b => {
                                const B = b[0];
                                C || (this.decoderConfig.wasmBinary = b[1]);
                                const R = E.toString(),
                                    I = ["/* draco decoder */", B, "", "/* worker */", R.substring(R.indexOf("{") + 1, R.lastIndexOf("}"))].join(`
`);
                                this.workerSourceURL = URL.createObjectURL(new Blob([I]))
                            }), this.decoderPending
                        }

                        _getWorker(C, M) {
                            return this._initDecoder().then(() => {
                                if (this.workerPool.length < this.workerLimit) {
                                    const B = new Worker(this.workerSourceURL);
                                    B._callbacks = {}, B._taskCosts = {}, B._taskLoad = 0, B.postMessage({
                                        type: "init",
                                        decoderConfig: this.decoderConfig
                                    }), B.onmessage = function (R) {
                                        const I = R.data;
                                        switch (I.type) {
                                            case"decode":
                                                B._callbacks[I.id].resolve(I);
                                                break;
                                            case"error":
                                                B._callbacks[I.id].reject(I);
                                                break;
                                            default:
                                                console.error('THREE.DRACOLoader: Unexpected message, "' + I.type + '"')
                                        }
                                    }, this.workerPool.push(B)
                                } else this.workerPool.sort(function (B, R) {
                                    return B._taskLoad > R._taskLoad ? -1 : 1
                                });
                                const b = this.workerPool[this.workerPool.length - 1];
                                return b._taskCosts[C] = M, b._taskLoad += M, b
                            })
                        }

                        _releaseTask(C, M) {
                            C._taskLoad -= C._taskCosts[M], delete C._callbacks[M], delete C._taskCosts[M]
                        }

                        debug() {
                            console.log("Task load: ", this.workerPool.map(C => C._taskLoad))
                        }

                        dispose() {
                            for (let C = 0; C < this.workerPool.length; ++C) this.workerPool[C].terminate();
                            return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this
                        }
                    }

                    function E() {
                        let p, C;
                        onmessage = function (I) {
                            const L = I.data;
                            switch (L.type) {
                                case"init":
                                    p = L.decoderConfig, C = new Promise(function (F) {
                                        p.onModuleLoaded = function (V) {
                                            F({draco: V})
                                        }, DracoDecoderModule(p)
                                    });
                                    break;
                                case"decode":
                                    const O = L.buffer, N = L.taskConfig;
                                    C.then(F => {
                                        const V = F.draco, U = new V.Decoder;
                                        try {
                                            const j = M(V, U, new Int8Array(O), N),
                                                Y = j.attributes.map(fe => fe.array.buffer);
                                            j.index && Y.push(j.index.array.buffer), self.postMessage({
                                                type: "decode",
                                                id: L.id,
                                                geometry: j
                                            }, Y)
                                        } catch (j) {
                                            console.error(j), self.postMessage({
                                                type: "error",
                                                id: L.id,
                                                error: j.message
                                            })
                                        } finally {
                                            V.destroy(U)
                                        }
                                    });
                                    break
                            }
                        };

                        function M(I, L, O, N) {
                            const F = N.attributeIDs, V = N.attributeTypes;
                            let U, j;
                            const Y = L.GetEncodedGeometryType(O);
                            if (Y === I.TRIANGULAR_MESH) U = new I.Mesh, j = L.DecodeArrayToMesh(O, O.byteLength, U); else if (Y === I.POINT_CLOUD) U = new I.PointCloud, j = L.DecodeArrayToPointCloud(O, O.byteLength, U); else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                            if (!j.ok() || U.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + j.error_msg());
                            const fe = {index: null, attributes: []};
                            for (const se in F) {
                                const pe = self[V[se]];
                                let ue, he;
                                if (N.useUniqueIDs) he = F[se], ue = L.GetAttributeByUniqueId(U, he); else {
                                    if (he = L.GetAttributeId(U, I[F[se]]), he === -1) continue;
                                    ue = L.GetAttribute(U, he)
                                }
                                const Z = B(I, L, U, se, pe, ue);
                                se === "color" && (Z.vertexColorSpace = N.vertexColorSpace), fe.attributes.push(Z)
                            }
                            return Y === I.TRIANGULAR_MESH && (fe.index = b(I, L, U)), I.destroy(U), fe
                        }

                        function b(I, L, O) {
                            const F = O.num_faces() * 3, V = F * 4, U = I._malloc(V);
                            L.GetTrianglesUInt32Array(O, V, U);
                            const j = new Uint32Array(I.HEAPF32.buffer, U, F).slice();
                            return I._free(U), {array: j, itemSize: 1}
                        }

                        function B(I, L, O, N, F, V) {
                            const U = V.num_components(), Y = O.num_points() * U, fe = Y * F.BYTES_PER_ELEMENT,
                                se = R(I, F), pe = I._malloc(fe);
                            L.GetAttributeDataArrayForAllPoints(O, V, se, fe, pe);
                            const ue = new F(I.HEAPF32.buffer, pe, Y).slice();
                            return I._free(pe), {name: N, array: ue, itemSize: U}
                        }

                        function R(I, L) {
                            switch (L) {
                                case Float32Array:
                                    return I.DT_FLOAT32;
                                case Int8Array:
                                    return I.DT_INT8;
                                case Int16Array:
                                    return I.DT_INT16;
                                case Int32Array:
                                    return I.DT_INT32;
                                case Uint8Array:
                                    return I.DT_UINT8;
                                case Uint16Array:
                                    return I.DT_UINT16;
                                case Uint32Array:
                                    return I.DT_UINT32
                            }
                        }
                    }
                },
                "./node_modules/three/examples/jsm/loaders/GLTFLoader.js": (m, x, h) => {
                    h.r(x), h.d(x, {GLTFLoader: () => v});
                    var g = h("./node_modules/three/build/three.module.js"),
                        w = h("./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js");

                    class v extends g.Loader {
                        constructor(Se) {
                            super(Se), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (_e) {
                                return new B(_e)
                            }), this.register(function (_e) {
                                return new R(_e)
                            }), this.register(function (_e) {
                                return new Y(_e)
                            }), this.register(function (_e) {
                                return new fe(_e)
                            }), this.register(function (_e) {
                                return new se(_e)
                            }), this.register(function (_e) {
                                return new L(_e)
                            }), this.register(function (_e) {
                                return new O(_e)
                            }), this.register(function (_e) {
                                return new N(_e)
                            }), this.register(function (_e) {
                                return new F(_e)
                            }), this.register(function (_e) {
                                return new b(_e)
                            }), this.register(function (_e) {
                                return new V(_e)
                            }), this.register(function (_e) {
                                return new I(_e)
                            }), this.register(function (_e) {
                                return new j(_e)
                            }), this.register(function (_e) {
                                return new U(_e)
                            }), this.register(function (_e) {
                                return new C(_e)
                            }), this.register(function (_e) {
                                return new pe(_e)
                            }), this.register(function (_e) {
                                return new ue(_e)
                            })
                        }

                        load(Se, _e, Ge, Le) {
                            const Ue = this;
                            let Qe;
                            if (this.resourcePath !== "") Qe = this.resourcePath; else if (this.path !== "") {
                                const X = g.LoaderUtils.extractUrlBase(Se);
                                Qe = g.LoaderUtils.resolveURL(X, this.path)
                            } else Qe = g.LoaderUtils.extractUrlBase(Se);
                            this.manager.itemStart(Se);
                            const oe = function (X) {
                                Le ? Le(X) : console.error(X), Ue.manager.itemError(Se), Ue.manager.itemEnd(Se)
                            }, G = new g.FileLoader(this.manager);
                            G.setPath(this.path), G.setResponseType("arraybuffer"), G.setRequestHeader(this.requestHeader), G.setWithCredentials(this.withCredentials), G.load(Se, function (X) {
                                try {
                                    Ue.parse(X, Qe, function (ve) {
                                        _e(ve), Ue.manager.itemEnd(Se)
                                    }, oe)
                                } catch (ve) {
                                    oe(ve)
                                }
                            }, Ge, oe)
                        }

                        setDRACOLoader(Se) {
                            return this.dracoLoader = Se, this
                        }

                        setDDSLoader() {
                            throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                        }

                        setKTX2Loader(Se) {
                            return this.ktx2Loader = Se, this
                        }

                        setMeshoptDecoder(Se) {
                            return this.meshoptDecoder = Se, this
                        }

                        register(Se) {
                            return this.pluginCallbacks.indexOf(Se) === -1 && this.pluginCallbacks.push(Se), this
                        }

                        unregister(Se) {
                            return this.pluginCallbacks.indexOf(Se) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(Se), 1), this
                        }

                        parse(Se, _e, Ge, Le) {
                            let Ue;
                            const Qe = {}, oe = {}, G = new TextDecoder;
                            if (typeof Se == "string") Ue = JSON.parse(Se); else if (Se instanceof ArrayBuffer) if (G.decode(new Uint8Array(Se, 0, 4)) === he) {
                                try {
                                    Qe[p.KHR_BINARY_GLTF] = new ae(Se)
                                } catch (Be) {
                                    Le && Le(Be);
                                    return
                                }
                                Ue = JSON.parse(Qe[p.KHR_BINARY_GLTF].content)
                            } else Ue = JSON.parse(G.decode(Se)); else Ue = Se;
                            if (Ue.asset === void 0 || Ue.asset.version[0] < 2) {
                                Le && Le(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                                return
                            }
                            const X = new ss(Ue, {
                                path: _e || this.resourcePath || "",
                                crossOrigin: this.crossOrigin,
                                requestHeader: this.requestHeader,
                                manager: this.manager,
                                ktx2Loader: this.ktx2Loader,
                                meshoptDecoder: this.meshoptDecoder
                            });
                            X.fileLoader.setRequestHeader(this.requestHeader);
                            for (let ve = 0; ve < this.pluginCallbacks.length; ve++) {
                                const Be = this.pluginCallbacks[ve](X);
                                Be.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), oe[Be.name] = Be, Qe[Be.name] = !0
                            }
                            if (Ue.extensionsUsed) for (let ve = 0; ve < Ue.extensionsUsed.length; ++ve) {
                                const Be = Ue.extensionsUsed[ve], je = Ue.extensionsRequired || [];
                                switch (Be) {
                                    case p.KHR_MATERIALS_UNLIT:
                                        Qe[Be] = new M;
                                        break;
                                    case p.KHR_DRACO_MESH_COMPRESSION:
                                        Qe[Be] = new ee(Ue, this.dracoLoader);
                                        break;
                                    case p.KHR_TEXTURE_TRANSFORM:
                                        Qe[Be] = new me;
                                        break;
                                    case p.KHR_MESH_QUANTIZATION:
                                        Qe[Be] = new Re;
                                        break;
                                    default:
                                        je.indexOf(Be) >= 0 && oe[Be] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + Be + '".')
                                }
                            }
                            X.setExtensions(Qe), X.setPlugins(oe), X.parse(Ge, Le)
                        }

                        parseAsync(Se, _e) {
                            const Ge = this;
                            return new Promise(function (Le, Ue) {
                                Ge.parse(Se, _e, Le, Ue)
                            })
                        }
                    }

                    function E() {
                        let jt = {};
                        return {
                            get: function (Se) {
                                return jt[Se]
                            }, add: function (Se, _e) {
                                jt[Se] = _e
                            }, remove: function (Se) {
                                delete jt[Se]
                            }, removeAll: function () {
                                jt = {}
                            }
                        }
                    }

                    const p = {
                        KHR_BINARY_GLTF: "KHR_binary_glTF",
                        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
                        KHR_MATERIALS_IOR: "KHR_materials_ior",
                        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
                        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
                        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
                        EXT_MATERIALS_BUMP: "EXT_materials_bump",
                        EXT_TEXTURE_WEBP: "EXT_texture_webp",
                        EXT_TEXTURE_AVIF: "EXT_texture_avif",
                        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
                    };

                    class C {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_LIGHTS_PUNCTUAL, this.cache = {refs: {}, uses: {}}
                        }

                        _markDefs() {
                            const Se = this.parser, _e = this.parser.json.nodes || [];
                            for (let Ge = 0, Le = _e.length; Ge < Le; Ge++) {
                                const Ue = _e[Ge];
                                Ue.extensions && Ue.extensions[this.name] && Ue.extensions[this.name].light !== void 0 && Se._addNodeRef(this.cache, Ue.extensions[this.name].light)
                            }
                        }

                        _loadLight(Se) {
                            const _e = this.parser, Ge = "light:" + Se;
                            let Le = _e.cache.get(Ge);
                            if (Le) return Le;
                            const Ue = _e.json,
                                G = ((Ue.extensions && Ue.extensions[this.name] || {}).lights || [])[Se];
                            let X;
                            const ve = new g.Color(16777215);
                            G.color !== void 0 && ve.setRGB(G.color[0], G.color[1], G.color[2], g.LinearSRGBColorSpace);
                            const Be = G.range !== void 0 ? G.range : 0;
                            switch (G.type) {
                                case"directional":
                                    X = new g.DirectionalLight(ve), X.target.position.set(0, 0, -1), X.add(X.target);
                                    break;
                                case"point":
                                    X = new g.PointLight(ve), X.distance = Be;
                                    break;
                                case"spot":
                                    X = new g.SpotLight(ve), X.distance = Be, G.spot = G.spot || {}, G.spot.innerConeAngle = G.spot.innerConeAngle !== void 0 ? G.spot.innerConeAngle : 0, G.spot.outerConeAngle = G.spot.outerConeAngle !== void 0 ? G.spot.outerConeAngle : Math.PI / 4, X.angle = G.spot.outerConeAngle, X.penumbra = 1 - G.spot.innerConeAngle / G.spot.outerConeAngle, X.target.position.set(0, 0, -1), X.add(X.target);
                                    break;
                                default:
                                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + G.type)
                            }
                            return X.position.set(0, 0, 0), X.decay = 2, yi(X, G), G.intensity !== void 0 && (X.intensity = G.intensity), X.name = _e.createUniqueName(G.name || "light_" + Se), Le = Promise.resolve(X), _e.cache.add(Ge, Le), Le
                        }

                        getDependency(Se, _e) {
                            if (Se === "light") return this._loadLight(_e)
                        }

                        createNodeAttachment(Se) {
                            const _e = this, Ge = this.parser, Ue = Ge.json.nodes[Se],
                                oe = (Ue.extensions && Ue.extensions[this.name] || {}).light;
                            return oe === void 0 ? null : this._loadLight(oe).then(function (G) {
                                return Ge._getNodeRef(_e.cache, oe, G)
                            })
                        }
                    }

                    class M {
                        constructor() {
                            this.name = p.KHR_MATERIALS_UNLIT
                        }

                        getMaterialType() {
                            return g.MeshBasicMaterial
                        }

                        extendParams(Se, _e, Ge) {
                            const Le = [];
                            Se.color = new g.Color(1, 1, 1), Se.opacity = 1;
                            const Ue = _e.pbrMetallicRoughness;
                            if (Ue) {
                                if (Array.isArray(Ue.baseColorFactor)) {
                                    const Qe = Ue.baseColorFactor;
                                    Se.color.setRGB(Qe[0], Qe[1], Qe[2], g.LinearSRGBColorSpace), Se.opacity = Qe[3]
                                }
                                Ue.baseColorTexture !== void 0 && Le.push(Ge.assignTexture(Se, "map", Ue.baseColorTexture, g.SRGBColorSpace))
                            }
                            return Promise.all(Le)
                        }
                    }

                    class b {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_EMISSIVE_STRENGTH
                        }

                        extendMaterialParams(Se, _e) {
                            const Le = this.parser.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = Le.extensions[this.name].emissiveStrength;
                            return Ue !== void 0 && (_e.emissiveIntensity = Ue), Promise.resolve()
                        }
                    }

                    class B {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_CLEARCOAT
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Ge = this.parser, Le = Ge.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = [], Qe = Le.extensions[this.name];
                            if (Qe.clearcoatFactor !== void 0 && (_e.clearcoat = Qe.clearcoatFactor), Qe.clearcoatTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "clearcoatMap", Qe.clearcoatTexture)), Qe.clearcoatRoughnessFactor !== void 0 && (_e.clearcoatRoughness = Qe.clearcoatRoughnessFactor), Qe.clearcoatRoughnessTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "clearcoatRoughnessMap", Qe.clearcoatRoughnessTexture)), Qe.clearcoatNormalTexture !== void 0 && (Ue.push(Ge.assignTexture(_e, "clearcoatNormalMap", Qe.clearcoatNormalTexture)), Qe.clearcoatNormalTexture.scale !== void 0)) {
                                const oe = Qe.clearcoatNormalTexture.scale;
                                _e.clearcoatNormalScale = new g.Vector2(oe, oe)
                            }
                            return Promise.all(Ue)
                        }
                    }

                    class R {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_DISPERSION
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Le = this.parser.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = Le.extensions[this.name];
                            return _e.dispersion = Ue.dispersion !== void 0 ? Ue.dispersion : 0, Promise.resolve()
                        }
                    }

                    class I {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_IRIDESCENCE
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Ge = this.parser, Le = Ge.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = [], Qe = Le.extensions[this.name];
                            return Qe.iridescenceFactor !== void 0 && (_e.iridescence = Qe.iridescenceFactor), Qe.iridescenceTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "iridescenceMap", Qe.iridescenceTexture)), Qe.iridescenceIor !== void 0 && (_e.iridescenceIOR = Qe.iridescenceIor), _e.iridescenceThicknessRange === void 0 && (_e.iridescenceThicknessRange = [100, 400]), Qe.iridescenceThicknessMinimum !== void 0 && (_e.iridescenceThicknessRange[0] = Qe.iridescenceThicknessMinimum), Qe.iridescenceThicknessMaximum !== void 0 && (_e.iridescenceThicknessRange[1] = Qe.iridescenceThicknessMaximum), Qe.iridescenceThicknessTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "iridescenceThicknessMap", Qe.iridescenceThicknessTexture)), Promise.all(Ue)
                        }
                    }

                    class L {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_SHEEN
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Ge = this.parser, Le = Ge.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = [];
                            _e.sheenColor = new g.Color(0, 0, 0), _e.sheenRoughness = 0, _e.sheen = 1;
                            const Qe = Le.extensions[this.name];
                            if (Qe.sheenColorFactor !== void 0) {
                                const oe = Qe.sheenColorFactor;
                                _e.sheenColor.setRGB(oe[0], oe[1], oe[2], g.LinearSRGBColorSpace)
                            }
                            return Qe.sheenRoughnessFactor !== void 0 && (_e.sheenRoughness = Qe.sheenRoughnessFactor), Qe.sheenColorTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "sheenColorMap", Qe.sheenColorTexture, g.SRGBColorSpace)), Qe.sheenRoughnessTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "sheenRoughnessMap", Qe.sheenRoughnessTexture)), Promise.all(Ue)
                        }
                    }

                    class O {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_TRANSMISSION
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Ge = this.parser, Le = Ge.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = [], Qe = Le.extensions[this.name];
                            return Qe.transmissionFactor !== void 0 && (_e.transmission = Qe.transmissionFactor), Qe.transmissionTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "transmissionMap", Qe.transmissionTexture)), Promise.all(Ue)
                        }
                    }

                    class N {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_VOLUME
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Ge = this.parser, Le = Ge.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = [], Qe = Le.extensions[this.name];
                            _e.thickness = Qe.thicknessFactor !== void 0 ? Qe.thicknessFactor : 0, Qe.thicknessTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "thicknessMap", Qe.thicknessTexture)), _e.attenuationDistance = Qe.attenuationDistance || 1 / 0;
                            const oe = Qe.attenuationColor || [1, 1, 1];
                            return _e.attenuationColor = new g.Color().setRGB(oe[0], oe[1], oe[2], g.LinearSRGBColorSpace), Promise.all(Ue)
                        }
                    }

                    class F {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_IOR
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Le = this.parser.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = Le.extensions[this.name];
                            return _e.ior = Ue.ior !== void 0 ? Ue.ior : 1.5, Promise.resolve()
                        }
                    }

                    class V {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_SPECULAR
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Ge = this.parser, Le = Ge.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = [], Qe = Le.extensions[this.name];
                            _e.specularIntensity = Qe.specularFactor !== void 0 ? Qe.specularFactor : 1, Qe.specularTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "specularIntensityMap", Qe.specularTexture));
                            const oe = Qe.specularColorFactor || [1, 1, 1];
                            return _e.specularColor = new g.Color().setRGB(oe[0], oe[1], oe[2], g.LinearSRGBColorSpace), Qe.specularColorTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "specularColorMap", Qe.specularColorTexture, g.SRGBColorSpace)), Promise.all(Ue)
                        }
                    }

                    class U {
                        constructor(Se) {
                            this.parser = Se, this.name = p.EXT_MATERIALS_BUMP
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Ge = this.parser, Le = Ge.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = [], Qe = Le.extensions[this.name];
                            return _e.bumpScale = Qe.bumpFactor !== void 0 ? Qe.bumpFactor : 1, Qe.bumpTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "bumpMap", Qe.bumpTexture)), Promise.all(Ue)
                        }
                    }

                    class j {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_MATERIALS_ANISOTROPY
                        }

                        getMaterialType(Se) {
                            const Ge = this.parser.json.materials[Se];
                            return !Ge.extensions || !Ge.extensions[this.name] ? null : g.MeshPhysicalMaterial
                        }

                        extendMaterialParams(Se, _e) {
                            const Ge = this.parser, Le = Ge.json.materials[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return Promise.resolve();
                            const Ue = [], Qe = Le.extensions[this.name];
                            return Qe.anisotropyStrength !== void 0 && (_e.anisotropy = Qe.anisotropyStrength), Qe.anisotropyRotation !== void 0 && (_e.anisotropyRotation = Qe.anisotropyRotation), Qe.anisotropyTexture !== void 0 && Ue.push(Ge.assignTexture(_e, "anisotropyMap", Qe.anisotropyTexture)), Promise.all(Ue)
                        }
                    }

                    class Y {
                        constructor(Se) {
                            this.parser = Se, this.name = p.KHR_TEXTURE_BASISU
                        }

                        loadTexture(Se) {
                            const _e = this.parser, Ge = _e.json, Le = Ge.textures[Se];
                            if (!Le.extensions || !Le.extensions[this.name]) return null;
                            const Ue = Le.extensions[this.name], Qe = _e.options.ktx2Loader;
                            if (!Qe) {
                                if (Ge.extensionsRequired && Ge.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                                return null
                            }
                            return _e.loadTextureImage(Se, Ue.source, Qe)
                        }
                    }

                    class fe {
                        constructor(Se) {
                            this.parser = Se, this.name = p.EXT_TEXTURE_WEBP, this.isSupported = null
                        }

                        loadTexture(Se) {
                            const _e = this.name, Ge = this.parser, Le = Ge.json, Ue = Le.textures[Se];
                            if (!Ue.extensions || !Ue.extensions[_e]) return null;
                            const Qe = Ue.extensions[_e], oe = Le.images[Qe.source];
                            let G = Ge.textureLoader;
                            if (oe.uri) {
                                const X = Ge.options.manager.getHandler(oe.uri);
                                X !== null && (G = X)
                            }
                            return this.detectSupport().then(function (X) {
                                if (X) return Ge.loadTextureImage(Se, Qe.source, G);
                                if (Le.extensionsRequired && Le.extensionsRequired.indexOf(_e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                                return Ge.loadTexture(Se)
                            })
                        }

                        detectSupport() {
                            return this.isSupported || (this.isSupported = new Promise(function (Se) {
                                const _e = new Image;
                                _e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", _e.onload = _e.onerror = function () {
                                    Se(_e.height === 1)
                                }
                            })), this.isSupported
                        }
                    }

                    class se {
                        constructor(Se) {
                            this.parser = Se, this.name = p.EXT_TEXTURE_AVIF, this.isSupported = null
                        }

                        loadTexture(Se) {
                            const _e = this.name, Ge = this.parser, Le = Ge.json, Ue = Le.textures[Se];
                            if (!Ue.extensions || !Ue.extensions[_e]) return null;
                            const Qe = Ue.extensions[_e], oe = Le.images[Qe.source];
                            let G = Ge.textureLoader;
                            if (oe.uri) {
                                const X = Ge.options.manager.getHandler(oe.uri);
                                X !== null && (G = X)
                            }
                            return this.detectSupport().then(function (X) {
                                if (X) return Ge.loadTextureImage(Se, Qe.source, G);
                                if (Le.extensionsRequired && Le.extensionsRequired.indexOf(_e) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                                return Ge.loadTexture(Se)
                            })
                        }

                        detectSupport() {
                            return this.isSupported || (this.isSupported = new Promise(function (Se) {
                                const _e = new Image;
                                _e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", _e.onload = _e.onerror = function () {
                                    Se(_e.height === 1)
                                }
                            })), this.isSupported
                        }
                    }

                    class pe {
                        constructor(Se) {
                            this.name = p.EXT_MESHOPT_COMPRESSION, this.parser = Se
                        }

                        loadBufferView(Se) {
                            const _e = this.parser.json, Ge = _e.bufferViews[Se];
                            if (Ge.extensions && Ge.extensions[this.name]) {
                                const Le = Ge.extensions[this.name],
                                    Ue = this.parser.getDependency("buffer", Le.buffer),
                                    Qe = this.parser.options.meshoptDecoder;
                                if (!Qe || !Qe.supported) {
                                    if (_e.extensionsRequired && _e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                                    return null
                                }
                                return Ue.then(function (oe) {
                                    const G = Le.byteOffset || 0, X = Le.byteLength || 0, ve = Le.count,
                                        Be = Le.byteStride, je = new Uint8Array(oe, G, X);
                                    return Qe.decodeGltfBufferAsync ? Qe.decodeGltfBufferAsync(ve, Be, je, Le.mode, Le.filter).then(function (tt) {
                                        return tt.buffer
                                    }) : Qe.ready.then(function () {
                                        const tt = new ArrayBuffer(ve * Be);
                                        return Qe.decodeGltfBuffer(new Uint8Array(tt), ve, Be, je, Le.mode, Le.filter), tt
                                    })
                                })
                            } else return null
                        }
                    }

                    class ue {
                        constructor(Se) {
                            this.name = p.EXT_MESH_GPU_INSTANCING, this.parser = Se
                        }

                        createNodeMesh(Se) {
                            const _e = this.parser.json, Ge = _e.nodes[Se];
                            if (!Ge.extensions || !Ge.extensions[this.name] || Ge.mesh === void 0) return null;
                            const Le = _e.meshes[Ge.mesh];
                            for (const X of Le.primitives) if (X.mode !== ot.TRIANGLES && X.mode !== ot.TRIANGLE_STRIP && X.mode !== ot.TRIANGLE_FAN && X.mode !== void 0) return null;
                            const Qe = Ge.extensions[this.name].attributes, oe = [], G = {};
                            for (const X in Qe) oe.push(this.parser.getDependency("accessor", Qe[X]).then(ve => (G[X] = ve, G[X])));
                            return oe.length < 1 ? null : (oe.push(this.parser.createNodeMesh(Se)), Promise.all(oe).then(X => {
                                const ve = X.pop(), Be = ve.isGroup ? ve.children : [ve], je = X[0].count, tt = [];
                                for (const Yt of Be) {
                                    const cn = new g.Matrix4, $t = new g.Vector3, en = new g.Quaternion,
                                        Sn = new g.Vector3(1, 1, 1),
                                        Gi = new g.InstancedMesh(Yt.geometry, Yt.material, je);
                                    for (let qn = 0; qn < je; qn++) G.TRANSLATION && $t.fromBufferAttribute(G.TRANSLATION, qn), G.ROTATION && en.fromBufferAttribute(G.ROTATION, qn), G.SCALE && Sn.fromBufferAttribute(G.SCALE, qn), Gi.setMatrixAt(qn, cn.compose($t, en, Sn));
                                    for (const qn in G) if (qn === "_COLOR_0") {
                                        const fr = G[qn];
                                        Gi.instanceColor = new g.InstancedBufferAttribute(fr.array, fr.itemSize, fr.normalized)
                                    } else qn !== "TRANSLATION" && qn !== "ROTATION" && qn !== "SCALE" && Yt.geometry.setAttribute(qn, G[qn]);
                                    g.Object3D.prototype.copy.call(Gi, Yt), this.parser.assignFinalMaterial(Gi), tt.push(Gi)
                                }
                                return ve.isGroup ? (ve.clear(), ve.add(...tt), ve) : tt[0]
                            }))
                        }
                    }

                    const he = "glTF", Z = 12, H = {JSON: 1313821514, BIN: 5130562};

                    class ae {
                        constructor(Se) {
                            this.name = p.KHR_BINARY_GLTF, this.content = null, this.body = null;
                            const _e = new DataView(Se, 0, Z), Ge = new TextDecoder;
                            if (this.header = {
                                magic: Ge.decode(new Uint8Array(Se.slice(0, 4))),
                                version: _e.getUint32(4, !0),
                                length: _e.getUint32(8, !0)
                            }, this.header.magic !== he) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                            const Le = this.header.length - Z, Ue = new DataView(Se, Z);
                            let Qe = 0;
                            for (; Qe < Le;) {
                                const oe = Ue.getUint32(Qe, !0);
                                Qe += 4;
                                const G = Ue.getUint32(Qe, !0);
                                if (Qe += 4, G === H.JSON) {
                                    const X = new Uint8Array(Se, Z + Qe, oe);
                                    this.content = Ge.decode(X)
                                } else if (G === H.BIN) {
                                    const X = Z + Qe;
                                    this.body = Se.slice(X, X + oe)
                                }
                                Qe += oe
                            }
                            if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
                        }
                    }

                    class ee {
                        constructor(Se, _e) {
                            if (!_e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                            this.name = p.KHR_DRACO_MESH_COMPRESSION, this.json = Se, this.dracoLoader = _e, this.dracoLoader.preload()
                        }

                        decodePrimitive(Se, _e) {
                            const Ge = this.json, Le = this.dracoLoader, Ue = Se.extensions[this.name].bufferView,
                                Qe = Se.extensions[this.name].attributes, oe = {}, G = {}, X = {};
                            for (const ve in Qe) {
                                const Be = En[ve] || ve.toLowerCase();
                                oe[Be] = Qe[ve]
                            }
                            for (const ve in Se.attributes) {
                                const Be = En[ve] || ve.toLowerCase();
                                if (Qe[ve] !== void 0) {
                                    const je = Ge.accessors[Se.attributes[ve]], tt = gt[je.componentType];
                                    X[Be] = tt.name, G[Be] = je.normalized === !0
                                }
                            }
                            return _e.getDependency("bufferView", Ue).then(function (ve) {
                                return new Promise(function (Be, je) {
                                    Le.decodeDracoFile(ve, function (tt) {
                                        for (const Yt in tt.attributes) {
                                            const cn = tt.attributes[Yt], $t = G[Yt];
                                            $t !== void 0 && (cn.normalized = $t)
                                        }
                                        Be(tt)
                                    }, oe, X, g.LinearSRGBColorSpace, je)
                                })
                            })
                        }
                    }

                    class me {
                        constructor() {
                            this.name = p.KHR_TEXTURE_TRANSFORM
                        }

                        extendTexture(Se, _e) {
                            return (_e.texCoord === void 0 || _e.texCoord === Se.channel) && _e.offset === void 0 && _e.rotation === void 0 && _e.scale === void 0 || (Se = Se.clone(), _e.texCoord !== void 0 && (Se.channel = _e.texCoord), _e.offset !== void 0 && Se.offset.fromArray(_e.offset), _e.rotation !== void 0 && (Se.rotation = _e.rotation), _e.scale !== void 0 && Se.repeat.fromArray(_e.scale), Se.needsUpdate = !0), Se
                        }
                    }

                    class Re {
                        constructor() {
                            this.name = p.KHR_MESH_QUANTIZATION
                        }
                    }

                    class ke extends g.Interpolant {
                        constructor(Se, _e, Ge, Le) {
                            super(Se, _e, Ge, Le)
                        }

                        copySampleValue_(Se) {
                            const _e = this.resultBuffer, Ge = this.sampleValues, Le = this.valueSize,
                                Ue = Se * Le * 3 + Le;
                            for (let Qe = 0; Qe !== Le; Qe++) _e[Qe] = Ge[Ue + Qe];
                            return _e
                        }

                        interpolate_(Se, _e, Ge, Le) {
                            const Ue = this.resultBuffer, Qe = this.sampleValues, oe = this.valueSize, G = oe * 2,
                                X = oe * 3, ve = Le - _e, Be = (Ge - _e) / ve, je = Be * Be, tt = je * Be, Yt = Se * X,
                                cn = Yt - X, $t = -2 * tt + 3 * je, en = tt - je, Sn = 1 - $t, Gi = en - je + Be;
                            for (let qn = 0; qn !== oe; qn++) {
                                const fr = Qe[cn + qn + oe], Vi = Qe[cn + qn + G] * ve, Zi = Qe[Yt + qn + oe],
                                    co = Qe[Yt + qn] * ve;
                                Ue[qn] = Sn * fr + Gi * Vi + $t * Zi + en * co
                            }
                            return Ue
                        }
                    }

                    const Ve = new g.Quaternion;

                    class He extends ke {
                        interpolate_(Se, _e, Ge, Le) {
                            const Ue = super.interpolate_(Se, _e, Ge, Le);
                            return Ve.fromArray(Ue).normalize().toArray(Ue), Ue
                        }
                    }

                    const ot = {
                            FLOAT: 5126,
                            FLOAT_MAT3: 35675,
                            FLOAT_MAT4: 35676,
                            FLOAT_VEC2: 35664,
                            FLOAT_VEC3: 35665,
                            FLOAT_VEC4: 35666,
                            LINEAR: 9729,
                            REPEAT: 10497,
                            SAMPLER_2D: 35678,
                            POINTS: 0,
                            LINES: 1,
                            LINE_LOOP: 2,
                            LINE_STRIP: 3,
                            TRIANGLES: 4,
                            TRIANGLE_STRIP: 5,
                            TRIANGLE_FAN: 6,
                            UNSIGNED_BYTE: 5121,
                            UNSIGNED_SHORT: 5123
                        }, gt = {
                            5120: Int8Array,
                            5121: Uint8Array,
                            5122: Int16Array,
                            5123: Uint16Array,
                            5125: Uint32Array,
                            5126: Float32Array
                        }, Bt = {
                            9728: g.NearestFilter,
                            9729: g.LinearFilter,
                            9984: g.NearestMipmapNearestFilter,
                            9985: g.LinearMipmapNearestFilter,
                            9986: g.NearestMipmapLinearFilter,
                            9987: g.LinearMipmapLinearFilter
                        }, Rt = {33071: g.ClampToEdgeWrapping, 33648: g.MirroredRepeatWrapping, 10497: g.RepeatWrapping},
                        an = {SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16}, En = {
                            POSITION: "position",
                            NORMAL: "normal",
                            TANGENT: "tangent",
                            TEXCOORD_0: "uv",
                            TEXCOORD_1: "uv1",
                            TEXCOORD_2: "uv2",
                            TEXCOORD_3: "uv3",
                            COLOR_0: "color",
                            WEIGHTS_0: "skinWeight",
                            JOINTS_0: "skinIndex"
                        }, Nn = {
                            scale: "scale",
                            translation: "position",
                            rotation: "quaternion",
                            weights: "morphTargetInfluences"
                        }, oi = {CUBICSPLINE: void 0, LINEAR: g.InterpolateLinear, STEP: g.InterpolateDiscrete},
                        pi = {OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND"};

                    function hi(jt) {
                        return jt.DefaultMaterial === void 0 && (jt.DefaultMaterial = new g.MeshStandardMaterial({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: g.FrontSide
                        })), jt.DefaultMaterial
                    }

                    function Vn(jt, Se, _e) {
                        for (const Ge in _e.extensions) jt[Ge] === void 0 && (Se.userData.gltfExtensions = Se.userData.gltfExtensions || {}, Se.userData.gltfExtensions[Ge] = _e.extensions[Ge])
                    }

                    function yi(jt, Se) {
                        Se.extras !== void 0 && (typeof Se.extras == "object" ? Object.assign(jt.userData, Se.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + Se.extras))
                    }

                    function nr(jt, Se, _e) {
                        let Ge = !1, Le = !1, Ue = !1;
                        for (let X = 0, ve = Se.length; X < ve; X++) {
                            const Be = Se[X];
                            if (Be.POSITION !== void 0 && (Ge = !0), Be.NORMAL !== void 0 && (Le = !0), Be.COLOR_0 !== void 0 && (Ue = !0), Ge && Le && Ue) break
                        }
                        if (!Ge && !Le && !Ue) return Promise.resolve(jt);
                        const Qe = [], oe = [], G = [];
                        for (let X = 0, ve = Se.length; X < ve; X++) {
                            const Be = Se[X];
                            if (Ge) {
                                const je = Be.POSITION !== void 0 ? _e.getDependency("accessor", Be.POSITION) : jt.attributes.position;
                                Qe.push(je)
                            }
                            if (Le) {
                                const je = Be.NORMAL !== void 0 ? _e.getDependency("accessor", Be.NORMAL) : jt.attributes.normal;
                                oe.push(je)
                            }
                            if (Ue) {
                                const je = Be.COLOR_0 !== void 0 ? _e.getDependency("accessor", Be.COLOR_0) : jt.attributes.color;
                                G.push(je)
                            }
                        }
                        return Promise.all([Promise.all(Qe), Promise.all(oe), Promise.all(G)]).then(function (X) {
                            const ve = X[0], Be = X[1], je = X[2];
                            return Ge && (jt.morphAttributes.position = ve), Le && (jt.morphAttributes.normal = Be), Ue && (jt.morphAttributes.color = je), jt.morphTargetsRelative = !0, jt
                        })
                    }

                    function Oi(jt, Se) {
                        if (jt.updateMorphTargets(), Se.weights !== void 0) for (let _e = 0, Ge = Se.weights.length; _e < Ge; _e++) jt.morphTargetInfluences[_e] = Se.weights[_e];
                        if (Se.extras && Array.isArray(Se.extras.targetNames)) {
                            const _e = Se.extras.targetNames;
                            if (jt.morphTargetInfluences.length === _e.length) {
                                jt.morphTargetDictionary = {};
                                for (let Ge = 0, Le = _e.length; Ge < Le; Ge++) jt.morphTargetDictionary[_e[Ge]] = Ge
                            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                        }
                    }

                    function Rr(jt) {
                        let Se;
                        const _e = jt.extensions && jt.extensions[p.KHR_DRACO_MESH_COMPRESSION];
                        if (_e ? Se = "draco:" + _e.bufferView + ":" + _e.indices + ":" + Ji(_e.attributes) : Se = jt.indices + ":" + Ji(jt.attributes) + ":" + jt.mode, jt.targets !== void 0) for (let Ge = 0, Le = jt.targets.length; Ge < Le; Ge++) Se += ":" + Ji(jt.targets[Ge]);
                        return Se
                    }

                    function Ji(jt) {
                        let Se = "";
                        const _e = Object.keys(jt).sort();
                        for (let Ge = 0, Le = _e.length; Ge < Le; Ge++) Se += _e[Ge] + ":" + jt[_e[Ge]] + ";";
                        return Se
                    }

                    function Pi(jt) {
                        switch (jt) {
                            case Int8Array:
                                return .007874015748031496;
                            case Uint8Array:
                                return .00392156862745098;
                            case Int16Array:
                                return 3051850947599719e-20;
                            case Uint16Array:
                                return 15259021896696422e-21;
                            default:
                                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                        }
                    }

                    function Br(jt) {
                        return jt.search(/\.jpe?g($|\?)/i) > 0 || jt.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : jt.search(/\.webp($|\?)/i) > 0 || jt.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
                    }

                    const cr = new g.Matrix4;

                    class ss {
                        constructor(Se = {}, _e = {}) {
                            this.json = Se, this.extensions = {}, this.plugins = {}, this.options = _e, this.cache = new E, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                                refs: {},
                                uses: {}
                            }, this.cameraCache = {refs: {}, uses: {}}, this.lightCache = {
                                refs: {},
                                uses: {}
                            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                            let Ge = !1, Le = !1, Ue = -1;
                            typeof navigator < "u" && (Ge = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, Le = navigator.userAgent.indexOf("Firefox") > -1, Ue = Le ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || Ge || Le && Ue < 98 ? this.textureLoader = new g.TextureLoader(this.options.manager) : this.textureLoader = new g.ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new g.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
                        }

                        setExtensions(Se) {
                            this.extensions = Se
                        }

                        setPlugins(Se) {
                            this.plugins = Se
                        }

                        parse(Se, _e) {
                            const Ge = this, Le = this.json, Ue = this.extensions;
                            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (Qe) {
                                return Qe._markDefs && Qe._markDefs()
                            }), Promise.all(this._invokeAll(function (Qe) {
                                return Qe.beforeRoot && Qe.beforeRoot()
                            })).then(function () {
                                return Promise.all([Ge.getDependencies("scene"), Ge.getDependencies("animation"), Ge.getDependencies("camera")])
                            }).then(function (Qe) {
                                const oe = {
                                    scene: Qe[0][Le.scene || 0],
                                    scenes: Qe[0],
                                    animations: Qe[1],
                                    cameras: Qe[2],
                                    asset: Le.asset,
                                    parser: Ge,
                                    userData: {}
                                };
                                return Vn(Ue, oe, Le), yi(oe, Le), Promise.all(Ge._invokeAll(function (G) {
                                    return G.afterRoot && G.afterRoot(oe)
                                })).then(function () {
                                    for (const G of oe.scenes) G.updateMatrixWorld();
                                    Se(oe)
                                })
                            }).catch(_e)
                        }

                        _markDefs() {
                            const Se = this.json.nodes || [], _e = this.json.skins || [], Ge = this.json.meshes || [];
                            for (let Le = 0, Ue = _e.length; Le < Ue; Le++) {
                                const Qe = _e[Le].joints;
                                for (let oe = 0, G = Qe.length; oe < G; oe++) Se[Qe[oe]].isBone = !0
                            }
                            for (let Le = 0, Ue = Se.length; Le < Ue; Le++) {
                                const Qe = Se[Le];
                                Qe.mesh !== void 0 && (this._addNodeRef(this.meshCache, Qe.mesh), Qe.skin !== void 0 && (Ge[Qe.mesh].isSkinnedMesh = !0)), Qe.camera !== void 0 && this._addNodeRef(this.cameraCache, Qe.camera)
                            }
                        }

                        _addNodeRef(Se, _e) {
                            _e !== void 0 && (Se.refs[_e] === void 0 && (Se.refs[_e] = Se.uses[_e] = 0), Se.refs[_e]++)
                        }

                        _getNodeRef(Se, _e, Ge) {
                            if (Se.refs[_e] <= 1) return Ge;
                            const Le = Ge.clone(), Ue = (Qe, oe) => {
                                const G = this.associations.get(Qe);
                                G != null && this.associations.set(oe, G);
                                for (const [X, ve] of Qe.children.entries()) Ue(ve, oe.children[X])
                            };
                            return Ue(Ge, Le), Le.name += "_instance_" + Se.uses[_e]++, Le
                        }

                        _invokeOne(Se) {
                            const _e = Object.values(this.plugins);
                            _e.push(this);
                            for (let Ge = 0; Ge < _e.length; Ge++) {
                                const Le = Se(_e[Ge]);
                                if (Le) return Le
                            }
                            return null
                        }

                        _invokeAll(Se) {
                            const _e = Object.values(this.plugins);
                            _e.unshift(this);
                            const Ge = [];
                            for (let Le = 0; Le < _e.length; Le++) {
                                const Ue = Se(_e[Le]);
                                Ue && Ge.push(Ue)
                            }
                            return Ge
                        }

                        getDependency(Se, _e) {
                            const Ge = Se + ":" + _e;
                            let Le = this.cache.get(Ge);
                            if (!Le) {
                                switch (Se) {
                                    case"scene":
                                        Le = this.loadScene(_e);
                                        break;
                                    case"node":
                                        Le = this._invokeOne(function (Ue) {
                                            return Ue.loadNode && Ue.loadNode(_e)
                                        });
                                        break;
                                    case"mesh":
                                        Le = this._invokeOne(function (Ue) {
                                            return Ue.loadMesh && Ue.loadMesh(_e)
                                        });
                                        break;
                                    case"accessor":
                                        Le = this.loadAccessor(_e);
                                        break;
                                    case"bufferView":
                                        Le = this._invokeOne(function (Ue) {
                                            return Ue.loadBufferView && Ue.loadBufferView(_e)
                                        });
                                        break;
                                    case"buffer":
                                        Le = this.loadBuffer(_e);
                                        break;
                                    case"material":
                                        Le = this._invokeOne(function (Ue) {
                                            return Ue.loadMaterial && Ue.loadMaterial(_e)
                                        });
                                        break;
                                    case"texture":
                                        Le = this._invokeOne(function (Ue) {
                                            return Ue.loadTexture && Ue.loadTexture(_e)
                                        });
                                        break;
                                    case"skin":
                                        Le = this.loadSkin(_e);
                                        break;
                                    case"animation":
                                        Le = this._invokeOne(function (Ue) {
                                            return Ue.loadAnimation && Ue.loadAnimation(_e)
                                        });
                                        break;
                                    case"camera":
                                        Le = this.loadCamera(_e);
                                        break;
                                    default:
                                        if (Le = this._invokeOne(function (Ue) {
                                            return Ue != this && Ue.getDependency && Ue.getDependency(Se, _e)
                                        }), !Le) throw new Error("Unknown type: " + Se);
                                        break
                                }
                                this.cache.add(Ge, Le)
                            }
                            return Le
                        }

                        getDependencies(Se) {
                            let _e = this.cache.get(Se);
                            if (!_e) {
                                const Ge = this, Le = this.json[Se + (Se === "mesh" ? "es" : "s")] || [];
                                _e = Promise.all(Le.map(function (Ue, Qe) {
                                    return Ge.getDependency(Se, Qe)
                                })), this.cache.add(Se, _e)
                            }
                            return _e
                        }

                        loadBuffer(Se) {
                            const _e = this.json.buffers[Se], Ge = this.fileLoader;
                            if (_e.type && _e.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + _e.type + " buffer type is not supported.");
                            if (_e.uri === void 0 && Se === 0) return Promise.resolve(this.extensions[p.KHR_BINARY_GLTF].body);
                            const Le = this.options;
                            return new Promise(function (Ue, Qe) {
                                Ge.load(g.LoaderUtils.resolveURL(_e.uri, Le.path), Ue, void 0, function () {
                                    Qe(new Error('THREE.GLTFLoader: Failed to load buffer "' + _e.uri + '".'))
                                })
                            })
                        }

                        loadBufferView(Se) {
                            const _e = this.json.bufferViews[Se];
                            return this.getDependency("buffer", _e.buffer).then(function (Ge) {
                                const Le = _e.byteLength || 0, Ue = _e.byteOffset || 0;
                                return Ge.slice(Ue, Ue + Le)
                            })
                        }

                        loadAccessor(Se) {
                            const _e = this, Ge = this.json, Le = this.json.accessors[Se];
                            if (Le.bufferView === void 0 && Le.sparse === void 0) {
                                const Qe = an[Le.type], oe = gt[Le.componentType], G = Le.normalized === !0,
                                    X = new oe(Le.count * Qe);
                                return Promise.resolve(new g.BufferAttribute(X, Qe, G))
                            }
                            const Ue = [];
                            return Le.bufferView !== void 0 ? Ue.push(this.getDependency("bufferView", Le.bufferView)) : Ue.push(null), Le.sparse !== void 0 && (Ue.push(this.getDependency("bufferView", Le.sparse.indices.bufferView)), Ue.push(this.getDependency("bufferView", Le.sparse.values.bufferView))), Promise.all(Ue).then(function (Qe) {
                                const oe = Qe[0], G = an[Le.type], X = gt[Le.componentType], ve = X.BYTES_PER_ELEMENT,
                                    Be = ve * G, je = Le.byteOffset || 0,
                                    tt = Le.bufferView !== void 0 ? Ge.bufferViews[Le.bufferView].byteStride : void 0,
                                    Yt = Le.normalized === !0;
                                let cn, $t;
                                if (tt && tt !== Be) {
                                    const en = Math.floor(je / tt),
                                        Sn = "InterleavedBuffer:" + Le.bufferView + ":" + Le.componentType + ":" + en + ":" + Le.count;
                                    let Gi = _e.cache.get(Sn);
                                    Gi || (cn = new X(oe, en * tt, Le.count * tt / ve), Gi = new g.InterleavedBuffer(cn, tt / ve), _e.cache.add(Sn, Gi)), $t = new g.InterleavedBufferAttribute(Gi, G, je % tt / ve, Yt)
                                } else oe === null ? cn = new X(Le.count * G) : cn = new X(oe, je, Le.count * G), $t = new g.BufferAttribute(cn, G, Yt);
                                if (Le.sparse !== void 0) {
                                    const en = an.SCALAR, Sn = gt[Le.sparse.indices.componentType],
                                        Gi = Le.sparse.indices.byteOffset || 0, qn = Le.sparse.values.byteOffset || 0,
                                        fr = new Sn(Qe[1], Gi, Le.sparse.count * en),
                                        Vi = new X(Qe[2], qn, Le.sparse.count * G);
                                    oe !== null && ($t = new g.BufferAttribute($t.array.slice(), $t.itemSize, $t.normalized));
                                    for (let Zi = 0, co = fr.length; Zi < co; Zi++) {
                                        const pr = fr[Zi];
                                        if ($t.setX(pr, Vi[Zi * G]), G >= 2 && $t.setY(pr, Vi[Zi * G + 1]), G >= 3 && $t.setZ(pr, Vi[Zi * G + 2]), G >= 4 && $t.setW(pr, Vi[Zi * G + 3]), G >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                    }
                                }
                                return $t
                            })
                        }

                        loadTexture(Se) {
                            const _e = this.json, Ge = this.options, Ue = _e.textures[Se].source, Qe = _e.images[Ue];
                            let oe = this.textureLoader;
                            if (Qe.uri) {
                                const G = Ge.manager.getHandler(Qe.uri);
                                G !== null && (oe = G)
                            }
                            return this.loadTextureImage(Se, Ue, oe)
                        }

                        loadTextureImage(Se, _e, Ge) {
                            const Le = this, Ue = this.json, Qe = Ue.textures[Se], oe = Ue.images[_e],
                                G = (oe.uri || oe.bufferView) + ":" + Qe.sampler;
                            if (this.textureCache[G]) return this.textureCache[G];
                            const X = this.loadImageSource(_e, Ge).then(function (ve) {
                                ve.flipY = !1, ve.name = Qe.name || oe.name || "", ve.name === "" && typeof oe.uri == "string" && oe.uri.startsWith("data:image/") === !1 && (ve.name = oe.uri);
                                const je = (Ue.samplers || {})[Qe.sampler] || {};
                                return ve.magFilter = Bt[je.magFilter] || g.LinearFilter, ve.minFilter = Bt[je.minFilter] || g.LinearMipmapLinearFilter, ve.wrapS = Rt[je.wrapS] || g.RepeatWrapping, ve.wrapT = Rt[je.wrapT] || g.RepeatWrapping, Le.associations.set(ve, {textures: Se}), ve
                            }).catch(function () {
                                return null
                            });
                            return this.textureCache[G] = X, X
                        }

                        loadImageSource(Se, _e) {
                            const Ge = this, Le = this.json, Ue = this.options;
                            if (this.sourceCache[Se] !== void 0) return this.sourceCache[Se].then(Be => Be.clone());
                            const Qe = Le.images[Se], oe = self.URL || self.webkitURL;
                            let G = Qe.uri || "", X = !1;
                            if (Qe.bufferView !== void 0) G = Ge.getDependency("bufferView", Qe.bufferView).then(function (Be) {
                                X = !0;
                                const je = new Blob([Be], {type: Qe.mimeType});
                                return G = oe.createObjectURL(je), G
                            }); else if (Qe.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + Se + " is missing URI and bufferView");
                            const ve = Promise.resolve(G).then(function (Be) {
                                return new Promise(function (je, tt) {
                                    let Yt = je;
                                    _e.isImageBitmapLoader === !0 && (Yt = function (cn) {
                                        const $t = new g.Texture(cn);
                                        $t.needsUpdate = !0, je($t)
                                    }), _e.load(g.LoaderUtils.resolveURL(Be, Ue.path), Yt, void 0, tt)
                                })
                            }).then(function (Be) {
                                return X === !0 && oe.revokeObjectURL(G), Be.userData.mimeType = Qe.mimeType || Br(Qe.uri), Be
                            }).catch(function (Be) {
                                throw console.error("THREE.GLTFLoader: Couldn't load texture", G), Be
                            });
                            return this.sourceCache[Se] = ve, ve
                        }

                        assignTexture(Se, _e, Ge, Le) {
                            const Ue = this;
                            return this.getDependency("texture", Ge.index).then(function (Qe) {
                                if (!Qe) return null;
                                if (Ge.texCoord !== void 0 && Ge.texCoord > 0 && (Qe = Qe.clone(), Qe.channel = Ge.texCoord), Ue.extensions[p.KHR_TEXTURE_TRANSFORM]) {
                                    const oe = Ge.extensions !== void 0 ? Ge.extensions[p.KHR_TEXTURE_TRANSFORM] : void 0;
                                    if (oe) {
                                        const G = Ue.associations.get(Qe);
                                        Qe = Ue.extensions[p.KHR_TEXTURE_TRANSFORM].extendTexture(Qe, oe), Ue.associations.set(Qe, G)
                                    }
                                }
                                return Le !== void 0 && (Qe.colorSpace = Le), Se[_e] = Qe, Qe
                            })
                        }

                        assignFinalMaterial(Se) {
                            const _e = Se.geometry;
                            let Ge = Se.material;
                            const Le = _e.attributes.tangent === void 0, Ue = _e.attributes.color !== void 0,
                                Qe = _e.attributes.normal === void 0;
                            if (Se.isPoints) {
                                const oe = "PointsMaterial:" + Ge.uuid;
                                let G = this.cache.get(oe);
                                G || (G = new g.PointsMaterial, g.Material.prototype.copy.call(G, Ge), G.color.copy(Ge.color), G.map = Ge.map, G.sizeAttenuation = !1, this.cache.add(oe, G)), Ge = G
                            } else if (Se.isLine) {
                                const oe = "LineBasicMaterial:" + Ge.uuid;
                                let G = this.cache.get(oe);
                                G || (G = new g.LineBasicMaterial, g.Material.prototype.copy.call(G, Ge), G.color.copy(Ge.color), G.map = Ge.map, this.cache.add(oe, G)), Ge = G
                            }
                            if (Le || Ue || Qe) {
                                let oe = "ClonedMaterial:" + Ge.uuid + ":";
                                Le && (oe += "derivative-tangents:"), Ue && (oe += "vertex-colors:"), Qe && (oe += "flat-shading:");
                                let G = this.cache.get(oe);
                                G || (G = Ge.clone(), Ue && (G.vertexColors = !0), Qe && (G.flatShading = !0), Le && (G.normalScale && (G.normalScale.y *= -1), G.clearcoatNormalScale && (G.clearcoatNormalScale.y *= -1)), this.cache.add(oe, G), this.associations.set(G, this.associations.get(Ge))), Ge = G
                            }
                            Se.material = Ge
                        }

                        getMaterialType() {
                            return g.MeshStandardMaterial
                        }

                        loadMaterial(Se) {
                            const _e = this, Ge = this.json, Le = this.extensions, Ue = Ge.materials[Se];
                            let Qe;
                            const oe = {}, G = Ue.extensions || {}, X = [];
                            if (G[p.KHR_MATERIALS_UNLIT]) {
                                const Be = Le[p.KHR_MATERIALS_UNLIT];
                                Qe = Be.getMaterialType(), X.push(Be.extendParams(oe, Ue, _e))
                            } else {
                                const Be = Ue.pbrMetallicRoughness || {};
                                if (oe.color = new g.Color(1, 1, 1), oe.opacity = 1, Array.isArray(Be.baseColorFactor)) {
                                    const je = Be.baseColorFactor;
                                    oe.color.setRGB(je[0], je[1], je[2], g.LinearSRGBColorSpace), oe.opacity = je[3]
                                }
                                Be.baseColorTexture !== void 0 && X.push(_e.assignTexture(oe, "map", Be.baseColorTexture, g.SRGBColorSpace)), oe.metalness = Be.metallicFactor !== void 0 ? Be.metallicFactor : 1, oe.roughness = Be.roughnessFactor !== void 0 ? Be.roughnessFactor : 1, Be.metallicRoughnessTexture !== void 0 && (X.push(_e.assignTexture(oe, "metalnessMap", Be.metallicRoughnessTexture)), X.push(_e.assignTexture(oe, "roughnessMap", Be.metallicRoughnessTexture))), Qe = this._invokeOne(function (je) {
                                    return je.getMaterialType && je.getMaterialType(Se)
                                }), X.push(Promise.all(this._invokeAll(function (je) {
                                    return je.extendMaterialParams && je.extendMaterialParams(Se, oe)
                                })))
                            }
                            Ue.doubleSided === !0 && (oe.side = g.DoubleSide);
                            const ve = Ue.alphaMode || pi.OPAQUE;
                            if (ve === pi.BLEND ? (oe.transparent = !0, oe.depthWrite = !1) : (oe.transparent = !1, ve === pi.MASK && (oe.alphaTest = Ue.alphaCutoff !== void 0 ? Ue.alphaCutoff : .5)), Ue.normalTexture !== void 0 && Qe !== g.MeshBasicMaterial && (X.push(_e.assignTexture(oe, "normalMap", Ue.normalTexture)), oe.normalScale = new g.Vector2(1, 1), Ue.normalTexture.scale !== void 0)) {
                                const Be = Ue.normalTexture.scale;
                                oe.normalScale.set(Be, Be)
                            }
                            if (Ue.occlusionTexture !== void 0 && Qe !== g.MeshBasicMaterial && (X.push(_e.assignTexture(oe, "aoMap", Ue.occlusionTexture)), Ue.occlusionTexture.strength !== void 0 && (oe.aoMapIntensity = Ue.occlusionTexture.strength)), Ue.emissiveFactor !== void 0 && Qe !== g.MeshBasicMaterial) {
                                const Be = Ue.emissiveFactor;
                                oe.emissive = new g.Color().setRGB(Be[0], Be[1], Be[2], g.LinearSRGBColorSpace)
                            }
                            return Ue.emissiveTexture !== void 0 && Qe !== g.MeshBasicMaterial && X.push(_e.assignTexture(oe, "emissiveMap", Ue.emissiveTexture, g.SRGBColorSpace)), Promise.all(X).then(function () {
                                const Be = new Qe(oe);
                                return Ue.name && (Be.name = Ue.name), yi(Be, Ue), _e.associations.set(Be, {materials: Se}), Ue.extensions && Vn(Le, Be, Ue), Be
                            })
                        }

                        createUniqueName(Se) {
                            const _e = g.PropertyBinding.sanitizeNodeName(Se || "");
                            return _e in this.nodeNamesUsed ? _e + "_" + ++this.nodeNamesUsed[_e] : (this.nodeNamesUsed[_e] = 0, _e)
                        }

                        loadGeometries(Se) {
                            const _e = this, Ge = this.extensions, Le = this.primitiveCache;

                            function Ue(oe) {
                                return Ge[p.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(oe, _e).then(function (G) {
                                    return ir(G, oe, _e)
                                })
                            }

                            const Qe = [];
                            for (let oe = 0, G = Se.length; oe < G; oe++) {
                                const X = Se[oe], ve = Rr(X), Be = Le[ve];
                                if (Be) Qe.push(Be.promise); else {
                                    let je;
                                    X.extensions && X.extensions[p.KHR_DRACO_MESH_COMPRESSION] ? je = Ue(X) : je = ir(new g.BufferGeometry, X, _e), Le[ve] = {
                                        primitive: X,
                                        promise: je
                                    }, Qe.push(je)
                                }
                            }
                            return Promise.all(Qe)
                        }

                        loadMesh(Se) {
                            const _e = this, Ge = this.json, Le = this.extensions, Ue = Ge.meshes[Se],
                                Qe = Ue.primitives, oe = [];
                            for (let G = 0, X = Qe.length; G < X; G++) {
                                const ve = Qe[G].material === void 0 ? hi(this.cache) : this.getDependency("material", Qe[G].material);
                                oe.push(ve)
                            }
                            return oe.push(_e.loadGeometries(Qe)), Promise.all(oe).then(function (G) {
                                const X = G.slice(0, G.length - 1), ve = G[G.length - 1], Be = [];
                                for (let tt = 0, Yt = ve.length; tt < Yt; tt++) {
                                    const cn = ve[tt], $t = Qe[tt];
                                    let en;
                                    const Sn = X[tt];
                                    if ($t.mode === ot.TRIANGLES || $t.mode === ot.TRIANGLE_STRIP || $t.mode === ot.TRIANGLE_FAN || $t.mode === void 0) en = Ue.isSkinnedMesh === !0 ? new g.SkinnedMesh(cn, Sn) : new g.Mesh(cn, Sn), en.isSkinnedMesh === !0 && en.normalizeSkinWeights(), $t.mode === ot.TRIANGLE_STRIP ? en.geometry = (0, w.toTrianglesDrawMode)(en.geometry, g.TriangleStripDrawMode) : $t.mode === ot.TRIANGLE_FAN && (en.geometry = (0, w.toTrianglesDrawMode)(en.geometry, g.TriangleFanDrawMode)); else if ($t.mode === ot.LINES) en = new g.LineSegments(cn, Sn); else if ($t.mode === ot.LINE_STRIP) en = new g.Line(cn, Sn); else if ($t.mode === ot.LINE_LOOP) en = new g.LineLoop(cn, Sn); else if ($t.mode === ot.POINTS) en = new g.Points(cn, Sn); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + $t.mode);
                                    Object.keys(en.geometry.morphAttributes).length > 0 && Oi(en, Ue), en.name = _e.createUniqueName(Ue.name || "mesh_" + Se), yi(en, Ue), $t.extensions && Vn(Le, en, $t), _e.assignFinalMaterial(en), Be.push(en)
                                }
                                for (let tt = 0, Yt = Be.length; tt < Yt; tt++) _e.associations.set(Be[tt], {
                                    meshes: Se,
                                    primitives: tt
                                });
                                if (Be.length === 1) return Ue.extensions && Vn(Le, Be[0], Ue), Be[0];
                                const je = new g.Group;
                                Ue.extensions && Vn(Le, je, Ue), _e.associations.set(je, {meshes: Se});
                                for (let tt = 0, Yt = Be.length; tt < Yt; tt++) je.add(Be[tt]);
                                return je
                            })
                        }

                        loadCamera(Se) {
                            let _e;
                            const Ge = this.json.cameras[Se], Le = Ge[Ge.type];
                            if (!Le) {
                                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                                return
                            }
                            return Ge.type === "perspective" ? _e = new g.PerspectiveCamera(g.MathUtils.radToDeg(Le.yfov), Le.aspectRatio || 1, Le.znear || 1, Le.zfar || 2e6) : Ge.type === "orthographic" && (_e = new g.OrthographicCamera(-Le.xmag, Le.xmag, Le.ymag, -Le.ymag, Le.znear, Le.zfar)), Ge.name && (_e.name = this.createUniqueName(Ge.name)), yi(_e, Ge), Promise.resolve(_e)
                        }

                        loadSkin(Se) {
                            const _e = this.json.skins[Se], Ge = [];
                            for (let Le = 0, Ue = _e.joints.length; Le < Ue; Le++) Ge.push(this._loadNodeShallow(_e.joints[Le]));
                            return _e.inverseBindMatrices !== void 0 ? Ge.push(this.getDependency("accessor", _e.inverseBindMatrices)) : Ge.push(null), Promise.all(Ge).then(function (Le) {
                                const Ue = Le.pop(), Qe = Le, oe = [], G = [];
                                for (let X = 0, ve = Qe.length; X < ve; X++) {
                                    const Be = Qe[X];
                                    if (Be) {
                                        oe.push(Be);
                                        const je = new g.Matrix4;
                                        Ue !== null && je.fromArray(Ue.array, X * 16), G.push(je)
                                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', _e.joints[X])
                                }
                                return new g.Skeleton(oe, G)
                            })
                        }

                        loadAnimation(Se) {
                            const _e = this.json, Ge = this, Le = _e.animations[Se],
                                Ue = Le.name ? Le.name : "animation_" + Se, Qe = [], oe = [], G = [], X = [], ve = [];
                            for (let Be = 0, je = Le.channels.length; Be < je; Be++) {
                                const tt = Le.channels[Be], Yt = Le.samplers[tt.sampler], cn = tt.target, $t = cn.node,
                                    en = Le.parameters !== void 0 ? Le.parameters[Yt.input] : Yt.input,
                                    Sn = Le.parameters !== void 0 ? Le.parameters[Yt.output] : Yt.output;
                                cn.node !== void 0 && (Qe.push(this.getDependency("node", $t)), oe.push(this.getDependency("accessor", en)), G.push(this.getDependency("accessor", Sn)), X.push(Yt), ve.push(cn))
                            }
                            return Promise.all([Promise.all(Qe), Promise.all(oe), Promise.all(G), Promise.all(X), Promise.all(ve)]).then(function (Be) {
                                const je = Be[0], tt = Be[1], Yt = Be[2], cn = Be[3], $t = Be[4], en = [];
                                for (let Sn = 0, Gi = je.length; Sn < Gi; Sn++) {
                                    const qn = je[Sn], fr = tt[Sn], Vi = Yt[Sn], Zi = cn[Sn], co = $t[Sn];
                                    if (qn === void 0) continue;
                                    qn.updateMatrix && qn.updateMatrix();
                                    const pr = Ge._createAnimationTracks(qn, fr, Vi, Zi, co);
                                    if (pr) for (let $s = 0; $s < pr.length; $s++) en.push(pr[$s])
                                }
                                return new g.AnimationClip(Ue, void 0, en)
                            })
                        }

                        createNodeMesh(Se) {
                            const _e = this.json, Ge = this, Le = _e.nodes[Se];
                            return Le.mesh === void 0 ? null : Ge.getDependency("mesh", Le.mesh).then(function (Ue) {
                                const Qe = Ge._getNodeRef(Ge.meshCache, Le.mesh, Ue);
                                return Le.weights !== void 0 && Qe.traverse(function (oe) {
                                    if (oe.isMesh) for (let G = 0, X = Le.weights.length; G < X; G++) oe.morphTargetInfluences[G] = Le.weights[G]
                                }), Qe
                            })
                        }

                        loadNode(Se) {
                            const _e = this.json, Ge = this, Le = _e.nodes[Se], Ue = Ge._loadNodeShallow(Se), Qe = [],
                                oe = Le.children || [];
                            for (let X = 0, ve = oe.length; X < ve; X++) Qe.push(Ge.getDependency("node", oe[X]));
                            const G = Le.skin === void 0 ? Promise.resolve(null) : Ge.getDependency("skin", Le.skin);
                            return Promise.all([Ue, Promise.all(Qe), G]).then(function (X) {
                                const ve = X[0], Be = X[1], je = X[2];
                                je !== null && ve.traverse(function (tt) {
                                    tt.isSkinnedMesh && tt.bind(je, cr)
                                });
                                for (let tt = 0, Yt = Be.length; tt < Yt; tt++) ve.add(Be[tt]);
                                return ve
                            })
                        }

                        _loadNodeShallow(Se) {
                            const _e = this.json, Ge = this.extensions, Le = this;
                            if (this.nodeCache[Se] !== void 0) return this.nodeCache[Se];
                            const Ue = _e.nodes[Se], Qe = Ue.name ? Le.createUniqueName(Ue.name) : "", oe = [],
                                G = Le._invokeOne(function (X) {
                                    return X.createNodeMesh && X.createNodeMesh(Se)
                                });
                            return G && oe.push(G), Ue.camera !== void 0 && oe.push(Le.getDependency("camera", Ue.camera).then(function (X) {
                                return Le._getNodeRef(Le.cameraCache, Ue.camera, X)
                            })), Le._invokeAll(function (X) {
                                return X.createNodeAttachment && X.createNodeAttachment(Se)
                            }).forEach(function (X) {
                                oe.push(X)
                            }), this.nodeCache[Se] = Promise.all(oe).then(function (X) {
                                let ve;
                                if (Ue.isBone === !0 ? ve = new g.Bone : X.length > 1 ? ve = new g.Group : X.length === 1 ? ve = X[0] : ve = new g.Object3D, ve !== X[0]) for (let Be = 0, je = X.length; Be < je; Be++) ve.add(X[Be]);
                                if (Ue.name && (ve.userData.name = Ue.name, ve.name = Qe), yi(ve, Ue), Ue.extensions && Vn(Ge, ve, Ue), Ue.matrix !== void 0) {
                                    const Be = new g.Matrix4;
                                    Be.fromArray(Ue.matrix), ve.applyMatrix4(Be)
                                } else Ue.translation !== void 0 && ve.position.fromArray(Ue.translation), Ue.rotation !== void 0 && ve.quaternion.fromArray(Ue.rotation), Ue.scale !== void 0 && ve.scale.fromArray(Ue.scale);
                                return Le.associations.has(ve) || Le.associations.set(ve, {}), Le.associations.get(ve).nodes = Se, ve
                            }), this.nodeCache[Se]
                        }

                        loadScene(Se) {
                            const _e = this.extensions, Ge = this.json.scenes[Se], Le = this, Ue = new g.Group;
                            Ge.name && (Ue.name = Le.createUniqueName(Ge.name)), yi(Ue, Ge), Ge.extensions && Vn(_e, Ue, Ge);
                            const Qe = Ge.nodes || [], oe = [];
                            for (let G = 0, X = Qe.length; G < X; G++) oe.push(Le.getDependency("node", Qe[G]));
                            return Promise.all(oe).then(function (G) {
                                for (let ve = 0, Be = G.length; ve < Be; ve++) Ue.add(G[ve]);
                                const X = ve => {
                                    const Be = new Map;
                                    for (const [je, tt] of Le.associations) (je instanceof g.Material || je instanceof g.Texture) && Be.set(je, tt);
                                    return ve.traverse(je => {
                                        const tt = Le.associations.get(je);
                                        tt != null && Be.set(je, tt)
                                    }), Be
                                };
                                return Le.associations = X(Ue), Ue
                            })
                        }

                        _createAnimationTracks(Se, _e, Ge, Le, Ue) {
                            const Qe = [], oe = Se.name ? Se.name : Se.uuid, G = [];
                            Nn[Ue.path] === Nn.weights ? Se.traverse(function (je) {
                                je.morphTargetInfluences && G.push(je.name ? je.name : je.uuid)
                            }) : G.push(oe);
                            let X;
                            switch (Nn[Ue.path]) {
                                case Nn.weights:
                                    X = g.NumberKeyframeTrack;
                                    break;
                                case Nn.rotation:
                                    X = g.QuaternionKeyframeTrack;
                                    break;
                                case Nn.position:
                                case Nn.scale:
                                    X = g.VectorKeyframeTrack;
                                    break;
                                default:
                                    switch (Ge.itemSize) {
                                        case 1:
                                            X = g.NumberKeyframeTrack;
                                            break;
                                        case 2:
                                        case 3:
                                        default:
                                            X = g.VectorKeyframeTrack;
                                            break
                                    }
                                    break
                            }
                            const ve = Le.interpolation !== void 0 ? oi[Le.interpolation] : g.InterpolateLinear,
                                Be = this._getArrayFromAccessor(Ge);
                            for (let je = 0, tt = G.length; je < tt; je++) {
                                const Yt = new X(G[je] + "." + Nn[Ue.path], _e.array, Be, ve);
                                Le.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(Yt), Qe.push(Yt)
                            }
                            return Qe
                        }

                        _getArrayFromAccessor(Se) {
                            let _e = Se.array;
                            if (Se.normalized) {
                                const Ge = Pi(_e.constructor), Le = new Float32Array(_e.length);
                                for (let Ue = 0, Qe = _e.length; Ue < Qe; Ue++) Le[Ue] = _e[Ue] * Ge;
                                _e = Le
                            }
                            return _e
                        }

                        _createCubicSplineTrackInterpolant(Se) {
                            Se.createInterpolant = function (Ge) {
                                const Le = this instanceof g.QuaternionKeyframeTrack ? He : ke;
                                return new Le(this.times, this.values, this.getValueSize() / 3, Ge)
                            }, Se.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
                        }
                    }

                    function Nr(jt, Se, _e) {
                        const Ge = Se.attributes, Le = new g.Box3;
                        if (Ge.POSITION !== void 0) {
                            const oe = _e.json.accessors[Ge.POSITION], G = oe.min, X = oe.max;
                            if (G !== void 0 && X !== void 0) {
                                if (Le.set(new g.Vector3(G[0], G[1], G[2]), new g.Vector3(X[0], X[1], X[2])), oe.normalized) {
                                    const ve = Pi(gt[oe.componentType]);
                                    Le.min.multiplyScalar(ve), Le.max.multiplyScalar(ve)
                                }
                            } else {
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                                return
                            }
                        } else return;
                        const Ue = Se.targets;
                        if (Ue !== void 0) {
                            const oe = new g.Vector3, G = new g.Vector3;
                            for (let X = 0, ve = Ue.length; X < ve; X++) {
                                const Be = Ue[X];
                                if (Be.POSITION !== void 0) {
                                    const je = _e.json.accessors[Be.POSITION], tt = je.min, Yt = je.max;
                                    if (tt !== void 0 && Yt !== void 0) {
                                        if (G.setX(Math.max(Math.abs(tt[0]), Math.abs(Yt[0]))), G.setY(Math.max(Math.abs(tt[1]), Math.abs(Yt[1]))), G.setZ(Math.max(Math.abs(tt[2]), Math.abs(Yt[2]))), je.normalized) {
                                            const cn = Pi(gt[je.componentType]);
                                            G.multiplyScalar(cn)
                                        }
                                        oe.max(G)
                                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                }
                            }
                            Le.expandByVector(oe)
                        }
                        jt.boundingBox = Le;
                        const Qe = new g.Sphere;
                        Le.getCenter(Qe.center), Qe.radius = Le.min.distanceTo(Le.max) / 2, jt.boundingSphere = Qe
                    }

                    function ir(jt, Se, _e) {
                        const Ge = Se.attributes, Le = [];

                        function Ue(Qe, oe) {
                            return _e.getDependency("accessor", Qe).then(function (G) {
                                jt.setAttribute(oe, G)
                            })
                        }

                        for (const Qe in Ge) {
                            const oe = En[Qe] || Qe.toLowerCase();
                            oe in jt.attributes || Le.push(Ue(Ge[Qe], oe))
                        }
                        if (Se.indices !== void 0 && !jt.index) {
                            const Qe = _e.getDependency("accessor", Se.indices).then(function (oe) {
                                jt.setIndex(oe)
                            });
                            Le.push(Qe)
                        }
                        return g.ColorManagement.workingColorSpace !== g.LinearSRGBColorSpace && "COLOR_0" in Ge && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${g.ColorManagement.workingColorSpace}" not supported.`), yi(jt, Se), Nr(jt, Se, _e), Promise.all(Le).then(function () {
                            return Se.targets !== void 0 ? nr(jt, Se.targets, _e) : jt
                        })
                    }
                },
                "./node_modules/three/examples/jsm/loaders/KTX2Loader.js": (m, x, h) => {
                    h.r(x), h.d(x, {KTX2Loader: () => b});
                    var g = h("./node_modules/three/build/three.module.js"),
                        w = h("./node_modules/three/examples/jsm/utils/WorkerPool.js"),
                        v = h("./node_modules/three/examples/jsm/libs/ktx-parse.module.js"),
                        E = h("./node_modules/three/examples/jsm/libs/zstddec.module.js");
                    const p = new WeakMap;
                    let C = 0, M;

                    class b extends g.Loader {
                        constructor(F) {
                            super(F), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new w.WorkerPool, this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
                        }

                        setTranscoderPath(F) {
                            return this.transcoderPath = F, this
                        }

                        setWorkerLimit(F) {
                            return this.workerPool.setWorkerLimit(F), this
                        }

                        async detectSupportAsync(F) {
                            return this.workerConfig = {
                                astcSupported: await F.hasFeatureAsync("texture-compression-astc"),
                                etc1Supported: await F.hasFeatureAsync("texture-compression-etc1"),
                                etc2Supported: await F.hasFeatureAsync("texture-compression-etc2"),
                                dxtSupported: await F.hasFeatureAsync("texture-compression-bc"),
                                bptcSupported: await F.hasFeatureAsync("texture-compression-bptc"),
                                pvrtcSupported: await F.hasFeatureAsync("texture-compression-pvrtc")
                            }, this
                        }

                        detectSupport(F) {
                            return F.isWebGPURenderer === !0 ? this.workerConfig = {
                                astcSupported: F.hasFeature("texture-compression-astc"),
                                etc1Supported: F.hasFeature("texture-compression-etc1"),
                                etc2Supported: F.hasFeature("texture-compression-etc2"),
                                dxtSupported: F.hasFeature("texture-compression-bc"),
                                bptcSupported: F.hasFeature("texture-compression-bptc"),
                                pvrtcSupported: F.hasFeature("texture-compression-pvrtc")
                            } : this.workerConfig = {
                                astcSupported: F.extensions.has("WEBGL_compressed_texture_astc"),
                                etc1Supported: F.extensions.has("WEBGL_compressed_texture_etc1"),
                                etc2Supported: F.extensions.has("WEBGL_compressed_texture_etc"),
                                dxtSupported: F.extensions.has("WEBGL_compressed_texture_s3tc"),
                                bptcSupported: F.extensions.has("EXT_texture_compression_bptc"),
                                pvrtcSupported: F.extensions.has("WEBGL_compressed_texture_pvrtc") || F.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                            }, this
                        }

                        init() {
                            if (!this.transcoderPending) {
                                const F = new g.FileLoader(this.manager);
                                F.setPath(this.transcoderPath), F.setWithCredentials(this.withCredentials);
                                const V = F.loadAsync("basis_transcoder.js"), U = new g.FileLoader(this.manager);
                                U.setPath(this.transcoderPath), U.setResponseType("arraybuffer"), U.setWithCredentials(this.withCredentials);
                                const j = U.loadAsync("basis_transcoder.wasm");
                                this.transcoderPending = Promise.all([V, j]).then(([Y, fe]) => {
                                    const se = b.BasisWorker.toString(),
                                        pe = ["/* constants */", "let _EngineFormat = " + JSON.stringify(b.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(b.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(b.BasisFormat), "/* basis_transcoder.js */", Y, "/* worker */", se.substring(se.indexOf("{") + 1, se.lastIndexOf("}"))].join(`
`);
                                    this.workerSourceURL = URL.createObjectURL(new Blob([pe])), this.transcoderBinary = fe, this.workerPool.setWorkerCreator(() => {
                                        const ue = new Worker(this.workerSourceURL),
                                            he = this.transcoderBinary.slice(0);
                                        return ue.postMessage({
                                            type: "init",
                                            config: this.workerConfig,
                                            transcoderBinary: he
                                        }, [he]), ue
                                    })
                                }), C > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), C++
                            }
                            return this.transcoderPending
                        }

                        load(F, V, U, j) {
                            if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                            const Y = new g.FileLoader(this.manager);
                            Y.setResponseType("arraybuffer"), Y.setWithCredentials(this.withCredentials), Y.load(F, fe => {
                                if (p.has(fe)) return p.get(fe).promise.then(V).catch(j);
                                this._createTexture(fe).then(se => V ? V(se) : null).catch(j)
                            }, U, j)
                        }

                        _createTextureFrom(F, V) {
                            const {faces: U, width: j, height: Y, format: fe, type: se, error: pe, dfdFlags: ue} = F;
                            if (se === "error") return Promise.reject(pe);
                            let he;
                            if (V.faceCount === 6) he = new g.CompressedCubeTexture(U, fe, g.UnsignedByteType); else {
                                const Z = U[0].mipmaps;
                                he = V.layerCount > 1 ? new g.CompressedArrayTexture(Z, j, Y, V.layerCount, fe, g.UnsignedByteType) : new g.CompressedTexture(Z, j, Y, fe, g.UnsignedByteType)
                            }
                            return he.minFilter = U[0].mipmaps.length === 1 ? g.LinearFilter : g.LinearMipmapLinearFilter, he.magFilter = g.LinearFilter, he.generateMipmaps = !1, he.needsUpdate = !0, he.colorSpace = O(V), he.premultiplyAlpha = !!(ue & v.KHR_DF_FLAG_ALPHA_PREMULTIPLIED), he
                        }

                        async _createTexture(F, V = {}) {
                            const U = (0, v.read)(new Uint8Array(F));
                            if (U.vkFormat !== v.VK_FORMAT_UNDEFINED) return L(U);
                            const j = V, Y = this.init().then(() => this.workerPool.postMessage({
                                type: "transcode",
                                buffer: F,
                                taskConfig: j
                            }, [F])).then(fe => this._createTextureFrom(fe.data, U));
                            return p.set(F, {promise: Y}), Y
                        }

                        dispose() {
                            return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), C--, this
                        }
                    }

                    b.BasisFormat = {ETC1S: 0, UASTC_4x4: 1}, b.TranscoderFormat = {
                        ETC1: 0,
                        ETC2: 1,
                        BC1: 2,
                        BC3: 3,
                        BC4: 4,
                        BC5: 5,
                        BC7_M6_OPAQUE_ONLY: 6,
                        BC7_M5: 7,
                        PVRTC1_4_RGB: 8,
                        PVRTC1_4_RGBA: 9,
                        ASTC_4x4: 10,
                        ATC_RGB: 11,
                        ATC_RGBA_INTERPOLATED_ALPHA: 12,
                        RGBA32: 13,
                        RGB565: 14,
                        BGR565: 15,
                        RGBA4444: 16
                    }, b.EngineFormat = {
                        RGBAFormat: g.RGBAFormat,
                        RGBA_ASTC_4x4_Format: g.RGBA_ASTC_4x4_Format,
                        RGBA_BPTC_Format: g.RGBA_BPTC_Format,
                        RGBA_ETC2_EAC_Format: g.RGBA_ETC2_EAC_Format,
                        RGBA_PVRTC_4BPPV1_Format: g.RGBA_PVRTC_4BPPV1_Format,
                        RGBA_S3TC_DXT5_Format: g.RGBA_S3TC_DXT5_Format,
                        RGB_ETC1_Format: g.RGB_ETC1_Format,
                        RGB_ETC2_Format: g.RGB_ETC2_Format,
                        RGB_PVRTC_4BPPV1_Format: g.RGB_PVRTC_4BPPV1_Format,
                        RGBA_S3TC_DXT1_Format: g.RGBA_S3TC_DXT1_Format
                    }, b.BasisWorker = function () {
                        let N, F, V;
                        const U = _EngineFormat, j = _TranscoderFormat, Y = _BasisFormat;
                        self.addEventListener("message", function (ee) {
                            const me = ee.data;
                            switch (me.type) {
                                case"init":
                                    N = me.config, fe(me.transcoderBinary);
                                    break;
                                case"transcode":
                                    F.then(() => {
                                        try {
                                            const {
                                                faces: Re,
                                                buffers: ke,
                                                width: Ve,
                                                height: He,
                                                hasAlpha: ot,
                                                format: gt,
                                                dfdFlags: Bt
                                            } = se(me.buffer);
                                            self.postMessage({
                                                type: "transcode",
                                                id: me.id,
                                                faces: Re,
                                                width: Ve,
                                                height: He,
                                                hasAlpha: ot,
                                                format: gt,
                                                dfdFlags: Bt
                                            }, ke)
                                        } catch (Re) {
                                            console.error(Re), self.postMessage({
                                                type: "error",
                                                id: me.id,
                                                error: Re.message
                                            })
                                        }
                                    });
                                    break
                            }
                        });

                        function fe(ee) {
                            F = new Promise(me => {
                                V = {wasmBinary: ee, onRuntimeInitialized: me}, BASIS(V)
                            }).then(() => {
                                V.initializeBasis(), V.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                            })
                        }

                        function se(ee) {
                            const me = new V.KTX2File(new Uint8Array(ee));

                            function Re() {
                                me.close(), me.delete()
                            }

                            if (!me.isValid()) throw Re(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
                            const ke = me.isUASTC() ? Y.UASTC_4x4 : Y.ETC1S, Ve = me.getWidth(), He = me.getHeight(),
                                ot = me.getLayers() || 1, gt = me.getLevels(), Bt = me.getFaces(),
                                Rt = me.getHasAlpha(), an = me.getDFDFlags(), {
                                    transcoderFormat: En,
                                    engineFormat: Nn
                                } = Z(ke, Ve, He, Rt);
                            if (!Ve || !He || !gt) throw Re(), new Error("THREE.KTX2Loader:	Invalid texture");
                            if (!me.startTranscoding()) throw Re(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                            const oi = [], pi = [];
                            for (let hi = 0; hi < Bt; hi++) {
                                const Vn = [];
                                for (let yi = 0; yi < gt; yi++) {
                                    const nr = [];
                                    let Oi, Rr;
                                    for (let Pi = 0; Pi < ot; Pi++) {
                                        const Br = me.getImageLevelInfo(yi, Pi, hi);
                                        hi === 0 && yi === 0 && Pi === 0 && (Br.origWidth % 4 !== 0 || Br.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), gt > 1 ? (Oi = Br.origWidth, Rr = Br.origHeight) : (Oi = Br.width, Rr = Br.height);
                                        const cr = new Uint8Array(me.getImageTranscodedSizeInBytes(yi, Pi, 0, En));
                                        if (!me.transcodeImage(cr, yi, Pi, hi, En, 0, -1, -1)) throw Re(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                        nr.push(cr)
                                    }
                                    const Ji = ae(nr);
                                    Vn.push({data: Ji, width: Oi, height: Rr}), pi.push(Ji.buffer)
                                }
                                oi.push({mipmaps: Vn, width: Ve, height: He, format: Nn})
                            }
                            return Re(), {
                                faces: oi,
                                buffers: pi,
                                width: Ve,
                                height: He,
                                hasAlpha: Rt,
                                format: Nn,
                                dfdFlags: an
                            }
                        }

                        const pe = [{
                            if: "astcSupported",
                            basisFormat: [Y.UASTC_4x4],
                            transcoderFormat: [j.ASTC_4x4, j.ASTC_4x4],
                            engineFormat: [U.RGBA_ASTC_4x4_Format, U.RGBA_ASTC_4x4_Format],
                            priorityETC1S: 1 / 0,
                            priorityUASTC: 1,
                            needsPowerOfTwo: !1
                        }, {
                            if: "bptcSupported",
                            basisFormat: [Y.ETC1S, Y.UASTC_4x4],
                            transcoderFormat: [j.BC7_M5, j.BC7_M5],
                            engineFormat: [U.RGBA_BPTC_Format, U.RGBA_BPTC_Format],
                            priorityETC1S: 3,
                            priorityUASTC: 2,
                            needsPowerOfTwo: !1
                        }, {
                            if: "dxtSupported",
                            basisFormat: [Y.ETC1S, Y.UASTC_4x4],
                            transcoderFormat: [j.BC1, j.BC3],
                            engineFormat: [U.RGBA_S3TC_DXT1_Format, U.RGBA_S3TC_DXT5_Format],
                            priorityETC1S: 4,
                            priorityUASTC: 5,
                            needsPowerOfTwo: !1
                        }, {
                            if: "etc2Supported",
                            basisFormat: [Y.ETC1S, Y.UASTC_4x4],
                            transcoderFormat: [j.ETC1, j.ETC2],
                            engineFormat: [U.RGB_ETC2_Format, U.RGBA_ETC2_EAC_Format],
                            priorityETC1S: 1,
                            priorityUASTC: 3,
                            needsPowerOfTwo: !1
                        }, {
                            if: "etc1Supported",
                            basisFormat: [Y.ETC1S, Y.UASTC_4x4],
                            transcoderFormat: [j.ETC1],
                            engineFormat: [U.RGB_ETC1_Format],
                            priorityETC1S: 2,
                            priorityUASTC: 4,
                            needsPowerOfTwo: !1
                        }, {
                            if: "pvrtcSupported",
                            basisFormat: [Y.ETC1S, Y.UASTC_4x4],
                            transcoderFormat: [j.PVRTC1_4_RGB, j.PVRTC1_4_RGBA],
                            engineFormat: [U.RGB_PVRTC_4BPPV1_Format, U.RGBA_PVRTC_4BPPV1_Format],
                            priorityETC1S: 5,
                            priorityUASTC: 6,
                            needsPowerOfTwo: !0
                        }], ue = pe.sort(function (ee, me) {
                            return ee.priorityETC1S - me.priorityETC1S
                        }), he = pe.sort(function (ee, me) {
                            return ee.priorityUASTC - me.priorityUASTC
                        });

                        function Z(ee, me, Re, ke) {
                            let Ve, He;
                            const ot = ee === Y.ETC1S ? ue : he;
                            for (let gt = 0; gt < ot.length; gt++) {
                                const Bt = ot[gt];
                                if (N[Bt.if] && Bt.basisFormat.includes(ee) && !(ke && Bt.transcoderFormat.length < 2) && !(Bt.needsPowerOfTwo && !(H(me) && H(Re)))) return Ve = Bt.transcoderFormat[ke ? 1 : 0], He = Bt.engineFormat[ke ? 1 : 0], {
                                    transcoderFormat: Ve,
                                    engineFormat: He
                                }
                            }
                            return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), Ve = j.RGBA32, He = U.RGBAFormat, {
                                transcoderFormat: Ve,
                                engineFormat: He
                            }
                        }

                        function H(ee) {
                            return ee <= 2 ? !0 : (ee & ee - 1) === 0 && ee !== 0
                        }

                        function ae(ee) {
                            if (ee.length === 1) return ee[0];
                            let me = 0;
                            for (let Ve = 0; Ve < ee.length; Ve++) {
                                const He = ee[Ve];
                                me += He.byteLength
                            }
                            const Re = new Uint8Array(me);
                            let ke = 0;
                            for (let Ve = 0; Ve < ee.length; Ve++) {
                                const He = ee[Ve];
                                Re.set(He, ke), ke += He.byteLength
                            }
                            return Re
                        }
                    };
                    const B = new Set([g.RGBAFormat, g.RGFormat, g.RedFormat]), R = {
                        [v.VK_FORMAT_R32G32B32A32_SFLOAT]: g.RGBAFormat,
                        [v.VK_FORMAT_R16G16B16A16_SFLOAT]: g.RGBAFormat,
                        [v.VK_FORMAT_R8G8B8A8_UNORM]: g.RGBAFormat,
                        [v.VK_FORMAT_R8G8B8A8_SRGB]: g.RGBAFormat,
                        [v.VK_FORMAT_R32G32_SFLOAT]: g.RGFormat,
                        [v.VK_FORMAT_R16G16_SFLOAT]: g.RGFormat,
                        [v.VK_FORMAT_R8G8_UNORM]: g.RGFormat,
                        [v.VK_FORMAT_R8G8_SRGB]: g.RGFormat,
                        [v.VK_FORMAT_R32_SFLOAT]: g.RedFormat,
                        [v.VK_FORMAT_R16_SFLOAT]: g.RedFormat,
                        [v.VK_FORMAT_R8_SRGB]: g.RedFormat,
                        [v.VK_FORMAT_R8_UNORM]: g.RedFormat,
                        [v.VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: g.RGBA_ASTC_6x6_Format,
                        [v.VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: g.RGBA_ASTC_6x6_Format
                    }, I = {
                        [v.VK_FORMAT_R32G32B32A32_SFLOAT]: g.FloatType,
                        [v.VK_FORMAT_R16G16B16A16_SFLOAT]: g.HalfFloatType,
                        [v.VK_FORMAT_R8G8B8A8_UNORM]: g.UnsignedByteType,
                        [v.VK_FORMAT_R8G8B8A8_SRGB]: g.UnsignedByteType,
                        [v.VK_FORMAT_R32G32_SFLOAT]: g.FloatType,
                        [v.VK_FORMAT_R16G16_SFLOAT]: g.HalfFloatType,
                        [v.VK_FORMAT_R8G8_UNORM]: g.UnsignedByteType,
                        [v.VK_FORMAT_R8G8_SRGB]: g.UnsignedByteType,
                        [v.VK_FORMAT_R32_SFLOAT]: g.FloatType,
                        [v.VK_FORMAT_R16_SFLOAT]: g.HalfFloatType,
                        [v.VK_FORMAT_R8_SRGB]: g.UnsignedByteType,
                        [v.VK_FORMAT_R8_UNORM]: g.UnsignedByteType,
                        [v.VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: g.UnsignedByteType,
                        [v.VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: g.UnsignedByteType
                    };

                    async function L(N) {
                        const {vkFormat: F} = N;
                        if (R[F] === void 0) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
                        let V;
                        N.supercompressionScheme === v.KHR_SUPERCOMPRESSION_ZSTD && (M || (M = new Promise(async Y => {
                            const fe = new E.ZSTDDecoder;
                            await fe.init(), Y(fe)
                        })), V = await M);
                        const U = [];
                        for (let Y = 0; Y < N.levels.length; Y++) {
                            const fe = Math.max(1, N.pixelWidth >> Y), se = Math.max(1, N.pixelHeight >> Y),
                                pe = N.pixelDepth ? Math.max(1, N.pixelDepth >> Y) : 0, ue = N.levels[Y];
                            let he;
                            if (N.supercompressionScheme === v.KHR_SUPERCOMPRESSION_NONE) he = ue.levelData; else if (N.supercompressionScheme === v.KHR_SUPERCOMPRESSION_ZSTD) he = V.decode(ue.levelData, ue.uncompressedByteLength); else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                            let Z;
                            I[F] === g.FloatType ? Z = new Float32Array(he.buffer, he.byteOffset, he.byteLength / Float32Array.BYTES_PER_ELEMENT) : I[F] === g.HalfFloatType ? Z = new Uint16Array(he.buffer, he.byteOffset, he.byteLength / Uint16Array.BYTES_PER_ELEMENT) : Z = he, U.push({
                                data: Z,
                                width: fe,
                                height: se,
                                depth: pe
                            })
                        }
                        let j;
                        if (B.has(R[F])) j = N.pixelDepth === 0 ? new g.DataTexture(U[0].data, N.pixelWidth, N.pixelHeight) : new g.Data3DTexture(U[0].data, N.pixelWidth, N.pixelHeight, N.pixelDepth); else {
                            if (N.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                            j = new g.CompressedTexture(U, N.pixelWidth, N.pixelHeight)
                        }
                        return j.mipmaps = U, j.type = I[F], j.format = R[F], j.colorSpace = O(N), j.needsUpdate = !0, Promise.resolve(j)
                    }

                    function O(N) {
                        const F = N.dataFormatDescriptor[0];
                        return F.colorPrimaries === v.KHR_DF_PRIMARIES_BT709 ? F.transferFunction === v.KHR_DF_TRANSFER_SRGB ? g.SRGBColorSpace : g.LinearSRGBColorSpace : F.colorPrimaries === v.KHR_DF_PRIMARIES_DISPLAYP3 ? F.transferFunction === v.KHR_DF_TRANSFER_SRGB ? g.DisplayP3ColorSpace : g.LinearDisplayP3ColorSpace : (F.colorPrimaries === v.KHR_DF_PRIMARIES_UNSPECIFIED || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${F.colorPrimaries}"`), g.NoColorSpace)
                    }
                },
                "./node_modules/three/examples/jsm/loaders/MTLLoader.js": (m, x, h) => {
                    h.r(x), h.d(x, {MTLLoader: () => w});
                    var g = h("./node_modules/three/build/three.module.js");

                    class w extends g.Loader {
                        constructor(p) {
                            super(p)
                        }

                        load(p, C, M, b) {
                            const B = this, R = this.path === "" ? g.LoaderUtils.extractUrlBase(p) : this.path,
                                I = new g.FileLoader(this.manager);
                            I.setPath(this.path), I.setRequestHeader(this.requestHeader), I.setWithCredentials(this.withCredentials), I.load(p, function (L) {
                                try {
                                    C(B.parse(L, R))
                                } catch (O) {
                                    b ? b(O) : console.error(O), B.manager.itemError(p)
                                }
                            }, M, b)
                        }

                        setMaterialOptions(p) {
                            return this.materialOptions = p, this
                        }

                        parse(p, C) {
                            const M = p.split(`
`);
                            let b = {};
                            const B = /\s+/, R = {};
                            for (let L = 0; L < M.length; L++) {
                                let O = M[L];
                                if (O = O.trim(), O.length === 0 || O.charAt(0) === "#") continue;
                                const N = O.indexOf(" ");
                                let F = N >= 0 ? O.substring(0, N) : O;
                                F = F.toLowerCase();
                                let V = N >= 0 ? O.substring(N + 1) : "";
                                if (V = V.trim(), F === "newmtl") b = {name: V}, R[V] = b; else if (F === "ka" || F === "kd" || F === "ks" || F === "ke") {
                                    const U = V.split(B, 3);
                                    b[F] = [parseFloat(U[0]), parseFloat(U[1]), parseFloat(U[2])]
                                } else b[F] = V
                            }
                            const I = new v(this.resourcePath || C, this.materialOptions);
                            return I.setCrossOrigin(this.crossOrigin), I.setManager(this.manager), I.setMaterials(R), I
                        }
                    }

                    class v {
                        constructor(p = "", C = {}) {
                            this.baseUrl = p, this.options = C, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : g.FrontSide, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : g.RepeatWrapping
                        }

                        setCrossOrigin(p) {
                            return this.crossOrigin = p, this
                        }

                        setManager(p) {
                            this.manager = p
                        }

                        setMaterials(p) {
                            this.materialsInfo = this.convert(p), this.materials = {}, this.materialsArray = [], this.nameLookup = {}
                        }

                        convert(p) {
                            if (!this.options) return p;
                            const C = {};
                            for (const M in p) {
                                const b = p[M], B = {};
                                C[M] = B;
                                for (const R in b) {
                                    let I = !0, L = b[R];
                                    const O = R.toLowerCase();
                                    switch (O) {
                                        case"kd":
                                        case"ka":
                                        case"ks":
                                            this.options && this.options.normalizeRGB && (L = [L[0] / 255, L[1] / 255, L[2] / 255]), this.options && this.options.ignoreZeroRGBs && L[0] === 0 && L[1] === 0 && L[2] === 0 && (I = !1);
                                            break
                                    }
                                    I && (B[O] = L)
                                }
                            }
                            return C
                        }

                        preload() {
                            for (const p in this.materialsInfo) this.create(p)
                        }

                        getIndex(p) {
                            return this.nameLookup[p]
                        }

                        getAsArray() {
                            let p = 0;
                            for (const C in this.materialsInfo) this.materialsArray[p] = this.create(C), this.nameLookup[C] = p, p++;
                            return this.materialsArray
                        }

                        create(p) {
                            return this.materials[p] === void 0 && this.createMaterial_(p), this.materials[p]
                        }

                        createMaterial_(p) {
                            const C = this, M = this.materialsInfo[p], b = {name: p, side: this.side};

                            function B(I, L) {
                                return typeof L != "string" || L === "" ? "" : /^https?:\/\//i.test(L) ? L : I + L
                            }

                            function R(I, L) {
                                if (b[I]) return;
                                const O = C.getTextureParams(L, b), N = C.loadTexture(B(C.baseUrl, O.url));
                                N.repeat.copy(O.scale), N.offset.copy(O.offset), N.wrapS = C.wrap, N.wrapT = C.wrap, (I === "map" || I === "emissiveMap") && (N.colorSpace = g.SRGBColorSpace), b[I] = N
                            }

                            for (const I in M) {
                                const L = M[I];
                                let O;
                                if (L !== "") switch (I.toLowerCase()) {
                                    case"kd":
                                        b.color = new g.Color().fromArray(L).convertSRGBToLinear();
                                        break;
                                    case"ks":
                                        b.specular = new g.Color().fromArray(L).convertSRGBToLinear();
                                        break;
                                    case"ke":
                                        b.emissive = new g.Color().fromArray(L).convertSRGBToLinear();
                                        break;
                                    case"map_kd":
                                        R("map", L);
                                        break;
                                    case"map_ks":
                                        R("specularMap", L);
                                        break;
                                    case"map_ke":
                                        R("emissiveMap", L);
                                        break;
                                    case"norm":
                                        R("normalMap", L);
                                        break;
                                    case"map_bump":
                                    case"bump":
                                        R("bumpMap", L);
                                        break;
                                    case"map_d":
                                        R("alphaMap", L), b.transparent = !0;
                                        break;
                                    case"ns":
                                        b.shininess = parseFloat(L);
                                        break;
                                    case"d":
                                        O = parseFloat(L), O < 1 && (b.opacity = O, b.transparent = !0);
                                        break;
                                    case"tr":
                                        O = parseFloat(L), this.options && this.options.invertTrProperty && (O = 1 - O), O > 0 && (b.opacity = 1 - O, b.transparent = !0);
                                        break
                                }
                            }
                            return this.materials[p] = new g.MeshPhongMaterial(b), this.materials[p]
                        }

                        getTextureParams(p, C) {
                            const M = {scale: new g.Vector2(1, 1), offset: new g.Vector2(0, 0)}, b = p.split(/\s+/);
                            let B;
                            return B = b.indexOf("-bm"), B >= 0 && (C.bumpScale = parseFloat(b[B + 1]), b.splice(B, 2)), B = b.indexOf("-s"), B >= 0 && (M.scale.set(parseFloat(b[B + 1]), parseFloat(b[B + 2])), b.splice(B, 4)), B = b.indexOf("-o"), B >= 0 && (M.offset.set(parseFloat(b[B + 1]), parseFloat(b[B + 2])), b.splice(B, 4)), M.url = b.join(" ").trim(), M
                        }

                        loadTexture(p, C, M, b, B) {
                            const R = this.manager !== void 0 ? this.manager : g.DefaultLoadingManager;
                            let I = R.getHandler(p);
                            I === null && (I = new g.TextureLoader(R)), I.setCrossOrigin && I.setCrossOrigin(this.crossOrigin);
                            const L = I.load(p, M, b, B);
                            return C !== void 0 && (L.mapping = C), L
                        }
                    }
                },
                "./node_modules/three/examples/jsm/loaders/OBJLoader.js": (m, x, h) => {
                    h.r(x), h.d(x, {OBJLoader: () => N});
                    var g = h("./node_modules/three/build/three.module.js");
                    const w = /^[og]\s*(.+)?/, v = /^mtllib /, E = /^usemtl /, p = /^usemap /, C = /\s+/,
                        M = new g.Vector3, b = new g.Vector3, B = new g.Vector3, R = new g.Vector3, I = new g.Vector3,
                        L = new g.Color;

                    function O() {
                        const F = {
                            objects: [],
                            object: {},
                            vertices: [],
                            normals: [],
                            colors: [],
                            uvs: [],
                            materials: {},
                            materialLibraries: [],
                            startObject: function (V, U) {
                                if (this.object && this.object.fromDeclaration === !1) {
                                    this.object.name = V, this.object.fromDeclaration = U !== !1;
                                    return
                                }
                                const j = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
                                if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
                                    name: V || "",
                                    fromDeclaration: U !== !1,
                                    geometry: {vertices: [], normals: [], colors: [], uvs: [], hasUVIndices: !1},
                                    materials: [],
                                    smooth: !0,
                                    startMaterial: function (Y, fe) {
                                        const se = this._finalize(!1);
                                        se && (se.inherited || se.groupCount <= 0) && this.materials.splice(se.index, 1);
                                        const pe = {
                                            index: this.materials.length,
                                            name: Y || "",
                                            mtllib: Array.isArray(fe) && fe.length > 0 ? fe[fe.length - 1] : "",
                                            smooth: se !== void 0 ? se.smooth : this.smooth,
                                            groupStart: se !== void 0 ? se.groupEnd : 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1,
                                            clone: function (ue) {
                                                const he = {
                                                    index: typeof ue == "number" ? ue : this.index,
                                                    name: this.name,
                                                    mtllib: this.mtllib,
                                                    smooth: this.smooth,
                                                    groupStart: 0,
                                                    groupEnd: -1,
                                                    groupCount: -1,
                                                    inherited: !1
                                                };
                                                return he.clone = this.clone.bind(he), he
                                            }
                                        };
                                        return this.materials.push(pe), pe
                                    },
                                    currentMaterial: function () {
                                        if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                                    },
                                    _finalize: function (Y) {
                                        const fe = this.currentMaterial();
                                        if (fe && fe.groupEnd === -1 && (fe.groupEnd = this.geometry.vertices.length / 3, fe.groupCount = fe.groupEnd - fe.groupStart, fe.inherited = !1), Y && this.materials.length > 1) for (let se = this.materials.length - 1; se >= 0; se--) this.materials[se].groupCount <= 0 && this.materials.splice(se, 1);
                                        return Y && this.materials.length === 0 && this.materials.push({
                                            name: "",
                                            smooth: this.smooth
                                        }), fe
                                    }
                                }, j && j.name && typeof j.clone == "function") {
                                    const Y = j.clone(0);
                                    Y.inherited = !0, this.object.materials.push(Y)
                                }
                                this.objects.push(this.object)
                            },
                            finalize: function () {
                                this.object && typeof this.object._finalize == "function" && this.object._finalize(!0)
                            },
                            parseVertexIndex: function (V, U) {
                                const j = parseInt(V, 10);
                                return (j >= 0 ? j - 1 : j + U / 3) * 3
                            },
                            parseNormalIndex: function (V, U) {
                                const j = parseInt(V, 10);
                                return (j >= 0 ? j - 1 : j + U / 3) * 3
                            },
                            parseUVIndex: function (V, U) {
                                const j = parseInt(V, 10);
                                return (j >= 0 ? j - 1 : j + U / 2) * 2
                            },
                            addVertex: function (V, U, j) {
                                const Y = this.vertices, fe = this.object.geometry.vertices;
                                fe.push(Y[V + 0], Y[V + 1], Y[V + 2]), fe.push(Y[U + 0], Y[U + 1], Y[U + 2]), fe.push(Y[j + 0], Y[j + 1], Y[j + 2])
                            },
                            addVertexPoint: function (V) {
                                const U = this.vertices;
                                this.object.geometry.vertices.push(U[V + 0], U[V + 1], U[V + 2])
                            },
                            addVertexLine: function (V) {
                                const U = this.vertices;
                                this.object.geometry.vertices.push(U[V + 0], U[V + 1], U[V + 2])
                            },
                            addNormal: function (V, U, j) {
                                const Y = this.normals, fe = this.object.geometry.normals;
                                fe.push(Y[V + 0], Y[V + 1], Y[V + 2]), fe.push(Y[U + 0], Y[U + 1], Y[U + 2]), fe.push(Y[j + 0], Y[j + 1], Y[j + 2])
                            },
                            addFaceNormal: function (V, U, j) {
                                const Y = this.vertices, fe = this.object.geometry.normals;
                                M.fromArray(Y, V), b.fromArray(Y, U), B.fromArray(Y, j), I.subVectors(B, b), R.subVectors(M, b), I.cross(R), I.normalize(), fe.push(I.x, I.y, I.z), fe.push(I.x, I.y, I.z), fe.push(I.x, I.y, I.z)
                            },
                            addColor: function (V, U, j) {
                                const Y = this.colors, fe = this.object.geometry.colors;
                                Y[V] !== void 0 && fe.push(Y[V + 0], Y[V + 1], Y[V + 2]), Y[U] !== void 0 && fe.push(Y[U + 0], Y[U + 1], Y[U + 2]), Y[j] !== void 0 && fe.push(Y[j + 0], Y[j + 1], Y[j + 2])
                            },
                            addUV: function (V, U, j) {
                                const Y = this.uvs, fe = this.object.geometry.uvs;
                                fe.push(Y[V + 0], Y[V + 1]), fe.push(Y[U + 0], Y[U + 1]), fe.push(Y[j + 0], Y[j + 1])
                            },
                            addDefaultUV: function () {
                                const V = this.object.geometry.uvs;
                                V.push(0, 0), V.push(0, 0), V.push(0, 0)
                            },
                            addUVLine: function (V) {
                                const U = this.uvs;
                                this.object.geometry.uvs.push(U[V + 0], U[V + 1])
                            },
                            addFace: function (V, U, j, Y, fe, se, pe, ue, he) {
                                const Z = this.vertices.length;
                                let H = this.parseVertexIndex(V, Z), ae = this.parseVertexIndex(U, Z),
                                    ee = this.parseVertexIndex(j, Z);
                                if (this.addVertex(H, ae, ee), this.addColor(H, ae, ee), pe !== void 0 && pe !== "") {
                                    const me = this.normals.length;
                                    H = this.parseNormalIndex(pe, me), ae = this.parseNormalIndex(ue, me), ee = this.parseNormalIndex(he, me), this.addNormal(H, ae, ee)
                                } else this.addFaceNormal(H, ae, ee);
                                if (Y !== void 0 && Y !== "") {
                                    const me = this.uvs.length;
                                    H = this.parseUVIndex(Y, me), ae = this.parseUVIndex(fe, me), ee = this.parseUVIndex(se, me), this.addUV(H, ae, ee), this.object.geometry.hasUVIndices = !0
                                } else this.addDefaultUV()
                            },
                            addPointGeometry: function (V) {
                                this.object.geometry.type = "Points";
                                const U = this.vertices.length;
                                for (let j = 0, Y = V.length; j < Y; j++) {
                                    const fe = this.parseVertexIndex(V[j], U);
                                    this.addVertexPoint(fe), this.addColor(fe)
                                }
                            },
                            addLineGeometry: function (V, U) {
                                this.object.geometry.type = "Line";
                                const j = this.vertices.length, Y = this.uvs.length;
                                for (let fe = 0, se = V.length; fe < se; fe++) this.addVertexLine(this.parseVertexIndex(V[fe], j));
                                for (let fe = 0, se = U.length; fe < se; fe++) this.addUVLine(this.parseUVIndex(U[fe], Y))
                            }
                        };
                        return F.startObject("", !1), F
                    }

                    class N extends g.Loader {
                        constructor(V) {
                            super(V), this.materials = null
                        }

                        load(V, U, j, Y) {
                            const fe = this, se = new g.FileLoader(this.manager);
                            se.setPath(this.path), se.setRequestHeader(this.requestHeader), se.setWithCredentials(this.withCredentials), se.load(V, function (pe) {
                                try {
                                    U(fe.parse(pe))
                                } catch (ue) {
                                    Y ? Y(ue) : console.error(ue), fe.manager.itemError(V)
                                }
                            }, j, Y)
                        }

                        setMaterials(V) {
                            return this.materials = V, this
                        }

                        parse(V) {
                            const U = new O;
                            V.indexOf(`\r
`) !== -1 && (V = V.replace(/\r\n/g, `
`)), V.indexOf(`\\
`) !== -1 && (V = V.replace(/\\\n/g, ""));
                            const j = V.split(`
`);
                            let Y = [];
                            for (let pe = 0, ue = j.length; pe < ue; pe++) {
                                const he = j[pe].trimStart();
                                if (he.length === 0) continue;
                                const Z = he.charAt(0);
                                if (Z !== "#") if (Z === "v") {
                                    const H = he.split(C);
                                    switch (H[0]) {
                                        case"v":
                                            U.vertices.push(parseFloat(H[1]), parseFloat(H[2]), parseFloat(H[3])), H.length >= 7 ? (L.setRGB(parseFloat(H[4]), parseFloat(H[5]), parseFloat(H[6])).convertSRGBToLinear(), U.colors.push(L.r, L.g, L.b)) : U.colors.push(void 0, void 0, void 0);
                                            break;
                                        case"vn":
                                            U.normals.push(parseFloat(H[1]), parseFloat(H[2]), parseFloat(H[3]));
                                            break;
                                        case"vt":
                                            U.uvs.push(parseFloat(H[1]), parseFloat(H[2]));
                                            break
                                    }
                                } else if (Z === "f") {
                                    const ae = he.slice(1).trim().split(C), ee = [];
                                    for (let Re = 0, ke = ae.length; Re < ke; Re++) {
                                        const Ve = ae[Re];
                                        if (Ve.length > 0) {
                                            const He = Ve.split("/");
                                            ee.push(He)
                                        }
                                    }
                                    const me = ee[0];
                                    for (let Re = 1, ke = ee.length - 1; Re < ke; Re++) {
                                        const Ve = ee[Re], He = ee[Re + 1];
                                        U.addFace(me[0], Ve[0], He[0], me[1], Ve[1], He[1], me[2], Ve[2], He[2])
                                    }
                                } else if (Z === "l") {
                                    const H = he.substring(1).trim().split(" ");
                                    let ae = [];
                                    const ee = [];
                                    if (he.indexOf("/") === -1) ae = H; else for (let me = 0, Re = H.length; me < Re; me++) {
                                        const ke = H[me].split("/");
                                        ke[0] !== "" && ae.push(ke[0]), ke[1] !== "" && ee.push(ke[1])
                                    }
                                    U.addLineGeometry(ae, ee)
                                } else if (Z === "p") {
                                    const ae = he.slice(1).trim().split(" ");
                                    U.addPointGeometry(ae)
                                } else if ((Y = w.exec(he)) !== null) {
                                    const H = (" " + Y[0].slice(1).trim()).slice(1);
                                    U.startObject(H)
                                } else if (E.test(he)) U.object.startMaterial(he.substring(7).trim(), U.materialLibraries); else if (v.test(he)) U.materialLibraries.push(he.substring(7).trim()); else if (p.test(he)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'); else if (Z === "s") {
                                    if (Y = he.split(" "), Y.length > 1) {
                                        const ae = Y[1].trim().toLowerCase();
                                        U.object.smooth = ae !== "0" && ae !== "off"
                                    } else U.object.smooth = !0;
                                    const H = U.object.currentMaterial();
                                    H && (H.smooth = U.object.smooth)
                                } else {
                                    if (he === "\0") continue;
                                    console.warn('THREE.OBJLoader: Unexpected line: "' + he + '"')
                                }
                            }
                            U.finalize();
                            const fe = new g.Group;
                            if (fe.materialLibraries = [].concat(U.materialLibraries), !(U.objects.length === 1 && U.objects[0].geometry.vertices.length === 0) === !0) for (let pe = 0, ue = U.objects.length; pe < ue; pe++) {
                                const he = U.objects[pe], Z = he.geometry, H = he.materials, ae = Z.type === "Line",
                                    ee = Z.type === "Points";
                                let me = !1;
                                if (Z.vertices.length === 0) continue;
                                const Re = new g.BufferGeometry;
                                Re.setAttribute("position", new g.Float32BufferAttribute(Z.vertices, 3)), Z.normals.length > 0 && Re.setAttribute("normal", new g.Float32BufferAttribute(Z.normals, 3)), Z.colors.length > 0 && (me = !0, Re.setAttribute("color", new g.Float32BufferAttribute(Z.colors, 3))), Z.hasUVIndices === !0 && Re.setAttribute("uv", new g.Float32BufferAttribute(Z.uvs, 2));
                                const ke = [];
                                for (let He = 0, ot = H.length; He < ot; He++) {
                                    const gt = H[He], Bt = gt.name + "_" + gt.smooth + "_" + me;
                                    let Rt = U.materials[Bt];
                                    if (this.materials !== null) {
                                        if (Rt = this.materials.create(gt.name), ae && Rt && !(Rt instanceof g.LineBasicMaterial)) {
                                            const an = new g.LineBasicMaterial;
                                            g.Material.prototype.copy.call(an, Rt), an.color.copy(Rt.color), Rt = an
                                        } else if (ee && Rt && !(Rt instanceof g.PointsMaterial)) {
                                            const an = new g.PointsMaterial({size: 10, sizeAttenuation: !1});
                                            g.Material.prototype.copy.call(an, Rt), an.color.copy(Rt.color), an.map = Rt.map, Rt = an
                                        }
                                    }
                                    Rt === void 0 && (ae ? Rt = new g.LineBasicMaterial : ee ? Rt = new g.PointsMaterial({
                                        size: 1,
                                        sizeAttenuation: !1
                                    }) : Rt = new g.MeshPhongMaterial, Rt.name = gt.name, Rt.flatShading = !gt.smooth, Rt.vertexColors = me, U.materials[Bt] = Rt), ke.push(Rt)
                                }
                                let Ve;
                                if (ke.length > 1) {
                                    for (let He = 0, ot = H.length; He < ot; He++) {
                                        const gt = H[He];
                                        Re.addGroup(gt.groupStart, gt.groupCount, He)
                                    }
                                    ae ? Ve = new g.LineSegments(Re, ke) : ee ? Ve = new g.Points(Re, ke) : Ve = new g.Mesh(Re, ke)
                                } else ae ? Ve = new g.LineSegments(Re, ke[0]) : ee ? Ve = new g.Points(Re, ke[0]) : Ve = new g.Mesh(Re, ke[0]);
                                Ve.name = he.name, fe.add(Ve)
                            } else if (U.vertices.length > 0) {
                                const pe = new g.PointsMaterial({size: 1, sizeAttenuation: !1}),
                                    ue = new g.BufferGeometry;
                                ue.setAttribute("position", new g.Float32BufferAttribute(U.vertices, 3)), U.colors.length > 0 && U.colors[0] !== void 0 && (ue.setAttribute("color", new g.Float32BufferAttribute(U.colors, 3)), pe.vertexColors = !0);
                                const he = new g.Points(ue, pe);
                                fe.add(he)
                            }
                            return fe
                        }
                    }
                },
                "./node_modules/three/examples/jsm/math/OBB.js": (m, x, h) => {
                    h.r(x), h.d(x, {OBB: () => j});
                    var g = h("./node_modules/three/build/three.module.js");
                    const w = {c: null, u: [new g.Vector3, new g.Vector3, new g.Vector3], e: []},
                        v = {c: null, u: [new g.Vector3, new g.Vector3, new g.Vector3], e: []}, E = [[], [], []],
                        p = [[], [], []], C = [], M = new g.Vector3, b = new g.Vector3, B = new g.Vector3,
                        R = new g.Vector3, I = new g.Vector3, L = new g.Vector3, O = new g.Matrix3, N = new g.Box3,
                        F = new g.Matrix4, V = new g.Matrix4, U = new g.Ray;

                    class j {
                        constructor(se = new g.Vector3, pe = new g.Vector3, ue = new g.Matrix3) {
                            this.center = se, this.halfSize = pe, this.rotation = ue
                        }

                        set(se, pe, ue) {
                            return this.center = se, this.halfSize = pe, this.rotation = ue, this
                        }

                        copy(se) {
                            return this.center.copy(se.center), this.halfSize.copy(se.halfSize), this.rotation.copy(se.rotation), this
                        }

                        clone() {
                            return new this.constructor().copy(this)
                        }

                        getSize(se) {
                            return se.copy(this.halfSize).multiplyScalar(2)
                        }

                        clampPoint(se, pe) {
                            const ue = this.halfSize;
                            R.subVectors(se, this.center), this.rotation.extractBasis(M, b, B), pe.copy(this.center);
                            const he = g.MathUtils.clamp(R.dot(M), -ue.x, ue.x);
                            pe.add(M.multiplyScalar(he));
                            const Z = g.MathUtils.clamp(R.dot(b), -ue.y, ue.y);
                            pe.add(b.multiplyScalar(Z));
                            const H = g.MathUtils.clamp(R.dot(B), -ue.z, ue.z);
                            return pe.add(B.multiplyScalar(H)), pe
                        }

                        containsPoint(se) {
                            return R.subVectors(se, this.center), this.rotation.extractBasis(M, b, B), Math.abs(R.dot(M)) <= this.halfSize.x && Math.abs(R.dot(b)) <= this.halfSize.y && Math.abs(R.dot(B)) <= this.halfSize.z
                        }

                        intersectsBox3(se) {
                            return this.intersectsOBB(Y.fromBox3(se))
                        }

                        intersectsSphere(se) {
                            return this.clampPoint(se.center, L), L.distanceToSquared(se.center) <= se.radius * se.radius
                        }

                        intersectsOBB(se, pe = Number.EPSILON) {
                            w.c = this.center, w.e[0] = this.halfSize.x, w.e[1] = this.halfSize.y, w.e[2] = this.halfSize.z, this.rotation.extractBasis(w.u[0], w.u[1], w.u[2]), v.c = se.center, v.e[0] = se.halfSize.x, v.e[1] = se.halfSize.y, v.e[2] = se.halfSize.z, se.rotation.extractBasis(v.u[0], v.u[1], v.u[2]);
                            for (let Z = 0; Z < 3; Z++) for (let H = 0; H < 3; H++) E[Z][H] = w.u[Z].dot(v.u[H]);
                            R.subVectors(v.c, w.c), C[0] = R.dot(w.u[0]), C[1] = R.dot(w.u[1]), C[2] = R.dot(w.u[2]);
                            for (let Z = 0; Z < 3; Z++) for (let H = 0; H < 3; H++) p[Z][H] = Math.abs(E[Z][H]) + pe;
                            let ue, he;
                            for (let Z = 0; Z < 3; Z++) if (ue = w.e[Z], he = v.e[0] * p[Z][0] + v.e[1] * p[Z][1] + v.e[2] * p[Z][2], Math.abs(C[Z]) > ue + he) return !1;
                            for (let Z = 0; Z < 3; Z++) if (ue = w.e[0] * p[0][Z] + w.e[1] * p[1][Z] + w.e[2] * p[2][Z], he = v.e[Z], Math.abs(C[0] * E[0][Z] + C[1] * E[1][Z] + C[2] * E[2][Z]) > ue + he) return !1;
                            return ue = w.e[1] * p[2][0] + w.e[2] * p[1][0], he = v.e[1] * p[0][2] + v.e[2] * p[0][1], !(Math.abs(C[2] * E[1][0] - C[1] * E[2][0]) > ue + he || (ue = w.e[1] * p[2][1] + w.e[2] * p[1][1], he = v.e[0] * p[0][2] + v.e[2] * p[0][0], Math.abs(C[2] * E[1][1] - C[1] * E[2][1]) > ue + he) || (ue = w.e[1] * p[2][2] + w.e[2] * p[1][2], he = v.e[0] * p[0][1] + v.e[1] * p[0][0], Math.abs(C[2] * E[1][2] - C[1] * E[2][2]) > ue + he) || (ue = w.e[0] * p[2][0] + w.e[2] * p[0][0], he = v.e[1] * p[1][2] + v.e[2] * p[1][1], Math.abs(C[0] * E[2][0] - C[2] * E[0][0]) > ue + he) || (ue = w.e[0] * p[2][1] + w.e[2] * p[0][1], he = v.e[0] * p[1][2] + v.e[2] * p[1][0], Math.abs(C[0] * E[2][1] - C[2] * E[0][1]) > ue + he) || (ue = w.e[0] * p[2][2] + w.e[2] * p[0][2], he = v.e[0] * p[1][1] + v.e[1] * p[1][0], Math.abs(C[0] * E[2][2] - C[2] * E[0][2]) > ue + he) || (ue = w.e[0] * p[1][0] + w.e[1] * p[0][0], he = v.e[1] * p[2][2] + v.e[2] * p[2][1], Math.abs(C[1] * E[0][0] - C[0] * E[1][0]) > ue + he) || (ue = w.e[0] * p[1][1] + w.e[1] * p[0][1], he = v.e[0] * p[2][2] + v.e[2] * p[2][0], Math.abs(C[1] * E[0][1] - C[0] * E[1][1]) > ue + he) || (ue = w.e[0] * p[1][2] + w.e[1] * p[0][2], he = v.e[0] * p[2][1] + v.e[1] * p[2][0], Math.abs(C[1] * E[0][2] - C[0] * E[1][2]) > ue + he))
                        }

                        intersectsPlane(se) {
                            this.rotation.extractBasis(M, b, B);
                            const pe = this.halfSize.x * Math.abs(se.normal.dot(M)) + this.halfSize.y * Math.abs(se.normal.dot(b)) + this.halfSize.z * Math.abs(se.normal.dot(B)),
                                ue = se.normal.dot(this.center) - se.constant;
                            return Math.abs(ue) <= pe
                        }

                        intersectRay(se, pe) {
                            return this.getSize(I), N.setFromCenterAndSize(R.set(0, 0, 0), I), F.setFromMatrix3(this.rotation), F.setPosition(this.center), V.copy(F).invert(), U.copy(se).applyMatrix4(V), U.intersectBox(N, pe) ? pe.applyMatrix4(F) : null
                        }

                        intersectsRay(se) {
                            return this.intersectRay(se, R) !== null
                        }

                        fromBox3(se) {
                            return se.getCenter(this.center), se.getSize(this.halfSize).multiplyScalar(.5), this.rotation.identity(), this
                        }

                        equals(se) {
                            return se.center.equals(this.center) && se.halfSize.equals(this.halfSize) && se.rotation.equals(this.rotation)
                        }

                        applyMatrix4(se) {
                            const pe = se.elements;
                            let ue = R.set(pe[0], pe[1], pe[2]).length();
                            const he = R.set(pe[4], pe[5], pe[6]).length(), Z = R.set(pe[8], pe[9], pe[10]).length();
                            se.determinant() < 0 && (ue = -ue), O.setFromMatrix4(se);
                            const ae = 1 / ue, ee = 1 / he, me = 1 / Z;
                            return O.elements[0] *= ae, O.elements[1] *= ae, O.elements[2] *= ae, O.elements[3] *= ee, O.elements[4] *= ee, O.elements[5] *= ee, O.elements[6] *= me, O.elements[7] *= me, O.elements[8] *= me, this.rotation.multiply(O), this.halfSize.x *= ue, this.halfSize.y *= he, this.halfSize.z *= Z, R.setFromMatrixPosition(se), this.center.add(R), this
                        }
                    }

                    const Y = new j
                },
                "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js": (m, x, h) => {
                    h.r(x), h.d(x, {
                        computeMikkTSpaceTangents: () => w,
                        computeMorphedAttributes: () => L,
                        deepCloneAttribute: () => p,
                        deinterleaveAttribute: () => M,
                        deinterleaveGeometry: () => b,
                        estimateBytesUsed: () => B,
                        interleaveAttributes: () => C,
                        mergeAttributes: () => E,
                        mergeGeometries: () => v,
                        mergeGroups: () => O,
                        mergeVertices: () => R,
                        toCreasedNormals: () => N,
                        toTrianglesDrawMode: () => I
                    });
                    var g = h("./node_modules/three/build/three.module.js");

                    function w(F, V, U = !0) {
                        if (!V || !V.isReady) throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
                        if (!F.hasAttribute("position") || !F.hasAttribute("normal") || !F.hasAttribute("uv")) throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');

                        function j(se) {
                            if (se.normalized || se.isInterleavedBufferAttribute) {
                                const pe = new Float32Array(se.count * se.itemSize);
                                for (let ue = 0, he = 0; ue < se.count; ue++) pe[he++] = se.getX(ue), pe[he++] = se.getY(ue), se.itemSize > 2 && (pe[he++] = se.getZ(ue));
                                return pe
                            }
                            return se.array instanceof Float32Array ? se.array : new Float32Array(se.array)
                        }

                        const Y = F.index ? F.toNonIndexed() : F,
                            fe = V.generateTangents(j(Y.attributes.position), j(Y.attributes.normal), j(Y.attributes.uv));
                        if (U) for (let se = 3; se < fe.length; se += 4) fe[se] *= -1;
                        return Y.setAttribute("tangent", new g.BufferAttribute(fe, 4)), F !== Y && F.copy(Y), F
                    }

                    function v(F, V = !1) {
                        const U = F[0].index !== null, j = new Set(Object.keys(F[0].attributes)),
                            Y = new Set(Object.keys(F[0].morphAttributes)), fe = {}, se = {},
                            pe = F[0].morphTargetsRelative, ue = new g.BufferGeometry;
                        let he = 0;
                        for (let Z = 0; Z < F.length; ++Z) {
                            const H = F[Z];
                            let ae = 0;
                            if (U !== (H.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Z + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
                            for (const ee in H.attributes) {
                                if (!j.has(ee)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Z + '. All geometries must have compatible attributes; make sure "' + ee + '" attribute exists among all geometries, or in none of them.'), null;
                                fe[ee] === void 0 && (fe[ee] = []), fe[ee].push(H.attributes[ee]), ae++
                            }
                            if (ae !== j.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Z + ". Make sure all geometries have the same number of attributes."), null;
                            if (pe !== H.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Z + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
                            for (const ee in H.morphAttributes) {
                                if (!Y.has(ee)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Z + ".  .morphAttributes must be consistent throughout all geometries."), null;
                                se[ee] === void 0 && (se[ee] = []), se[ee].push(H.morphAttributes[ee])
                            }
                            if (V) {
                                let ee;
                                if (U) ee = H.index.count; else if (H.attributes.position !== void 0) ee = H.attributes.position.count; else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + Z + ". The geometry must have either an index or a position attribute"), null;
                                ue.addGroup(he, ee, Z), he += ee
                            }
                        }
                        if (U) {
                            let Z = 0;
                            const H = [];
                            for (let ae = 0; ae < F.length; ++ae) {
                                const ee = F[ae].index;
                                for (let me = 0; me < ee.count; ++me) H.push(ee.getX(me) + Z);
                                Z += F[ae].attributes.position.count
                            }
                            ue.setIndex(H)
                        }
                        for (const Z in fe) {
                            const H = E(fe[Z]);
                            if (!H) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + Z + " attribute."), null;
                            ue.setAttribute(Z, H)
                        }
                        for (const Z in se) {
                            const H = se[Z][0].length;
                            if (H === 0) break;
                            ue.morphAttributes = ue.morphAttributes || {}, ue.morphAttributes[Z] = [];
                            for (let ae = 0; ae < H; ++ae) {
                                const ee = [];
                                for (let Re = 0; Re < se[Z].length; ++Re) ee.push(se[Z][Re][ae]);
                                const me = E(ee);
                                if (!me) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + Z + " morphAttribute."), null;
                                ue.morphAttributes[Z].push(me)
                            }
                        }
                        return ue
                    }

                    function E(F) {
                        let V, U, j, Y = -1, fe = 0;
                        for (let he = 0; he < F.length; ++he) {
                            const Z = F[he];
                            if (V === void 0 && (V = Z.array.constructor), V !== Z.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
                            if (U === void 0 && (U = Z.itemSize), U !== Z.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
                            if (j === void 0 && (j = Z.normalized), j !== Z.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
                            if (Y === -1 && (Y = Z.gpuType), Y !== Z.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
                            fe += Z.count * U
                        }
                        const se = new V(fe), pe = new g.BufferAttribute(se, U, j);
                        let ue = 0;
                        for (let he = 0; he < F.length; ++he) {
                            const Z = F[he];
                            if (Z.isInterleavedBufferAttribute) {
                                const H = ue / U;
                                for (let ae = 0, ee = Z.count; ae < ee; ae++) for (let me = 0; me < U; me++) {
                                    const Re = Z.getComponent(ae, me);
                                    pe.setComponent(ae + H, me, Re)
                                }
                            } else se.set(Z.array, ue);
                            ue += Z.count * U
                        }
                        return Y !== void 0 && (pe.gpuType = Y), pe
                    }

                    function p(F) {
                        return F.isInstancedInterleavedBufferAttribute || F.isInterleavedBufferAttribute ? M(F) : F.isInstancedBufferAttribute ? new g.InstancedBufferAttribute().copy(F) : new g.BufferAttribute().copy(F)
                    }

                    function C(F) {
                        let V, U = 0, j = 0;
                        for (let he = 0, Z = F.length; he < Z; ++he) {
                            const H = F[he];
                            if (V === void 0 && (V = H.array.constructor), V !== H.array.constructor) return console.error("AttributeBuffers of different types cannot be interleaved"), null;
                            U += H.array.length, j += H.itemSize
                        }
                        const Y = new g.InterleavedBuffer(new V(U), j);
                        let fe = 0;
                        const se = [], pe = ["getX", "getY", "getZ", "getW"], ue = ["setX", "setY", "setZ", "setW"];
                        for (let he = 0, Z = F.length; he < Z; he++) {
                            const H = F[he], ae = H.itemSize, ee = H.count,
                                me = new g.InterleavedBufferAttribute(Y, ae, fe, H.normalized);
                            se.push(me), fe += ae;
                            for (let Re = 0; Re < ee; Re++) for (let ke = 0; ke < ae; ke++) me[ue[ke]](Re, H[pe[ke]](Re))
                        }
                        return se
                    }

                    function M(F) {
                        const V = F.data.array.constructor, U = F.count, j = F.itemSize, Y = F.normalized,
                            fe = new V(U * j);
                        let se;
                        F.isInstancedInterleavedBufferAttribute ? se = new g.InstancedBufferAttribute(fe, j, Y, F.meshPerAttribute) : se = new g.BufferAttribute(fe, j, Y);
                        for (let pe = 0; pe < U; pe++) se.setX(pe, F.getX(pe)), j >= 2 && se.setY(pe, F.getY(pe)), j >= 3 && se.setZ(pe, F.getZ(pe)), j >= 4 && se.setW(pe, F.getW(pe));
                        return se
                    }

                    function b(F) {
                        const V = F.attributes, U = F.morphTargets, j = new Map;
                        for (const Y in V) {
                            const fe = V[Y];
                            fe.isInterleavedBufferAttribute && (j.has(fe) || j.set(fe, M(fe)), V[Y] = j.get(fe))
                        }
                        for (const Y in U) {
                            const fe = U[Y];
                            fe.isInterleavedBufferAttribute && (j.has(fe) || j.set(fe, M(fe)), U[Y] = j.get(fe))
                        }
                    }

                    function B(F) {
                        let V = 0;
                        for (const j in F.attributes) {
                            const Y = F.getAttribute(j);
                            V += Y.count * Y.itemSize * Y.array.BYTES_PER_ELEMENT
                        }
                        const U = F.getIndex();
                        return V += U ? U.count * U.itemSize * U.array.BYTES_PER_ELEMENT : 0, V
                    }

                    function R(F, V = 1e-4) {
                        V = Math.max(V, Number.EPSILON);
                        const U = {}, j = F.getIndex(), Y = F.getAttribute("position"), fe = j ? j.count : Y.count;
                        let se = 0;
                        const pe = Object.keys(F.attributes), ue = {}, he = {}, Z = [],
                            H = ["getX", "getY", "getZ", "getW"], ae = ["setX", "setY", "setZ", "setW"];
                        for (let He = 0, ot = pe.length; He < ot; He++) {
                            const gt = pe[He], Bt = F.attributes[gt];
                            ue[gt] = new g.BufferAttribute(new Bt.array.constructor(Bt.count * Bt.itemSize), Bt.itemSize, Bt.normalized);
                            const Rt = F.morphAttributes[gt];
                            Rt && (he[gt] = new g.BufferAttribute(new Rt.array.constructor(Rt.count * Rt.itemSize), Rt.itemSize, Rt.normalized))
                        }
                        const ee = V * .5, me = Math.log10(1 / V), Re = Math.pow(10, me), ke = ee * Re;
                        for (let He = 0; He < fe; He++) {
                            const ot = j ? j.getX(He) : He;
                            let gt = "";
                            for (let Bt = 0, Rt = pe.length; Bt < Rt; Bt++) {
                                const an = pe[Bt], En = F.getAttribute(an), Nn = En.itemSize;
                                for (let oi = 0; oi < Nn; oi++) gt += `${~~(En[H[oi]](ot) * Re + ke)},`
                            }
                            if (gt in U) Z.push(U[gt]); else {
                                for (let Bt = 0, Rt = pe.length; Bt < Rt; Bt++) {
                                    const an = pe[Bt], En = F.getAttribute(an), Nn = F.morphAttributes[an],
                                        oi = En.itemSize, pi = ue[an], hi = he[an];
                                    for (let Vn = 0; Vn < oi; Vn++) {
                                        const yi = H[Vn], nr = ae[Vn];
                                        if (pi[nr](se, En[yi](ot)), Nn) for (let Oi = 0, Rr = Nn.length; Oi < Rr; Oi++) hi[Oi][nr](se, Nn[Oi][yi](ot))
                                    }
                                }
                                U[gt] = se, Z.push(se), se++
                            }
                        }
                        const Ve = F.clone();
                        for (const He in F.attributes) {
                            const ot = ue[He];
                            if (Ve.setAttribute(He, new g.BufferAttribute(ot.array.slice(0, se * ot.itemSize), ot.itemSize, ot.normalized)), He in he) for (let gt = 0; gt < he[He].length; gt++) {
                                const Bt = he[He][gt];
                                Ve.morphAttributes[He][gt] = new g.BufferAttribute(Bt.array.slice(0, se * Bt.itemSize), Bt.itemSize, Bt.normalized)
                            }
                        }
                        return Ve.setIndex(Z), Ve
                    }

                    function I(F, V) {
                        if (V === g.TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), F;
                        if (V === g.TriangleFanDrawMode || V === g.TriangleStripDrawMode) {
                            let U = F.getIndex();
                            if (U === null) {
                                const se = [], pe = F.getAttribute("position");
                                if (pe !== void 0) {
                                    for (let ue = 0; ue < pe.count; ue++) se.push(ue);
                                    F.setIndex(se), U = F.getIndex()
                                } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), F
                            }
                            const j = U.count - 2, Y = [];
                            if (V === g.TriangleFanDrawMode) for (let se = 1; se <= j; se++) Y.push(U.getX(0)), Y.push(U.getX(se)), Y.push(U.getX(se + 1)); else for (let se = 0; se < j; se++) se % 2 === 0 ? (Y.push(U.getX(se)), Y.push(U.getX(se + 1)), Y.push(U.getX(se + 2))) : (Y.push(U.getX(se + 2)), Y.push(U.getX(se + 1)), Y.push(U.getX(se)));
                            Y.length / 3 !== j && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                            const fe = F.clone();
                            return fe.setIndex(Y), fe.clearGroups(), fe
                        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", V), F
                    }

                    function L(F) {
                        const V = new g.Vector3, U = new g.Vector3, j = new g.Vector3, Y = new g.Vector3,
                            fe = new g.Vector3, se = new g.Vector3, pe = new g.Vector3, ue = new g.Vector3,
                            he = new g.Vector3;

                        function Z(Pi, Br, cr, ss, Nr, ir, jt, Se) {
                            V.fromBufferAttribute(Br, Nr), U.fromBufferAttribute(Br, ir), j.fromBufferAttribute(Br, jt);
                            const _e = Pi.morphTargetInfluences;
                            if (cr && _e) {
                                pe.set(0, 0, 0), ue.set(0, 0, 0), he.set(0, 0, 0);
                                for (let Ge = 0, Le = cr.length; Ge < Le; Ge++) {
                                    const Ue = _e[Ge], Qe = cr[Ge];
                                    Ue !== 0 && (Y.fromBufferAttribute(Qe, Nr), fe.fromBufferAttribute(Qe, ir), se.fromBufferAttribute(Qe, jt), ss ? (pe.addScaledVector(Y, Ue), ue.addScaledVector(fe, Ue), he.addScaledVector(se, Ue)) : (pe.addScaledVector(Y.sub(V), Ue), ue.addScaledVector(fe.sub(U), Ue), he.addScaledVector(se.sub(j), Ue)))
                                }
                                V.add(pe), U.add(ue), j.add(he)
                            }
                            Pi.isSkinnedMesh && (Pi.applyBoneTransform(Nr, V), Pi.applyBoneTransform(ir, U), Pi.applyBoneTransform(jt, j)), Se[Nr * 3 + 0] = V.x, Se[Nr * 3 + 1] = V.y, Se[Nr * 3 + 2] = V.z, Se[ir * 3 + 0] = U.x, Se[ir * 3 + 1] = U.y, Se[ir * 3 + 2] = U.z, Se[jt * 3 + 0] = j.x, Se[jt * 3 + 1] = j.y, Se[jt * 3 + 2] = j.z
                        }

                        const H = F.geometry, ae = F.material;
                        let ee, me, Re;
                        const ke = H.index, Ve = H.attributes.position, He = H.morphAttributes.position,
                            ot = H.morphTargetsRelative, gt = H.attributes.normal, Bt = H.morphAttributes.position,
                            Rt = H.groups, an = H.drawRange;
                        let En, Nn, oi, pi, hi, Vn, yi;
                        const nr = new Float32Array(Ve.count * Ve.itemSize),
                            Oi = new Float32Array(gt.count * gt.itemSize);
                        if (ke !== null) if (Array.isArray(ae)) for (En = 0, oi = Rt.length; En < oi; En++) for (hi = Rt[En], Vn = Math.max(hi.start, an.start), yi = Math.min(hi.start + hi.count, an.start + an.count), Nn = Vn, pi = yi; Nn < pi; Nn += 3) ee = ke.getX(Nn), me = ke.getX(Nn + 1), Re = ke.getX(Nn + 2), Z(F, Ve, He, ot, ee, me, Re, nr), Z(F, gt, Bt, ot, ee, me, Re, Oi); else for (Vn = Math.max(0, an.start), yi = Math.min(ke.count, an.start + an.count), En = Vn, oi = yi; En < oi; En += 3) ee = ke.getX(En), me = ke.getX(En + 1), Re = ke.getX(En + 2), Z(F, Ve, He, ot, ee, me, Re, nr), Z(F, gt, Bt, ot, ee, me, Re, Oi); else if (Array.isArray(ae)) for (En = 0, oi = Rt.length; En < oi; En++) for (hi = Rt[En], Vn = Math.max(hi.start, an.start), yi = Math.min(hi.start + hi.count, an.start + an.count), Nn = Vn, pi = yi; Nn < pi; Nn += 3) ee = Nn, me = Nn + 1, Re = Nn + 2, Z(F, Ve, He, ot, ee, me, Re, nr), Z(F, gt, Bt, ot, ee, me, Re, Oi); else for (Vn = Math.max(0, an.start), yi = Math.min(Ve.count, an.start + an.count), En = Vn, oi = yi; En < oi; En += 3) ee = En, me = En + 1, Re = En + 2, Z(F, Ve, He, ot, ee, me, Re, nr), Z(F, gt, Bt, ot, ee, me, Re, Oi);
                        const Rr = new g.Float32BufferAttribute(nr, 3), Ji = new g.Float32BufferAttribute(Oi, 3);
                        return {
                            positionAttribute: Ve,
                            normalAttribute: gt,
                            morphedPositionAttribute: Rr,
                            morphedNormalAttribute: Ji
                        }
                    }

                    function O(F) {
                        if (F.groups.length === 0) return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), F;
                        let V = F.groups;
                        if (V = V.sort((se, pe) => se.materialIndex !== pe.materialIndex ? se.materialIndex - pe.materialIndex : se.start - pe.start), F.getIndex() === null) {
                            const se = F.getAttribute("position"), pe = [];
                            for (let ue = 0; ue < se.count; ue += 3) pe.push(ue, ue + 1, ue + 2);
                            F.setIndex(pe)
                        }
                        const U = F.getIndex(), j = [];
                        for (let se = 0; se < V.length; se++) {
                            const pe = V[se], ue = pe.start, he = ue + pe.count;
                            for (let Z = ue; Z < he; Z++) j.push(U.getX(Z))
                        }
                        F.dispose(), F.setIndex(j);
                        let Y = 0;
                        for (let se = 0; se < V.length; se++) {
                            const pe = V[se];
                            pe.start = Y, Y += pe.count
                        }
                        let fe = V[0];
                        F.groups = [fe];
                        for (let se = 1; se < V.length; se++) {
                            const pe = V[se];
                            fe.materialIndex === pe.materialIndex ? fe.count += pe.count : (fe = pe, F.groups.push(fe))
                        }
                        return F
                    }

                    function N(F, V = Math.PI / 3) {
                        const U = Math.cos(V), j = (1 + 1e-10) * 100, Y = [new g.Vector3, new g.Vector3, new g.Vector3],
                            fe = new g.Vector3, se = new g.Vector3, pe = new g.Vector3, ue = new g.Vector3;

                        function he(Re) {
                            const ke = ~~(Re.x * j), Ve = ~~(Re.y * j), He = ~~(Re.z * j);
                            return `${ke},${Ve},${He}`
                        }

                        const Z = F.index ? F.toNonIndexed() : F, H = Z.attributes.position, ae = {};
                        for (let Re = 0, ke = H.count / 3; Re < ke; Re++) {
                            const Ve = 3 * Re, He = Y[0].fromBufferAttribute(H, Ve + 0),
                                ot = Y[1].fromBufferAttribute(H, Ve + 1), gt = Y[2].fromBufferAttribute(H, Ve + 2);
                            fe.subVectors(gt, ot), se.subVectors(He, ot);
                            const Bt = new g.Vector3().crossVectors(fe, se).normalize();
                            for (let Rt = 0; Rt < 3; Rt++) {
                                const an = Y[Rt], En = he(an);
                                En in ae || (ae[En] = []), ae[En].push(Bt)
                            }
                        }
                        const ee = new Float32Array(H.count * 3), me = new g.BufferAttribute(ee, 3, !1);
                        for (let Re = 0, ke = H.count / 3; Re < ke; Re++) {
                            const Ve = 3 * Re, He = Y[0].fromBufferAttribute(H, Ve + 0),
                                ot = Y[1].fromBufferAttribute(H, Ve + 1), gt = Y[2].fromBufferAttribute(H, Ve + 2);
                            fe.subVectors(gt, ot), se.subVectors(He, ot), pe.crossVectors(fe, se).normalize();
                            for (let Bt = 0; Bt < 3; Bt++) {
                                const Rt = Y[Bt], an = he(Rt), En = ae[an];
                                ue.set(0, 0, 0);
                                for (let Nn = 0, oi = En.length; Nn < oi; Nn++) {
                                    const pi = En[Nn];
                                    pe.dot(pi) > U && ue.add(pi)
                                }
                                ue.normalize(), me.setXYZ(Ve + Bt, ue.x, ue.y, ue.z)
                            }
                        }
                        return Z.setAttribute("normal", me), Z
                    }
                },
                "./node_modules/three/examples/jsm/utils/WorkerPool.js": (m, x, h) => {
                    h.r(x), h.d(x, {WorkerPool: () => g});

                    class g {
                        constructor(v = 4) {
                            this.pool = v, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
                        }

                        _initWorker(v) {
                            if (!this.workers[v]) {
                                const E = this.workerCreator();
                                E.addEventListener("message", this._onMessage.bind(this, v)), this.workers[v] = E
                            }
                        }

                        _getIdleWorker() {
                            for (let v = 0; v < this.pool; v++) if (!(this.workerStatus & 1 << v)) return v;
                            return -1
                        }

                        _onMessage(v, E) {
                            const p = this.workersResolve[v];
                            if (p && p(E), this.queue.length) {
                                const {resolve: C, msg: M, transfer: b} = this.queue.shift();
                                this.workersResolve[v] = C, this.workers[v].postMessage(M, b)
                            } else this.workerStatus ^= 1 << v
                        }

                        setWorkerCreator(v) {
                            this.workerCreator = v
                        }

                        setWorkerLimit(v) {
                            this.pool = v
                        }

                        postMessage(v, E) {
                            return new Promise(p => {
                                const C = this._getIdleWorker();
                                C !== -1 ? (this._initWorker(C), this.workerStatus |= 1 << C, this.workersResolve[C] = p, this.workers[C].postMessage(v, E)) : this.queue.push({
                                    resolve: p,
                                    msg: v,
                                    transfer: E
                                })
                            })
                        }

                        dispose() {
                            this.workers.forEach(v => v.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
                        }
                    }
                },
                "./src/lib/three.mjs": (m, x, h) => {
                    h.r(x), h.d(x, {default: () => I});
                    var g = h("./node_modules/three/build/three.module.js"),
                        w = h("./node_modules/three/examples/jsm/loaders/DRACOLoader.js"),
                        v = h("./node_modules/three/examples/jsm/loaders/GLTFLoader.js"),
                        E = h("./node_modules/three/examples/jsm/loaders/KTX2Loader.js"),
                        p = h("./node_modules/three/examples/jsm/math/OBB.js"),
                        C = h("./node_modules/three/examples/jsm/loaders/OBJLoader.js"),
                        M = h("./node_modules/three/examples/jsm/loaders/MTLLoader.js"),
                        b = h("./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"),
                        B = h("./node_modules/three/examples/jsm/lights/LightProbeGenerator.js"), R = {...g};
                    R.DRACOLoader = w.DRACOLoader, R.GLTFLoader = v.GLTFLoader, R.KTX2Loader = E.KTX2Loader, R.OBJLoader = C.OBJLoader, R.MTLLoader = M.MTLLoader, R.OBB = p.OBB, R.BufferGeometryUtils = b, R.LightProbeGenerator = B.LightProbeGenerator;
                    const I = R
                },
                "./package.json": m => {
                    m.exports = JSON.parse('{"name":"aframe","version":"1.6.0","description":"A web framework for building virtual reality experiences.","homepage":"https://aframe.io/","main":"dist/aframe-master.js","scripts":{"dev":"cross-env INSPECTOR_VERSION=dev webpack serve --port 8080","dist":"node scripts/updateVersionLog.js && npm run dist:min && npm run dist:max","dist:max":"webpack --config webpack.config.js","dist:min":"webpack --config webpack.prod.config.js","docs":"markserv --dir docs --port 9001","preghpages":"node ./scripts/preghpages.js","ghpages":"ghpages -p gh-pages/","lint":"standardx -v | snazzy","lint:fix":"standardx --fix","precommit":"npm run lint","prepush":"node scripts/testOnlyCheck.js","prerelease":"node scripts/release.js 1.5.0 1.6.0","start":"npm run dev","start:https":"npm run dev -- --server-type https","test":"karma start ./tests/karma.conf.js","test:docs":"node scripts/docsLint.js","test:firefox":"npm test -- --browsers Firefox","test:chrome":"npm test -- --browsers Chrome","test:nobrowser":"NO_BROWSER=true npm test","test:node":"node --experimental-require-module ./node_modules/mocha/bin/mocha --ui tdd tests/node"},"repository":"aframevr/aframe","license":"MIT","files":["dist/*","docs/**/*","src/**/*","vendor/**/*"],"dependencies":{"buffer":"^6.0.3","debug":"^4.3.4","deep-assign":"^2.0.0","load-bmfont":"^1.2.3","super-animejs":"^3.1.0","three":"npm:super-three@0.164.0","three-bmfont-text":"dmarcos/three-bmfont-text#eed4878795be9b3e38cf6aec6b903f56acd1f695","webvr-polyfill":"^0.10.12"},"devDependencies":{"@babel/core":"^7.17.10","babel-loader":"^8.2.5","babel-plugin-istanbul":"^6.1.1","chai":"^4.3.6","chai-shallow-deep-equal":"^1.4.0","chalk":"^1.1.3","cross-env":"^7.0.3","css-loader":"^6.7.1","eslint":"^8.45.0","eslint-config-semistandard":"^17.0.0","eslint-config-standard-jsx":"^11.0.0","ghpages":"0.0.8","git-rev":"^0.2.1","glob":"^8.0.3","husky":"^0.11.7","jsdom":"^24.0.0","jsdom-global":"^3.0.2","karma":"^6.4.0","karma-chai-shallow-deep-equal":"0.0.4","karma-chrome-launcher":"^3.1.1","karma-coverage":"^2.2.0","karma-env-preprocessor":"^0.1.1","karma-firefox-launcher":"^2.1.2","karma-mocha":"^2.0.1","karma-mocha-reporter":"^2.2.5","karma-sinon-chai":"^2.0.2","karma-webpack":"^5.0.0","markserv":"github:sukima/markserv#feature/fix-broken-websoketio-link","mocha":"^10.0.0","replace-in-file":"^2.5.3","shelljs":"^0.7.7","shx":"^0.2.2","sinon":"<12.0.0","sinon-chai":"^3.7.0","snazzy":"^5.0.0","standardx":"^7.0.0","style-loader":"^3.3.1","too-wordy":"ngokevin/too-wordy","webpack":"^5.73.0","webpack-cli":"^4.10.0","webpack-dev-server":"^4.11.0","webpack-merge":"^5.8.0","write-good":"^1.0.8"},"link":true,"standardx":{"ignore":["build/**","dist/**","examples/**/shaders/*.js","**/vendor/**"]},"keywords":["3d","aframe","cardboard","components","oculus","three","three.js","rift","vive","vr","quest","meta","web-components","webvr","webxr"],"engines":{"node":">= 4.6.0","npm":">= 2.15.9"}}')
                }
            }, c = {};

            function f(m) {
                var x = c[m];
                if (x !== void 0) return x.exports;
                var h = c[m] = {id: m, exports: {}};
                return o[m].call(h.exports, h, h.exports, f), h.exports
            }

            f.m = o, f.n = m => {
                var x = m && m.__esModule ? () => m.default : () => m;
                return f.d(x, {a: x}), x
            }, f.d = (m, x) => {
                for (var h in x) f.o(x, h) && !f.o(m, h) && Object.defineProperty(m, h, {enumerable: !0, get: x[h]})
            }, f.g = function () {
                if (typeof globalThis == "object") return globalThis;
                try {
                    return this || new Function("return this")()
                } catch {
                    if (typeof window == "object") return window
                }
            }(), f.o = (m, x) => Object.prototype.hasOwnProperty.call(m, x), f.r = m => {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(m, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(m, "__esModule", {value: !0})
            }, f.b = document.baseURI || self.location.href, f.nc = void 0;
            var T = f("./src/index.js");
            return T
        })())
    }(sy)), sy.exports
}

y3();
var $x = {}, eC = {}, oy, tC;

function E3() {
    if (tC) return oy;
    tC = 1;
    const A = .1;
    return oy = AFRAME.registerComponent("checkpoint-controls", {
        schema: {
            enabled: {default: !0},
            mode: {default: "teleport", oneOf: ["teleport", "animate"]},
            animateSpeed: {default: 3}
        }, init: function () {
            this.active = !0, this.checkpoint = null, this.isNavMeshConstrained = !1, this.offset = new THREE.Vector3, this.position = new THREE.Vector3, this.targetPosition = new THREE.Vector3
        }, play: function () {
            this.active = !0
        }, pause: function () {
            this.active = !1
        }, setCheckpoint: function (t) {
            const i = this.el;
            if (this.active && this.checkpoint !== t) {
                if (this.checkpoint && i.emit("navigation-end", {checkpoint: this.checkpoint}), this.checkpoint = t, this.sync(), this.position.distanceTo(this.targetPosition) < A) {
                    this.checkpoint = null;
                    return
                }
                i.emit("navigation-start", {checkpoint: t}), this.data.mode === "teleport" && (this.el.setAttribute("position", this.targetPosition), this.checkpoint = null, i.emit("navigation-end", {checkpoint: t}), i.components["movement-controls"].updateNavLocation())
            }
        }, isVelocityActive: function () {
            return !!(this.active && this.checkpoint)
        }, getVelocity: function () {
            if (!this.active) return;
            const t = this.data, i = this.offset, o = this.position, c = this.targetPosition, f = this.checkpoint;
            return this.sync(), o.distanceTo(c) < A ? (this.checkpoint = null, this.el.emit("navigation-end", {checkpoint: f}), i.set(0, 0, 0)) : (i.setLength(t.animateSpeed), i)
        }, sync: function () {
            const t = this.offset, i = this.position, o = this.targetPosition;
            i.copy(this.el.getAttribute("position")), this.checkpoint.object3D.getWorldPosition(o), o.add(this.checkpoint.components.checkpoint.getOffset()), t.copy(o).sub(i)
        }
    }), oy
}

var ay, nC;

function x3() {
    return nC || (nC = 1, ay = Object.assign(function () {
    }, {
        FACE_1: 0,
        FACE_2: 1,
        FACE_3: 2,
        FACE_4: 3,
        L_SHOULDER_1: 4,
        R_SHOULDER_1: 5,
        L_SHOULDER_2: 6,
        R_SHOULDER_2: 7,
        SELECT: 8,
        START: 9,
        DPAD_UP: 12,
        DPAD_DOWN: 13,
        DPAD_LEFT: 14,
        DPAD_RIGHT: 15,
        VENDOR: 16
    })), ay
}

var ly, iC;

function C3() {
    if (iC) return ly;
    iC = 1;

    function A(t, i, o) {
        this.type = t, this.index = i, this.pressed = o.pressed, this.value = o.value
    }

    return ly = A, ly
}

var cy, rC;

function w3() {
    if (rC) return cy;
    rC = 1;
    const A = x3(), t = C3(), i = .2, o = {LEFT: "left", RIGHT: "right"}, c = {MOVEMENT: 1, ROTATION: 2};
    return cy = AFRAME.registerComponent("gamepad-controls", {
        GamepadButton: A, schema: {enabled: {default: !0}, rotationSensitivity: {default: 2}}, init: function () {
            const f = this.el.sceneEl;
            this.system = f.systems["tracked-controls"] || f.systems["tracked-controls-webxr"] || {controllers: []}, this.prevTime = window.performance.now(), this.buttons = {};
            const T = this.el.object3D.rotation;
            this.pitch = new THREE.Object3D, this.pitch.rotation.x = T.x, this.yaw = new THREE.Object3D, this.yaw.position.y = 10, this.yaw.rotation.y = T.y, this.yaw.add(this.pitch), this._lookVector = new THREE.Vector2, this._moveVector = new THREE.Vector2, this._dpadVector = new THREE.Vector2, f.addBehavior(this)
        }, update: function () {
            this.tick()
        }, tick: function (f, T) {
            this.updateButtonState(), this.updateRotation(T)
        }, remove: function () {
        }, isVelocityActive: function () {
            if (!this.data.enabled || !this.isConnected()) return !1;
            const f = this._dpadVector, T = this._moveVector;
            this.getDpad(f), this.getJoystick(c.MOVEMENT, T);
            const m = f.x || T.x, x = f.y || T.y;
            return Math.abs(m) > i || Math.abs(x) > i
        }, getVelocityDelta: function () {
            const f = this._dpadVector, T = this._moveVector;
            this.getDpad(f), this.getJoystick(c.MOVEMENT, T);
            const m = f.x || T.x, x = f.y || T.y, h = new THREE.Vector3;
            return Math.abs(m) > i && (h.x += m), Math.abs(x) > i && (h.z += x), h
        }, isRotationActive: function () {
            if (!this.data.enabled || !this.isConnected()) return !1;
            const f = this._lookVector;
            return this.getJoystick(c.ROTATION, f), Math.abs(f.x) > i || Math.abs(f.y) > i
        }, updateRotation: function (f) {
            if (!this.isRotationActive()) return;
            const T = this.data, m = this.yaw, x = this.pitch;
            m.rotation.y = this.el.object3D.rotation.y, x.rotation.x = this.el.object3D.rotation.x;
            const h = this._lookVector;
            this.getJoystick(c.ROTATION, h), Math.abs(h.x) <= i && (h.x = 0), Math.abs(h.y) <= i && (h.y = 0), h.multiplyScalar(T.rotationSensitivity * f / 1e3), m.rotation.y -= h.x, x.rotation.x -= h.y, x.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, x.rotation.x)), this.el.object3D.rotation.set(x.rotation.x, m.rotation.y, 0)
        }, updateButtonState: function () {
            const f = this.getGamepad(o.RIGHT);
            if (this.data.enabled && f) for (var T = 0; T < f.buttons.length; T++) f.buttons[T].pressed && !this.buttons[T] ? this.emit(new t("gamepadbuttondown", T, f.buttons[T])) : !f.buttons[T].pressed && this.buttons[T] && this.emit(new t("gamepadbuttonup", T, f.buttons[T])), this.buttons[T] = f.buttons[T].pressed; else for (const m in this.buttons) this.buttons[m] = !1
        }, emit: function (f) {
            this.el.emit(f.type, f), this.el.emit(f.type + ":" + f.index, new t(f.type, f.index, f))
        }, getGamepad: function () {
            const f = [], T = [];
            return function (m) {
                const x = this.el.sceneEl.components["proxy-controls"], h = x && x.isConnected() && x.getGamepad(0);
                if (h) return h;
                f.length = 0;
                for (let w = 0; w < this.system.controllers.length; w++) {
                    const v = this.system.controllers[w], E = v ? v.gamepad : null;
                    if (f.push(E), E && v.handedness === m) return E
                }
                const g = navigator.getGamepads ? navigator.getGamepads() : T;
                for (let w = 0; w < g.length; w++) {
                    const v = g[w];
                    if (v && v.hand === m) return v
                }
                return f[0] || g[0]
            }
        }(), getButton: function (f) {
            return this.getGamepad(o.RIGHT).buttons[f]
        }, getAxis: function (f) {
            return this.getGamepad(f > 1 ? o.RIGHT : o.LEFT).axes[f]
        }, getJoystick: function (f, T) {
            const m = this.getGamepad(f === c.MOVEMENT ? o.LEFT : o.RIGHT);
            if (!m) return T.set(0, 0);
            if (m.mapping === "xr-standard") switch (f) {
                case c.MOVEMENT:
                    return T.set(m.axes[2], m.axes[3]);
                case c.ROTATION:
                    return T.set(m.axes[2], 0)
            } else switch (f) {
                case c.MOVEMENT:
                    return T.set(m.axes[0], m.axes[1]);
                case c.ROTATION:
                    return T.set(m.axes[2], m.axes[3])
            }
            throw new Error('Unexpected joystick index "%d".', f)
        }, getDpad: function (f) {
            const T = this.getGamepad(o.LEFT);
            return !T || !T.buttons[A.DPAD_RIGHT] ? f.set(0, 0) : f.set((T.buttons[A.DPAD_RIGHT].pressed ? 1 : 0) + (T.buttons[A.DPAD_LEFT].pressed ? -1 : 0), (T.buttons[A.DPAD_UP].pressed ? -1 : 0) + (T.buttons[A.DPAD_DOWN].pressed ? 1 : 0))
        }, isConnected: function () {
            const f = this.getGamepad(o.LEFT);
            return !!(f && f.connected)
        }, getID: function () {
            return this.getGamepad(o.LEFT).id
        }
    }), cy
}

var sC = {}, oC;

function b3() {
    return oC || (oC = 1, function (A) {
        var t = "KeyboardEvent" in A;
        t || (A.KeyboardEvent = function () {
            throw TypeError("Illegal constructor")
        }), "DOM_KEY_LOCATION_STANDARD" in A.KeyboardEvent || (A.KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0), "DOM_KEY_LOCATION_LEFT" in A.KeyboardEvent || (A.KeyboardEvent.DOM_KEY_LOCATION_LEFT = 1), "DOM_KEY_LOCATION_RIGHT" in A.KeyboardEvent || (A.KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 2), "DOM_KEY_LOCATION_NUMPAD" in A.KeyboardEvent || (A.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 3);
        var i = window.KeyboardEvent.DOM_KEY_LOCATION_STANDARD, o = window.KeyboardEvent.DOM_KEY_LOCATION_LEFT,
            c = window.KeyboardEvent.DOM_KEY_LOCATION_RIGHT, f = window.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD;

        function T(L, O) {
            return String(L).indexOf(O) !== -1
        }

        var m = function () {
            return T(navigator.platform, "Win") ? "win" : T(navigator.platform, "Mac") ? "mac" : T(navigator.platform, "CrOS") ? "cros" : T(navigator.platform, "Linux") ? "linux" : T(navigator.userAgent, "iPad") || T(navigator.platform, "iPod") || T(navigator.platform, "iPhone") ? "ios" : ""
        }(), x = function () {
            return T(navigator.userAgent, "Chrome/") ? "chrome" : T(navigator.vendor, "Apple") ? "safari" : T(navigator.userAgent, "MSIE") ? "ie" : T(navigator.userAgent, "Gecko/") ? "moz" : T(navigator.userAgent, "Opera/") ? "opera" : ""
        }(), h = x + "-" + m;

        function g(L, O, N) {
            (h === O || x === O || m === O) && Object.keys(N).forEach(function (F) {
                L[F] = N[F]
            })
        }

        function w(L, O) {
            var N = {};
            return Object.keys(L).forEach(function (F) {
                var V = L[F];
                O in V && (N[V[O]] = V)
            }), N
        }

        var v = {
            3: {code: "Cancel"},
            6: {code: "Help"},
            8: {code: "Backspace"},
            9: {code: "Tab"},
            12: {code: "Clear"},
            13: {code: "Enter"},
            16: {code: "Shift"},
            17: {code: "Control"},
            18: {code: "Alt"},
            19: {code: "Pause"},
            20: {code: "CapsLock"},
            21: {code: "KanaMode"},
            22: {code: "HangulMode"},
            23: {code: "JunjaMode"},
            24: {code: "FinalMode"},
            25: {code: "KanjiMode"},
            27: {code: "Escape"},
            28: {code: "Convert"},
            29: {code: "NonConvert"},
            30: {code: "Accept"},
            31: {code: "ModeChange"},
            32: {code: "Space"},
            33: {code: "PageUp"},
            34: {code: "PageDown"},
            35: {code: "End"},
            36: {code: "Home"},
            37: {code: "ArrowLeft"},
            38: {code: "ArrowUp"},
            39: {code: "ArrowRight"},
            40: {code: "ArrowDown"},
            41: {code: "Select"},
            42: {code: "Print"},
            43: {code: "Execute"},
            44: {code: "PrintScreen"},
            45: {code: "Insert"},
            46: {code: "Delete"},
            47: {code: "Help"},
            48: {code: "Digit0", keyCap: "0"},
            49: {code: "Digit1", keyCap: "1"},
            50: {code: "Digit2", keyCap: "2"},
            51: {code: "Digit3", keyCap: "3"},
            52: {code: "Digit4", keyCap: "4"},
            53: {code: "Digit5", keyCap: "5"},
            54: {code: "Digit6", keyCap: "6"},
            55: {code: "Digit7", keyCap: "7"},
            56: {code: "Digit8", keyCap: "8"},
            57: {code: "Digit9", keyCap: "9"},
            65: {code: "KeyA", keyCap: "a"},
            66: {code: "KeyB", keyCap: "b"},
            67: {code: "KeyC", keyCap: "c"},
            68: {code: "KeyD", keyCap: "d"},
            69: {code: "KeyE", keyCap: "e"},
            70: {code: "KeyF", keyCap: "f"},
            71: {code: "KeyG", keyCap: "g"},
            72: {code: "KeyH", keyCap: "h"},
            73: {code: "KeyI", keyCap: "i"},
            74: {code: "KeyJ", keyCap: "j"},
            75: {code: "KeyK", keyCap: "k"},
            76: {code: "KeyL", keyCap: "l"},
            77: {code: "KeyM", keyCap: "m"},
            78: {code: "KeyN", keyCap: "n"},
            79: {code: "KeyO", keyCap: "o"},
            80: {code: "KeyP", keyCap: "p"},
            81: {code: "KeyQ", keyCap: "q"},
            82: {code: "KeyR", keyCap: "r"},
            83: {code: "KeyS", keyCap: "s"},
            84: {code: "KeyT", keyCap: "t"},
            85: {code: "KeyU", keyCap: "u"},
            86: {code: "KeyV", keyCap: "v"},
            87: {code: "KeyW", keyCap: "w"},
            88: {code: "KeyX", keyCap: "x"},
            89: {code: "KeyY", keyCap: "y"},
            90: {code: "KeyZ", keyCap: "z"},
            91: {code: "OSLeft", location: o},
            92: {code: "OSRight", location: c},
            93: {code: "ContextMenu"},
            95: {code: "Standby"},
            96: {code: "Numpad0", keyCap: "0", location: f},
            97: {code: "Numpad1", keyCap: "1", location: f},
            98: {code: "Numpad2", keyCap: "2", location: f},
            99: {code: "Numpad3", keyCap: "3", location: f},
            100: {code: "Numpad4", keyCap: "4", location: f},
            101: {code: "Numpad5", keyCap: "5", location: f},
            102: {code: "Numpad6", keyCap: "6", location: f},
            103: {code: "Numpad7", keyCap: "7", location: f},
            104: {code: "Numpad8", keyCap: "8", location: f},
            105: {code: "Numpad9", keyCap: "9", location: f},
            106: {code: "NumpadMultiply", keyCap: "*", location: f},
            107: {code: "NumpadAdd", keyCap: "+", location: f},
            108: {code: "NumpadComma", keyCap: ",", location: f},
            109: {code: "NumpadSubtract", keyCap: "-", location: f},
            110: {code: "NumpadDecimal", keyCap: ".", location: f},
            111: {code: "NumpadDivide", keyCap: "/", location: f},
            112: {code: "F1"},
            113: {code: "F2"},
            114: {code: "F3"},
            115: {code: "F4"},
            116: {code: "F5"},
            117: {code: "F6"},
            118: {code: "F7"},
            119: {code: "F8"},
            120: {code: "F9"},
            121: {code: "F10"},
            122: {code: "F11"},
            123: {code: "F12"},
            124: {code: "F13"},
            125: {code: "F14"},
            126: {code: "F15"},
            127: {code: "F16"},
            128: {code: "F17"},
            129: {code: "F18"},
            130: {code: "F19"},
            131: {code: "F20"},
            132: {code: "F21"},
            133: {code: "F22"},
            134: {code: "F23"},
            135: {code: "F24"},
            144: {code: "NumLock", location: f},
            145: {code: "ScrollLock"},
            160: {code: "ShiftLeft", location: o},
            161: {code: "ShiftRight", location: c},
            162: {code: "ControlLeft", location: o},
            163: {code: "ControlRight", location: c},
            164: {code: "AltLeft", location: o},
            165: {code: "AltRight", location: c},
            166: {code: "BrowserBack"},
            167: {code: "BrowserForward"},
            168: {code: "BrowserRefresh"},
            169: {code: "BrowserStop"},
            170: {code: "BrowserSearch"},
            171: {code: "BrowserFavorites"},
            172: {code: "BrowserHome"},
            173: {code: "VolumeMute"},
            174: {code: "VolumeDown"},
            175: {code: "VolumeUp"},
            176: {code: "MediaTrackNext"},
            177: {code: "MediaTrackPrevious"},
            178: {code: "MediaStop"},
            179: {code: "MediaPlayPause"},
            180: {code: "LaunchMail"},
            181: {code: "MediaSelect"},
            182: {code: "LaunchApp1"},
            183: {code: "LaunchApp2"},
            186: {code: "Semicolon", keyCap: ";"},
            187: {code: "Equal", keyCap: "="},
            188: {code: "Comma", keyCap: ","},
            189: {code: "Minus", keyCap: "-"},
            190: {code: "Period", keyCap: "."},
            191: {code: "Slash", keyCap: "/"},
            192: {code: "Backquote", keyCap: "`"},
            219: {code: "BracketLeft", keyCap: "["},
            220: {code: "Backslash", keyCap: "\\"},
            221: {code: "BracketRight", keyCap: "]"},
            222: {code: "Quote", keyCap: "'"},
            226: {code: "IntlBackslash", keyCap: "\\"},
            229: {code: "Process"},
            246: {code: "Attn"},
            247: {code: "CrSel"},
            248: {code: "ExSel"},
            249: {code: "EraseEof"},
            250: {code: "Play"},
            251: {code: "ZoomToggle"},
            254: {code: "Clear"}
        };
        g(v, "moz", {
            59: {code: "Semicolon", keyCap: ";"},
            61: {code: "Equal", keyCap: "="},
            107: {code: "Equal", keyCap: "="},
            109: {code: "Minus", keyCap: "-"},
            187: {code: "NumpadAdd", keyCap: "+", location: f},
            189: {code: "NumpadSubtract", keyCap: "-", location: f}
        }), g(v, "moz-mac", {
            12: {code: "NumLock", location: f},
            173: {code: "Minus", keyCap: "-"}
        }), g(v, "moz-win", {173: {code: "Minus", keyCap: "-"}}), g(v, "chrome-mac", {
            93: {
                code: "OSRight",
                location: c
            }
        }), g(v, "safari", {3: {code: "Enter"}, 25: {code: "Tab"}}), g(v, "ios", {
            10: {
                code: "Enter",
                location: i
            }
        }), g(v, "safari-mac", {
            91: {code: "OSLeft", location: o},
            93: {code: "OSRight", location: c},
            229: {code: "KeyQ", keyCap: "Q"}
        });
        var E = {};
        m === "cros" && (E["U+00A0"] = {code: "ShiftLeft", location: o}, E["U+00A1"] = {
            code: "ShiftRight",
            location: c
        }, E["U+00A2"] = {code: "ControlLeft", location: o}, E["U+00A3"] = {
            code: "ControlRight",
            location: c
        }, E["U+00A4"] = {code: "AltLeft", location: o}, E["U+00A5"] = {
            code: "AltRight",
            location: c
        }), h === "chrome-mac" && (E["U+0010"] = {code: "ContextMenu"}), h === "safari-mac" && (E["U+0010"] = {code: "ContextMenu"}), m === "ios" && (E["U+0010"] = {code: "Function"}, E["U+001C"] = {code: "ArrowLeft"}, E["U+001D"] = {code: "ArrowRight"}, E["U+001E"] = {code: "ArrowUp"}, E["U+001F"] = {code: "ArrowDown"}, E["U+0001"] = {code: "Home"}, E["U+0004"] = {code: "End"}, E["U+000B"] = {code: "PageUp"}, E["U+000C"] = {code: "PageDown"});
        var p = [];
        p[o] = {
            16: {code: "ShiftLeft", location: o},
            17: {code: "ControlLeft", location: o},
            18: {code: "AltLeft", location: o}
        }, p[c] = {
            16: {code: "ShiftRight", location: c},
            17: {code: "ControlRight", location: c},
            18: {code: "AltRight", location: c}
        }, p[f] = {13: {code: "NumpadEnter", location: f}}, g(p[f], "moz", {
            109: {code: "NumpadSubtract", location: f},
            107: {code: "NumpadAdd", location: f}
        }), g(p[o], "moz-mac", {224: {code: "OSLeft", location: o}}), g(p[c], "moz-mac", {
            224: {
                code: "OSRight",
                location: c
            }
        }), g(p[c], "moz-win", {91: {code: "OSRight", location: c}}), g(p[c], "mac", {
            93: {
                code: "OSRight",
                location: c
            }
        }), g(p[f], "chrome-mac", {12: {code: "NumLock", location: f}}), g(p[f], "safari-mac", {
            12: {
                code: "NumLock",
                location: f
            },
            187: {code: "NumpadAdd", location: f},
            189: {code: "NumpadSubtract", location: f},
            190: {code: "NumpadDecimal", location: f},
            191: {code: "NumpadDivide", location: f}
        });
        var C = {
            ShiftLeft: {key: "Shift"},
            ShiftRight: {key: "Shift"},
            ControlLeft: {key: "Control"},
            ControlRight: {key: "Control"},
            AltLeft: {key: "Alt"},
            AltRight: {key: "Alt"},
            OSLeft: {key: "OS"},
            OSRight: {key: "OS"},
            NumpadEnter: {key: "Enter"},
            Space: {key: " "},
            Digit0: {key: "0", shiftKey: ")"},
            Digit1: {key: "1", shiftKey: "!"},
            Digit2: {key: "2", shiftKey: "@"},
            Digit3: {key: "3", shiftKey: "#"},
            Digit4: {key: "4", shiftKey: "$"},
            Digit5: {key: "5", shiftKey: "%"},
            Digit6: {key: "6", shiftKey: "^"},
            Digit7: {key: "7", shiftKey: "&"},
            Digit8: {key: "8", shiftKey: "*"},
            Digit9: {key: "9", shiftKey: "("},
            KeyA: {key: "a", shiftKey: "A"},
            KeyB: {key: "b", shiftKey: "B"},
            KeyC: {key: "c", shiftKey: "C"},
            KeyD: {key: "d", shiftKey: "D"},
            KeyE: {key: "e", shiftKey: "E"},
            KeyF: {key: "f", shiftKey: "F"},
            KeyG: {key: "g", shiftKey: "G"},
            KeyH: {key: "h", shiftKey: "H"},
            KeyI: {key: "i", shiftKey: "I"},
            KeyJ: {key: "j", shiftKey: "J"},
            KeyK: {key: "k", shiftKey: "K"},
            KeyL: {key: "l", shiftKey: "L"},
            KeyM: {key: "m", shiftKey: "M"},
            KeyN: {key: "n", shiftKey: "N"},
            KeyO: {key: "o", shiftKey: "O"},
            KeyP: {key: "p", shiftKey: "P"},
            KeyQ: {key: "q", shiftKey: "Q"},
            KeyR: {key: "r", shiftKey: "R"},
            KeyS: {key: "s", shiftKey: "S"},
            KeyT: {key: "t", shiftKey: "T"},
            KeyU: {key: "u", shiftKey: "U"},
            KeyV: {key: "v", shiftKey: "V"},
            KeyW: {key: "w", shiftKey: "W"},
            KeyX: {key: "x", shiftKey: "X"},
            KeyY: {key: "y", shiftKey: "Y"},
            KeyZ: {key: "z", shiftKey: "Z"},
            Numpad0: {key: "0"},
            Numpad1: {key: "1"},
            Numpad2: {key: "2"},
            Numpad3: {key: "3"},
            Numpad4: {key: "4"},
            Numpad5: {key: "5"},
            Numpad6: {key: "6"},
            Numpad7: {key: "7"},
            Numpad8: {key: "8"},
            Numpad9: {key: "9"},
            NumpadMultiply: {key: "*"},
            NumpadAdd: {key: "+"},
            NumpadComma: {key: ","},
            NumpadSubtract: {key: "-"},
            NumpadDecimal: {key: "."},
            NumpadDivide: {key: "/"},
            Semicolon: {key: ";", shiftKey: ":"},
            Equal: {key: "=", shiftKey: "+"},
            Comma: {key: ",", shiftKey: "<"},
            Minus: {key: "-", shiftKey: "_"},
            Period: {key: ".", shiftKey: ">"},
            Slash: {key: "/", shiftKey: "?"},
            Backquote: {key: "`", shiftKey: "~"},
            BracketLeft: {key: "[", shiftKey: "{"},
            Backslash: {key: "\\", shiftKey: "|"},
            BracketRight: {key: "]", shiftKey: "}"},
            Quote: {key: "'", shiftKey: '"'},
            IntlBackslash: {key: "\\", shiftKey: "|"}
        };
        g(C, "mac", {OSLeft: {key: "Meta"}, OSRight: {key: "Meta"}});
        var M = {
            Esc: "Escape",
            Nonconvert: "NonConvert",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Menu: "ContextMenu",
            MediaNextTrack: "MediaTrackNext",
            MediaPreviousTrack: "MediaTrackPrevious",
            SelectMedia: "MediaSelect",
            HalfWidth: "Hankaku",
            FullWidth: "Zenkaku",
            RomanCharacters: "Romaji",
            Crsel: "CrSel",
            Exsel: "ExSel",
            Zoom: "ZoomToggle"
        }, b = w(v, "code");
        try {
            var B = t && "location" in new KeyboardEvent("")
        } catch {
        }

        function R(L) {
            var O = "keyCode" in L ? L.keyCode : "which" in L ? L.which : 0, N = function () {
                if (B || "keyLocation" in L) {
                    var V = B ? L.location : L.keyLocation;
                    if (V && O in p[V]) return p[V][O]
                }
                return "keyIdentifier" in L && L.keyIdentifier in E ? E[L.keyIdentifier] : O in v ? v[O] : null
            }();
            if (!N) return null;
            var F = function () {
                var V = C[N.code];
                return V ? L.shiftKey && "shiftKey" in V ? V.shiftKey : V.key : N.code
            }();
            return {code: N.code, key: F, location: N.location, keyCap: N.keyCap}
        }

        function I(L, O) {
            if (L = String(L), !b.hasOwnProperty(L)) return "Undefined";
            if (O && String(O).toLowerCase() !== "en-us") throw Error("Unsupported locale");
            var N = b[L];
            return N.keyCap || N.code || "Undefined"
        }

        "KeyboardEvent" in A && "defineProperty" in Object && function () {
            function L(N, F, V) {
                F in N || Object.defineProperty(N, F, V)
            }

            if (L(KeyboardEvent.prototype, "code", {
                get: function () {
                    var N = R(this);
                    return N ? N.code : ""
                }
            }), "key" in KeyboardEvent.prototype) {
                var O = Object.getOwnPropertyDescriptor(KeyboardEvent.prototype, "key");
                Object.defineProperty(KeyboardEvent.prototype, "key", {
                    get: function () {
                        var N = O.get.call(this);
                        return M.hasOwnProperty(N) ? M[N] : N
                    }
                })
            }
            L(KeyboardEvent.prototype, "key", {
                get: function () {
                    var N = R(this);
                    return N && "key" in N ? N.key : "Unidentified"
                }
            }), L(KeyboardEvent.prototype, "location", {
                get: function () {
                    var N = R(this);
                    return N && "location" in N ? N.location : i
                }
            }), L(KeyboardEvent.prototype, "locale", {
                get: function () {
                    return ""
                }
            })
        }(), "queryKeyCap" in A.KeyboardEvent || (A.KeyboardEvent.queryKeyCap = I), A.identifyKey = function (L) {
            if (!("code" in L)) {
                var O = R(L);
                L.code = O ? O.code : "", L.key = O && "key" in O ? O.key : "Unidentified", L.location = "location" in L ? L.location : "keyLocation" in L ? L.keyLocation : O && "location" in O ? O.location : i, L.locale = ""
            }
        }
    }(window)), sC
}

var uy, aC;

function _3() {
    if (aC) return uy;
    aC = 1, b3();
    const A = "__keyboard-controls-proxy", t = window.KeyboardEvent;
    return uy = AFRAME.registerComponent("keyboard-controls", {
        schema: {enabled: {default: !0}, debug: {default: !1}}, init: function () {
            this.dVelocity = new THREE.Vector3, this.localKeys = {}, this.listeners = {
                keydown: this.onKeyDown.bind(this),
                keyup: this.onKeyUp.bind(this),
                blur: this.onBlur.bind(this),
                onContextMenu: this.onContextMenu.bind(this)
            }
        }, isVelocityActive: function () {
            return this.data.enabled && !!Object.keys(this.getKeys()).length
        }, getVelocityDelta: function () {
            const i = this.data, o = this.getKeys();
            return this.dVelocity.set(0, 0, 0), i.enabled && ((o.KeyW || o.ArrowUp) && (this.dVelocity.z -= 1), (o.KeyA || o.ArrowLeft) && (this.dVelocity.x -= 1), (o.KeyS || o.ArrowDown) && (this.dVelocity.z += 1), (o.KeyD || o.ArrowRight) && (this.dVelocity.x += 1), o.ShiftLeft && (this.dVelocity = this.dVelocity.multiplyScalar(2))), this.dVelocity.clone()
        }, play: function () {
            this.attachEventListeners()
        }, pause: function () {
            this.removeEventListeners()
        }, attachEventListeners: function () {
            window.addEventListener("contextmenu", this.listeners.onContextMenu, !1), window.addEventListener("keydown", this.listeners.keydown, !1), window.addEventListener("keyup", this.listeners.keyup, !1), window.addEventListener("blur", this.listeners.blur, !1)
        }, onContextMenu: function () {
            for (const i in this.localKeys) this.localKeys.hasOwnProperty(i) && delete this.localKeys[i]
        }, removeEventListeners: function () {
            window.removeEventListener("keydown", this.listeners.keydown), window.removeEventListener("keyup", this.listeners.keyup), window.removeEventListener("blur", this.listeners.blur)
        }, onKeyDown: function (i) {
            AFRAME.utils.shouldCaptureKeyEvent(i) && (this.localKeys[i.code] = !0, this.emit(i))
        }, onKeyUp: function (i) {
            AFRAME.utils.shouldCaptureKeyEvent(i) && (delete this.localKeys[i.code], this.emit(i))
        }, onBlur: function () {
            for (const i in this.localKeys) this.localKeys.hasOwnProperty(i) && delete this.localKeys[i]
        }, emit: function (i) {
            A in i && this.el.emit(i.type, i), this.el.emit(i.type + ":" + i.code, new t(i.type, i)), this.data.debug && console.log(i.type + ":" + i.code)
        }, isPressed: function (i) {
            return i in this.getKeys()
        }, getKeys: function () {
            return this.isProxied() ? this.el.sceneEl.components["proxy-controls"].getKeyboard() : this.localKeys
        }, isProxied: function () {
            const i = this.el.sceneEl.components["proxy-controls"];
            return i && i.isConnected()
        }
    }), uy
}

var hy, lC;

function M3() {
    return lC || (lC = 1, hy = AFRAME.registerComponent("touch-controls", {
        schema: {enabled: {default: !0}, reverseEnabled: {default: !0}}, init: function () {
            this.dVelocity = new THREE.Vector3, this.bindMethods(), this.direction = 0
        }, play: function () {
            this.addEventListeners()
        }, pause: function () {
            this.removeEventListeners(), this.dVelocity.set(0, 0, 0)
        }, remove: function () {
            this.pause()
        }, addEventListeners: function () {
            const A = this.el.sceneEl, t = A.canvas;
            if (!t) {
                A.addEventListener("render-target-loaded", this.addEventListeners.bind(this));
                return
            }
            t.addEventListener("touchstart", this.onTouchStart, {passive: !0}), t.addEventListener("touchend", this.onTouchEnd, {passive: !0});
            const i = A.getAttribute("vr-mode-ui");
            i && i.cardboardModeEnabled && A.addEventListener("enter-vr", this.onEnterVR)
        }, removeEventListeners: function () {
            const A = this.el.sceneEl && this.el.sceneEl.canvas;
            A && (A.removeEventListener("touchstart", this.onTouchStart), A.removeEventListener("touchend", this.onTouchEnd), this.el.sceneEl.removeEventListener("enter-vr", this.onEnterVR))
        }, isVelocityActive: function () {
            return this.data.enabled && !!this.direction
        }, getVelocityDelta: function () {
            return this.dVelocity.z = this.direction, this.dVelocity.clone()
        }, bindMethods: function () {
            this.onTouchStart = this.onTouchStart.bind(this), this.onTouchEnd = this.onTouchEnd.bind(this), this.onEnterVR = this.onEnterVR.bind(this)
        }, onTouchStart: function (A) {
            this.direction = -1, this.data.reverseEnabled && A.touches && A.touches.length === 2 && (this.direction = 1), A.preventDefault()
        }, onTouchEnd: function (A) {
            this.direction = 0, A.preventDefault()
        }, onEnterVR: function () {
            const A = this.el.sceneEl.xrSession;
            A && (A.addEventListener("selectstart", this.onTouchStart), A.addEventListener("selectend", this.onTouchEnd))
        }
    })), hy
}

var dy, cC;

function S3() {
    if (cC) return dy;
    cC = 1;
    const A = "-controls", t = .2, i = 1e-5, o = "moved";
    return dy = AFRAME.registerComponent("movement-controls", {
        dependencies: ["rotation"],
        schema: {
            enabled: {default: !0},
            controls: {default: ["gamepad", "trackpad", "keyboard", "touch"]},
            speed: {default: .3, min: 0},
            fly: {default: !1},
            constrainToNavMesh: {default: !1},
            camera: {default: "[movement-controls] [camera]", type: "selector"}
        },
        init: function () {
            const c = this.el;
            this.data.camera || (this.data.camera = c.querySelector("[camera]")), this.velocityCtrl = null, this.velocity = new THREE.Vector3, this.heading = new THREE.Quaternion, this.eventDetail = {}, this.navGroup = null, this.navNode = null, c.sceneEl.hasLoaded ? this.injectControls() : c.sceneEl.addEventListener("loaded", this.injectControls.bind(this))
        },
        update: function (c) {
            const f = this.el, T = this.data, m = f.sceneEl.systems.nav;
            if (f.sceneEl.hasLoaded && this.injectControls(), m && T.constrainToNavMesh !== c.constrainToNavMesh && (T.constrainToNavMesh ? m.addAgent(this) : m.removeAgent(this)), T.enabled !== c.enabled) for (let x = 0; x < T.controls.length; x++) {
                const h = T.controls[x] + A;
                this.el.setAttribute(h, {enabled: this.data.enabled})
            }
        },
        injectControls: function () {
            const c = this.data;
            for (let f = 0; f < c.controls.length; f++) {
                const T = c.controls[f] + A;
                this.el.setAttribute(T, {enabled: this.data.enabled})
            }
        },
        updateNavLocation: function () {
            this.navGroup = null, this.navNode = null
        },
        tick: function () {
            const c = new THREE.Vector3, f = new THREE.Vector3, T = new THREE.Vector3;
            return function (m, x) {
                if (!x) return;
                const h = this.el, g = this.data;
                if (!g.enabled) return;
                this.updateVelocityCtrl();
                const w = this.velocityCtrl, v = this.velocity;
                if (w) if (x / 1e3 > t ? v.set(0, 0, 0) : this.updateVelocity(x), g.constrainToNavMesh && w.isNavMeshConstrained !== !1) {
                    if (v.lengthSq() < i) return;
                    c.copy(h.object3D.position), f.copy(v).multiplyScalar(x / 1e3).add(c);
                    const E = h.sceneEl.systems.nav;
                    this.navGroup = this.navGroup === null ? E.getGroup(c) : this.navGroup, this.navNode = this.navNode || E.getNode(c, this.navGroup), this.navNode = E.clampStep(c, f, this.navGroup, this.navNode, T), h.object3D.position.copy(T)
                } else h.hasAttribute("velocity") ? h.setAttribute("velocity", v) : (h.object3D.position.x += v.x * x / 1e3, h.object3D.position.y += v.y * x / 1e3, h.object3D.position.z += v.z * x / 1e3)
            }
        }(),
        updateVelocityCtrl: function () {
            const c = this.data;
            if (c.enabled) {
                for (let f = 0, T = c.controls.length; f < T; f++) {
                    const m = this.el.components[c.controls[f] + A];
                    if (m && m.isVelocityActive()) {
                        this.velocityCtrl = m;
                        return
                    }
                }
                this.velocityCtrl = null
            }
        },
        updateVelocity: function () {
            const c = new THREE.Vector2, f = new THREE.Quaternion;
            return function (T) {
                let m;
                const x = this.el, h = this.velocityCtrl, g = this.velocity, w = this.data;
                if (h) if (h.getVelocityDelta) m = h.getVelocityDelta(T); else if (h.getVelocity) {
                    g.copy(h.getVelocity());
                    return
                } else if (h.getPositionDelta) {
                    g.copy(h.getPositionDelta(T).multiplyScalar(1e3 / T));
                    return
                } else throw new Error("Incompatible movement controls: ", h);
                if (x.hasAttribute("velocity") && !w.constrainToNavMesh && g.copy(this.el.getAttribute("velocity")), m && w.enabled) {
                    const v = w.camera;
                    f.copy(v.object3D.quaternion), f.premultiply(x.object3D.quaternion), m.applyQuaternion(f);
                    const E = m.length();
                    w.fly ? (g.copy(m), g.multiplyScalar(this.data.speed * 16.66667)) : (c.set(m.x, m.z), c.setLength(E * this.data.speed * 16.66667), g.x = c.x, g.y = 0, g.z = c.y), (g.x !== 0 || g.y !== 0 || g.z !== 0) && (this.eventDetail.velocity = g, this.el.emit(o, this.eventDetail))
                }
            }
        }()
    }), dy
}

var fy, uC;

function T3() {
    return uC || (uC = 1, fy = AFRAME.registerComponent("trackpad-controls", {
        schema: {
            enabled: {default: !0},
            enableNegX: {default: !0},
            enablePosX: {default: !0},
            enableNegZ: {default: !0},
            enablePosZ: {default: !0},
            mode: {default: "touch", oneOf: ["swipe", "touch", "press"]}
        }, init: function () {
            this.dVelocity = new THREE.Vector3, this.zVel = 0, this.xVel = 0, this.bindMethods()
        }, play: function () {
            this.addEventListeners()
        }, pause: function () {
            this.removeEventListeners(), this.dVelocity.set(0, 0, 0)
        }, remove: function () {
            this.pause()
        }, addEventListeners: function () {
            const A = this.data, t = this.el.sceneEl;
            switch (t.addEventListener("axismove", this.onAxisMove), A.mode) {
                case"swipe":
                case"touch":
                    t.addEventListener("trackpadtouchstart", this.onTouchStart), t.addEventListener("trackpadtouchend", this.onTouchEnd);
                    break;
                case"press":
                    t.addEventListener("trackpaddown", this.onTouchStart), t.addEventListener("trackpadup", this.onTouchEnd);
                    break
            }
        }, removeEventListeners: function () {
            const A = this.el.sceneEl;
            A.removeEventListener("axismove", this.onAxisMove), A.removeEventListener("trackpadtouchstart", this.onTouchStart), A.removeEventListener("trackpadtouchend", this.onTouchEnd), A.removeEventListener("trackpaddown", this.onTouchStart), A.removeEventListener("trackpadup", this.onTouchEnd)
        }, isVelocityActive: function () {
            return this.data.enabled && this.isMoving
        }, getVelocityDelta: function () {
            return this.dVelocity.z = this.isMoving ? -this.zVel : 1, this.dVelocity.x = this.isMoving ? this.xVel : 1, this.dVelocity.clone()
        }, bindMethods: function () {
            this.onTouchStart = this.onTouchStart.bind(this), this.onTouchEnd = this.onTouchEnd.bind(this), this.onAxisMove = this.onAxisMove.bind(this)
        }, onTouchStart: function (A) {
            switch (this.data.mode) {
                case"swipe":
                    this.canRecordAxis = !0, this.startingAxisData = [];
                    break;
                case"touch":
                    this.isMoving = !0;
                    break;
                case"press":
                    this.isMoving = !0;
                    break
            }
            A.preventDefault()
        }, onTouchEnd: function (A) {
            this.data.mode == "swipe" && (this.startingAxisData = []), this.isMoving = !1, A.preventDefault()
        }, onAxisMove: function (A) {
            switch (this.data.mode) {
                case"swipe":
                    return this.handleSwipeAxis(A);
                case"touch":
                case"press":
                    return this.handleTouchAxis(A)
            }
        }, handleSwipeAxis: function (A) {
            const t = this.data, i = A.detail.axis;
            if (this.startingAxisData.length === 0 && this.canRecordAxis && (this.canRecordAxis = !1, this.startingAxisData[0] = i[0], this.startingAxisData[1] = i[1]), this.startingAxisData.length > 0) {
                let o = 0, c = 0;
                t.enableNegX && i[0] < this.startingAxisData[0] && (o = -1), t.enablePosX && i[0] > this.startingAxisData[0] && (o = 1), t.enablePosZ && i[1] > this.startingAxisData[1] && (c = -1), t.enableNegZ && i[1] < this.startingAxisData[1] && (c = 1);
                const f = Math.abs(this.startingAxisData[1] - i[1]);
                Math.abs(this.startingAxisData[0] - i[0]) > f ? (this.zVel = 0, this.xVel = o, this.isMoving = !0) : (this.xVel = 0, this.zVel = c, this.isMoving = !0)
            }
        }, handleTouchAxis: function (A) {
            const t = this.data, i = A.detail.axis;
            let o = 0, c = 0;
            t.enableNegX && i[0] < 0 && (o = -1), t.enablePosX && i[0] > 0 && (o = 1), t.enablePosZ && i[1] > 0 && (c = -1), t.enableNegZ && i[1] < 0 && (c = 1), Math.abs(i[0]) > Math.abs(i[1]) ? (this.zVel = 0, this.xVel = o) : (this.xVel = 0, this.zVel = c)
        }
    })), fy
}

const u0 = (A, t) => {
        const i = t.x - A.x, o = t.y - A.y;
        return Math.sqrt(i * i + o * o)
    }, I3 = (A, t) => {
        const i = t.x - A.x, o = t.y - A.y;
        return B3(Math.atan2(o, i))
    }, R3 = (A, t, i) => {
        const o = {x: 0, y: 0};
        return i = h1(i), o.x = A.x - t * Math.cos(i), o.y = A.y - t * Math.sin(i), o
    }, h1 = A => A * (Math.PI / 180), B3 = A => A * (180 / Math.PI),
    L3 = A => isNaN(A.buttons) ? A.pressure !== 0 : A.buttons !== 0, py = new Map, hC = A => {
        py.has(A) && clearTimeout(py.get(A)), py.set(A, setTimeout(A, 100))
    }, A0 = (A, t, i) => {
        const o = t.split(/[ ,]+/g);
        let c;
        for (let f = 0; f < o.length; f += 1) c = o[f], A.addEventListener ? A.addEventListener(c, i, !1) : A.attachEvent && A.attachEvent(c, i)
    }, dC = (A, t, i) => {
        const o = t.split(/[ ,]+/g);
        let c;
        for (let f = 0; f < o.length; f += 1) c = o[f], A.removeEventListener ? A.removeEventListener(c, i) : A.detachEvent && A.detachEvent(c, i)
    }, fw = A => (A.preventDefault(), A.type.match(/^touch/) ? A.changedTouches : A), fC = () => {
        const A = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft,
            t = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
        return {x: A, y: t}
    }, pC = (A, t) => {
        t.top || t.right || t.bottom || t.left ? (A.style.top = t.top, A.style.right = t.right, A.style.bottom = t.bottom, A.style.left = t.left) : (A.style.left = t.x + "px", A.style.top = t.y + "px")
    }, _1 = (A, t, i) => {
        const o = pw(A);
        for (let c in o) if (o.hasOwnProperty(c)) if (typeof t == "string") o[c] = t + " " + i; else {
            let f = "";
            for (let T = 0, m = t.length; T < m; T += 1) f += t[T] + " " + i + ", ";
            o[c] = f.slice(0, -2)
        }
        return o
    }, D3 = (A, t) => {
        const i = pw(A);
        for (let o in i) i.hasOwnProperty(o) && (i[o] = t);
        return i
    }, pw = A => {
        const t = {};
        return t[A] = "", ["webkit", "Moz", "o"].forEach(function (o) {
            t[o + A.charAt(0).toUpperCase() + A.slice(1)] = ""
        }), t
    }, my = (A, t) => {
        for (let i in t) t.hasOwnProperty(i) && (A[i] = t[i]);
        return A
    }, P3 = (A, t) => {
        const i = {};
        for (let o in A) A.hasOwnProperty(o) && t.hasOwnProperty(o) ? i[o] = t[o] : A.hasOwnProperty(o) && (i[o] = A[o]);
        return i
    }, d1 = (A, t) => {
        if (A.length) for (let i = 0, o = A.length; i < o; i += 1) t(A[i]); else t(A)
    }, O3 = (A, t, i) => ({x: Math.min(Math.max(A.x, t.x - i), t.x + i), y: Math.min(Math.max(A.y, t.y - i), t.y + i)});
var k3 = "ontouchstart" in window, F3 = !!window.PointerEvent, N3 = !!window.MSPointerEvent, Xp = {
    touch: {start: "touchstart", move: "touchmove", end: "touchend, touchcancel"},
    mouse: {start: "mousedown", move: "mousemove", end: "mouseup"},
    pointer: {start: "pointerdown", move: "pointermove", end: "pointerup, pointercancel"},
    MSPointer: {start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp"}
}, rf, cm = {};
F3 ? rf = Xp.pointer : N3 ? rf = Xp.MSPointer : k3 ? (rf = Xp.touch, cm = Xp.mouse) : rf = Xp.mouse;

function Hc() {
}

Hc.prototype.on = function (A, t) {
    var i = this, o = A.split(/[ ,]+/g), c;
    i._handlers_ = i._handlers_ || {};
    for (var f = 0; f < o.length; f += 1) c = o[f], i._handlers_[c] = i._handlers_[c] || [], i._handlers_[c].push(t);
    return i
};
Hc.prototype.off = function (A, t) {
    var i = this;
    return i._handlers_ = i._handlers_ || {}, A === void 0 ? i._handlers_ = {} : t === void 0 ? i._handlers_[A] = null : i._handlers_[A] && i._handlers_[A].indexOf(t) >= 0 && i._handlers_[A].splice(i._handlers_[A].indexOf(t), 1), i
};
Hc.prototype.trigger = function (A, t) {
    var i = this, o = A.split(/[ ,]+/g), c;
    i._handlers_ = i._handlers_ || {};
    for (var f = 0; f < o.length; f += 1) c = o[f], i._handlers_[c] && i._handlers_[c].length && i._handlers_[c].forEach(function (T) {
        T.call(i, {type: c, target: i}, t)
    })
};
Hc.prototype.config = function (A) {
    var t = this;
    t.options = t.defaults || {}, A && (t.options = P3(t.options, A))
};
Hc.prototype.bindEvt = function (A, t) {
    var i = this;
    return i._domHandlers_ = i._domHandlers_ || {}, i._domHandlers_[t] = function () {
        typeof i["on" + t] == "function" ? i["on" + t].apply(i, arguments) : console.warn('[WARNING] : Missing "on' + t + '" handler.')
    }, A0(A, rf[t], i._domHandlers_[t]), cm[t] && A0(A, cm[t], i._domHandlers_[t]), i
};
Hc.prototype.unbindEvt = function (A, t) {
    var i = this;
    return i._domHandlers_ = i._domHandlers_ || {}, dC(A, rf[t], i._domHandlers_[t]), cm[t] && dC(A, cm[t], i._domHandlers_[t]), delete i._domHandlers_[t], this
};

function lo(A, t) {
    return this.identifier = t.identifier, this.position = t.position, this.frontPosition = t.frontPosition, this.collection = A, this.defaults = {
        size: 100,
        threshold: .1,
        color: "white",
        fadeTime: 250,
        dataOnly: !1,
        restJoystick: !0,
        restOpacity: .5,
        mode: "dynamic",
        zone: document.body,
        lockX: !1,
        lockY: !1,
        shape: "circle"
    }, this.config(t), this.options.mode === "dynamic" && (this.options.restOpacity = 0), this.id = lo.id, lo.id += 1, this.buildEl().stylize(), this.instance = {
        el: this.ui.el,
        on: this.on.bind(this),
        off: this.off.bind(this),
        show: this.show.bind(this),
        hide: this.hide.bind(this),
        add: this.addToDom.bind(this),
        remove: this.removeFromDom.bind(this),
        destroy: this.destroy.bind(this),
        setPosition: this.setPosition.bind(this),
        resetDirection: this.resetDirection.bind(this),
        computeDirection: this.computeDirection.bind(this),
        trigger: this.trigger.bind(this),
        position: this.position,
        frontPosition: this.frontPosition,
        ui: this.ui,
        identifier: this.identifier,
        id: this.id,
        options: this.options
    }, this.instance
}

lo.prototype = new Hc;
lo.constructor = lo;
lo.id = 0;
lo.prototype.buildEl = function (A) {
    return this.ui = {}, this.options.dataOnly ? this : (this.ui.el = document.createElement("div"), this.ui.back = document.createElement("div"), this.ui.front = document.createElement("div"), this.ui.el.className = "nipple collection_" + this.collection.id, this.ui.back.className = "back", this.ui.front.className = "front", this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id), this.ui.el.appendChild(this.ui.back), this.ui.el.appendChild(this.ui.front), this)
};
lo.prototype.stylize = function () {
    if (this.options.dataOnly) return this;
    var A = this.options.fadeTime + "ms", t = D3("borderRadius", "50%"), i = _1("transition", "opacity", A), o = {};
    return o.el = {
        position: "absolute",
        opacity: this.options.restOpacity,
        display: "block",
        zIndex: 999
    }, o.back = {
        position: "absolute",
        display: "block",
        width: this.options.size + "px",
        height: this.options.size + "px",
        left: 0,
        marginLeft: -this.options.size / 2 + "px",
        marginTop: -this.options.size / 2 + "px",
        background: this.options.color,
        opacity: ".5"
    }, o.front = {
        width: this.options.size / 2 + "px",
        height: this.options.size / 2 + "px",
        position: "absolute",
        display: "block",
        left: 0,
        marginLeft: -this.options.size / 4 + "px",
        marginTop: -this.options.size / 4 + "px",
        background: this.options.color,
        opacity: ".5",
        transform: "translate(0px, 0px)"
    }, my(o.el, i), this.options.shape === "circle" && my(o.back, t), my(o.front, t), this.applyStyles(o), this
};
lo.prototype.applyStyles = function (A) {
    for (var t in this.ui) if (this.ui.hasOwnProperty(t)) for (var i in A[t]) this.ui[t].style[i] = A[t][i];
    return this
};
lo.prototype.addToDom = function () {
    return this.options.dataOnly || document.body.contains(this.ui.el) ? this : (this.options.zone.appendChild(this.ui.el), this)
};
lo.prototype.removeFromDom = function () {
    return this.options.dataOnly || !document.body.contains(this.ui.el) ? this : (this.options.zone.removeChild(this.ui.el), this)
};
lo.prototype.destroy = function () {
    clearTimeout(this.removeTimeout), clearTimeout(this.showTimeout), clearTimeout(this.restTimeout), this.trigger("destroyed", this.instance), this.removeFromDom(), this.off()
};
lo.prototype.show = function (A) {
    var t = this;
    return t.options.dataOnly || (clearTimeout(t.removeTimeout), clearTimeout(t.showTimeout), clearTimeout(t.restTimeout), t.addToDom(), t.restCallback(), setTimeout(function () {
        t.ui.el.style.opacity = 1
    }, 0), t.showTimeout = setTimeout(function () {
        t.trigger("shown", t.instance), typeof A == "function" && A.call(this)
    }, t.options.fadeTime)), t
};
lo.prototype.hide = function (A) {
    var t = this;
    if (t.options.dataOnly) return t;
    if (t.ui.el.style.opacity = t.options.restOpacity, clearTimeout(t.removeTimeout), clearTimeout(t.showTimeout), clearTimeout(t.restTimeout), t.removeTimeout = setTimeout(function () {
        var i = t.options.mode === "dynamic" ? "none" : "block";
        t.ui.el.style.display = i, typeof A == "function" && A.call(t), t.trigger("hidden", t.instance)
    }, t.options.fadeTime), t.options.restJoystick) {
        const i = t.options.restJoystick, o = {};
        o.x = i === !0 || i.x !== !1 ? 0 : t.instance.frontPosition.x, o.y = i === !0 || i.y !== !1 ? 0 : t.instance.frontPosition.y, t.setPosition(A, o)
    }
    return t
};
lo.prototype.setPosition = function (A, t) {
    var i = this;
    i.frontPosition = {x: t.x, y: t.y};
    var o = i.options.fadeTime + "ms", c = {};
    c.front = _1("transition", ["transform"], o);
    var f = {front: {}};
    f.front = {transform: "translate(" + i.frontPosition.x + "px," + i.frontPosition.y + "px)"}, i.applyStyles(c), i.applyStyles(f), i.restTimeout = setTimeout(function () {
        typeof A == "function" && A.call(i), i.restCallback()
    }, i.options.fadeTime)
};
lo.prototype.restCallback = function () {
    var A = this, t = {};
    t.front = _1("transition", "none", ""), A.applyStyles(t), A.trigger("rested", A.instance)
};
lo.prototype.resetDirection = function () {
    this.direction = {x: !1, y: !1, angle: !1}
};
lo.prototype.computeDirection = function (A) {
    var t = A.angle.radian, i = Math.PI / 4, o = Math.PI / 2, c, f, T;
    if (t > i && t < i * 3 && !A.lockX ? c = "up" : t > -i && t <= i && !A.lockY ? c = "left" : t > -i * 3 && t <= -i && !A.lockX ? c = "down" : A.lockY || (c = "right"), A.lockY || (t > -o && t < o ? f = "left" : f = "right"), A.lockX || (t > 0 ? T = "up" : T = "down"), A.force > this.options.threshold) {
        var m = {}, x;
        for (x in this.direction) this.direction.hasOwnProperty(x) && (m[x] = this.direction[x]);
        var h = {};
        this.direction = {x: f, y: T, angle: c}, A.direction = this.direction;
        for (x in m) m[x] === this.direction[x] && (h[x] = !0);
        if (h.x && h.y && h.angle) return A;
        (!h.x || !h.y) && this.trigger("plain", A), h.x || this.trigger("plain:" + f, A), h.y || this.trigger("plain:" + T, A), h.angle || this.trigger("dir dir:" + c, A)
    } else this.resetDirection();
    return A
};

function Us(A, t) {
    var i = this;
    i.nipples = [], i.idles = [], i.actives = [], i.ids = [], i.pressureIntervals = {}, i.manager = A, i.id = Us.id, Us.id += 1, i.defaults = {
        zone: document.body,
        multitouch: !1,
        maxNumberOfNipples: 10,
        mode: "dynamic",
        position: {top: 0, left: 0},
        catchDistance: 200,
        size: 100,
        threshold: .1,
        color: "white",
        fadeTime: 250,
        dataOnly: !1,
        restJoystick: !0,
        restOpacity: .5,
        lockX: !1,
        lockY: !1,
        shape: "circle",
        dynamicPage: !1,
        follow: !1
    }, i.config(t), (i.options.mode === "static" || i.options.mode === "semi") && (i.options.multitouch = !1), i.options.multitouch || (i.options.maxNumberOfNipples = 1);
    const o = getComputedStyle(i.options.zone.parentElement);
    return o && o.display === "flex" && (i.parentIsFlex = !0), i.updateBox(), i.prepareNipples(), i.bindings(), i.begin(), i.nipples
}

Us.prototype = new Hc;
Us.constructor = Us;
Us.id = 0;
Us.prototype.prepareNipples = function () {
    var A = this, t = A.nipples;
    t.on = A.on.bind(A), t.off = A.off.bind(A), t.options = A.options, t.destroy = A.destroy.bind(A), t.ids = A.ids, t.id = A.id, t.processOnMove = A.processOnMove.bind(A), t.processOnEnd = A.processOnEnd.bind(A), t.get = function (i) {
        if (i === void 0) return t[0];
        for (var o = 0, c = t.length; o < c; o += 1) if (t[o].identifier === i) return t[o];
        return !1
    }
};
Us.prototype.bindings = function () {
    var A = this;
    A.bindEvt(A.options.zone, "start"), A.options.zone.style.touchAction = "none", A.options.zone.style.msTouchAction = "none"
};
Us.prototype.begin = function () {
    var A = this, t = A.options;
    if (t.mode === "static") {
        var i = A.createNipple(t.position, A.manager.getIdentifier());
        i.add(), A.idles.push(i)
    }
};
Us.prototype.createNipple = function (A, t) {
    var i = this, o = i.manager.scroll, c = {}, f = i.options,
        T = {x: i.parentIsFlex ? o.x : o.x + i.box.left, y: i.parentIsFlex ? o.y : o.y + i.box.top};
    if (A.x && A.y) c = {x: A.x - T.x, y: A.y - T.y}; else if (A.top || A.right || A.bottom || A.left) {
        var m = document.createElement("DIV");
        m.style.display = "hidden", m.style.top = A.top, m.style.right = A.right, m.style.bottom = A.bottom, m.style.left = A.left, m.style.position = "absolute", f.zone.appendChild(m);
        var x = m.getBoundingClientRect();
        f.zone.removeChild(m), c = A, A = {x: x.left + o.x, y: x.top + o.y}
    }
    var h = new lo(i, {
        color: f.color,
        size: f.size,
        threshold: f.threshold,
        fadeTime: f.fadeTime,
        dataOnly: f.dataOnly,
        restJoystick: f.restJoystick,
        restOpacity: f.restOpacity,
        mode: f.mode,
        identifier: t,
        position: A,
        zone: f.zone,
        frontPosition: {x: 0, y: 0},
        shape: f.shape
    });
    return f.dataOnly || (pC(h.ui.el, c), pC(h.ui.front, h.frontPosition)), i.nipples.push(h), i.trigger("added " + h.identifier + ":added", h), i.manager.trigger("added " + h.identifier + ":added", h), i.bindNipple(h), h
};
Us.prototype.updateBox = function () {
    var A = this;
    A.box = A.options.zone.getBoundingClientRect()
};
Us.prototype.bindNipple = function (A) {
    var t = this, i, o = function (c, f) {
        i = c.type + " " + f.id + ":" + c.type, t.trigger(i, f)
    };
    A.on("destroyed", t.onDestroyed.bind(t)), A.on("shown hidden rested dir plain", o), A.on("dir:up dir:right dir:down dir:left", o), A.on("plain:up plain:right plain:down plain:left", o)
};
Us.prototype.pressureFn = function (A, t, i) {
    var o = this, c = 0;
    clearInterval(o.pressureIntervals[i]), o.pressureIntervals[i] = setInterval((function () {
        var f = A.force || A.pressure || A.webkitForce || 0;
        f !== c && (t.trigger("pressure", f), o.trigger("pressure " + t.identifier + ":pressure", f), c = f)
    }).bind(o), 100)
};
Us.prototype.onstart = function (A) {
    var t = this, i = t.options, o = A;
    A = fw(A), t.updateBox();
    var c = function (f) {
        t.actives.length < i.maxNumberOfNipples ? t.processOnStart(f) : o.type.match(/^touch/) && (Object.keys(t.manager.ids).forEach(function (T) {
            if (Object.values(o.touches).findIndex(function (x) {
                return x.identifier === T
            }) < 0) {
                var m = [A[0]];
                m.identifier = T, t.processOnEnd(m)
            }
        }), t.actives.length < i.maxNumberOfNipples && t.processOnStart(f))
    };
    return d1(A, c), t.manager.bindDocument(), !1
};
Us.prototype.processOnStart = function (A) {
    var t = this, i = t.options, o, c = t.manager.getIdentifier(A), f = A.force || A.pressure || A.webkitForce || 0,
        T = {x: A.pageX, y: A.pageY}, m = t.getOrCreate(c, T);
    m.identifier !== c && t.manager.removeIdentifier(m.identifier), m.identifier = c;
    var x = function (g) {
        g.trigger("start", g), t.trigger("start " + g.id + ":start", g), g.show(), f > 0 && t.pressureFn(A, g, g.identifier), t.processOnMove(A)
    };
    if ((o = t.idles.indexOf(m)) >= 0 && t.idles.splice(o, 1), t.actives.push(m), t.ids.push(m.identifier), i.mode !== "semi") x(m); else {
        var h = u0(T, m.position);
        if (h <= i.catchDistance) x(m); else {
            m.destroy(), t.processOnStart(A);
            return
        }
    }
    return m
};
Us.prototype.getOrCreate = function (A, t) {
    var i = this, o = i.options, c;
    return /(semi|static)/.test(o.mode) ? (c = i.idles[0], c ? (i.idles.splice(0, 1), c) : o.mode === "semi" ? i.createNipple(t, A) : (console.warn("Coudln't find the needed nipple."), !1)) : (c = i.createNipple(t, A), c)
};
Us.prototype.processOnMove = function (A) {
    var t = this, i = t.options, o = t.manager.getIdentifier(A), c = t.nipples.get(o), f = t.manager.scroll;
    if (!L3(A)) {
        this.processOnEnd(A);
        return
    }
    if (!c) {
        console.error("Found zombie joystick with ID " + o), t.manager.removeIdentifier(o);
        return
    }
    if (i.dynamicPage) {
        var T = c.el.getBoundingClientRect();
        c.position = {x: f.x + T.left, y: f.y + T.top}
    }
    c.identifier = o;
    var m = c.options.size / 2, x = {x: A.pageX, y: A.pageY};
    i.lockX && (x.y = c.position.y), i.lockY && (x.x = c.position.x);
    var h = u0(x, c.position), g = I3(x, c.position), w = h1(g), v = h / m, E = {distance: h, position: x}, p, C;
    if (c.options.shape === "circle" ? (p = Math.min(h, m), C = R3(c.position, p, g)) : (C = O3(x, c.position, m), p = u0(C, c.position)), i.follow) {
        if (h > m) {
            let R = x.x - C.x, I = x.y - C.y;
            c.position.x += R, c.position.y += I, c.el.style.top = c.position.y - (t.box.top + f.y) + "px", c.el.style.left = c.position.x - (t.box.left + f.x) + "px", h = u0(x, c.position)
        }
    } else x = C, h = p;
    var M = x.x - c.position.x, b = x.y - c.position.y;
    c.frontPosition = {x: M, y: b}, i.dataOnly || (c.ui.front.style.transform = "translate(" + M + "px," + b + "px)");
    var B = {
        identifier: c.identifier,
        position: x,
        force: v,
        pressure: A.force || A.pressure || A.webkitForce || 0,
        distance: h,
        angle: {radian: w, degree: g},
        vector: {x: M / m, y: -b / m},
        raw: E,
        instance: c,
        lockX: i.lockX,
        lockY: i.lockY
    };
    B = c.computeDirection(B), B.angle = {
        radian: h1(180 - g),
        degree: 180 - g
    }, c.trigger("move", B), t.trigger("move " + c.id + ":move", B)
};
Us.prototype.processOnEnd = function (A) {
    var t = this, i = t.options, o = t.manager.getIdentifier(A), c = t.nipples.get(o),
        f = t.manager.removeIdentifier(c.identifier);
    c && (i.dataOnly || c.hide(function () {
        i.mode === "dynamic" && (c.trigger("removed", c), t.trigger("removed " + c.id + ":removed", c), t.manager.trigger("removed " + c.id + ":removed", c), c.destroy())
    }), clearInterval(t.pressureIntervals[c.identifier]), c.resetDirection(), c.trigger("end", c), t.trigger("end " + c.id + ":end", c), t.ids.indexOf(c.identifier) >= 0 && t.ids.splice(t.ids.indexOf(c.identifier), 1), t.actives.indexOf(c) >= 0 && t.actives.splice(t.actives.indexOf(c), 1), /(semi|static)/.test(i.mode) ? t.idles.push(c) : t.nipples.indexOf(c) >= 0 && t.nipples.splice(t.nipples.indexOf(c), 1), t.manager.unbindDocument(), /(semi|static)/.test(i.mode) && (t.manager.ids[f.id] = f.identifier))
};
Us.prototype.onDestroyed = function (A, t) {
    var i = this;
    i.nipples.indexOf(t) >= 0 && i.nipples.splice(i.nipples.indexOf(t), 1), i.actives.indexOf(t) >= 0 && i.actives.splice(i.actives.indexOf(t), 1), i.idles.indexOf(t) >= 0 && i.idles.splice(i.idles.indexOf(t), 1), i.ids.indexOf(t.identifier) >= 0 && i.ids.splice(i.ids.indexOf(t.identifier), 1), i.manager.removeIdentifier(t.identifier), i.manager.unbindDocument()
};
Us.prototype.destroy = function () {
    var A = this;
    A.unbindEvt(A.options.zone, "start"), A.nipples.forEach(function (i) {
        i.destroy()
    });
    for (var t in A.pressureIntervals) A.pressureIntervals.hasOwnProperty(t) && clearInterval(A.pressureIntervals[t]);
    A.trigger("destroyed", A.nipples), A.manager.unbindDocument(), A.off()
};

function yo(A) {
    var t = this;
    t.ids = {}, t.index = 0, t.collections = [], t.scroll = fC(), t.config(A), t.prepareCollections();
    var i = function () {
        var c;
        t.collections.forEach(function (f) {
            f.forEach(function (T) {
                c = T.el.getBoundingClientRect(), T.position = {x: t.scroll.x + c.left, y: t.scroll.y + c.top}
            })
        })
    };
    A0(window, "resize", function () {
        hC(i)
    });
    var o = function () {
        t.scroll = fC()
    };
    return A0(window, "scroll", function () {
        hC(o)
    }), t.collections
}

yo.prototype = new Hc;
yo.constructor = yo;
yo.prototype.prepareCollections = function () {
    var A = this;
    A.collections.create = A.create.bind(A), A.collections.on = A.on.bind(A), A.collections.off = A.off.bind(A), A.collections.destroy = A.destroy.bind(A), A.collections.get = function (t) {
        var i;
        return A.collections.every(function (o) {
            return i = o.get(t), !i
        }), i
    }
};
yo.prototype.create = function (A) {
    return this.createCollection(A)
};
yo.prototype.createCollection = function (A) {
    var t = this, i = new Us(t, A);
    return t.bindCollection(i), t.collections.push(i), i
};
yo.prototype.bindCollection = function (A) {
    var t = this, i, o = function (c, f) {
        i = c.type + " " + f.id + ":" + c.type, t.trigger(i, f)
    };
    A.on("destroyed", t.onDestroyed.bind(t)), A.on("shown hidden rested dir plain", o), A.on("dir:up dir:right dir:down dir:left", o), A.on("plain:up plain:right plain:down plain:left", o)
};
yo.prototype.bindDocument = function () {
    var A = this;
    A.binded || (A.bindEvt(document, "move").bindEvt(document, "end"), A.binded = !0)
};
yo.prototype.unbindDocument = function (A) {
    var t = this;
    (!Object.keys(t.ids).length || A === !0) && (t.unbindEvt(document, "move").unbindEvt(document, "end"), t.binded = !1)
};
yo.prototype.getIdentifier = function (A) {
    var t;
    return A ? (t = A.identifier === void 0 ? A.pointerId : A.identifier, t === void 0 && (t = this.latest || 0)) : t = this.index, this.ids[t] === void 0 && (this.ids[t] = this.index, this.index += 1), this.latest = t, this.ids[t]
};
yo.prototype.removeIdentifier = function (A) {
    var t = {};
    for (var i in this.ids) if (this.ids[i] === A) {
        t.id = i, t.identifier = this.ids[i], delete this.ids[i];
        break
    }
    return t
};
yo.prototype.onmove = function (A) {
    var t = this;
    return t.onAny("move", A), !1
};
yo.prototype.onend = function (A) {
    var t = this;
    return t.onAny("end", A), !1
};
yo.prototype.oncancel = function (A) {
    var t = this;
    return t.onAny("end", A), !1
};
yo.prototype.onAny = function (A, t) {
    var i = this, o, c = "processOn" + A.charAt(0).toUpperCase() + A.slice(1);
    t = fw(t);
    var f = function (m, x, h) {
        h.ids.indexOf(x) >= 0 && (h[c](m), m._found_ = !0)
    }, T = function (m) {
        o = i.getIdentifier(m), d1(i.collections, f.bind(null, m, o)), m._found_ || i.removeIdentifier(o)
    };
    return d1(t, T), !1
};
yo.prototype.destroy = function () {
    var A = this;
    A.unbindDocument(!0), A.ids = {}, A.index = 0, A.collections.forEach(function (t) {
        t.destroy()
    }), A.off()
};
yo.prototype.onDestroyed = function (A, t) {
    var i = this;
    if (i.collections.indexOf(t) < 0) return !1;
    i.collections.splice(i.collections.indexOf(t), 1)
};
const mC = new yo, AC = {
    create: function (A) {
        return mC.create(A)
    }, factory: mC
};
AFRAME.registerComponent("nipple-controls", {
    schema: {
        enabled: {default: !0},
        mode: {default: "dynamic", oneOf: ["static", "semi", "dynamic"]},
        rotationSensitivity: {default: 1},
        moveJoystickEnabled: {default: !0},
        lookJoystickEnabled: {default: !0},
        sideMargin: {default: "30px"},
        bottomMargin: {default: "70px"},
        moveJoystickPosition: {default: "left", oneOf: ["left", "right"]},
        lookJoystickPosition: {default: "right", oneOf: ["left", "right"]}
    }, init() {
        this.dVelocity = new THREE.Vector3, this.lookVector = new THREE.Vector2;
        const A = this.el.querySelector("[look-controls]").components["look-controls"];
        this.pitchObject = A.pitchObject, this.yawObject = A.yawObject, this.rigRotation = this.el.object3D.rotation, this.moveData = void 0, this.lookData = void 0, this.moving = !1, this.rotating = !1
    }, update(A) {
        (this.data.moveJoystickPosition !== A.moveJoystickPosition || this.data.sideMargin !== A.sideMargin || this.data.bottomMargin !== A.bottomMargin || this.data.mode !== A.mode) && this.removeMoveJoystick(), (this.data.lookJoystickPosition !== A.lookJoystickPosition || this.data.sideMargin !== A.sideMargin || this.data.bottomMargin !== A.bottomMargin || this.data.mode !== A.mode) && this.removeLookJoystick(), this.data.enabled && this.data.moveJoystickEnabled ? this.createMoveJoystick() : this.removeMoveJoystick(), this.data.enabled && this.data.lookJoystickEnabled ? this.createLookJoystick() : this.removeLookJoystick()
    }, pause() {
        this.moving = !1, this.rotating = !1
    }, remove() {
        this.removeMoveJoystick(), this.removeLookJoystick()
    }, isVelocityActive() {
        return this.data.enabled && this.moving
    }, getVelocityDelta() {
        if (this.dVelocity.set(0, 0, 0), this.isVelocityActive()) {
            const A = this.moveData.force < 1 ? this.moveData.force : 1, t = this.moveData.angle.radian,
                i = Math.cos(t) * A, o = -Math.sin(t) * A;
            this.dVelocity.set(i, 0, o)
        }
        return this.dVelocity
    }, isRotationActive() {
        return this.data.enabled && this.rotating
    }, updateRotation(A) {
        if (!this.isRotationActive()) return;
        const t = this.lookData.force < 1 ? this.lookData.force : 1, i = this.lookData.angle.radian,
            o = this.lookVector;
        o.x = Math.cos(i) * t, o.y = Math.sin(i) * t, o.multiplyScalar(this.data.rotationSensitivity * A / 1e3), this.yawObject.rotation.y -= o.x;
        let c = this.pitchObject.rotation.x + o.y;
        c = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, c)), this.pitchObject.rotation.x = c
    }, tick: function (A, t) {
        this.updateRotation(t)
    }, initLeftZone() {
        const A = document.createElement("div");
        A.setAttribute("id", "joystickLeftZone"), A.setAttribute("style", `position:absolute;${this.data.moveJoystickPosition}:${this.data.sideMargin};bottom:${this.data.bottomMargin};z-index:1`), document.body.appendChild(A), this.leftZone = A
    }, initRightZone() {
        const A = document.createElement("div");
        A.setAttribute("id", "joystickRightZone"), A.setAttribute("style", `position:absolute;${this.data.lookJoystickPosition}:${this.data.sideMargin};bottom:${this.data.bottomMargin};z-index:1`), document.body.appendChild(A), this.rightZone = A
    }, createMoveJoystick() {
        if (this.moveJoystick) return;
        this.initLeftZone();
        const A = {mode: this.data.mode, zone: this.leftZone, color: "white", fadeTime: 0};
        this.leftZone.style.width = "100px", this.data.mode === "static" ? (this.leftZone.style.height = "100px", A.position = {
            left: "50%",
            bottom: "50%"
        }) : this.leftZone.style.height = "400px", this.moveJoystick = AC.create(A), this.moveJoystick.on("move", (t, i) => {
            this.moveData = i, this.moving = !0
        }), this.moveJoystick.on("end", (t, i) => {
            this.moving = !1
        })
    }, createLookJoystick() {
        if (this.lookJoystick) return;
        this.initRightZone();
        const A = {mode: this.data.mode, zone: this.rightZone, color: "white", fadeTime: 0};
        this.rightZone.style.width = "100px", this.data.mode === "static" ? (this.rightZone.style.height = "100px", A.position = {
            left: "50%",
            bottom: "50%"
        }) : this.rightZone.style.height = "400px", this.lookJoystick = AC.create(A), this.lookJoystick.on("move", (t, i) => {
            this.lookData = i, this.rotating = !0
        }), this.lookJoystick.on("end", (t, i) => {
            this.rotating = !1
        })
    }, removeMoveJoystick() {
        this.moveJoystick && (this.moveJoystick.destroy(), this.moveJoystick = void 0), this.moveData = void 0, this.leftZone && this.leftZone.parentNode && (this.leftZone.remove(), this.leftZone = void 0)
    }, removeLookJoystick() {
        this.lookJoystick && (this.lookJoystick.destroy(), this.lookJoystick = void 0), this.lookData = void 0, this.rightZone && this.rightZone.parentNode && (this.rightZone.remove(), this.rightZone = void 0)
    }
});
var gC;

function U3() {
    return gC || (gC = 1, E3(), w3(), _3(), M3(), S3(), T3()), eC
}

var vC = {}, Ay, yC;

function z3() {
    if (yC) return Ay;
    yC = 1;
    const A = {once: THREE.LoopOnce, repeat: THREE.LoopRepeat, pingpong: THREE.LoopPingPong};
    Ay = AFRAME.registerComponent("animation-mixer", {
        schema: {
            clip: {default: "*"},
            useRegExp: {default: !1},
            duration: {default: 0},
            clampWhenFinished: {default: !1, type: "boolean"},
            crossFadeDuration: {default: 0},
            loop: {default: "repeat", oneOf: Object.keys(A)},
            repetitions: {default: 1 / 0, min: 0},
            timeScale: {default: 1},
            startAt: {default: 0}
        }, init: function () {
            this.model = null, this.mixer = null, this.activeActions = [];
            const o = this.el.getObject3D("mesh");
            o ? this.load(o) : this.el.addEventListener("model-loaded", c => {
                this.load(c.detail.model)
            })
        }, load: function (o) {
            const c = this.el;
            this.model = o, this.mixer = new THREE.AnimationMixer(o), this.mixer.addEventListener("loop", f => {
                c.emit("animation-loop", {action: f.action, loopDelta: f.loopDelta})
            }), this.mixer.addEventListener("finished", f => {
                c.emit("animation-finished", {action: f.action, direction: f.direction})
            }), this.data.clip && this.update({})
        }, remove: function () {
            this.mixer && this.mixer.stopAllAction()
        }, update: function (o) {
            if (!o) return;
            const c = this.data, f = AFRAME.utils.diff(c, o);
            if ("clip" in f) {
                this.stopAction(), c.clip && this.playAction();
                return
            }
            this.activeActions.forEach(T => {
                "duration" in f && c.duration && T.setDuration(c.duration), "clampWhenFinished" in f && (T.clampWhenFinished = c.clampWhenFinished), ("loop" in f || "repetitions" in f) && T.setLoop(A[c.loop], c.repetitions), "timeScale" in f && T.setEffectiveTimeScale(c.timeScale)
            })
        }, stopAction: function () {
            const o = this.data;
            for (let c = 0; c < this.activeActions.length; c++) o.crossFadeDuration ? this.activeActions[c].fadeOut(o.crossFadeDuration) : this.activeActions[c].stop();
            this.activeActions.length = 0
        }, playAction: function () {
            if (!this.mixer) return;
            const o = this.model, c = this.data, f = o.animations || (o.geometry || {}).animations || [];
            if (!f.length) return;
            const T = c.useRegExp ? c.clip : t(c.clip);
            for (let m, x = 0; m = f[x]; x++) if (m.name.match(T)) {
                const h = this.mixer.clipAction(m, o);
                h.enabled = !0, h.clampWhenFinished = c.clampWhenFinished, c.duration && h.setDuration(c.duration), c.timeScale !== 1 && h.setEffectiveTimeScale(c.timeScale), h.startAt(this.mixer.time - c.startAt / 1e3), h.setLoop(A[c.loop], c.repetitions).fadeIn(c.crossFadeDuration).play(), this.activeActions.push(h)
            }
        }, tick: function (o, c) {
            this.mixer && !isNaN(c) && this.mixer.update(c / 1e3)
        }
    });

    function t(o) {
        return new RegExp("^" + o.split(/\*+/).map(i).join(".*") + "$")
    }

    function i(o) {
        return o.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&")
    }

    return Ay
}

/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const mw = "164", g0 = 0, G3 = 1, V3 = 2, EC = 1, xC = 100, CC = 204, wC = 205, bC = 3, M1 = 0, _C = "attached",
    H3 = "detached", Aw = 300, Q3 = 303, Iu = 1e3, Xl = 1001, MC = 1002, v0 = 1003, im = 1006, S1 = 1008, j3 = 1009,
    W3 = 1014, gw = 1015, K3 = 1020, vw = 1023, gy = 1026, SC = 1027, y0 = 2300, E0 = 2301, vy = 2302, TC = 2400,
    IC = 2401, RC = 2402, X3 = 2500, yw = 0, Ew = "", ca = "srgb", T1 = "srgb-linear", Y3 = "display-p3",
    xw = "display-p3-linear", f1 = "linear", BC = "srgb", LC = "rec709", DC = "p3", Gd = 7680, PC = 519, q3 = 515,
    OC = 35044, Ph = 2e3, p1 = 2001;

class Gc {
    addEventListener(t, i) {
        this._listeners === void 0 && (this._listeners = {});
        const o = this._listeners;
        o[t] === void 0 && (o[t] = []), o[t].indexOf(i) === -1 && o[t].push(i)
    }

    hasEventListener(t, i) {
        if (this._listeners === void 0) return !1;
        const o = this._listeners;
        return o[t] !== void 0 && o[t].indexOf(i) !== -1
    }

    removeEventListener(t, i) {
        if (this._listeners === void 0) return;
        const c = this._listeners[t];
        if (c !== void 0) {
            const f = c.indexOf(i);
            f !== -1 && c.splice(f, 1)
        }
    }

    dispatchEvent(t) {
        if (this._listeners === void 0) return;
        const o = this._listeners[t.type];
        if (o !== void 0) {
            t.target = this;
            const c = o.slice(0);
            for (let f = 0, T = c.length; f < T; f++) c[f].call(this, t);
            t.target = null
        }
    }
}

const Go = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let kC = 1234567;
const rm = Math.PI / 180, um = 180 / Math.PI;

function Pu() {
    const A = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0,
        o = Math.random() * 4294967295 | 0;
    return (Go[A & 255] + Go[A >> 8 & 255] + Go[A >> 16 & 255] + Go[A >> 24 & 255] + "-" + Go[t & 255] + Go[t >> 8 & 255] + "-" + Go[t >> 16 & 15 | 64] + Go[t >> 24 & 255] + "-" + Go[i & 63 | 128] + Go[i >> 8 & 255] + "-" + Go[i >> 16 & 255] + Go[i >> 24 & 255] + Go[o & 255] + Go[o >> 8 & 255] + Go[o >> 16 & 255] + Go[o >> 24 & 255]).toLowerCase()
}

function Ro(A, t, i) {
    return Math.max(t, Math.min(i, A))
}

function I1(A, t) {
    return (A % t + t) % t
}

function J3(A, t, i, o, c) {
    return o + (A - t) * (c - o) / (i - t)
}

function Z3(A, t, i) {
    return A !== t ? (i - A) / (t - A) : 0
}

function sm(A, t, i) {
    return (1 - i) * A + i * t
}

function $3(A, t, i, o) {
    return sm(A, t, 1 - Math.exp(-i * o))
}

function eS(A, t = 1) {
    return t - Math.abs(I1(A, t * 2) - t)
}

function tS(A, t, i) {
    return A <= t ? 0 : A >= i ? 1 : (A = (A - t) / (i - t), A * A * (3 - 2 * A))
}

function nS(A, t, i) {
    return A <= t ? 0 : A >= i ? 1 : (A = (A - t) / (i - t), A * A * A * (A * (A * 6 - 15) + 10))
}

function iS(A, t) {
    return A + Math.floor(Math.random() * (t - A + 1))
}

function rS(A, t) {
    return A + Math.random() * (t - A)
}

function sS(A) {
    return A * (.5 - Math.random())
}

function oS(A) {
    A !== void 0 && (kC = A);
    let t = kC += 1831565813;
    return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296
}

function aS(A) {
    return A * rm
}

function lS(A) {
    return A * um
}

function cS(A) {
    return (A & A - 1) === 0 && A !== 0
}

function uS(A) {
    return Math.pow(2, Math.ceil(Math.log(A) / Math.LN2))
}

function hS(A) {
    return Math.pow(2, Math.floor(Math.log(A) / Math.LN2))
}

function dS(A, t, i, o, c) {
    const f = Math.cos, T = Math.sin, m = f(i / 2), x = T(i / 2), h = f((t + o) / 2), g = T((t + o) / 2),
        w = f((t - o) / 2), v = T((t - o) / 2), E = f((o - t) / 2), p = T((o - t) / 2);
    switch (c) {
        case"XYX":
            A.set(m * g, x * w, x * v, m * h);
            break;
        case"YZY":
            A.set(x * v, m * g, x * w, m * h);
            break;
        case"ZXZ":
            A.set(x * w, x * v, m * g, m * h);
            break;
        case"XZX":
            A.set(m * g, x * p, x * E, m * h);
            break;
        case"YXY":
            A.set(x * E, m * g, x * p, m * h);
            break;
        case"ZYZ":
            A.set(x * p, x * E, m * g, m * h);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + c)
    }
}

function nf(A, t) {
    switch (t.constructor) {
        case Float32Array:
            return A;
        case Uint32Array:
            return A / 4294967295;
        case Uint16Array:
            return A / 65535;
        case Uint8Array:
            return A / 255;
        case Int32Array:
            return Math.max(A / 2147483647, -1);
        case Int16Array:
            return Math.max(A / 32767, -1);
        case Int8Array:
            return Math.max(A / 127, -1);
        default:
            throw new Error("Invalid component type.")
    }
}

function aa(A, t) {
    switch (t.constructor) {
        case Float32Array:
            return A;
        case Uint32Array:
            return Math.round(A * 4294967295);
        case Uint16Array:
            return Math.round(A * 65535);
        case Uint8Array:
            return Math.round(A * 255);
        case Int32Array:
            return Math.round(A * 2147483647);
        case Int16Array:
            return Math.round(A * 32767);
        case Int8Array:
            return Math.round(A * 127);
        default:
            throw new Error("Invalid component type.")
    }
}

const Js = {
    DEG2RAD: rm,
    RAD2DEG: um,
    generateUUID: Pu,
    clamp: Ro,
    euclideanModulo: I1,
    mapLinear: J3,
    inverseLerp: Z3,
    lerp: sm,
    damp: $3,
    pingpong: eS,
    smoothstep: tS,
    smootherstep: nS,
    randInt: iS,
    randFloat: rS,
    randFloatSpread: sS,
    seededRandom: oS,
    degToRad: aS,
    radToDeg: lS,
    isPowerOfTwo: cS,
    ceilPowerOfTwo: uS,
    floorPowerOfTwo: hS,
    setQuaternionFromProperEuler: dS,
    normalize: aa,
    denormalize: nf
};

class es {
    constructor(t = 0, i = 0) {
        es.prototype.isVector2 = !0, this.x = t, this.y = i
    }

    get width() {
        return this.x
    }

    set width(t) {
        this.x = t
    }

    get height() {
        return this.y
    }

    set height(t) {
        this.y = t
    }

    set(t, i) {
        return this.x = t, this.y = i, this
    }

    setScalar(t) {
        return this.x = t, this.y = t, this
    }

    setX(t) {
        return this.x = t, this
    }

    setY(t) {
        return this.y = t, this
    }

    setComponent(t, i) {
        switch (t) {
            case 0:
                this.x = i;
                break;
            case 1:
                this.y = i;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }

    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
        }
    }

    clone() {
        return new this.constructor(this.x, this.y)
    }

    copy(t) {
        return this.x = t.x, this.y = t.y, this
    }

    add(t) {
        return this.x += t.x, this.y += t.y, this
    }

    addScalar(t) {
        return this.x += t, this.y += t, this
    }

    addVectors(t, i) {
        return this.x = t.x + i.x, this.y = t.y + i.y, this
    }

    addScaledVector(t, i) {
        return this.x += t.x * i, this.y += t.y * i, this
    }

    sub(t) {
        return this.x -= t.x, this.y -= t.y, this
    }

    subScalar(t) {
        return this.x -= t, this.y -= t, this
    }

    subVectors(t, i) {
        return this.x = t.x - i.x, this.y = t.y - i.y, this
    }

    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this
    }

    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this
    }

    divide(t) {
        return this.x /= t.x, this.y /= t.y, this
    }

    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }

    applyMatrix3(t) {
        const i = this.x, o = this.y, c = t.elements;
        return this.x = c[0] * i + c[3] * o + c[6], this.y = c[1] * i + c[4] * o + c[7], this
    }

    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
    }

    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
    }

    clamp(t, i) {
        return this.x = Math.max(t.x, Math.min(i.x, this.x)), this.y = Math.max(t.y, Math.min(i.y, this.y)), this
    }

    clampScalar(t, i) {
        return this.x = Math.max(t, Math.min(i, this.x)), this.y = Math.max(t, Math.min(i, this.y)), this
    }

    clampLength(t, i) {
        const o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(t, Math.min(i, o)))
    }

    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }

    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }

    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }

    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
    }

    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }

    dot(t) {
        return this.x * t.x + this.y * t.y
    }

    cross(t) {
        return this.x * t.y - this.y * t.x
    }

    lengthSq() {
        return this.x * this.x + this.y * this.y
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }

    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }

    normalize() {
        return this.divideScalar(this.length() || 1)
    }

    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }

    angleTo(t) {
        const i = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (i === 0) return Math.PI / 2;
        const o = this.dot(t) / i;
        return Math.acos(Ro(o, -1, 1))
    }

    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
    }

    distanceToSquared(t) {
        const i = this.x - t.x, o = this.y - t.y;
        return i * i + o * o
    }

    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }

    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }

    lerp(t, i) {
        return this.x += (t.x - this.x) * i, this.y += (t.y - this.y) * i, this
    }

    lerpVectors(t, i, o) {
        return this.x = t.x + (i.x - t.x) * o, this.y = t.y + (i.y - t.y) * o, this
    }

    equals(t) {
        return t.x === this.x && t.y === this.y
    }

    fromArray(t, i = 0) {
        return this.x = t[i], this.y = t[i + 1], this
    }

    toArray(t = [], i = 0) {
        return t[i] = this.x, t[i + 1] = this.y, t
    }

    fromBufferAttribute(t, i) {
        return this.x = t.getX(i), this.y = t.getY(i), this
    }

    rotateAround(t, i) {
        const o = Math.cos(i), c = Math.sin(i), f = this.x - t.x, T = this.y - t.y;
        return this.x = f * o - T * c + t.x, this.y = f * c + T * o + t.y, this
    }

    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }

    * [Symbol.iterator]() {
        yield this.x, yield this.y
    }
}

class Jl {
    constructor(t, i, o, c, f, T, m, x, h) {
        Jl.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], t !== void 0 && this.set(t, i, o, c, f, T, m, x, h)
    }

    set(t, i, o, c, f, T, m, x, h) {
        const g = this.elements;
        return g[0] = t, g[1] = c, g[2] = m, g[3] = i, g[4] = f, g[5] = x, g[6] = o, g[7] = T, g[8] = h, this
    }

    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }

    copy(t) {
        const i = this.elements, o = t.elements;
        return i[0] = o[0], i[1] = o[1], i[2] = o[2], i[3] = o[3], i[4] = o[4], i[5] = o[5], i[6] = o[6], i[7] = o[7], i[8] = o[8], this
    }

    extractBasis(t, i, o) {
        return t.setFromMatrix3Column(this, 0), i.setFromMatrix3Column(this, 1), o.setFromMatrix3Column(this, 2), this
    }

    setFromMatrix4(t) {
        const i = t.elements;
        return this.set(i[0], i[4], i[8], i[1], i[5], i[9], i[2], i[6], i[10]), this
    }

    multiply(t) {
        return this.multiplyMatrices(this, t)
    }

    premultiply(t) {
        return this.multiplyMatrices(t, this)
    }

    multiplyMatrices(t, i) {
        const o = t.elements, c = i.elements, f = this.elements, T = o[0], m = o[3], x = o[6], h = o[1], g = o[4],
            w = o[7], v = o[2], E = o[5], p = o[8], C = c[0], M = c[3], b = c[6], B = c[1], R = c[4], I = c[7],
            L = c[2], O = c[5], N = c[8];
        return f[0] = T * C + m * B + x * L, f[3] = T * M + m * R + x * O, f[6] = T * b + m * I + x * N, f[1] = h * C + g * B + w * L, f[4] = h * M + g * R + w * O, f[7] = h * b + g * I + w * N, f[2] = v * C + E * B + p * L, f[5] = v * M + E * R + p * O, f[8] = v * b + E * I + p * N, this
    }

    multiplyScalar(t) {
        const i = this.elements;
        return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= t, i[4] *= t, i[7] *= t, i[2] *= t, i[5] *= t, i[8] *= t, this
    }

    determinant() {
        const t = this.elements, i = t[0], o = t[1], c = t[2], f = t[3], T = t[4], m = t[5], x = t[6], h = t[7],
            g = t[8];
        return i * T * g - i * m * h - o * f * g + o * m * x + c * f * h - c * T * x
    }

    invert() {
        const t = this.elements, i = t[0], o = t[1], c = t[2], f = t[3], T = t[4], m = t[5], x = t[6], h = t[7],
            g = t[8], w = g * T - m * h, v = m * x - g * f, E = h * f - T * x, p = i * w + o * v + c * E;
        if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const C = 1 / p;
        return t[0] = w * C, t[1] = (c * h - g * o) * C, t[2] = (m * o - c * T) * C, t[3] = v * C, t[4] = (g * i - c * x) * C, t[5] = (c * f - m * i) * C, t[6] = E * C, t[7] = (o * x - h * i) * C, t[8] = (T * i - o * f) * C, this
    }

    transpose() {
        let t;
        const i = this.elements;
        return t = i[1], i[1] = i[3], i[3] = t, t = i[2], i[2] = i[6], i[6] = t, t = i[5], i[5] = i[7], i[7] = t, this
    }

    getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose()
    }

    transposeIntoArray(t) {
        const i = this.elements;
        return t[0] = i[0], t[1] = i[3], t[2] = i[6], t[3] = i[1], t[4] = i[4], t[5] = i[7], t[6] = i[2], t[7] = i[5], t[8] = i[8], this
    }

    setUvTransform(t, i, o, c, f, T, m) {
        const x = Math.cos(f), h = Math.sin(f);
        return this.set(o * x, o * h, -o * (x * T + h * m) + T + t, -c * h, c * x, -c * (-h * T + x * m) + m + i, 0, 0, 1), this
    }

    scale(t, i) {
        return this.premultiply(yy.makeScale(t, i)), this
    }

    rotate(t) {
        return this.premultiply(yy.makeRotation(-t)), this
    }

    translate(t, i) {
        return this.premultiply(yy.makeTranslation(t, i)), this
    }

    makeTranslation(t, i) {
        return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, i, 0, 0, 1), this
    }

    makeRotation(t) {
        const i = Math.cos(t), o = Math.sin(t);
        return this.set(i, -o, 0, o, i, 0, 0, 0, 1), this
    }

    makeScale(t, i) {
        return this.set(t, 0, 0, 0, i, 0, 0, 0, 1), this
    }

    equals(t) {
        const i = this.elements, o = t.elements;
        for (let c = 0; c < 9; c++) if (i[c] !== o[c]) return !1;
        return !0
    }

    fromArray(t, i = 0) {
        for (let o = 0; o < 9; o++) this.elements[o] = t[o + i];
        return this
    }

    toArray(t = [], i = 0) {
        const o = this.elements;
        return t[i] = o[0], t[i + 1] = o[1], t[i + 2] = o[2], t[i + 3] = o[3], t[i + 4] = o[4], t[i + 5] = o[5], t[i + 6] = o[6], t[i + 7] = o[7], t[i + 8] = o[8], t
    }

    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}

const yy = new Jl;

function fS(A) {
    for (let t = A.length - 1; t >= 0; --t) if (A[t] >= 65535) return !0;
    return !1
}

function m1(A) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", A)
}

const FC = {};

function pS(A) {
    A in FC || (FC[A] = !0, console.warn(A))
}

const NC = new Jl().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
    UC = new Jl().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735), Pg = {
        [T1]: {transfer: f1, primaries: LC, toReference: A => A, fromReference: A => A},
        [ca]: {
            transfer: BC,
            primaries: LC,
            toReference: A => A.convertSRGBToLinear(),
            fromReference: A => A.convertLinearToSRGB()
        },
        [xw]: {transfer: f1, primaries: DC, toReference: A => A.applyMatrix3(UC), fromReference: A => A.applyMatrix3(NC)},
        [Y3]: {
            transfer: BC,
            primaries: DC,
            toReference: A => A.convertSRGBToLinear().applyMatrix3(UC),
            fromReference: A => A.applyMatrix3(NC).convertLinearToSRGB()
        }
    }, mS = new Set([T1, xw]), gl = {
        enabled: !0, _workingColorSpace: T1, get workingColorSpace() {
            return this._workingColorSpace
        }, set workingColorSpace(A) {
            if (!mS.has(A)) throw new Error(`Unsupported working color space, "${A}".`);
            this._workingColorSpace = A
        }, convert: function (A, t, i) {
            if (this.enabled === !1 || t === i || !t || !i) return A;
            const o = Pg[t].toReference, c = Pg[i].fromReference;
            return c(o(A))
        }, fromWorkingColorSpace: function (A, t) {
            return this.convert(A, this._workingColorSpace, t)
        }, toWorkingColorSpace: function (A, t) {
            return this.convert(A, t, this._workingColorSpace)
        }, getPrimaries: function (A) {
            return Pg[A].primaries
        }, getTransfer: function (A) {
            return A === Ew ? f1 : Pg[A].transfer
        }
    };

function af(A) {
    return A < .04045 ? A * .0773993808 : Math.pow(A * .9478672986 + .0521327014, 2.4)
}

function Ey(A) {
    return A < .0031308 ? A * 12.92 : 1.055 * Math.pow(A, .41666) - .055
}

let Vd;

class AS {
    static getDataURL(t) {
        if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
        let i;
        if (t instanceof HTMLCanvasElement) i = t; else {
            Vd === void 0 && (Vd = m1("canvas")), Vd.width = t.width, Vd.height = t.height;
            const o = Vd.getContext("2d");
            t instanceof ImageData ? o.putImageData(t, 0, 0) : o.drawImage(t, 0, 0, t.width, t.height), i = Vd
        }
        return i.width > 2048 || i.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), i.toDataURL("image/jpeg", .6)) : i.toDataURL("image/png")
    }

    static sRGBToLinear(t) {
        if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
            const i = m1("canvas");
            i.width = t.width, i.height = t.height;
            const o = i.getContext("2d");
            o.drawImage(t, 0, 0, t.width, t.height);
            const c = o.getImageData(0, 0, t.width, t.height), f = c.data;
            for (let T = 0; T < f.length; T++) f[T] = af(f[T] / 255) * 255;
            return o.putImageData(c, 0, 0), i
        } else if (t.data) {
            const i = t.data.slice(0);
            for (let o = 0; o < i.length; o++) i instanceof Uint8Array || i instanceof Uint8ClampedArray ? i[o] = Math.floor(af(i[o] / 255) * 255) : i[o] = af(i[o]);
            return {data: i, width: t.width, height: t.height}
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
    }
}

let gS = 0;

class Cw {
    constructor(t = null) {
        this.isSource = !0, Object.defineProperty(this, "id", {value: gS++}), this.uuid = Pu(), this.data = t, this.dataReady = !0, this.version = 0
    }

    set needsUpdate(t) {
        t === !0 && this.version++
    }

    toJSON(t) {
        const i = t === void 0 || typeof t == "string";
        if (!i && t.images[this.uuid] !== void 0) return t.images[this.uuid];
        const o = {uuid: this.uuid, url: ""}, c = this.data;
        if (c !== null) {
            let f;
            if (Array.isArray(c)) {
                f = [];
                for (let T = 0, m = c.length; T < m; T++) c[T].isDataTexture ? f.push(xy(c[T].image)) : f.push(xy(c[T]))
            } else f = xy(c);
            o.url = f
        }
        return i || (t.images[this.uuid] = o), o
    }
}

function xy(A) {
    return typeof HTMLImageElement < "u" && A instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && A instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && A instanceof ImageBitmap ? AS.getDataURL(A) : A.data ? {
        data: Array.from(A.data),
        width: A.width,
        height: A.height,
        type: A.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}

let vS = 0;

class ya extends Gc {
    constructor(t = ya.DEFAULT_IMAGE, i = ya.DEFAULT_MAPPING, o = Xl, c = Xl, f = im, T = S1, m = vw, x = j3, h = ya.DEFAULT_ANISOTROPY, g = Ew) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {value: vS++}), this.uuid = Pu(), this.name = "", this.source = new Cw(t), this.mipmaps = [], this.mapping = i, this.channel = 0, this.wrapS = o, this.wrapT = c, this.magFilter = f, this.minFilter = T, this.anisotropy = h, this.format = m, this.internalFormat = null, this.type = x, this.offset = new es(0, 0), this.repeat = new es(1, 1), this.center = new es(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Jl, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = g, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
    }

    get image() {
        return this.source.data
    }

    set image(t = null) {
        this.source.data = t
    }

    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
    }

    toJSON(t) {
        const i = t === void 0 || typeof t == "string";
        if (!i && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
        const o = {
            metadata: {version: 4.6, type: "Texture", generator: "Texture.toJSON"},
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (o.userData = this.userData), i || (t.textures[this.uuid] = o), o
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }

    transformUv(t) {
        if (this.mapping !== Aw) return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
            case Iu:
                t.x = t.x - Math.floor(t.x);
                break;
            case Xl:
                t.x = t.x < 0 ? 0 : 1;
                break;
            case MC:
                Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                break
        }
        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
            case Iu:
                t.y = t.y - Math.floor(t.y);
                break;
            case Xl:
                t.y = t.y < 0 ? 0 : 1;
                break;
            case MC:
                Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                break
        }
        return this.flipY && (t.y = 1 - t.y), t
    }

    set needsUpdate(t) {
        t === !0 && (this.version++, this.source.needsUpdate = !0)
    }

    set needsPMREMUpdate(t) {
        t === !0 && this.pmremVersion++
    }
}

ya.DEFAULT_IMAGE = null;
ya.DEFAULT_MAPPING = Aw;
ya.DEFAULT_ANISOTROPY = 1;

class Zs {
    constructor(t = 0, i = 0, o = 0, c = 1) {
        Zs.prototype.isVector4 = !0, this.x = t, this.y = i, this.z = o, this.w = c
    }

    get width() {
        return this.z
    }

    set width(t) {
        this.z = t
    }

    get height() {
        return this.w
    }

    set height(t) {
        this.w = t
    }

    set(t, i, o, c) {
        return this.x = t, this.y = i, this.z = o, this.w = c, this
    }

    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this.w = t, this
    }

    setX(t) {
        return this.x = t, this
    }

    setY(t) {
        return this.y = t, this
    }

    setZ(t) {
        return this.z = t, this
    }

    setW(t) {
        return this.w = t, this
    }

    setComponent(t, i) {
        switch (t) {
            case 0:
                this.x = i;
                break;
            case 1:
                this.y = i;
                break;
            case 2:
                this.z = i;
                break;
            case 3:
                this.w = i;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }

    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
        }
    }

    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }

    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this
    }

    add(t) {
        return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
    }

    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this.w += t, this
    }

    addVectors(t, i) {
        return this.x = t.x + i.x, this.y = t.y + i.y, this.z = t.z + i.z, this.w = t.w + i.w, this
    }

    addScaledVector(t, i) {
        return this.x += t.x * i, this.y += t.y * i, this.z += t.z * i, this.w += t.w * i, this
    }

    sub(t) {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
    }

    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
    }

    subVectors(t, i) {
        return this.x = t.x - i.x, this.y = t.y - i.y, this.z = t.z - i.z, this.w = t.w - i.w, this
    }

    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
    }

    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
    }

    applyMatrix4(t) {
        const i = this.x, o = this.y, c = this.z, f = this.w, T = t.elements;
        return this.x = T[0] * i + T[4] * o + T[8] * c + T[12] * f, this.y = T[1] * i + T[5] * o + T[9] * c + T[13] * f, this.z = T[2] * i + T[6] * o + T[10] * c + T[14] * f, this.w = T[3] * i + T[7] * o + T[11] * c + T[15] * f, this
    }

    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }

    setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const i = Math.sqrt(1 - t.w * t.w);
        return i < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / i, this.y = t.y / i, this.z = t.z / i), this
    }

    setAxisAngleFromRotationMatrix(t) {
        let i, o, c, f;
        const x = t.elements, h = x[0], g = x[4], w = x[8], v = x[1], E = x[5], p = x[9], C = x[2], M = x[6], b = x[10];
        if (Math.abs(g - v) < .01 && Math.abs(w - C) < .01 && Math.abs(p - M) < .01) {
            if (Math.abs(g + v) < .1 && Math.abs(w + C) < .1 && Math.abs(p + M) < .1 && Math.abs(h + E + b - 3) < .1) return this.set(1, 0, 0, 0), this;
            i = Math.PI;
            const R = (h + 1) / 2, I = (E + 1) / 2, L = (b + 1) / 2, O = (g + v) / 4, N = (w + C) / 4, F = (p + M) / 4;
            return R > I && R > L ? R < .01 ? (o = 0, c = .707106781, f = .707106781) : (o = Math.sqrt(R), c = O / o, f = N / o) : I > L ? I < .01 ? (o = .707106781, c = 0, f = .707106781) : (c = Math.sqrt(I), o = O / c, f = F / c) : L < .01 ? (o = .707106781, c = .707106781, f = 0) : (f = Math.sqrt(L), o = N / f, c = F / f), this.set(o, c, f, i), this
        }
        let B = Math.sqrt((M - p) * (M - p) + (w - C) * (w - C) + (v - g) * (v - g));
        return Math.abs(B) < .001 && (B = 1), this.x = (M - p) / B, this.y = (w - C) / B, this.z = (v - g) / B, this.w = Math.acos((h + E + b - 1) / 2), this
    }

    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
    }

    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
    }

    clamp(t, i) {
        return this.x = Math.max(t.x, Math.min(i.x, this.x)), this.y = Math.max(t.y, Math.min(i.y, this.y)), this.z = Math.max(t.z, Math.min(i.z, this.z)), this.w = Math.max(t.w, Math.min(i.w, this.w)), this
    }

    clampScalar(t, i) {
        return this.x = Math.max(t, Math.min(i, this.x)), this.y = Math.max(t, Math.min(i, this.y)), this.z = Math.max(t, Math.min(i, this.z)), this.w = Math.max(t, Math.min(i, this.w)), this
    }

    clampLength(t, i) {
        const o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(t, Math.min(i, o)))
    }

    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }

    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }

    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }

    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }

    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }

    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }

    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }

    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }

    normalize() {
        return this.divideScalar(this.length() || 1)
    }

    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }

    lerp(t, i) {
        return this.x += (t.x - this.x) * i, this.y += (t.y - this.y) * i, this.z += (t.z - this.z) * i, this.w += (t.w - this.w) * i, this
    }

    lerpVectors(t, i, o) {
        return this.x = t.x + (i.x - t.x) * o, this.y = t.y + (i.y - t.y) * o, this.z = t.z + (i.z - t.z) * o, this.w = t.w + (i.w - t.w) * o, this
    }

    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }

    fromArray(t, i = 0) {
        return this.x = t[i], this.y = t[i + 1], this.z = t[i + 2], this.w = t[i + 3], this
    }

    toArray(t = [], i = 0) {
        return t[i] = this.x, t[i + 1] = this.y, t[i + 2] = this.z, t[i + 3] = this.w, t
    }

    fromBufferAttribute(t, i) {
        return this.x = t.getX(i), this.y = t.getY(i), this.z = t.getZ(i), this.w = t.getW(i), this
    }

    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }

    * [Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}

class yS extends Gc {
    constructor(t = 1, i = 1, o = {}) {
        super(), this.isRenderTarget = !0, this.width = t, this.height = i, this.depth = 1, this.scissor = new Zs(0, 0, t, i), this.scissorTest = !1, this.viewport = new Zs(0, 0, t, i);
        const c = {width: t, height: i, depth: 1};
        o = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: im,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, o);
        const f = new ya(c, o.mapping, o.wrapS, o.wrapT, o.magFilter, o.minFilter, o.format, o.type, o.anisotropy, o.colorSpace);
        f.flipY = !1, f.generateMipmaps = o.generateMipmaps, f.internalFormat = o.internalFormat, this.textures = [];
        const T = o.count;
        for (let m = 0; m < T; m++) this.textures[m] = f.clone(), this.textures[m].isRenderTargetTexture = !0;
        this.depthBuffer = o.depthBuffer, this.stencilBuffer = o.stencilBuffer, this.resolveDepthBuffer = o.resolveDepthBuffer, this.resolveStencilBuffer = o.resolveStencilBuffer, this.depthTexture = o.depthTexture, this.samples = o.samples
    }

    get texture() {
        return this.textures[0]
    }

    set texture(t) {
        this.textures[0] = t
    }

    setSize(t, i, o = 1) {
        if (this.width !== t || this.height !== i || this.depth !== o) {
            this.width = t, this.height = i, this.depth = o;
            for (let c = 0, f = this.textures.length; c < f; c++) this.textures[c].image.width = t, this.textures[c].image.height = i, this.textures[c].image.depth = o;
            this.dispose()
        }
        this.viewport.set(0, 0, t, i), this.scissor.set(0, 0, t, i)
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
        for (let o = 0, c = t.textures.length; o < c; o++) this.textures[o] = t.textures[o].clone(), this.textures[o].isRenderTargetTexture = !0;
        const i = Object.assign({}, t.texture.image);
        return this.texture.source = new Cw(i), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }
}

class ES extends yS {
    constructor(t = 1, i = 1, o = {}) {
        super(t, i, o), this.isWebGLRenderTarget = !0
    }
}

class Ho {
    constructor(t = 0, i = 0, o = 0, c = 1) {
        this.isQuaternion = !0, this._x = t, this._y = i, this._z = o, this._w = c
    }

    static slerpFlat(t, i, o, c, f, T, m) {
        let x = o[c + 0], h = o[c + 1], g = o[c + 2], w = o[c + 3];
        const v = f[T + 0], E = f[T + 1], p = f[T + 2], C = f[T + 3];
        if (m === 0) {
            t[i + 0] = x, t[i + 1] = h, t[i + 2] = g, t[i + 3] = w;
            return
        }
        if (m === 1) {
            t[i + 0] = v, t[i + 1] = E, t[i + 2] = p, t[i + 3] = C;
            return
        }
        if (w !== C || x !== v || h !== E || g !== p) {
            let M = 1 - m;
            const b = x * v + h * E + g * p + w * C, B = b >= 0 ? 1 : -1, R = 1 - b * b;
            if (R > Number.EPSILON) {
                const L = Math.sqrt(R), O = Math.atan2(L, b * B);
                M = Math.sin(M * O) / L, m = Math.sin(m * O) / L
            }
            const I = m * B;
            if (x = x * M + v * I, h = h * M + E * I, g = g * M + p * I, w = w * M + C * I, M === 1 - m) {
                const L = 1 / Math.sqrt(x * x + h * h + g * g + w * w);
                x *= L, h *= L, g *= L, w *= L
            }
        }
        t[i] = x, t[i + 1] = h, t[i + 2] = g, t[i + 3] = w
    }

    static multiplyQuaternionsFlat(t, i, o, c, f, T) {
        const m = o[c], x = o[c + 1], h = o[c + 2], g = o[c + 3], w = f[T], v = f[T + 1], E = f[T + 2], p = f[T + 3];
        return t[i] = m * p + g * w + x * E - h * v, t[i + 1] = x * p + g * v + h * w - m * E, t[i + 2] = h * p + g * E + m * v - x * w, t[i + 3] = g * p - m * w - x * v - h * E, t
    }

    get x() {
        return this._x
    }

    set x(t) {
        this._x = t, this._onChangeCallback()
    }

    get y() {
        return this._y
    }

    set y(t) {
        this._y = t, this._onChangeCallback()
    }

    get z() {
        return this._z
    }

    set z(t) {
        this._z = t, this._onChangeCallback()
    }

    get w() {
        return this._w
    }

    set w(t) {
        this._w = t, this._onChangeCallback()
    }

    set(t, i, o, c) {
        return this._x = t, this._y = i, this._z = o, this._w = c, this._onChangeCallback(), this
    }

    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }

    copy(t) {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
    }

    setFromEuler(t, i = !0) {
        const o = t._x, c = t._y, f = t._z, T = t._order, m = Math.cos, x = Math.sin, h = m(o / 2), g = m(c / 2),
            w = m(f / 2), v = x(o / 2), E = x(c / 2), p = x(f / 2);
        switch (T) {
            case"XYZ":
                this._x = v * g * w + h * E * p, this._y = h * E * w - v * g * p, this._z = h * g * p + v * E * w, this._w = h * g * w - v * E * p;
                break;
            case"YXZ":
                this._x = v * g * w + h * E * p, this._y = h * E * w - v * g * p, this._z = h * g * p - v * E * w, this._w = h * g * w + v * E * p;
                break;
            case"ZXY":
                this._x = v * g * w - h * E * p, this._y = h * E * w + v * g * p, this._z = h * g * p + v * E * w, this._w = h * g * w - v * E * p;
                break;
            case"ZYX":
                this._x = v * g * w - h * E * p, this._y = h * E * w + v * g * p, this._z = h * g * p - v * E * w, this._w = h * g * w + v * E * p;
                break;
            case"YZX":
                this._x = v * g * w + h * E * p, this._y = h * E * w + v * g * p, this._z = h * g * p - v * E * w, this._w = h * g * w - v * E * p;
                break;
            case"XZY":
                this._x = v * g * w - h * E * p, this._y = h * E * w - v * g * p, this._z = h * g * p + v * E * w, this._w = h * g * w + v * E * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + T)
        }
        return i === !0 && this._onChangeCallback(), this
    }

    setFromAxisAngle(t, i) {
        const o = i / 2, c = Math.sin(o);
        return this._x = t.x * c, this._y = t.y * c, this._z = t.z * c, this._w = Math.cos(o), this._onChangeCallback(), this
    }

    setFromRotationMatrix(t) {
        const i = t.elements, o = i[0], c = i[4], f = i[8], T = i[1], m = i[5], x = i[9], h = i[2], g = i[6], w = i[10],
            v = o + m + w;
        if (v > 0) {
            const E = .5 / Math.sqrt(v + 1);
            this._w = .25 / E, this._x = (g - x) * E, this._y = (f - h) * E, this._z = (T - c) * E
        } else if (o > m && o > w) {
            const E = 2 * Math.sqrt(1 + o - m - w);
            this._w = (g - x) / E, this._x = .25 * E, this._y = (c + T) / E, this._z = (f + h) / E
        } else if (m > w) {
            const E = 2 * Math.sqrt(1 + m - o - w);
            this._w = (f - h) / E, this._x = (c + T) / E, this._y = .25 * E, this._z = (x + g) / E
        } else {
            const E = 2 * Math.sqrt(1 + w - o - m);
            this._w = (T - c) / E, this._x = (f + h) / E, this._y = (x + g) / E, this._z = .25 * E
        }
        return this._onChangeCallback(), this
    }

    setFromUnitVectors(t, i) {
        let o = t.dot(i) + 1;
        return o < Number.EPSILON ? (o = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = o) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = o)) : (this._x = t.y * i.z - t.z * i.y, this._y = t.z * i.x - t.x * i.z, this._z = t.x * i.y - t.y * i.x, this._w = o), this.normalize()
    }

    angleTo(t) {
        return 2 * Math.acos(Math.abs(Ro(this.dot(t), -1, 1)))
    }

    rotateTowards(t, i) {
        const o = this.angleTo(t);
        if (o === 0) return this;
        const c = Math.min(1, i / o);
        return this.slerp(t, c), this
    }

    identity() {
        return this.set(0, 0, 0, 1)
    }

    invert() {
        return this.conjugate()
    }

    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }

    dot(t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }

    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }

    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }

    normalize() {
        let t = this.length();
        return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
    }

    multiply(t) {
        return this.multiplyQuaternions(this, t)
    }

    premultiply(t) {
        return this.multiplyQuaternions(t, this)
    }

    multiplyQuaternions(t, i) {
        const o = t._x, c = t._y, f = t._z, T = t._w, m = i._x, x = i._y, h = i._z, g = i._w;
        return this._x = o * g + T * m + c * h - f * x, this._y = c * g + T * x + f * m - o * h, this._z = f * g + T * h + o * x - c * m, this._w = T * g - o * m - c * x - f * h, this._onChangeCallback(), this
    }

    slerp(t, i) {
        if (i === 0) return this;
        if (i === 1) return this.copy(t);
        const o = this._x, c = this._y, f = this._z, T = this._w;
        let m = T * t._w + o * t._x + c * t._y + f * t._z;
        if (m < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, m = -m) : this.copy(t), m >= 1) return this._w = T, this._x = o, this._y = c, this._z = f, this;
        const x = 1 - m * m;
        if (x <= Number.EPSILON) {
            const E = 1 - i;
            return this._w = E * T + i * this._w, this._x = E * o + i * this._x, this._y = E * c + i * this._y, this._z = E * f + i * this._z, this.normalize(), this
        }
        const h = Math.sqrt(x), g = Math.atan2(h, m), w = Math.sin((1 - i) * g) / h, v = Math.sin(i * g) / h;
        return this._w = T * w + this._w * v, this._x = o * w + this._x * v, this._y = c * w + this._y * v, this._z = f * w + this._z * v, this._onChangeCallback(), this
    }

    slerpQuaternions(t, i, o) {
        return this.copy(t).slerp(i, o)
    }

    random() {
        const t = 2 * Math.PI * Math.random(), i = 2 * Math.PI * Math.random(), o = Math.random(), c = Math.sqrt(1 - o),
            f = Math.sqrt(o);
        return this.set(c * Math.sin(t), c * Math.cos(t), f * Math.sin(i), f * Math.cos(i))
    }

    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
    }

    fromArray(t, i = 0) {
        return this._x = t[i], this._y = t[i + 1], this._z = t[i + 2], this._w = t[i + 3], this._onChangeCallback(), this
    }

    toArray(t = [], i = 0) {
        return t[i] = this._x, t[i + 1] = this._y, t[i + 2] = this._z, t[i + 3] = this._w, t
    }

    fromBufferAttribute(t, i) {
        return this._x = t.getX(i), this._y = t.getY(i), this._z = t.getZ(i), this._w = t.getW(i), this._onChangeCallback(), this
    }

    toJSON() {
        return this.toArray()
    }

    _onChange(t) {
        return this._onChangeCallback = t, this
    }

    _onChangeCallback() {
    }

    * [Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w
    }
}

class ft {
    constructor(t = 0, i = 0, o = 0) {
        ft.prototype.isVector3 = !0, this.x = t, this.y = i, this.z = o
    }

    set(t, i, o) {
        return o === void 0 && (o = this.z), this.x = t, this.y = i, this.z = o, this
    }

    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this
    }

    setX(t) {
        return this.x = t, this
    }

    setY(t) {
        return this.y = t, this
    }

    setZ(t) {
        return this.z = t, this
    }

    setComponent(t, i) {
        switch (t) {
            case 0:
                this.x = i;
                break;
            case 1:
                this.y = i;
                break;
            case 2:
                this.z = i;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }

    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
        }
    }

    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }

    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this
    }

    add(t) {
        return this.x += t.x, this.y += t.y, this.z += t.z, this
    }

    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this
    }

    addVectors(t, i) {
        return this.x = t.x + i.x, this.y = t.y + i.y, this.z = t.z + i.z, this
    }

    addScaledVector(t, i) {
        return this.x += t.x * i, this.y += t.y * i, this.z += t.z * i, this
    }

    sub(t) {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
    }

    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this
    }

    subVectors(t, i) {
        return this.x = t.x - i.x, this.y = t.y - i.y, this.z = t.z - i.z, this
    }

    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
    }

    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this
    }

    multiplyVectors(t, i) {
        return this.x = t.x * i.x, this.y = t.y * i.y, this.z = t.z * i.z, this
    }

    applyEuler(t) {
        return this.applyQuaternion(zC.setFromEuler(t))
    }

    applyAxisAngle(t, i) {
        return this.applyQuaternion(zC.setFromAxisAngle(t, i))
    }

    applyMatrix3(t) {
        const i = this.x, o = this.y, c = this.z, f = t.elements;
        return this.x = f[0] * i + f[3] * o + f[6] * c, this.y = f[1] * i + f[4] * o + f[7] * c, this.z = f[2] * i + f[5] * o + f[8] * c, this
    }

    applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize()
    }

    applyMatrix4(t) {
        const i = this.x, o = this.y, c = this.z, f = t.elements, T = 1 / (f[3] * i + f[7] * o + f[11] * c + f[15]);
        return this.x = (f[0] * i + f[4] * o + f[8] * c + f[12]) * T, this.y = (f[1] * i + f[5] * o + f[9] * c + f[13]) * T, this.z = (f[2] * i + f[6] * o + f[10] * c + f[14]) * T, this
    }

    applyQuaternion(t) {
        const i = this.x, o = this.y, c = this.z, f = t.x, T = t.y, m = t.z, x = t.w, h = 2 * (T * c - m * o),
            g = 2 * (m * i - f * c), w = 2 * (f * o - T * i);
        return this.x = i + x * h + T * w - m * g, this.y = o + x * g + m * h - f * w, this.z = c + x * w + f * g - T * h, this
    }

    project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
    }

    unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
    }

    transformDirection(t) {
        const i = this.x, o = this.y, c = this.z, f = t.elements;
        return this.x = f[0] * i + f[4] * o + f[8] * c, this.y = f[1] * i + f[5] * o + f[9] * c, this.z = f[2] * i + f[6] * o + f[10] * c, this.normalize()
    }

    divide(t) {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
    }

    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }

    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
    }

    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
    }

    clamp(t, i) {
        return this.x = Math.max(t.x, Math.min(i.x, this.x)), this.y = Math.max(t.y, Math.min(i.y, this.y)), this.z = Math.max(t.z, Math.min(i.z, this.z)), this
    }

    clampScalar(t, i) {
        return this.x = Math.max(t, Math.min(i, this.x)), this.y = Math.max(t, Math.min(i, this.y)), this.z = Math.max(t, Math.min(i, this.z)), this
    }

    clampLength(t, i) {
        const o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(t, Math.min(i, o)))
    }

    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }

    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }

    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }

    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
    }

    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }

    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z
    }

    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }

    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }

    normalize() {
        return this.divideScalar(this.length() || 1)
    }

    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }

    lerp(t, i) {
        return this.x += (t.x - this.x) * i, this.y += (t.y - this.y) * i, this.z += (t.z - this.z) * i, this
    }

    lerpVectors(t, i, o) {
        return this.x = t.x + (i.x - t.x) * o, this.y = t.y + (i.y - t.y) * o, this.z = t.z + (i.z - t.z) * o, this
    }

    cross(t) {
        return this.crossVectors(this, t)
    }

    crossVectors(t, i) {
        const o = t.x, c = t.y, f = t.z, T = i.x, m = i.y, x = i.z;
        return this.x = c * x - f * m, this.y = f * T - o * x, this.z = o * m - c * T, this
    }

    projectOnVector(t) {
        const i = t.lengthSq();
        if (i === 0) return this.set(0, 0, 0);
        const o = t.dot(this) / i;
        return this.copy(t).multiplyScalar(o)
    }

    projectOnPlane(t) {
        return Cy.copy(this).projectOnVector(t), this.sub(Cy)
    }

    reflect(t) {
        return this.sub(Cy.copy(t).multiplyScalar(2 * this.dot(t)))
    }

    angleTo(t) {
        const i = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (i === 0) return Math.PI / 2;
        const o = this.dot(t) / i;
        return Math.acos(Ro(o, -1, 1))
    }

    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
    }

    distanceToSquared(t) {
        const i = this.x - t.x, o = this.y - t.y, c = this.z - t.z;
        return i * i + o * o + c * c
    }

    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    }

    setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }

    setFromSphericalCoords(t, i, o) {
        const c = Math.sin(i) * t;
        return this.x = c * Math.sin(o), this.y = Math.cos(i) * t, this.z = c * Math.cos(o), this
    }

    setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }

    setFromCylindricalCoords(t, i, o) {
        return this.x = t * Math.sin(i), this.y = o, this.z = t * Math.cos(i), this
    }

    setFromMatrixPosition(t) {
        const i = t.elements;
        return this.x = i[12], this.y = i[13], this.z = i[14], this
    }

    setFromMatrixScale(t) {
        const i = this.setFromMatrixColumn(t, 0).length(), o = this.setFromMatrixColumn(t, 1).length(),
            c = this.setFromMatrixColumn(t, 2).length();
        return this.x = i, this.y = o, this.z = c, this
    }

    setFromMatrixColumn(t, i) {
        return this.fromArray(t.elements, i * 4)
    }

    setFromMatrix3Column(t, i) {
        return this.fromArray(t.elements, i * 3)
    }

    setFromEuler(t) {
        return this.x = t._x, this.y = t._y, this.z = t._z, this
    }

    setFromColor(t) {
        return this.x = t.r, this.y = t.g, this.z = t.b, this
    }

    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z
    }

    fromArray(t, i = 0) {
        return this.x = t[i], this.y = t[i + 1], this.z = t[i + 2], this
    }

    toArray(t = [], i = 0) {
        return t[i] = this.x, t[i + 1] = this.y, t[i + 2] = this.z, t
    }

    fromBufferAttribute(t, i) {
        return this.x = t.getX(i), this.y = t.getY(i), this.z = t.getZ(i), this
    }

    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }

    randomDirection() {
        const t = Math.random() * Math.PI * 2, i = Math.random() * 2 - 1, o = Math.sqrt(1 - i * i);
        return this.x = o * Math.cos(t), this.y = i, this.z = o * Math.sin(t), this
    }

    * [Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z
    }
}

const Cy = new ft, zC = new Ho;

class lf {
    constructor(t = new ft(1 / 0, 1 / 0, 1 / 0), i = new ft(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = t, this.max = i
    }

    set(t, i) {
        return this.min.copy(t), this.max.copy(i), this
    }

    setFromArray(t) {
        this.makeEmpty();
        for (let i = 0, o = t.length; i < o; i += 3) this.expandByPoint(vl.fromArray(t, i));
        return this
    }

    setFromBufferAttribute(t) {
        this.makeEmpty();
        for (let i = 0, o = t.count; i < o; i++) this.expandByPoint(vl.fromBufferAttribute(t, i));
        return this
    }

    setFromPoints(t) {
        this.makeEmpty();
        for (let i = 0, o = t.length; i < o; i++) this.expandByPoint(t[i]);
        return this
    }

    setFromCenterAndSize(t, i) {
        const o = vl.copy(i).multiplyScalar(.5);
        return this.min.copy(t).sub(o), this.max.copy(t).add(o), this
    }

    setFromObject(t, i = !1) {
        return this.makeEmpty(), this.expandByObject(t, i)
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this
    }

    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }

    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }

    getCenter(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }

    getSize(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }

    expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this
    }

    expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this
    }

    expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this
    }

    expandByObject(t, i = !1) {
        t.updateWorldMatrix(!1, !1);
        const o = t.geometry;
        if (o !== void 0) {
            const f = o.getAttribute("position");
            if (i === !0 && f !== void 0 && t.isInstancedMesh !== !0) for (let T = 0, m = f.count; T < m; T++) t.isMesh === !0 ? t.getVertexPosition(T, vl) : vl.fromBufferAttribute(f, T), vl.applyMatrix4(t.matrixWorld), this.expandByPoint(vl); else t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), Og.copy(t.boundingBox)) : (o.boundingBox === null && o.computeBoundingBox(), Og.copy(o.boundingBox)), Og.applyMatrix4(t.matrixWorld), this.union(Og)
        }
        const c = t.children;
        for (let f = 0, T = c.length; f < T; f++) this.expandByObject(c[f], i);
        return this
    }

    containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
    }

    containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
    }

    getParameter(t, i) {
        return i.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
    }

    intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
    }

    intersectsSphere(t) {
        return this.clampPoint(t.center, vl), vl.distanceToSquared(t.center) <= t.radius * t.radius
    }

    intersectsPlane(t) {
        let i, o;
        return t.normal.x > 0 ? (i = t.normal.x * this.min.x, o = t.normal.x * this.max.x) : (i = t.normal.x * this.max.x, o = t.normal.x * this.min.x), t.normal.y > 0 ? (i += t.normal.y * this.min.y, o += t.normal.y * this.max.y) : (i += t.normal.y * this.max.y, o += t.normal.y * this.min.y), t.normal.z > 0 ? (i += t.normal.z * this.min.z, o += t.normal.z * this.max.z) : (i += t.normal.z * this.max.z, o += t.normal.z * this.min.z), i <= -t.constant && o >= -t.constant
    }

    intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(Yp), kg.subVectors(this.max, Yp), Hd.subVectors(t.a, Yp), Qd.subVectors(t.b, Yp), jd.subVectors(t.c, Yp), vu.subVectors(Qd, Hd), yu.subVectors(jd, Qd), Rh.subVectors(Hd, jd);
        let i = [0, -vu.z, vu.y, 0, -yu.z, yu.y, 0, -Rh.z, Rh.y, vu.z, 0, -vu.x, yu.z, 0, -yu.x, Rh.z, 0, -Rh.x, -vu.y, vu.x, 0, -yu.y, yu.x, 0, -Rh.y, Rh.x, 0];
        return !wy(i, Hd, Qd, jd, kg) || (i = [1, 0, 0, 0, 1, 0, 0, 0, 1], !wy(i, Hd, Qd, jd, kg)) ? !1 : (Fg.crossVectors(vu, yu), i = [Fg.x, Fg.y, Fg.z], wy(i, Hd, Qd, jd, kg))
    }

    clampPoint(t, i) {
        return i.copy(t).clamp(this.min, this.max)
    }

    distanceToPoint(t) {
        return this.clampPoint(t, vl).distanceTo(t)
    }

    getBoundingSphere(t) {
        return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(vl).length() * .5), t
    }

    intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
    }

    union(t) {
        return this.min.min(t.min), this.max.max(t.max), this
    }

    applyMatrix4(t) {
        return this.isEmpty() ? this : (Oc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Oc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Oc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Oc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Oc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Oc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Oc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Oc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Oc), this)
    }

    translate(t) {
        return this.min.add(t), this.max.add(t), this
    }

    equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max)
    }
}

const Oc = [new ft, new ft, new ft, new ft, new ft, new ft, new ft, new ft], vl = new ft, Og = new lf, Hd = new ft,
    Qd = new ft, jd = new ft, vu = new ft, yu = new ft, Rh = new ft, Yp = new ft, kg = new ft, Fg = new ft, Bh = new ft;

function wy(A, t, i, o, c) {
    for (let f = 0, T = A.length - 3; f <= T; f += 3) {
        Bh.fromArray(A, f);
        const m = c.x * Math.abs(Bh.x) + c.y * Math.abs(Bh.y) + c.z * Math.abs(Bh.z), x = t.dot(Bh), h = i.dot(Bh),
            g = o.dot(Bh);
        if (Math.max(-Math.max(x, h, g), Math.min(x, h, g)) > m) return !1
    }
    return !0
}

const xS = new lf, qp = new ft, by = new ft;

class cf {
    constructor(t = new ft, i = -1) {
        this.isSphere = !0, this.center = t, this.radius = i
    }

    set(t, i) {
        return this.center.copy(t), this.radius = i, this
    }

    setFromPoints(t, i) {
        const o = this.center;
        i !== void 0 ? o.copy(i) : xS.setFromPoints(t).getCenter(o);
        let c = 0;
        for (let f = 0, T = t.length; f < T; f++) c = Math.max(c, o.distanceToSquared(t[f]));
        return this.radius = Math.sqrt(c), this
    }

    copy(t) {
        return this.center.copy(t.center), this.radius = t.radius, this
    }

    isEmpty() {
        return this.radius < 0
    }

    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }

    containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius
    }

    distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius
    }

    intersectsSphere(t) {
        const i = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= i * i
    }

    intersectsBox(t) {
        return t.intersectsSphere(this)
    }

    intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }

    clampPoint(t, i) {
        const o = this.center.distanceToSquared(t);
        return i.copy(t), o > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i
    }

    getBoundingBox(t) {
        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    }

    applyMatrix4(t) {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
    }

    translate(t) {
        return this.center.add(t), this
    }

    expandByPoint(t) {
        if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
        qp.subVectors(t, this.center);
        const i = qp.lengthSq();
        if (i > this.radius * this.radius) {
            const o = Math.sqrt(i), c = (o - this.radius) * .5;
            this.center.addScaledVector(qp, c / o), this.radius += c
        }
        return this
    }

    union(t) {
        return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (by.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(qp.copy(t.center).add(by)), this.expandByPoint(qp.copy(t.center).sub(by))), this)
    }

    equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

const kc = new ft, _y = new ft, Ng = new ft, Eu = new ft, My = new ft, Ug = new ft, Sy = new ft;

class R1 {
    constructor(t = new ft, i = new ft(0, 0, -1)) {
        this.origin = t, this.direction = i
    }

    set(t, i) {
        return this.origin.copy(t), this.direction.copy(i), this
    }

    copy(t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
    }

    at(t, i) {
        return i.copy(this.origin).addScaledVector(this.direction, t)
    }

    lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this
    }

    recast(t) {
        return this.origin.copy(this.at(t, kc)), this
    }

    closestPointToPoint(t, i) {
        i.subVectors(t, this.origin);
        const o = i.dot(this.direction);
        return o < 0 ? i.copy(this.origin) : i.copy(this.origin).addScaledVector(this.direction, o)
    }

    distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t))
    }

    distanceSqToPoint(t) {
        const i = kc.subVectors(t, this.origin).dot(this.direction);
        return i < 0 ? this.origin.distanceToSquared(t) : (kc.copy(this.origin).addScaledVector(this.direction, i), kc.distanceToSquared(t))
    }

    distanceSqToSegment(t, i, o, c) {
        _y.copy(t).add(i).multiplyScalar(.5), Ng.copy(i).sub(t).normalize(), Eu.copy(this.origin).sub(_y);
        const f = t.distanceTo(i) * .5, T = -this.direction.dot(Ng), m = Eu.dot(this.direction), x = -Eu.dot(Ng),
            h = Eu.lengthSq(), g = Math.abs(1 - T * T);
        let w, v, E, p;
        if (g > 0) if (w = T * x - m, v = T * m - x, p = f * g, w >= 0) if (v >= -p) if (v <= p) {
            const C = 1 / g;
            w *= C, v *= C, E = w * (w + T * v + 2 * m) + v * (T * w + v + 2 * x) + h
        } else v = f, w = Math.max(0, -(T * v + m)), E = -w * w + v * (v + 2 * x) + h; else v = -f, w = Math.max(0, -(T * v + m)), E = -w * w + v * (v + 2 * x) + h; else v <= -p ? (w = Math.max(0, -(-T * f + m)), v = w > 0 ? -f : Math.min(Math.max(-f, -x), f), E = -w * w + v * (v + 2 * x) + h) : v <= p ? (w = 0, v = Math.min(Math.max(-f, -x), f), E = v * (v + 2 * x) + h) : (w = Math.max(0, -(T * f + m)), v = w > 0 ? f : Math.min(Math.max(-f, -x), f), E = -w * w + v * (v + 2 * x) + h); else v = T > 0 ? -f : f, w = Math.max(0, -(T * v + m)), E = -w * w + v * (v + 2 * x) + h;
        return o && o.copy(this.origin).addScaledVector(this.direction, w), c && c.copy(_y).addScaledVector(Ng, v), E
    }

    intersectSphere(t, i) {
        kc.subVectors(t.center, this.origin);
        const o = kc.dot(this.direction), c = kc.dot(kc) - o * o, f = t.radius * t.radius;
        if (c > f) return null;
        const T = Math.sqrt(f - c), m = o - T, x = o + T;
        return x < 0 ? null : m < 0 ? this.at(x, i) : this.at(m, i)
    }

    intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }

    distanceToPlane(t) {
        const i = t.normal.dot(this.direction);
        if (i === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
        const o = -(this.origin.dot(t.normal) + t.constant) / i;
        return o >= 0 ? o : null
    }

    intersectPlane(t, i) {
        const o = this.distanceToPlane(t);
        return o === null ? null : this.at(o, i)
    }

    intersectsPlane(t) {
        const i = t.distanceToPoint(this.origin);
        return i === 0 || t.normal.dot(this.direction) * i < 0
    }

    intersectBox(t, i) {
        let o, c, f, T, m, x;
        const h = 1 / this.direction.x, g = 1 / this.direction.y, w = 1 / this.direction.z, v = this.origin;
        return h >= 0 ? (o = (t.min.x - v.x) * h, c = (t.max.x - v.x) * h) : (o = (t.max.x - v.x) * h, c = (t.min.x - v.x) * h), g >= 0 ? (f = (t.min.y - v.y) * g, T = (t.max.y - v.y) * g) : (f = (t.max.y - v.y) * g, T = (t.min.y - v.y) * g), o > T || f > c || ((f > o || isNaN(o)) && (o = f), (T < c || isNaN(c)) && (c = T), w >= 0 ? (m = (t.min.z - v.z) * w, x = (t.max.z - v.z) * w) : (m = (t.max.z - v.z) * w, x = (t.min.z - v.z) * w), o > x || m > c) || ((m > o || o !== o) && (o = m), (x < c || c !== c) && (c = x), c < 0) ? null : this.at(o >= 0 ? o : c, i)
    }

    intersectsBox(t) {
        return this.intersectBox(t, kc) !== null
    }

    intersectTriangle(t, i, o, c, f) {
        My.subVectors(i, t), Ug.subVectors(o, t), Sy.crossVectors(My, Ug);
        let T = this.direction.dot(Sy), m;
        if (T > 0) {
            if (c) return null;
            m = 1
        } else if (T < 0) m = -1, T = -T; else return null;
        Eu.subVectors(this.origin, t);
        const x = m * this.direction.dot(Ug.crossVectors(Eu, Ug));
        if (x < 0) return null;
        const h = m * this.direction.dot(My.cross(Eu));
        if (h < 0 || x + h > T) return null;
        const g = -m * Eu.dot(Sy);
        return g < 0 ? null : this.at(g / T, f)
    }

    applyMatrix4(t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    }

    equals(t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

class $n {
    constructor(t, i, o, c, f, T, m, x, h, g, w, v, E, p, C, M) {
        $n.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], t !== void 0 && this.set(t, i, o, c, f, T, m, x, h, g, w, v, E, p, C, M)
    }

    set(t, i, o, c, f, T, m, x, h, g, w, v, E, p, C, M) {
        const b = this.elements;
        return b[0] = t, b[4] = i, b[8] = o, b[12] = c, b[1] = f, b[5] = T, b[9] = m, b[13] = x, b[2] = h, b[6] = g, b[10] = w, b[14] = v, b[3] = E, b[7] = p, b[11] = C, b[15] = M, this
    }

    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }

    clone() {
        return new $n().fromArray(this.elements)
    }

    copy(t) {
        const i = this.elements, o = t.elements;
        return i[0] = o[0], i[1] = o[1], i[2] = o[2], i[3] = o[3], i[4] = o[4], i[5] = o[5], i[6] = o[6], i[7] = o[7], i[8] = o[8], i[9] = o[9], i[10] = o[10], i[11] = o[11], i[12] = o[12], i[13] = o[13], i[14] = o[14], i[15] = o[15], this
    }

    copyPosition(t) {
        const i = this.elements, o = t.elements;
        return i[12] = o[12], i[13] = o[13], i[14] = o[14], this
    }

    setFromMatrix3(t) {
        const i = t.elements;
        return this.set(i[0], i[3], i[6], 0, i[1], i[4], i[7], 0, i[2], i[5], i[8], 0, 0, 0, 0, 1), this
    }

    extractBasis(t, i, o) {
        return t.setFromMatrixColumn(this, 0), i.setFromMatrixColumn(this, 1), o.setFromMatrixColumn(this, 2), this
    }

    makeBasis(t, i, o) {
        return this.set(t.x, i.x, o.x, 0, t.y, i.y, o.y, 0, t.z, i.z, o.z, 0, 0, 0, 0, 1), this
    }

    extractRotation(t) {
        const i = this.elements, o = t.elements, c = 1 / Wd.setFromMatrixColumn(t, 0).length(),
            f = 1 / Wd.setFromMatrixColumn(t, 1).length(), T = 1 / Wd.setFromMatrixColumn(t, 2).length();
        return i[0] = o[0] * c, i[1] = o[1] * c, i[2] = o[2] * c, i[3] = 0, i[4] = o[4] * f, i[5] = o[5] * f, i[6] = o[6] * f, i[7] = 0, i[8] = o[8] * T, i[9] = o[9] * T, i[10] = o[10] * T, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
    }

    makeRotationFromEuler(t) {
        const i = this.elements, o = t.x, c = t.y, f = t.z, T = Math.cos(o), m = Math.sin(o), x = Math.cos(c),
            h = Math.sin(c), g = Math.cos(f), w = Math.sin(f);
        if (t.order === "XYZ") {
            const v = T * g, E = T * w, p = m * g, C = m * w;
            i[0] = x * g, i[4] = -x * w, i[8] = h, i[1] = E + p * h, i[5] = v - C * h, i[9] = -m * x, i[2] = C - v * h, i[6] = p + E * h, i[10] = T * x
        } else if (t.order === "YXZ") {
            const v = x * g, E = x * w, p = h * g, C = h * w;
            i[0] = v + C * m, i[4] = p * m - E, i[8] = T * h, i[1] = T * w, i[5] = T * g, i[9] = -m, i[2] = E * m - p, i[6] = C + v * m, i[10] = T * x
        } else if (t.order === "ZXY") {
            const v = x * g, E = x * w, p = h * g, C = h * w;
            i[0] = v - C * m, i[4] = -T * w, i[8] = p + E * m, i[1] = E + p * m, i[5] = T * g, i[9] = C - v * m, i[2] = -T * h, i[6] = m, i[10] = T * x
        } else if (t.order === "ZYX") {
            const v = T * g, E = T * w, p = m * g, C = m * w;
            i[0] = x * g, i[4] = p * h - E, i[8] = v * h + C, i[1] = x * w, i[5] = C * h + v, i[9] = E * h - p, i[2] = -h, i[6] = m * x, i[10] = T * x
        } else if (t.order === "YZX") {
            const v = T * x, E = T * h, p = m * x, C = m * h;
            i[0] = x * g, i[4] = C - v * w, i[8] = p * w + E, i[1] = w, i[5] = T * g, i[9] = -m * g, i[2] = -h * g, i[6] = E * w + p, i[10] = v - C * w
        } else if (t.order === "XZY") {
            const v = T * x, E = T * h, p = m * x, C = m * h;
            i[0] = x * g, i[4] = -w, i[8] = h * g, i[1] = v * w + C, i[5] = T * g, i[9] = E * w - p, i[2] = p * w - E, i[6] = m * g, i[10] = C * w + v
        }
        return i[3] = 0, i[7] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
    }

    makeRotationFromQuaternion(t) {
        return this.compose(CS, t, wS)
    }

    lookAt(t, i, o) {
        const c = this.elements;
        return Pa.subVectors(t, i), Pa.lengthSq() === 0 && (Pa.z = 1), Pa.normalize(), xu.crossVectors(o, Pa), xu.lengthSq() === 0 && (Math.abs(o.z) === 1 ? Pa.x += 1e-4 : Pa.z += 1e-4, Pa.normalize(), xu.crossVectors(o, Pa)), xu.normalize(), zg.crossVectors(Pa, xu), c[0] = xu.x, c[4] = zg.x, c[8] = Pa.x, c[1] = xu.y, c[5] = zg.y, c[9] = Pa.y, c[2] = xu.z, c[6] = zg.z, c[10] = Pa.z, this
    }

    multiply(t) {
        return this.multiplyMatrices(this, t)
    }

    premultiply(t) {
        return this.multiplyMatrices(t, this)
    }

    multiplyMatrices(t, i) {
        const o = t.elements, c = i.elements, f = this.elements, T = o[0], m = o[4], x = o[8], h = o[12], g = o[1],
            w = o[5], v = o[9], E = o[13], p = o[2], C = o[6], M = o[10], b = o[14], B = o[3], R = o[7], I = o[11],
            L = o[15], O = c[0], N = c[4], F = c[8], V = c[12], U = c[1], j = c[5], Y = c[9], fe = c[13], se = c[2],
            pe = c[6], ue = c[10], he = c[14], Z = c[3], H = c[7], ae = c[11], ee = c[15];
        return f[0] = T * O + m * U + x * se + h * Z, f[4] = T * N + m * j + x * pe + h * H, f[8] = T * F + m * Y + x * ue + h * ae, f[12] = T * V + m * fe + x * he + h * ee, f[1] = g * O + w * U + v * se + E * Z, f[5] = g * N + w * j + v * pe + E * H, f[9] = g * F + w * Y + v * ue + E * ae, f[13] = g * V + w * fe + v * he + E * ee, f[2] = p * O + C * U + M * se + b * Z, f[6] = p * N + C * j + M * pe + b * H, f[10] = p * F + C * Y + M * ue + b * ae, f[14] = p * V + C * fe + M * he + b * ee, f[3] = B * O + R * U + I * se + L * Z, f[7] = B * N + R * j + I * pe + L * H, f[11] = B * F + R * Y + I * ue + L * ae, f[15] = B * V + R * fe + I * he + L * ee, this
    }

    multiplyScalar(t) {
        const i = this.elements;
        return i[0] *= t, i[4] *= t, i[8] *= t, i[12] *= t, i[1] *= t, i[5] *= t, i[9] *= t, i[13] *= t, i[2] *= t, i[6] *= t, i[10] *= t, i[14] *= t, i[3] *= t, i[7] *= t, i[11] *= t, i[15] *= t, this
    }

    determinant() {
        const t = this.elements, i = t[0], o = t[4], c = t[8], f = t[12], T = t[1], m = t[5], x = t[9], h = t[13],
            g = t[2], w = t[6], v = t[10], E = t[14], p = t[3], C = t[7], M = t[11], b = t[15];
        return p * (+f * x * w - c * h * w - f * m * v + o * h * v + c * m * E - o * x * E) + C * (+i * x * E - i * h * v + f * T * v - c * T * E + c * h * g - f * x * g) + M * (+i * h * w - i * m * E - f * T * w + o * T * E + f * m * g - o * h * g) + b * (-c * m * g - i * x * w + i * m * v + c * T * w - o * T * v + o * x * g)
    }

    transpose() {
        const t = this.elements;
        let i;
        return i = t[1], t[1] = t[4], t[4] = i, i = t[2], t[2] = t[8], t[8] = i, i = t[6], t[6] = t[9], t[9] = i, i = t[3], t[3] = t[12], t[12] = i, i = t[7], t[7] = t[13], t[13] = i, i = t[11], t[11] = t[14], t[14] = i, this
    }

    setPosition(t, i, o) {
        const c = this.elements;
        return t.isVector3 ? (c[12] = t.x, c[13] = t.y, c[14] = t.z) : (c[12] = t, c[13] = i, c[14] = o), this
    }

    invert() {
        const t = this.elements, i = t[0], o = t[1], c = t[2], f = t[3], T = t[4], m = t[5], x = t[6], h = t[7],
            g = t[8], w = t[9], v = t[10], E = t[11], p = t[12], C = t[13], M = t[14], b = t[15],
            B = w * M * h - C * v * h + C * x * E - m * M * E - w * x * b + m * v * b,
            R = p * v * h - g * M * h - p * x * E + T * M * E + g * x * b - T * v * b,
            I = g * C * h - p * w * h + p * m * E - T * C * E - g * m * b + T * w * b,
            L = p * w * x - g * C * x - p * m * v + T * C * v + g * m * M - T * w * M,
            O = i * B + o * R + c * I + f * L;
        if (O === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const N = 1 / O;
        return t[0] = B * N, t[1] = (C * v * f - w * M * f - C * c * E + o * M * E + w * c * b - o * v * b) * N, t[2] = (m * M * f - C * x * f + C * c * h - o * M * h - m * c * b + o * x * b) * N, t[3] = (w * x * f - m * v * f - w * c * h + o * v * h + m * c * E - o * x * E) * N, t[4] = R * N, t[5] = (g * M * f - p * v * f + p * c * E - i * M * E - g * c * b + i * v * b) * N, t[6] = (p * x * f - T * M * f - p * c * h + i * M * h + T * c * b - i * x * b) * N, t[7] = (T * v * f - g * x * f + g * c * h - i * v * h - T * c * E + i * x * E) * N, t[8] = I * N, t[9] = (p * w * f - g * C * f - p * o * E + i * C * E + g * o * b - i * w * b) * N, t[10] = (T * C * f - p * m * f + p * o * h - i * C * h - T * o * b + i * m * b) * N, t[11] = (g * m * f - T * w * f - g * o * h + i * w * h + T * o * E - i * m * E) * N, t[12] = L * N, t[13] = (g * C * c - p * w * c + p * o * v - i * C * v - g * o * M + i * w * M) * N, t[14] = (p * m * c - T * C * c - p * o * x + i * C * x + T * o * M - i * m * M) * N, t[15] = (T * w * c - g * m * c + g * o * x - i * w * x - T * o * v + i * m * v) * N, this
    }

    scale(t) {
        const i = this.elements, o = t.x, c = t.y, f = t.z;
        return i[0] *= o, i[4] *= c, i[8] *= f, i[1] *= o, i[5] *= c, i[9] *= f, i[2] *= o, i[6] *= c, i[10] *= f, i[3] *= o, i[7] *= c, i[11] *= f, this
    }

    getMaxScaleOnAxis() {
        const t = this.elements, i = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            o = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], c = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(i, o, c))
    }

    makeTranslation(t, i, o) {
        return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, i, 0, 0, 1, o, 0, 0, 0, 1), this
    }

    makeRotationX(t) {
        const i = Math.cos(t), o = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, i, -o, 0, 0, o, i, 0, 0, 0, 0, 1), this
    }

    makeRotationY(t) {
        const i = Math.cos(t), o = Math.sin(t);
        return this.set(i, 0, o, 0, 0, 1, 0, 0, -o, 0, i, 0, 0, 0, 0, 1), this
    }

    makeRotationZ(t) {
        const i = Math.cos(t), o = Math.sin(t);
        return this.set(i, -o, 0, 0, o, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }

    makeRotationAxis(t, i) {
        const o = Math.cos(i), c = Math.sin(i), f = 1 - o, T = t.x, m = t.y, x = t.z, h = f * T, g = f * m;
        return this.set(h * T + o, h * m - c * x, h * x + c * m, 0, h * m + c * x, g * m + o, g * x - c * T, 0, h * x - c * m, g * x + c * T, f * x * x + o, 0, 0, 0, 0, 1), this
    }

    makeScale(t, i, o) {
        return this.set(t, 0, 0, 0, 0, i, 0, 0, 0, 0, o, 0, 0, 0, 0, 1), this
    }

    makeShear(t, i, o, c, f, T) {
        return this.set(1, o, f, 0, t, 1, T, 0, i, c, 1, 0, 0, 0, 0, 1), this
    }

    compose(t, i, o) {
        const c = this.elements, f = i._x, T = i._y, m = i._z, x = i._w, h = f + f, g = T + T, w = m + m, v = f * h,
            E = f * g, p = f * w, C = T * g, M = T * w, b = m * w, B = x * h, R = x * g, I = x * w, L = o.x, O = o.y,
            N = o.z;
        return c[0] = (1 - (C + b)) * L, c[1] = (E + I) * L, c[2] = (p - R) * L, c[3] = 0, c[4] = (E - I) * O, c[5] = (1 - (v + b)) * O, c[6] = (M + B) * O, c[7] = 0, c[8] = (p + R) * N, c[9] = (M - B) * N, c[10] = (1 - (v + C)) * N, c[11] = 0, c[12] = t.x, c[13] = t.y, c[14] = t.z, c[15] = 1, this
    }

    decompose(t, i, o) {
        const c = this.elements;
        let f = Wd.set(c[0], c[1], c[2]).length();
        const T = Wd.set(c[4], c[5], c[6]).length(), m = Wd.set(c[8], c[9], c[10]).length();
        this.determinant() < 0 && (f = -f), t.x = c[12], t.y = c[13], t.z = c[14], yl.copy(this);
        const h = 1 / f, g = 1 / T, w = 1 / m;
        return yl.elements[0] *= h, yl.elements[1] *= h, yl.elements[2] *= h, yl.elements[4] *= g, yl.elements[5] *= g, yl.elements[6] *= g, yl.elements[8] *= w, yl.elements[9] *= w, yl.elements[10] *= w, i.setFromRotationMatrix(yl), o.x = f, o.y = T, o.z = m, this
    }

    makePerspective(t, i, o, c, f, T, m = Ph) {
        const x = this.elements, h = 2 * f / (i - t), g = 2 * f / (o - c), w = (i + t) / (i - t), v = (o + c) / (o - c);
        let E, p;
        if (m === Ph) E = -(T + f) / (T - f), p = -2 * T * f / (T - f); else if (m === p1) E = -T / (T - f), p = -T * f / (T - f); else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + m);
        return x[0] = h, x[4] = 0, x[8] = w, x[12] = 0, x[1] = 0, x[5] = g, x[9] = v, x[13] = 0, x[2] = 0, x[6] = 0, x[10] = E, x[14] = p, x[3] = 0, x[7] = 0, x[11] = -1, x[15] = 0, this
    }

    makeOrthographic(t, i, o, c, f, T, m = Ph) {
        const x = this.elements, h = 1 / (i - t), g = 1 / (o - c), w = 1 / (T - f), v = (i + t) * h, E = (o + c) * g;
        let p, C;
        if (m === Ph) p = (T + f) * w, C = -2 * w; else if (m === p1) p = f * w, C = -1 * w; else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + m);
        return x[0] = 2 * h, x[4] = 0, x[8] = 0, x[12] = -v, x[1] = 0, x[5] = 2 * g, x[9] = 0, x[13] = -E, x[2] = 0, x[6] = 0, x[10] = C, x[14] = -p, x[3] = 0, x[7] = 0, x[11] = 0, x[15] = 1, this
    }

    equals(t) {
        const i = this.elements, o = t.elements;
        for (let c = 0; c < 16; c++) if (i[c] !== o[c]) return !1;
        return !0
    }

    fromArray(t, i = 0) {
        for (let o = 0; o < 16; o++) this.elements[o] = t[o + i];
        return this
    }

    toArray(t = [], i = 0) {
        const o = this.elements;
        return t[i] = o[0], t[i + 1] = o[1], t[i + 2] = o[2], t[i + 3] = o[3], t[i + 4] = o[4], t[i + 5] = o[5], t[i + 6] = o[6], t[i + 7] = o[7], t[i + 8] = o[8], t[i + 9] = o[9], t[i + 10] = o[10], t[i + 11] = o[11], t[i + 12] = o[12], t[i + 13] = o[13], t[i + 14] = o[14], t[i + 15] = o[15], t
    }
}

const Wd = new ft, yl = new $n, CS = new ft(0, 0, 0), wS = new ft(1, 1, 1), xu = new ft, zg = new ft, Pa = new ft,
    GC = new $n, VC = new Ho;

class ao {
    constructor(t = 0, i = 0, o = 0, c = ao.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = t, this._y = i, this._z = o, this._order = c
    }

    get x() {
        return this._x
    }

    set x(t) {
        this._x = t, this._onChangeCallback()
    }

    get y() {
        return this._y
    }

    set y(t) {
        this._y = t, this._onChangeCallback()
    }

    get z() {
        return this._z
    }

    set z(t) {
        this._z = t, this._onChangeCallback()
    }

    get order() {
        return this._order
    }

    set order(t) {
        this._order = t, this._onChangeCallback()
    }

    set(t, i, o, c = this._order) {
        return this._x = t, this._y = i, this._z = o, this._order = c, this._onChangeCallback(), this
    }

    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }

    copy(t) {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
    }

    setFromRotationMatrix(t, i = this._order, o = !0) {
        const c = t.elements, f = c[0], T = c[4], m = c[8], x = c[1], h = c[5], g = c[9], w = c[2], v = c[6], E = c[10];
        switch (i) {
            case"XYZ":
                this._y = Math.asin(Ro(m, -1, 1)), Math.abs(m) < .9999999 ? (this._x = Math.atan2(-g, E), this._z = Math.atan2(-T, f)) : (this._x = Math.atan2(v, h), this._z = 0);
                break;
            case"YXZ":
                this._x = Math.asin(-Ro(g, -1, 1)), Math.abs(g) < .9999999 ? (this._y = Math.atan2(m, E), this._z = Math.atan2(x, h)) : (this._y = Math.atan2(-w, f), this._z = 0);
                break;
            case"ZXY":
                this._x = Math.asin(Ro(v, -1, 1)), Math.abs(v) < .9999999 ? (this._y = Math.atan2(-w, E), this._z = Math.atan2(-T, h)) : (this._y = 0, this._z = Math.atan2(x, f));
                break;
            case"ZYX":
                this._y = Math.asin(-Ro(w, -1, 1)), Math.abs(w) < .9999999 ? (this._x = Math.atan2(v, E), this._z = Math.atan2(x, f)) : (this._x = 0, this._z = Math.atan2(-T, h));
                break;
            case"YZX":
                this._z = Math.asin(Ro(x, -1, 1)), Math.abs(x) < .9999999 ? (this._x = Math.atan2(-g, h), this._y = Math.atan2(-w, f)) : (this._x = 0, this._y = Math.atan2(m, E));
                break;
            case"XZY":
                this._z = Math.asin(-Ro(T, -1, 1)), Math.abs(T) < .9999999 ? (this._x = Math.atan2(v, h), this._y = Math.atan2(m, f)) : (this._x = Math.atan2(-g, E), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i)
        }
        return this._order = i, o === !0 && this._onChangeCallback(), this
    }

    setFromQuaternion(t, i, o) {
        return GC.makeRotationFromQuaternion(t), this.setFromRotationMatrix(GC, i, o)
    }

    setFromVector3(t, i = this._order) {
        return this.set(t.x, t.y, t.z, i)
    }

    reorder(t) {
        return VC.setFromEuler(this), this.setFromQuaternion(VC, t)
    }

    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
    }

    fromArray(t) {
        return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this
    }

    toArray(t = [], i = 0) {
        return t[i] = this._x, t[i + 1] = this._y, t[i + 2] = this._z, t[i + 3] = this._order, t
    }

    _onChange(t) {
        return this._onChangeCallback = t, this
    }

    _onChangeCallback() {
    }

    * [Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
}

ao.DEFAULT_ORDER = "XYZ";

class bS {
    constructor() {
        this.mask = 1
    }

    set(t) {
        this.mask = (1 << t | 0) >>> 0
    }

    enable(t) {
        this.mask |= 1 << t | 0
    }

    enableAll() {
        this.mask = -1
    }

    toggle(t) {
        this.mask ^= 1 << t | 0
    }

    disable(t) {
        this.mask &= ~(1 << t | 0)
    }

    disableAll() {
        this.mask = 0
    }

    test(t) {
        return (this.mask & t.mask) !== 0
    }

    isEnabled(t) {
        return (this.mask & (1 << t | 0)) !== 0
    }
}

let _S = 0;
const HC = new ft, Kd = new Ho, Fc = new $n, Gg = new ft, Jp = new ft, MS = new ft, SS = new Ho, QC = new ft(1, 0, 0),
    jC = new ft(0, 1, 0), WC = new ft(0, 0, 1), KC = {type: "added"}, TS = {type: "removed"},
    Xd = {type: "childadded", child: null}, Ty = {type: "childremoved", child: null};

class rs extends Gc {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {value: _S++}), this.uuid = Pu(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = rs.DEFAULT_UP.clone();
        const t = new ft, i = new ao, o = new Ho, c = new ft(1, 1, 1);

        function f() {
            o.setFromEuler(i, !1)
        }

        function T() {
            i.setFromQuaternion(o, void 0, !1)
        }

        i._onChange(f), o._onChange(T), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {configurable: !0, enumerable: !0, value: i},
            quaternion: {configurable: !0, enumerable: !0, value: o},
            scale: {configurable: !0, enumerable: !0, value: c},
            modelViewMatrix: {value: new $n},
            normalMatrix: {value: new Jl}
        }), this.matrix = new $n, this.matrixWorld = new $n, this.matrixAutoUpdate = rs.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = rs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new bS, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }

    onBeforeShadow() {
    }

    onAfterShadow() {
    }

    onBeforeRender() {
    }

    onAfterRender() {
    }

    applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }

    applyQuaternion(t) {
        return this.quaternion.premultiply(t), this
    }

    setRotationFromAxisAngle(t, i) {
        this.quaternion.setFromAxisAngle(t, i)
    }

    setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, !0)
    }

    setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t)
    }

    setRotationFromQuaternion(t) {
        this.quaternion.copy(t)
    }

    rotateOnAxis(t, i) {
        return Kd.setFromAxisAngle(t, i), this.quaternion.multiply(Kd), this
    }

    rotateOnWorldAxis(t, i) {
        return Kd.setFromAxisAngle(t, i), this.quaternion.premultiply(Kd), this
    }

    rotateX(t) {
        return this.rotateOnAxis(QC, t)
    }

    rotateY(t) {
        return this.rotateOnAxis(jC, t)
    }

    rotateZ(t) {
        return this.rotateOnAxis(WC, t)
    }

    translateOnAxis(t, i) {
        return HC.copy(t).applyQuaternion(this.quaternion), this.position.add(HC.multiplyScalar(i)), this
    }

    translateX(t) {
        return this.translateOnAxis(QC, t)
    }

    translateY(t) {
        return this.translateOnAxis(jC, t)
    }

    translateZ(t) {
        return this.translateOnAxis(WC, t)
    }

    localToWorld(t) {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
    }

    worldToLocal(t) {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(Fc.copy(this.matrixWorld).invert())
    }

    lookAt(t, i, o) {
        t.isVector3 ? Gg.copy(t) : Gg.set(t, i, o);
        const c = this.parent;
        this.updateWorldMatrix(!0, !1), Jp.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Fc.lookAt(Jp, Gg, this.up) : Fc.lookAt(Gg, Jp, this.up), this.quaternion.setFromRotationMatrix(Fc), c && (Fc.extractRotation(c.matrixWorld), Kd.setFromRotationMatrix(Fc), this.quaternion.premultiply(Kd.invert()))
    }

    add(t) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
            return this
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(KC), Xd.child = t, this.dispatchEvent(Xd), Xd.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
    }

    remove(t) {
        if (arguments.length > 1) {
            for (let o = 0; o < arguments.length; o++) this.remove(arguments[o]);
            return this
        }
        const i = this.children.indexOf(t);
        return i !== -1 && (t.parent = null, this.children.splice(i, 1), t.dispatchEvent(TS), Ty.child = t, this.dispatchEvent(Ty), Ty.child = null), this
    }

    removeFromParent() {
        const t = this.parent;
        return t !== null && t.remove(this), this
    }

    clear() {
        return this.remove(...this.children)
    }

    attach(t) {
        return this.updateWorldMatrix(!0, !1), Fc.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), Fc.multiply(t.parent.matrixWorld)), t.applyMatrix4(Fc), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(KC), Xd.child = t, this.dispatchEvent(Xd), Xd.child = null, this
    }

    getObjectById(t) {
        return this.getObjectByProperty("id", t)
    }

    getObjectByName(t) {
        return this.getObjectByProperty("name", t)
    }

    getObjectByProperty(t, i) {
        if (this[t] === i) return this;
        for (let o = 0, c = this.children.length; o < c; o++) {
            const T = this.children[o].getObjectByProperty(t, i);
            if (T !== void 0) return T
        }
    }

    getObjectsByProperty(t, i, o = []) {
        this[t] === i && o.push(this);
        const c = this.children;
        for (let f = 0, T = c.length; f < T; f++) c[f].getObjectsByProperty(t, i, o);
        return o
    }

    getWorldPosition(t) {
        return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    }

    getWorldQuaternion(t) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jp, t, MS), t
    }

    getWorldScale(t) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jp, SS, t), t
    }

    getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const i = this.matrixWorld.elements;
        return t.set(i[8], i[9], i[10]).normalize()
    }

    raycast() {
    }

    traverse(t) {
        t(this);
        const i = this.children;
        for (let o = 0, c = i.length; o < c; o++) i[o].traverse(t)
    }

    traverseVisible(t) {
        if (this.visible === !1) return;
        t(this);
        const i = this.children;
        for (let o = 0, c = i.length; o < c; o++) i[o].traverseVisible(t)
    }

    traverseAncestors(t) {
        const i = this.parent;
        i !== null && (t(i), i.traverseAncestors(t))
    }

    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }

    updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
        const i = this.children;
        for (let o = 0, c = i.length; o < c; o++) {
            const f = i[o];
            (f.matrixWorldAutoUpdate === !0 || t === !0) && f.updateMatrixWorld(t)
        }
    }

    updateWorldMatrix(t, i) {
        const o = this.parent;
        if (t === !0 && o !== null && o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), i === !0) {
            const c = this.children;
            for (let f = 0, T = c.length; f < T; f++) {
                const m = c[f];
                m.matrixWorldAutoUpdate === !0 && m.updateWorldMatrix(!1, !0)
            }
        }
    }

    toJSON(t) {
        const i = t === void 0 || typeof t == "string", o = {};
        i && (t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, o.metadata = {version: 4.6, type: "Object", generator: "Object3D.toJSON"});
        const c = {};
        c.uuid = this.uuid, c.type = this.type, this.name !== "" && (c.name = this.name), this.castShadow === !0 && (c.castShadow = !0), this.receiveShadow === !0 && (c.receiveShadow = !0), this.visible === !1 && (c.visible = !1), this.frustumCulled === !1 && (c.frustumCulled = !1), this.renderOrder !== 0 && (c.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (c.userData = this.userData), c.layers = this.layers.mask, c.matrix = this.matrix.toArray(), c.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (c.matrixAutoUpdate = !1), this.isInstancedMesh && (c.type = "InstancedMesh", c.count = this.count, c.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (c.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (c.type = "BatchedMesh", c.perObjectFrustumCulled = this.perObjectFrustumCulled, c.sortObjects = this.sortObjects, c.drawRanges = this._drawRanges, c.reservedRanges = this._reservedRanges, c.visibility = this._visibility, c.active = this._active, c.bounds = this._bounds.map(m => ({
            boxInitialized: m.boxInitialized,
            boxMin: m.box.min.toArray(),
            boxMax: m.box.max.toArray(),
            sphereInitialized: m.sphereInitialized,
            sphereRadius: m.sphere.radius,
            sphereCenter: m.sphere.center.toArray()
        })), c.maxGeometryCount = this._maxGeometryCount, c.maxVertexCount = this._maxVertexCount, c.maxIndexCount = this._maxIndexCount, c.geometryInitialized = this._geometryInitialized, c.geometryCount = this._geometryCount, c.matricesTexture = this._matricesTexture.toJSON(t), this.boundingSphere !== null && (c.boundingSphere = {
            center: c.boundingSphere.center.toArray(),
            radius: c.boundingSphere.radius
        }), this.boundingBox !== null && (c.boundingBox = {
            min: c.boundingBox.min.toArray(),
            max: c.boundingBox.max.toArray()
        }));

        function f(m, x) {
            return m[x.uuid] === void 0 && (m[x.uuid] = x.toJSON(t)), x.uuid
        }

        if (this.isScene) this.background && (this.background.isColor ? c.background = this.background.toJSON() : this.background.isTexture && (c.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (c.environment = this.environment.toJSON(t).uuid); else if (this.isMesh || this.isLine || this.isPoints) {
            c.geometry = f(t.geometries, this.geometry);
            const m = this.geometry.parameters;
            if (m !== void 0 && m.shapes !== void 0) {
                const x = m.shapes;
                if (Array.isArray(x)) for (let h = 0, g = x.length; h < g; h++) {
                    const w = x[h];
                    f(t.shapes, w)
                } else f(t.shapes, x)
            }
        }
        if (this.isSkinnedMesh && (c.bindMode = this.bindMode, c.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (f(t.skeletons, this.skeleton), c.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
            const m = [];
            for (let x = 0, h = this.material.length; x < h; x++) m.push(f(t.materials, this.material[x]));
            c.material = m
        } else c.material = f(t.materials, this.material);
        if (this.children.length > 0) {
            c.children = [];
            for (let m = 0; m < this.children.length; m++) c.children.push(this.children[m].toJSON(t).object)
        }
        if (this.animations.length > 0) {
            c.animations = [];
            for (let m = 0; m < this.animations.length; m++) {
                const x = this.animations[m];
                c.animations.push(f(t.animations, x))
            }
        }
        if (i) {
            const m = T(t.geometries), x = T(t.materials), h = T(t.textures), g = T(t.images), w = T(t.shapes),
                v = T(t.skeletons), E = T(t.animations), p = T(t.nodes);
            m.length > 0 && (o.geometries = m), x.length > 0 && (o.materials = x), h.length > 0 && (o.textures = h), g.length > 0 && (o.images = g), w.length > 0 && (o.shapes = w), v.length > 0 && (o.skeletons = v), E.length > 0 && (o.animations = E), p.length > 0 && (o.nodes = p)
        }
        return o.object = c, o;

        function T(m) {
            const x = [];
            for (const h in m) {
                const g = m[h];
                delete g.metadata, x.push(g)
            }
            return x
        }
    }

    clone(t) {
        return new this.constructor().copy(this, t)
    }

    copy(t, i = !0) {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), i === !0) for (let o = 0; o < t.children.length; o++) {
            const c = t.children[o];
            this.add(c.clone())
        }
        return this
    }
}

rs.DEFAULT_UP = new ft(0, 1, 0);
rs.DEFAULT_MATRIX_AUTO_UPDATE = !0;
rs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const El = new ft, Nc = new ft, Iy = new ft, Uc = new ft, Yd = new ft, qd = new ft, XC = new ft, Ry = new ft,
    By = new ft, Ly = new ft;

class wl {
    constructor(t = new ft, i = new ft, o = new ft) {
        this.a = t, this.b = i, this.c = o
    }

    static getNormal(t, i, o, c) {
        c.subVectors(o, i), El.subVectors(t, i), c.cross(El);
        const f = c.lengthSq();
        return f > 0 ? c.multiplyScalar(1 / Math.sqrt(f)) : c.set(0, 0, 0)
    }

    static getBarycoord(t, i, o, c, f) {
        El.subVectors(c, i), Nc.subVectors(o, i), Iy.subVectors(t, i);
        const T = El.dot(El), m = El.dot(Nc), x = El.dot(Iy), h = Nc.dot(Nc), g = Nc.dot(Iy), w = T * h - m * m;
        if (w === 0) return f.set(0, 0, 0), null;
        const v = 1 / w, E = (h * x - m * g) * v, p = (T * g - m * x) * v;
        return f.set(1 - E - p, p, E)
    }

    static containsPoint(t, i, o, c) {
        return this.getBarycoord(t, i, o, c, Uc) === null ? !1 : Uc.x >= 0 && Uc.y >= 0 && Uc.x + Uc.y <= 1
    }

    static getInterpolation(t, i, o, c, f, T, m, x) {
        return this.getBarycoord(t, i, o, c, Uc) === null ? (x.x = 0, x.y = 0, "z" in x && (x.z = 0), "w" in x && (x.w = 0), null) : (x.setScalar(0), x.addScaledVector(f, Uc.x), x.addScaledVector(T, Uc.y), x.addScaledVector(m, Uc.z), x)
    }

    static isFrontFacing(t, i, o, c) {
        return El.subVectors(o, i), Nc.subVectors(t, i), El.cross(Nc).dot(c) < 0
    }

    set(t, i, o) {
        return this.a.copy(t), this.b.copy(i), this.c.copy(o), this
    }

    setFromPointsAndIndices(t, i, o, c) {
        return this.a.copy(t[i]), this.b.copy(t[o]), this.c.copy(t[c]), this
    }

    setFromAttributeAndIndices(t, i, o, c) {
        return this.a.fromBufferAttribute(t, i), this.b.fromBufferAttribute(t, o), this.c.fromBufferAttribute(t, c), this
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
    }

    getArea() {
        return El.subVectors(this.c, this.b), Nc.subVectors(this.a, this.b), El.cross(Nc).length() * .5
    }

    getMidpoint(t) {
        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }

    getNormal(t) {
        return wl.getNormal(this.a, this.b, this.c, t)
    }

    getPlane(t) {
        return t.setFromCoplanarPoints(this.a, this.b, this.c)
    }

    getBarycoord(t, i) {
        return wl.getBarycoord(t, this.a, this.b, this.c, i)
    }

    getInterpolation(t, i, o, c, f) {
        return wl.getInterpolation(t, this.a, this.b, this.c, i, o, c, f)
    }

    containsPoint(t) {
        return wl.containsPoint(t, this.a, this.b, this.c)
    }

    isFrontFacing(t) {
        return wl.isFrontFacing(this.a, this.b, this.c, t)
    }

    intersectsBox(t) {
        return t.intersectsTriangle(this)
    }

    closestPointToPoint(t, i) {
        const o = this.a, c = this.b, f = this.c;
        let T, m;
        Yd.subVectors(c, o), qd.subVectors(f, o), Ry.subVectors(t, o);
        const x = Yd.dot(Ry), h = qd.dot(Ry);
        if (x <= 0 && h <= 0) return i.copy(o);
        By.subVectors(t, c);
        const g = Yd.dot(By), w = qd.dot(By);
        if (g >= 0 && w <= g) return i.copy(c);
        const v = x * w - g * h;
        if (v <= 0 && x >= 0 && g <= 0) return T = x / (x - g), i.copy(o).addScaledVector(Yd, T);
        Ly.subVectors(t, f);
        const E = Yd.dot(Ly), p = qd.dot(Ly);
        if (p >= 0 && E <= p) return i.copy(f);
        const C = E * h - x * p;
        if (C <= 0 && h >= 0 && p <= 0) return m = h / (h - p), i.copy(o).addScaledVector(qd, m);
        const M = g * p - E * w;
        if (M <= 0 && w - g >= 0 && E - p >= 0) return XC.subVectors(f, c), m = (w - g) / (w - g + (E - p)), i.copy(c).addScaledVector(XC, m);
        const b = 1 / (M + C + v);
        return T = C * b, m = v * b, i.copy(o).addScaledVector(Yd, T).addScaledVector(qd, m)
    }

    equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
}

const ww = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}, Cu = {h: 0, s: 0, l: 0}, Vg = {h: 0, s: 0, l: 0};

function Dy(A, t, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? A + (t - A) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? A + (t - A) * 6 * (2 / 3 - i) : A
}

class xs {
    constructor(t, i, o) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, i, o)
    }

    set(t, i, o) {
        if (i === void 0 && o === void 0) {
            const c = t;
            c && c.isColor ? this.copy(c) : typeof c == "number" ? this.setHex(c) : typeof c == "string" && this.setStyle(c)
        } else this.setRGB(t, i, o);
        return this
    }

    setScalar(t) {
        return this.r = t, this.g = t, this.b = t, this
    }

    setHex(t, i = ca) {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, gl.toWorkingColorSpace(this, i), this
    }

    setRGB(t, i, o, c = gl.workingColorSpace) {
        return this.r = t, this.g = i, this.b = o, gl.toWorkingColorSpace(this, c), this
    }

    setHSL(t, i, o, c = gl.workingColorSpace) {
        if (t = I1(t, 1), i = Ro(i, 0, 1), o = Ro(o, 0, 1), i === 0) this.r = this.g = this.b = o; else {
            const f = o <= .5 ? o * (1 + i) : o + i - o * i, T = 2 * o - f;
            this.r = Dy(T, f, t + 1 / 3), this.g = Dy(T, f, t), this.b = Dy(T, f, t - 1 / 3)
        }
        return gl.toWorkingColorSpace(this, c), this
    }

    setStyle(t, i = ca) {
        function o(f) {
            f !== void 0 && parseFloat(f) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
        }

        let c;
        if (c = /^(\w+)\(([^\)]*)\)/.exec(t)) {
            let f;
            const T = c[1], m = c[2];
            switch (T) {
                case"rgb":
                case"rgba":
                    if (f = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(m)) return o(f[4]), this.setRGB(Math.min(255, parseInt(f[1], 10)) / 255, Math.min(255, parseInt(f[2], 10)) / 255, Math.min(255, parseInt(f[3], 10)) / 255, i);
                    if (f = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(m)) return o(f[4]), this.setRGB(Math.min(100, parseInt(f[1], 10)) / 100, Math.min(100, parseInt(f[2], 10)) / 100, Math.min(100, parseInt(f[3], 10)) / 100, i);
                    break;
                case"hsl":
                case"hsla":
                    if (f = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(m)) return o(f[4]), this.setHSL(parseFloat(f[1]) / 360, parseFloat(f[2]) / 100, parseFloat(f[3]) / 100, i);
                    break;
                default:
                    console.warn("THREE.Color: Unknown color model " + t)
            }
        } else if (c = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const f = c[1], T = f.length;
            if (T === 3) return this.setRGB(parseInt(f.charAt(0), 16) / 15, parseInt(f.charAt(1), 16) / 15, parseInt(f.charAt(2), 16) / 15, i);
            if (T === 6) return this.setHex(parseInt(f, 16), i);
            console.warn("THREE.Color: Invalid hex color " + t)
        } else if (t && t.length > 0) return this.setColorName(t, i);
        return this
    }

    setColorName(t, i = ca) {
        const o = ww[t.toLowerCase()];
        return o !== void 0 ? this.setHex(o, i) : console.warn("THREE.Color: Unknown color " + t), this
    }

    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }

    copy(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this
    }

    copySRGBToLinear(t) {
        return this.r = af(t.r), this.g = af(t.g), this.b = af(t.b), this
    }

    copyLinearToSRGB(t) {
        return this.r = Ey(t.r), this.g = Ey(t.g), this.b = Ey(t.b), this
    }

    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }

    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }

    getHex(t = ca) {
        return gl.fromWorkingColorSpace(Vo.copy(this), t), Math.round(Ro(Vo.r * 255, 0, 255)) * 65536 + Math.round(Ro(Vo.g * 255, 0, 255)) * 256 + Math.round(Ro(Vo.b * 255, 0, 255))
    }

    getHexString(t = ca) {
        return ("000000" + this.getHex(t).toString(16)).slice(-6)
    }

    getHSL(t, i = gl.workingColorSpace) {
        gl.fromWorkingColorSpace(Vo.copy(this), i);
        const o = Vo.r, c = Vo.g, f = Vo.b, T = Math.max(o, c, f), m = Math.min(o, c, f);
        let x, h;
        const g = (m + T) / 2;
        if (m === T) x = 0, h = 0; else {
            const w = T - m;
            switch (h = g <= .5 ? w / (T + m) : w / (2 - T - m), T) {
                case o:
                    x = (c - f) / w + (c < f ? 6 : 0);
                    break;
                case c:
                    x = (f - o) / w + 2;
                    break;
                case f:
                    x = (o - c) / w + 4;
                    break
            }
            x /= 6
        }
        return t.h = x, t.s = h, t.l = g, t
    }

    getRGB(t, i = gl.workingColorSpace) {
        return gl.fromWorkingColorSpace(Vo.copy(this), i), t.r = Vo.r, t.g = Vo.g, t.b = Vo.b, t
    }

    getStyle(t = ca) {
        gl.fromWorkingColorSpace(Vo.copy(this), t);
        const i = Vo.r, o = Vo.g, c = Vo.b;
        return t !== ca ? `color(${t} ${i.toFixed(3)} ${o.toFixed(3)} ${c.toFixed(3)})` : `rgb(${Math.round(i * 255)},${Math.round(o * 255)},${Math.round(c * 255)})`
    }

    offsetHSL(t, i, o) {
        return this.getHSL(Cu), this.setHSL(Cu.h + t, Cu.s + i, Cu.l + o)
    }

    add(t) {
        return this.r += t.r, this.g += t.g, this.b += t.b, this
    }

    addColors(t, i) {
        return this.r = t.r + i.r, this.g = t.g + i.g, this.b = t.b + i.b, this
    }

    addScalar(t) {
        return this.r += t, this.g += t, this.b += t, this
    }

    sub(t) {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
    }

    multiply(t) {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
    }

    multiplyScalar(t) {
        return this.r *= t, this.g *= t, this.b *= t, this
    }

    lerp(t, i) {
        return this.r += (t.r - this.r) * i, this.g += (t.g - this.g) * i, this.b += (t.b - this.b) * i, this
    }

    lerpColors(t, i, o) {
        return this.r = t.r + (i.r - t.r) * o, this.g = t.g + (i.g - t.g) * o, this.b = t.b + (i.b - t.b) * o, this
    }

    lerpHSL(t, i) {
        this.getHSL(Cu), t.getHSL(Vg);
        const o = sm(Cu.h, Vg.h, i), c = sm(Cu.s, Vg.s, i), f = sm(Cu.l, Vg.l, i);
        return this.setHSL(o, c, f), this
    }

    setFromVector3(t) {
        return this.r = t.x, this.g = t.y, this.b = t.z, this
    }

    applyMatrix3(t) {
        const i = this.r, o = this.g, c = this.b, f = t.elements;
        return this.r = f[0] * i + f[3] * o + f[6] * c, this.g = f[1] * i + f[4] * o + f[7] * c, this.b = f[2] * i + f[5] * o + f[8] * c, this
    }

    equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b
    }

    fromArray(t, i = 0) {
        return this.r = t[i], this.g = t[i + 1], this.b = t[i + 2], this
    }

    toArray(t = [], i = 0) {
        return t[i] = this.r, t[i + 1] = this.g, t[i + 2] = this.b, t
    }

    fromBufferAttribute(t, i) {
        return this.r = t.getX(i), this.g = t.getY(i), this.b = t.getZ(i), this
    }

    toJSON() {
        return this.getHex()
    }

    * [Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
}

const Vo = new xs;
xs.NAMES = ww;
let IS = 0;

class R0 extends Gc {
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {value: IS++}), this.uuid = Pu(), this.name = "", this.type = "Material", this.blending = EC, this.side = g0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = CC, this.blendDst = wC, this.blendEquation = xC, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new xs(0, 0, 0), this.blendAlpha = 0, this.depthFunc = bC, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = PC, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Gd, this.stencilZFail = Gd, this.stencilZPass = Gd, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }

    get alphaTest() {
        return this._alphaTest
    }

    set alphaTest(t) {
        this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
    }

    onBuild() {
    }

    onBeforeRender() {
    }

    onBeforeCompile() {
    }

    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }

    setValues(t) {
        if (t !== void 0) for (const i in t) {
            const o = t[i];
            if (o === void 0) {
                console.warn(`THREE.Material: parameter '${i}' has value of undefined.`);
                continue
            }
            const c = this[i];
            if (c === void 0) {
                console.warn(`THREE.Material: '${i}' is not a property of THREE.${this.type}.`);
                continue
            }
            c && c.isColor ? c.set(o) : c && c.isVector3 && o && o.isVector3 ? c.copy(o) : this[i] = o
        }
    }

    toJSON(t) {
        const i = t === void 0 || typeof t == "string";
        i && (t = {textures: {}, images: {}});
        const o = {metadata: {version: 4.6, type: "Material", generator: "Material.toJSON"}};
        o.uuid = this.uuid, o.type = this.type, this.name !== "" && (o.name = this.name), this.color && this.color.isColor && (o.color = this.color.getHex()), this.roughness !== void 0 && (o.roughness = this.roughness), this.metalness !== void 0 && (o.metalness = this.metalness), this.sheen !== void 0 && (o.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (o.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (o.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (o.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (o.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (o.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (o.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (o.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (o.shininess = this.shininess), this.clearcoat !== void 0 && (o.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (o.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (o.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (o.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (o.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, o.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (o.dispersion = this.dispersion), this.iridescence !== void 0 && (o.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (o.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (o.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (o.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (o.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (o.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (o.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (o.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (o.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (o.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (o.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (o.lightMap = this.lightMap.toJSON(t).uuid, o.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (o.aoMap = this.aoMap.toJSON(t).uuid, o.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (o.bumpMap = this.bumpMap.toJSON(t).uuid, o.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (o.normalMap = this.normalMap.toJSON(t).uuid, o.normalMapType = this.normalMapType, o.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (o.displacementMap = this.displacementMap.toJSON(t).uuid, o.displacementScale = this.displacementScale, o.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (o.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (o.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (o.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (o.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (o.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (o.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (o.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (o.combine = this.combine)), this.envMapRotation !== void 0 && (o.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (o.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (o.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (o.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (o.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (o.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (o.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (o.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (o.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (o.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (o.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (o.size = this.size), this.shadowSide !== null && (o.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (o.sizeAttenuation = this.sizeAttenuation), this.blending !== EC && (o.blending = this.blending), this.side !== g0 && (o.side = this.side), this.vertexColors === !0 && (o.vertexColors = !0), this.opacity < 1 && (o.opacity = this.opacity), this.transparent === !0 && (o.transparent = !0), this.blendSrc !== CC && (o.blendSrc = this.blendSrc), this.blendDst !== wC && (o.blendDst = this.blendDst), this.blendEquation !== xC && (o.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (o.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (o.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (o.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (o.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (o.blendAlpha = this.blendAlpha), this.depthFunc !== bC && (o.depthFunc = this.depthFunc), this.depthTest === !1 && (o.depthTest = this.depthTest), this.depthWrite === !1 && (o.depthWrite = this.depthWrite), this.colorWrite === !1 && (o.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (o.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== PC && (o.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (o.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (o.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Gd && (o.stencilFail = this.stencilFail), this.stencilZFail !== Gd && (o.stencilZFail = this.stencilZFail), this.stencilZPass !== Gd && (o.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (o.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (o.rotation = this.rotation), this.polygonOffset === !0 && (o.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (o.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (o.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (o.linewidth = this.linewidth), this.dashSize !== void 0 && (o.dashSize = this.dashSize), this.gapSize !== void 0 && (o.gapSize = this.gapSize), this.scale !== void 0 && (o.scale = this.scale), this.dithering === !0 && (o.dithering = !0), this.alphaTest > 0 && (o.alphaTest = this.alphaTest), this.alphaHash === !0 && (o.alphaHash = !0), this.alphaToCoverage === !0 && (o.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (o.premultipliedAlpha = !0), this.forceSinglePass === !0 && (o.forceSinglePass = !0), this.wireframe === !0 && (o.wireframe = !0), this.wireframeLinewidth > 1 && (o.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (o.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (o.wireframeLinejoin = this.wireframeLinejoin),this.flatShading === !0 && (o.flatShading = !0),this.visible === !1 && (o.visible = !1),this.toneMapped === !1 && (o.toneMapped = !1),this.fog === !1 && (o.fog = !1),Object.keys(this.userData).length > 0 && (o.userData = this.userData);

        function c(f) {
            const T = [];
            for (const m in f) {
                const x = f[m];
                delete x.metadata, T.push(x)
            }
            return T
        }

        if (i) {
            const f = c(t.textures), T = c(t.images);
            f.length > 0 && (o.textures = f), T.length > 0 && (o.images = T)
        }
        return o
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
        const i = t.clippingPlanes;
        let o = null;
        if (i !== null) {
            const c = i.length;
            o = new Array(c);
            for (let f = 0; f !== c; ++f) o[f] = i[f].clone()
        }
        return this.clippingPlanes = o, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }

    set needsUpdate(t) {
        t === !0 && this.version++
    }
}

class Su extends R0 {
    constructor(t) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new xs(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ao, this.combine = M1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
    }
}

const qs = new ft, Hg = new es;

class Ru {
    constructor(t, i, o = !1) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = i, this.count = t !== void 0 ? t.length / i : 0, this.normalized = o, this.usage = OC, this._updateRange = {
            offset: 0,
            count: -1
        }, this.updateRanges = [], this.gpuType = gw, this.version = 0
    }

    onUploadCallback() {
    }

    set needsUpdate(t) {
        t === !0 && this.version++
    }

    get updateRange() {
        return pS("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }

    setUsage(t) {
        return this.usage = t, this
    }

    addUpdateRange(t, i) {
        this.updateRanges.push({start: t, count: i})
    }

    clearUpdateRanges() {
        this.updateRanges.length = 0
    }

    copy(t) {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
    }

    copyAt(t, i, o) {
        t *= this.itemSize, o *= i.itemSize;
        for (let c = 0, f = this.itemSize; c < f; c++) this.array[t + c] = i.array[o + c];
        return this
    }

    copyArray(t) {
        return this.array.set(t), this
    }

    applyMatrix3(t) {
        if (this.itemSize === 2) for (let i = 0, o = this.count; i < o; i++) Hg.fromBufferAttribute(this, i), Hg.applyMatrix3(t), this.setXY(i, Hg.x, Hg.y); else if (this.itemSize === 3) for (let i = 0, o = this.count; i < o; i++) qs.fromBufferAttribute(this, i), qs.applyMatrix3(t), this.setXYZ(i, qs.x, qs.y, qs.z);
        return this
    }

    applyMatrix4(t) {
        for (let i = 0, o = this.count; i < o; i++) qs.fromBufferAttribute(this, i), qs.applyMatrix4(t), this.setXYZ(i, qs.x, qs.y, qs.z);
        return this
    }

    applyNormalMatrix(t) {
        for (let i = 0, o = this.count; i < o; i++) qs.fromBufferAttribute(this, i), qs.applyNormalMatrix(t), this.setXYZ(i, qs.x, qs.y, qs.z);
        return this
    }

    transformDirection(t) {
        for (let i = 0, o = this.count; i < o; i++) qs.fromBufferAttribute(this, i), qs.transformDirection(t), this.setXYZ(i, qs.x, qs.y, qs.z);
        return this
    }

    set(t, i = 0) {
        return this.array.set(t, i), this
    }

    getComponent(t, i) {
        let o = this.array[t * this.itemSize + i];
        return this.normalized && (o = nf(o, this.array)), o
    }

    setComponent(t, i, o) {
        return this.normalized && (o = aa(o, this.array)), this.array[t * this.itemSize + i] = o, this
    }

    getX(t) {
        let i = this.array[t * this.itemSize];
        return this.normalized && (i = nf(i, this.array)), i
    }

    setX(t, i) {
        return this.normalized && (i = aa(i, this.array)), this.array[t * this.itemSize] = i, this
    }

    getY(t) {
        let i = this.array[t * this.itemSize + 1];
        return this.normalized && (i = nf(i, this.array)), i
    }

    setY(t, i) {
        return this.normalized && (i = aa(i, this.array)), this.array[t * this.itemSize + 1] = i, this
    }

    getZ(t) {
        let i = this.array[t * this.itemSize + 2];
        return this.normalized && (i = nf(i, this.array)), i
    }

    setZ(t, i) {
        return this.normalized && (i = aa(i, this.array)), this.array[t * this.itemSize + 2] = i, this
    }

    getW(t) {
        let i = this.array[t * this.itemSize + 3];
        return this.normalized && (i = nf(i, this.array)), i
    }

    setW(t, i) {
        return this.normalized && (i = aa(i, this.array)), this.array[t * this.itemSize + 3] = i, this
    }

    setXY(t, i, o) {
        return t *= this.itemSize, this.normalized && (i = aa(i, this.array), o = aa(o, this.array)), this.array[t + 0] = i, this.array[t + 1] = o, this
    }

    setXYZ(t, i, o, c) {
        return t *= this.itemSize, this.normalized && (i = aa(i, this.array), o = aa(o, this.array), c = aa(c, this.array)), this.array[t + 0] = i, this.array[t + 1] = o, this.array[t + 2] = c, this
    }

    setXYZW(t, i, o, c, f) {
        return t *= this.itemSize, this.normalized && (i = aa(i, this.array), o = aa(o, this.array), c = aa(c, this.array), f = aa(f, this.array)), this.array[t + 0] = i, this.array[t + 1] = o, this.array[t + 2] = c, this.array[t + 3] = f, this
    }

    onUpload(t) {
        return this.onUploadCallback = t, this
    }

    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }

    toJSON() {
        const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (t.name = this.name), this.usage !== OC && (t.usage = this.usage), t
    }
}

class bw extends Ru {
    constructor(t, i, o) {
        super(new Uint16Array(t), i, o)
    }
}

class RS extends Ru {
    constructor(t, i, o) {
        super(new Uint32Array(t), i, o)
    }
}

class Cs extends Ru {
    constructor(t, i, o) {
        super(new Float32Array(t), i, o)
    }
}

let BS = 0;
const tl = new $n, Py = new rs, Jd = new ft, Oa = new lf, Zp = new lf, vo = new ft;

class il extends Gc {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {value: BS++}), this.uuid = Pu(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }

    getIndex() {
        return this.index
    }

    setIndex(t) {
        return Array.isArray(t) ? this.index = new (fS(t) ? RS : bw)(t, 1) : this.index = t, this
    }

    getAttribute(t) {
        return this.attributes[t]
    }

    setAttribute(t, i) {
        return this.attributes[t] = i, this
    }

    deleteAttribute(t) {
        return delete this.attributes[t], this
    }

    hasAttribute(t) {
        return this.attributes[t] !== void 0
    }

    addGroup(t, i, o = 0) {
        this.groups.push({start: t, count: i, materialIndex: o})
    }

    clearGroups() {
        this.groups = []
    }

    setDrawRange(t, i) {
        this.drawRange.start = t, this.drawRange.count = i
    }

    applyMatrix4(t) {
        const i = this.attributes.position;
        i !== void 0 && (i.applyMatrix4(t), i.needsUpdate = !0);
        const o = this.attributes.normal;
        if (o !== void 0) {
            const f = new Jl().getNormalMatrix(t);
            o.applyNormalMatrix(f), o.needsUpdate = !0
        }
        const c = this.attributes.tangent;
        return c !== void 0 && (c.transformDirection(t), c.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }

    applyQuaternion(t) {
        return tl.makeRotationFromQuaternion(t), this.applyMatrix4(tl), this
    }

    rotateX(t) {
        return tl.makeRotationX(t), this.applyMatrix4(tl), this
    }

    rotateY(t) {
        return tl.makeRotationY(t), this.applyMatrix4(tl), this
    }

    rotateZ(t) {
        return tl.makeRotationZ(t), this.applyMatrix4(tl), this
    }

    translate(t, i, o) {
        return tl.makeTranslation(t, i, o), this.applyMatrix4(tl), this
    }

    scale(t, i, o) {
        return tl.makeScale(t, i, o), this.applyMatrix4(tl), this
    }

    lookAt(t) {
        return Py.lookAt(t), Py.updateMatrix(), this.applyMatrix4(Py.matrix), this
    }

    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(Jd).negate(), this.translate(Jd.x, Jd.y, Jd.z), this
    }

    setFromPoints(t) {
        const i = [];
        for (let o = 0, c = t.length; o < c; o++) {
            const f = t[o];
            i.push(f.x, f.y, f.z || 0)
        }
        return this.setAttribute("position", new Cs(i, 3)), this
    }

    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new lf);
        const t = this.attributes.position, i = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new ft(-1 / 0, -1 / 0, -1 / 0), new ft(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (t !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(t), i) for (let o = 0, c = i.length; o < c; o++) {
                const f = i[o];
                Oa.setFromBufferAttribute(f), this.morphTargetsRelative ? (vo.addVectors(this.boundingBox.min, Oa.min), this.boundingBox.expandByPoint(vo), vo.addVectors(this.boundingBox.max, Oa.max), this.boundingBox.expandByPoint(vo)) : (this.boundingBox.expandByPoint(Oa.min), this.boundingBox.expandByPoint(Oa.max))
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }

    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new cf);
        const t = this.attributes.position, i = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new ft, 1 / 0);
            return
        }
        if (t) {
            const o = this.boundingSphere.center;
            if (Oa.setFromBufferAttribute(t), i) for (let f = 0, T = i.length; f < T; f++) {
                const m = i[f];
                Zp.setFromBufferAttribute(m), this.morphTargetsRelative ? (vo.addVectors(Oa.min, Zp.min), Oa.expandByPoint(vo), vo.addVectors(Oa.max, Zp.max), Oa.expandByPoint(vo)) : (Oa.expandByPoint(Zp.min), Oa.expandByPoint(Zp.max))
            }
            Oa.getCenter(o);
            let c = 0;
            for (let f = 0, T = t.count; f < T; f++) vo.fromBufferAttribute(t, f), c = Math.max(c, o.distanceToSquared(vo));
            if (i) for (let f = 0, T = i.length; f < T; f++) {
                const m = i[f], x = this.morphTargetsRelative;
                for (let h = 0, g = m.count; h < g; h++) vo.fromBufferAttribute(m, h), x && (Jd.fromBufferAttribute(t, h), vo.add(Jd)), c = Math.max(c, o.distanceToSquared(vo))
            }
            this.boundingSphere.radius = Math.sqrt(c), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }

    computeTangents() {
        const t = this.index, i = this.attributes;
        if (t === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const o = i.position, c = i.normal, f = i.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ru(new Float32Array(4 * o.count), 4));
        const T = this.getAttribute("tangent"), m = [], x = [];
        for (let F = 0; F < o.count; F++) m[F] = new ft, x[F] = new ft;
        const h = new ft, g = new ft, w = new ft, v = new es, E = new es, p = new es, C = new ft, M = new ft;

        function b(F, V, U) {
            h.fromBufferAttribute(o, F), g.fromBufferAttribute(o, V), w.fromBufferAttribute(o, U), v.fromBufferAttribute(f, F), E.fromBufferAttribute(f, V), p.fromBufferAttribute(f, U), g.sub(h), w.sub(h), E.sub(v), p.sub(v);
            const j = 1 / (E.x * p.y - p.x * E.y);
            isFinite(j) && (C.copy(g).multiplyScalar(p.y).addScaledVector(w, -E.y).multiplyScalar(j), M.copy(w).multiplyScalar(E.x).addScaledVector(g, -p.x).multiplyScalar(j), m[F].add(C), m[V].add(C), m[U].add(C), x[F].add(M), x[V].add(M), x[U].add(M))
        }

        let B = this.groups;
        B.length === 0 && (B = [{start: 0, count: t.count}]);
        for (let F = 0, V = B.length; F < V; ++F) {
            const U = B[F], j = U.start, Y = U.count;
            for (let fe = j, se = j + Y; fe < se; fe += 3) b(t.getX(fe + 0), t.getX(fe + 1), t.getX(fe + 2))
        }
        const R = new ft, I = new ft, L = new ft, O = new ft;

        function N(F) {
            L.fromBufferAttribute(c, F), O.copy(L);
            const V = m[F];
            R.copy(V), R.sub(L.multiplyScalar(L.dot(V))).normalize(), I.crossVectors(O, V);
            const j = I.dot(x[F]) < 0 ? -1 : 1;
            T.setXYZW(F, R.x, R.y, R.z, j)
        }

        for (let F = 0, V = B.length; F < V; ++F) {
            const U = B[F], j = U.start, Y = U.count;
            for (let fe = j, se = j + Y; fe < se; fe += 3) N(t.getX(fe + 0)), N(t.getX(fe + 1)), N(t.getX(fe + 2))
        }
    }

    computeVertexNormals() {
        const t = this.index, i = this.getAttribute("position");
        if (i !== void 0) {
            let o = this.getAttribute("normal");
            if (o === void 0) o = new Ru(new Float32Array(i.count * 3), 3), this.setAttribute("normal", o); else for (let v = 0, E = o.count; v < E; v++) o.setXYZ(v, 0, 0, 0);
            const c = new ft, f = new ft, T = new ft, m = new ft, x = new ft, h = new ft, g = new ft, w = new ft;
            if (t) for (let v = 0, E = t.count; v < E; v += 3) {
                const p = t.getX(v + 0), C = t.getX(v + 1), M = t.getX(v + 2);
                c.fromBufferAttribute(i, p), f.fromBufferAttribute(i, C), T.fromBufferAttribute(i, M), g.subVectors(T, f), w.subVectors(c, f), g.cross(w), m.fromBufferAttribute(o, p), x.fromBufferAttribute(o, C), h.fromBufferAttribute(o, M), m.add(g), x.add(g), h.add(g), o.setXYZ(p, m.x, m.y, m.z), o.setXYZ(C, x.x, x.y, x.z), o.setXYZ(M, h.x, h.y, h.z)
            } else for (let v = 0, E = i.count; v < E; v += 3) c.fromBufferAttribute(i, v + 0), f.fromBufferAttribute(i, v + 1), T.fromBufferAttribute(i, v + 2), g.subVectors(T, f), w.subVectors(c, f), g.cross(w), o.setXYZ(v + 0, g.x, g.y, g.z), o.setXYZ(v + 1, g.x, g.y, g.z), o.setXYZ(v + 2, g.x, g.y, g.z);
            this.normalizeNormals(), o.needsUpdate = !0
        }
    }

    normalizeNormals() {
        const t = this.attributes.normal;
        for (let i = 0, o = t.count; i < o; i++) vo.fromBufferAttribute(t, i), vo.normalize(), t.setXYZ(i, vo.x, vo.y, vo.z)
    }

    toNonIndexed() {
        function t(m, x) {
            const h = m.array, g = m.itemSize, w = m.normalized, v = new h.constructor(x.length * g);
            let E = 0, p = 0;
            for (let C = 0, M = x.length; C < M; C++) {
                m.isInterleavedBufferAttribute ? E = x[C] * m.data.stride + m.offset : E = x[C] * g;
                for (let b = 0; b < g; b++) v[p++] = h[E++]
            }
            return new Ru(v, g, w)
        }

        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const i = new il, o = this.index.array, c = this.attributes;
        for (const m in c) {
            const x = c[m], h = t(x, o);
            i.setAttribute(m, h)
        }
        const f = this.morphAttributes;
        for (const m in f) {
            const x = [], h = f[m];
            for (let g = 0, w = h.length; g < w; g++) {
                const v = h[g], E = t(v, o);
                x.push(E)
            }
            i.morphAttributes[m] = x
        }
        i.morphTargetsRelative = this.morphTargetsRelative;
        const T = this.groups;
        for (let m = 0, x = T.length; m < x; m++) {
            const h = T[m];
            i.addGroup(h.start, h.count, h.materialIndex)
        }
        return i
    }

    toJSON() {
        const t = {metadata: {version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
        if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
            const x = this.parameters;
            for (const h in x) x[h] !== void 0 && (t[h] = x[h]);
            return t
        }
        t.data = {attributes: {}};
        const i = this.index;
        i !== null && (t.data.index = {type: i.array.constructor.name, array: Array.prototype.slice.call(i.array)});
        const o = this.attributes;
        for (const x in o) {
            const h = o[x];
            t.data.attributes[x] = h.toJSON(t.data)
        }
        const c = {};
        let f = !1;
        for (const x in this.morphAttributes) {
            const h = this.morphAttributes[x], g = [];
            for (let w = 0, v = h.length; w < v; w++) {
                const E = h[w];
                g.push(E.toJSON(t.data))
            }
            g.length > 0 && (c[x] = g, f = !0)
        }
        f && (t.data.morphAttributes = c, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const T = this.groups;
        T.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(T)));
        const m = this.boundingSphere;
        return m !== null && (t.data.boundingSphere = {center: m.center.toArray(), radius: m.radius}), t
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const i = {};
        this.name = t.name;
        const o = t.index;
        o !== null && this.setIndex(o.clone(i));
        const c = t.attributes;
        for (const h in c) {
            const g = c[h];
            this.setAttribute(h, g.clone(i))
        }
        const f = t.morphAttributes;
        for (const h in f) {
            const g = [], w = f[h];
            for (let v = 0, E = w.length; v < E; v++) g.push(w[v].clone(i));
            this.morphAttributes[h] = g
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const T = t.groups;
        for (let h = 0, g = T.length; h < g; h++) {
            const w = T[h];
            this.addGroup(w.start, w.count, w.materialIndex)
        }
        const m = t.boundingBox;
        m !== null && (this.boundingBox = m.clone());
        const x = t.boundingSphere;
        return x !== null && (this.boundingSphere = x.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }
}

const YC = new $n, Lh = new R1, Qg = new cf, qC = new ft, Zd = new ft, $d = new ft, ef = new ft, Oy = new ft,
    jg = new ft, Wg = new es, Kg = new es, Xg = new es, JC = new ft, ZC = new ft, $C = new ft, Yg = new ft, qg = new ft;

class Tu extends rs {
    constructor(t = new il, i = new Su) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = i, this.updateMorphTargets()
    }

    copy(t, i) {
        return super.copy(t, i), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
    }

    updateMorphTargets() {
        const i = this.geometry.morphAttributes, o = Object.keys(i);
        if (o.length > 0) {
            const c = i[o[0]];
            if (c !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let f = 0, T = c.length; f < T; f++) {
                    const m = c[f].name || String(f);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[m] = f
                }
            }
        }
    }

    getVertexPosition(t, i) {
        const o = this.geometry, c = o.attributes.position, f = o.morphAttributes.position, T = o.morphTargetsRelative;
        i.fromBufferAttribute(c, t);
        const m = this.morphTargetInfluences;
        if (f && m) {
            jg.set(0, 0, 0);
            for (let x = 0, h = f.length; x < h; x++) {
                const g = m[x], w = f[x];
                g !== 0 && (Oy.fromBufferAttribute(w, t), T ? jg.addScaledVector(Oy, g) : jg.addScaledVector(Oy.sub(i), g))
            }
            i.add(jg)
        }
        return i
    }

    raycast(t, i) {
        const o = this.geometry, c = this.material, f = this.matrixWorld;
        c !== void 0 && (o.boundingSphere === null && o.computeBoundingSphere(), Qg.copy(o.boundingSphere), Qg.applyMatrix4(f), Lh.copy(t.ray).recast(t.near), !(Qg.containsPoint(Lh.origin) === !1 && (Lh.intersectSphere(Qg, qC) === null || Lh.origin.distanceToSquared(qC) > (t.far - t.near) ** 2)) && (YC.copy(f).invert(), Lh.copy(t.ray).applyMatrix4(YC), !(o.boundingBox !== null && Lh.intersectsBox(o.boundingBox) === !1) && this._computeIntersections(t, i, Lh)))
    }

    _computeIntersections(t, i, o) {
        let c;
        const f = this.geometry, T = this.material, m = f.index, x = f.attributes.position, h = f.attributes.uv,
            g = f.attributes.uv1, w = f.attributes.normal, v = f.groups, E = f.drawRange;
        if (m !== null) if (Array.isArray(T)) for (let p = 0, C = v.length; p < C; p++) {
            const M = v[p], b = T[M.materialIndex], B = Math.max(M.start, E.start),
                R = Math.min(m.count, Math.min(M.start + M.count, E.start + E.count));
            for (let I = B, L = R; I < L; I += 3) {
                const O = m.getX(I), N = m.getX(I + 1), F = m.getX(I + 2);
                c = Jg(this, b, t, o, h, g, w, O, N, F), c && (c.faceIndex = Math.floor(I / 3), c.face.materialIndex = M.materialIndex, i.push(c))
            }
        } else {
            const p = Math.max(0, E.start), C = Math.min(m.count, E.start + E.count);
            for (let M = p, b = C; M < b; M += 3) {
                const B = m.getX(M), R = m.getX(M + 1), I = m.getX(M + 2);
                c = Jg(this, T, t, o, h, g, w, B, R, I), c && (c.faceIndex = Math.floor(M / 3), i.push(c))
            }
        } else if (x !== void 0) if (Array.isArray(T)) for (let p = 0, C = v.length; p < C; p++) {
            const M = v[p], b = T[M.materialIndex], B = Math.max(M.start, E.start),
                R = Math.min(x.count, Math.min(M.start + M.count, E.start + E.count));
            for (let I = B, L = R; I < L; I += 3) {
                const O = I, N = I + 1, F = I + 2;
                c = Jg(this, b, t, o, h, g, w, O, N, F), c && (c.faceIndex = Math.floor(I / 3), c.face.materialIndex = M.materialIndex, i.push(c))
            }
        } else {
            const p = Math.max(0, E.start), C = Math.min(x.count, E.start + E.count);
            for (let M = p, b = C; M < b; M += 3) {
                const B = M, R = M + 1, I = M + 2;
                c = Jg(this, T, t, o, h, g, w, B, R, I), c && (c.faceIndex = Math.floor(M / 3), i.push(c))
            }
        }
    }
}

function LS(A, t, i, o, c, f, T, m) {
    let x;
    if (t.side === G3 ? x = o.intersectTriangle(T, f, c, !0, m) : x = o.intersectTriangle(c, f, T, t.side === g0, m), x === null) return null;
    qg.copy(m), qg.applyMatrix4(A.matrixWorld);
    const h = i.ray.origin.distanceTo(qg);
    return h < i.near || h > i.far ? null : {distance: h, point: qg.clone(), object: A}
}

function Jg(A, t, i, o, c, f, T, m, x, h) {
    A.getVertexPosition(m, Zd), A.getVertexPosition(x, $d), A.getVertexPosition(h, ef);
    const g = LS(A, t, i, o, Zd, $d, ef, Yg);
    if (g) {
        c && (Wg.fromBufferAttribute(c, m), Kg.fromBufferAttribute(c, x), Xg.fromBufferAttribute(c, h), g.uv = wl.getInterpolation(Yg, Zd, $d, ef, Wg, Kg, Xg, new es)), f && (Wg.fromBufferAttribute(f, m), Kg.fromBufferAttribute(f, x), Xg.fromBufferAttribute(f, h), g.uv1 = wl.getInterpolation(Yg, Zd, $d, ef, Wg, Kg, Xg, new es)), T && (JC.fromBufferAttribute(T, m), ZC.fromBufferAttribute(T, x), $C.fromBufferAttribute(T, h), g.normal = wl.getInterpolation(Yg, Zd, $d, ef, JC, ZC, $C, new ft), g.normal.dot(o.direction) > 0 && g.normal.multiplyScalar(-1));
        const w = {a: m, b: x, c: h, normal: new ft, materialIndex: 0};
        wl.getNormal(Zd, $d, ef, w.normal), g.face = w
    }
    return g
}

class om extends il {
    constructor(t = 1, i = 1, o = 1, c = 1, f = 1, T = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: i,
            depth: o,
            widthSegments: c,
            heightSegments: f,
            depthSegments: T
        };
        const m = this;
        c = Math.floor(c), f = Math.floor(f), T = Math.floor(T);
        const x = [], h = [], g = [], w = [];
        let v = 0, E = 0;
        p("z", "y", "x", -1, -1, o, i, t, T, f, 0), p("z", "y", "x", 1, -1, o, i, -t, T, f, 1), p("x", "z", "y", 1, 1, t, o, i, c, T, 2), p("x", "z", "y", 1, -1, t, o, -i, c, T, 3), p("x", "y", "z", 1, -1, t, i, o, c, f, 4), p("x", "y", "z", -1, -1, t, i, -o, c, f, 5), this.setIndex(x), this.setAttribute("position", new Cs(h, 3)), this.setAttribute("normal", new Cs(g, 3)), this.setAttribute("uv", new Cs(w, 2));

        function p(C, M, b, B, R, I, L, O, N, F, V) {
            const U = I / N, j = L / F, Y = I / 2, fe = L / 2, se = O / 2, pe = N + 1, ue = F + 1;
            let he = 0, Z = 0;
            const H = new ft;
            for (let ae = 0; ae < ue; ae++) {
                const ee = ae * j - fe;
                for (let me = 0; me < pe; me++) {
                    const Re = me * U - Y;
                    H[C] = Re * B, H[M] = ee * R, H[b] = se, h.push(H.x, H.y, H.z), H[C] = 0, H[M] = 0, H[b] = O > 0 ? 1 : -1, g.push(H.x, H.y, H.z), w.push(me / N), w.push(1 - ae / F), he += 1
                }
            }
            for (let ae = 0; ae < F; ae++) for (let ee = 0; ee < N; ee++) {
                const me = v + ee + pe * ae, Re = v + ee + pe * (ae + 1), ke = v + (ee + 1) + pe * (ae + 1),
                    Ve = v + (ee + 1) + pe * ae;
                x.push(me, Re, Ve), x.push(Re, ke, Ve), Z += 6
            }
            m.addGroup(E, Z, V), E += Z, v += he
        }
    }

    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }

    static fromJSON(t) {
        return new om(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
    }
}

class _w extends rs {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new $n, this.projectionMatrix = new $n, this.projectionMatrixInverse = new $n, this.coordinateSystem = Ph
    }

    copy(t, i) {
        return super.copy(t, i), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
    }

    getWorldDirection(t) {
        return super.getWorldDirection(t).negate()
    }

    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }

    updateWorldMatrix(t, i) {
        super.updateWorldMatrix(t, i), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

const wu = new ft, e2 = new es, t2 = new es;

class Bu extends _w {
    constructor(t = 50, i = 1, o = .1, c = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = o, this.far = c, this.focus = 10, this.aspect = i, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    copy(t, i) {
        return super.copy(t, i), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
    }

    setFocalLength(t) {
        const i = .5 * this.getFilmHeight() / t;
        this.fov = um * 2 * Math.atan(i), this.updateProjectionMatrix()
    }

    getFocalLength() {
        const t = Math.tan(rm * .5 * this.fov);
        return .5 * this.getFilmHeight() / t
    }

    getEffectiveFOV() {
        return um * 2 * Math.atan(Math.tan(rm * .5 * this.fov) / this.zoom)
    }

    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }

    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }

    getViewBounds(t, i, o) {
        wu.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(wu.x, wu.y).multiplyScalar(-t / wu.z), wu.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), o.set(wu.x, wu.y).multiplyScalar(-t / wu.z)
    }

    getViewSize(t, i) {
        return this.getViewBounds(t, e2, t2), i.subVectors(t2, e2)
    }

    setViewOffset(t, i, o, c, f, T) {
        this.aspect = t / i, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = i, this.view.offsetX = o, this.view.offsetY = c, this.view.width = f, this.view.height = T, this.updateProjectionMatrix()
    }

    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }

    updateProjectionMatrix() {
        const t = this.near;
        let i = t * Math.tan(rm * .5 * this.fov) / this.zoom, o = 2 * i, c = this.aspect * o, f = -.5 * c;
        const T = this.view;
        if (this.view !== null && this.view.enabled) {
            const x = T.fullWidth, h = T.fullHeight;
            f += T.offsetX * c / x, i -= T.offsetY * o / h, c *= T.width / x, o *= T.height / h
        }
        const m = this.filmOffset;
        m !== 0 && (f += t * m / this.getFilmWidth()), this.projectionMatrix.makePerspective(f, f + c, i, i - o, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }

    toJSON(t) {
        const i = super.toJSON(t);
        return i.object.fov = this.fov, i.object.zoom = this.zoom, i.object.near = this.near, i.object.far = this.far, i.object.focus = this.focus, i.object.aspect = this.aspect, this.view !== null && (i.object.view = Object.assign({}, this.view)), i.object.filmGauge = this.filmGauge, i.object.filmOffset = this.filmOffset, i
    }
}

const ky = new ft, DS = new ft, PS = new Jl;

class Mu {
    constructor(t = new ft(1, 0, 0), i = 0) {
        this.isPlane = !0, this.normal = t, this.constant = i
    }

    set(t, i) {
        return this.normal.copy(t), this.constant = i, this
    }

    setComponents(t, i, o, c) {
        return this.normal.set(t, i, o), this.constant = c, this
    }

    setFromNormalAndCoplanarPoint(t, i) {
        return this.normal.copy(t), this.constant = -i.dot(this.normal), this
    }

    setFromCoplanarPoints(t, i, o) {
        const c = ky.subVectors(o, i).cross(DS.subVectors(t, i)).normalize();
        return this.setFromNormalAndCoplanarPoint(c, t), this
    }

    copy(t) {
        return this.normal.copy(t.normal), this.constant = t.constant, this
    }

    normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this
    }

    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }

    distanceToPoint(t) {
        return this.normal.dot(t) + this.constant
    }

    distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius
    }

    projectPoint(t, i) {
        return i.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
    }

    intersectLine(t, i) {
        const o = t.delta(ky), c = this.normal.dot(o);
        if (c === 0) return this.distanceToPoint(t.start) === 0 ? i.copy(t.start) : null;
        const f = -(t.start.dot(this.normal) + this.constant) / c;
        return f < 0 || f > 1 ? null : i.copy(t.start).addScaledVector(o, f)
    }

    intersectsLine(t) {
        const i = this.distanceToPoint(t.start), o = this.distanceToPoint(t.end);
        return i < 0 && o > 0 || o < 0 && i > 0
    }

    intersectsBox(t) {
        return t.intersectsPlane(this)
    }

    intersectsSphere(t) {
        return t.intersectsPlane(this)
    }

    coplanarPoint(t) {
        return t.copy(this.normal).multiplyScalar(-this.constant)
    }

    applyMatrix4(t, i) {
        const o = i || PS.getNormalMatrix(t), c = this.coplanarPoint(ky).applyMatrix4(t),
            f = this.normal.applyMatrix3(o).normalize();
        return this.constant = -c.dot(f), this
    }

    translate(t) {
        return this.constant -= t.dot(this.normal), this
    }

    equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

const Dh = new cf, Zg = new ft;

class OS {
    constructor(t = new Mu, i = new Mu, o = new Mu, c = new Mu, f = new Mu, T = new Mu) {
        this.planes = [t, i, o, c, f, T]
    }

    set(t, i, o, c, f, T) {
        const m = this.planes;
        return m[0].copy(t), m[1].copy(i), m[2].copy(o), m[3].copy(c), m[4].copy(f), m[5].copy(T), this
    }

    copy(t) {
        const i = this.planes;
        for (let o = 0; o < 6; o++) i[o].copy(t.planes[o]);
        return this
    }

    setFromProjectionMatrix(t, i = Ph) {
        const o = this.planes, c = t.elements, f = c[0], T = c[1], m = c[2], x = c[3], h = c[4], g = c[5], w = c[6],
            v = c[7], E = c[8], p = c[9], C = c[10], M = c[11], b = c[12], B = c[13], R = c[14], I = c[15];
        if (o[0].setComponents(x - f, v - h, M - E, I - b).normalize(), o[1].setComponents(x + f, v + h, M + E, I + b).normalize(), o[2].setComponents(x + T, v + g, M + p, I + B).normalize(), o[3].setComponents(x - T, v - g, M - p, I - B).normalize(), o[4].setComponents(x - m, v - w, M - C, I - R).normalize(), i === Ph) o[5].setComponents(x + m, v + w, M + C, I + R).normalize(); else if (i === p1) o[5].setComponents(m, w, C, R).normalize(); else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + i);
        return this
    }

    intersectsObject(t) {
        if (t.boundingSphere !== void 0) t.boundingSphere === null && t.computeBoundingSphere(), Dh.copy(t.boundingSphere).applyMatrix4(t.matrixWorld); else {
            const i = t.geometry;
            i.boundingSphere === null && i.computeBoundingSphere(), Dh.copy(i.boundingSphere).applyMatrix4(t.matrixWorld)
        }
        return this.intersectsSphere(Dh)
    }

    intersectsSprite(t) {
        return Dh.center.set(0, 0, 0), Dh.radius = .7071067811865476, Dh.applyMatrix4(t.matrixWorld), this.intersectsSphere(Dh)
    }

    intersectsSphere(t) {
        const i = this.planes, o = t.center, c = -t.radius;
        for (let f = 0; f < 6; f++) if (i[f].distanceToPoint(o) < c) return !1;
        return !0
    }

    intersectsBox(t) {
        const i = this.planes;
        for (let o = 0; o < 6; o++) {
            const c = i[o];
            if (Zg.x = c.normal.x > 0 ? t.max.x : t.min.x, Zg.y = c.normal.y > 0 ? t.max.y : t.min.y, Zg.z = c.normal.z > 0 ? t.max.z : t.min.z, c.distanceToPoint(Zg) < 0) return !1
        }
        return !0
    }

    containsPoint(t) {
        const i = this.planes;
        for (let o = 0; o < 6; o++) if (i[o].distanceToPoint(t) < 0) return !1;
        return !0
    }

    clone() {
        return new this.constructor().copy(this)
    }
}

function kS() {
    let A = null, t = !1, i = null, o = null;

    function c(f, T) {
        i(f, T), o = A.requestAnimationFrame(c)
    }

    return {
        start: function () {
            t !== !0 && i !== null && (o = A.requestAnimationFrame(c), t = !0)
        }, stop: function () {
            A.cancelAnimationFrame(o), t = !1
        }, setAnimationLoop: function (f) {
            i = f
        }, setContext: function (f) {
            A = f
        }
    }
}

class B1 extends _w {
    constructor(t = -1, i = 1, o = 1, c = -1, f = .1, T = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = i, this.top = o, this.bottom = c, this.near = f, this.far = T, this.updateProjectionMatrix()
    }

    copy(t, i) {
        return super.copy(t, i), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this
    }

    setViewOffset(t, i, o, c, f, T) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = i, this.view.offsetX = o, this.view.offsetY = c, this.view.width = f, this.view.height = T, this.updateProjectionMatrix()
    }

    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }

    updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom), i = (this.top - this.bottom) / (2 * this.zoom),
            o = (this.right + this.left) / 2, c = (this.top + this.bottom) / 2;
        let f = o - t, T = o + t, m = c + i, x = c - i;
        if (this.view !== null && this.view.enabled) {
            const h = (this.right - this.left) / this.view.fullWidth / this.zoom,
                g = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            f += h * this.view.offsetX, T = f + h * this.view.width, m -= g * this.view.offsetY, x = m - g * this.view.height
        }
        this.projectionMatrix.makeOrthographic(f, T, m, x, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }

    toJSON(t) {
        const i = super.toJSON(t);
        return i.object.zoom = this.zoom, i.object.left = this.left, i.object.right = this.right, i.object.top = this.top, i.object.bottom = this.bottom, i.object.near = this.near, i.object.far = this.far, this.view !== null && (i.object.view = Object.assign({}, this.view)), i
    }
}

class FS extends ya {
    constructor(t, i, o, c, f, T, m, x, h, g) {
        if (g = g !== void 0 ? g : gy, g !== gy && g !== SC) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        o === void 0 && g === gy && (o = W3), o === void 0 && g === SC && (o = K3), super(null, c, f, T, m, x, g, o, h), this.isDepthTexture = !0, this.image = {
            width: t,
            height: i
        }, this.magFilter = m !== void 0 ? m : v0, this.minFilter = x !== void 0 ? x : v0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
    }

    copy(t) {
        return super.copy(t), this.compareFunction = t.compareFunction, this
    }

    toJSON(t) {
        const i = super.toJSON(t);
        return this.compareFunction !== null && (i.compareFunction = this.compareFunction), i
    }
}

const NS = new FS(1, 1);
NS.compareFunction = q3;

class hm extends rs {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
}

class US extends Bu {
    constructor(t = []) {
        super(), this.isArrayCamera = !0, this.cameras = t
    }
}

var n2 = new ft, i2 = new ft;

function zS(A, t, i) {
    n2.setFromMatrixPosition(t.matrixWorld), i2.setFromMatrixPosition(i.matrixWorld);
    var o = n2.distanceTo(i2), c = t.projectionMatrix.elements, f = i.projectionMatrix.elements,
        T = c[14] / (c[10] - 1), m = c[14] / (c[10] + 1), x = (c[9] + 1) / c[5], h = (c[9] - 1) / c[5],
        g = (c[8] - 1) / c[0], w = (f[8] + 1) / f[0], v = T * g, E = T * w, p = o / (-g + w), C = p * -g;
    t.matrixWorld.decompose(A.position, A.quaternion, A.scale), A.translateX(C), A.translateZ(p), A.matrixWorld.compose(A.position, A.quaternion, A.scale), A.matrixWorldInverse.copy(A.matrixWorld).invert();
    var M = T + p, b = m + p, B = v - C, R = E + (o - C), I = x * m / b * M, L = h * m / b * M;
    A.projectionMatrix.makePerspective(B, R, I, L, M, b)
}

function GS(A) {
    var t, i, o = this, c = null, f = null, T = null, m = [], x = new $n, h = new $n, g = 1, w = "local-floor";
    typeof window < "u" && "VRFrameData" in window && (f = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", I, !1));
    var v = new $n, E = new Ho, p = new ft, C = new Bu;
    C.viewport = new Zs, C.layers.enable(1);
    var M = new Bu;
    M.viewport = new Zs, M.layers.enable(2);
    var b = new US([C, M]);
    b.layers.enable(1), b.layers.enable(2);
    var B = new es, R;

    function I() {
        var j = o.isPresenting = c !== null && c.isPresenting === !0;
        if (j) {
            var Y = c.getEyeParameters("left");
            t = 2 * Y.renderWidth * g, i = Y.renderHeight * g, R = A.getPixelRatio(), A.getSize(B), A.setDrawingBufferSize(t, i, 1), C.viewport.set(0, 0, t / 2, i), M.viewport.set(t / 2, 0, t / 2, i), U.start(), o.dispatchEvent({type: "sessionstart"})
        } else o.enabled && A.setDrawingBufferSize(B.width, B.height, R), U.stop(), o.dispatchEvent({type: "sessionend"})
    }

    var L = [], O = [];

    function N(j) {
        for (var Y = navigator.getGamepads && navigator.getGamepads(), fe = 0, se = Y.length; fe < se; fe++) {
            var pe = Y[fe];
            if (pe && (pe.id === "Daydream Controller" || pe.id === "Gear VR Controller" || pe.id === "Oculus Go Controller" || pe.id === "OpenVR Gamepad" || pe.id.startsWith("Oculus Touch") || pe.id.startsWith("HTC Vive Focus") || pe.id.startsWith("Spatial Controller"))) {
                var ue = pe.hand;
                if (j === 0 && (ue === "" || ue === "right") || j === 1 && ue === "left") return pe
            }
        }
    }

    function F() {
        for (var j = 0; j < m.length; j++) {
            var Y = m[j], fe = N(j);
            if (fe !== void 0 && fe.pose !== void 0) {
                if (fe.pose === null) return;
                var se = fe.pose;
                se.hasPosition === !1 && Y.position.set(.2, -.6, -.05), se.position !== null && Y.position.fromArray(se.position), se.orientation !== null && Y.quaternion.fromArray(se.orientation), Y.matrix.compose(Y.position, Y.quaternion, Y.scale), Y.matrix.premultiply(x), Y.matrix.decompose(Y.position, Y.quaternion, Y.scale), Y.matrixWorldNeedsUpdate = !0, Y.visible = !0;
                var pe = fe.id === "Daydream Controller" ? 0 : 1;
                L[j] === void 0 && (L[j] = !1), L[j] !== fe.buttons[pe].pressed && (L[j] = fe.buttons[pe].pressed, L[j] === !0 ? Y.dispatchEvent({type: "selectstart"}) : (Y.dispatchEvent({type: "selectend"}), Y.dispatchEvent({type: "select"}))), pe = 2, O[j] === void 0 && (O[j] = !1), fe.buttons[pe] !== void 0 && O[j] !== fe.buttons[pe].pressed && (O[j] = fe.buttons[pe].pressed, O[j] === !0 ? Y.dispatchEvent({type: "squeezestart"}) : (Y.dispatchEvent({type: "squeezeend"}), Y.dispatchEvent({type: "squeeze"})))
            } else Y.visible = !1
        }
    }

    function V(j, Y) {
        Y !== null && Y.length === 4 && j.set(Y[0] * t, Y[1] * i, Y[2] * t, Y[3] * i)
    }

    this.enabled = !1, this.getController = function (j) {
        var Y = m[j];
        return Y === void 0 && (Y = new hm, Y.matrixAutoUpdate = !1, Y.visible = !1, m[j] = Y), Y
    }, this.getDevice = function () {
        return c
    }, this.setDevice = function (j) {
        j !== void 0 && (c = j), U.setContext(j)
    }, this.setFramebufferScaleFactor = function (j) {
        g = j
    }, this.setReferenceSpaceType = function (j) {
        w = j
    }, this.setPoseTarget = function (j) {
        j !== void 0 && (T = j)
    }, this.cameraAutoUpdate = !0, this.updateCamera = function (j) {
        var Y = w === "local-floor" ? 1.6 : 0;
        if (c.depthNear = j.near, c.depthFar = j.far, c.getFrameData(f), w === "local-floor") {
            var fe = c.stageParameters;
            fe ? x.fromArray(fe.sittingToStandingTransform) : x.makeTranslation(0, Y, 0)
        }
        var se = f.pose, pe = T !== null ? T : j;
        pe.matrix.copy(x), pe.matrix.decompose(pe.position, pe.quaternion, pe.scale), se.orientation !== null && (E.fromArray(se.orientation), pe.quaternion.multiply(E)), se.position !== null && (E.setFromRotationMatrix(x), p.fromArray(se.position), p.applyQuaternion(E), pe.position.add(p)), pe.updateMatrixWorld();
        for (var ue = pe.children, he = 0, Z = ue.length; he < Z; he++) ue[he].updateMatrixWorld(!0);
        C.near = j.near, M.near = j.near, C.far = j.far, M.far = j.far, C.matrixWorldInverse.fromArray(f.leftViewMatrix), M.matrixWorldInverse.fromArray(f.rightViewMatrix), h.copy(x).invert(), w === "local-floor" && (C.matrixWorldInverse.multiply(h), M.matrixWorldInverse.multiply(h));
        var H = pe.parent;
        H !== null && (v.copy(H.matrixWorld).invert(), C.matrixWorldInverse.multiply(v), M.matrixWorldInverse.multiply(v)), C.matrixWorld.copy(C.matrixWorldInverse).invert(), M.matrixWorld.copy(M.matrixWorldInverse).invert(), C.projectionMatrix.fromArray(f.leftProjectionMatrix), M.projectionMatrix.fromArray(f.rightProjectionMatrix), zS(b, C, M);
        var ae = c.getLayers();
        if (ae.length) {
            var ee = ae[0];
            V(C.viewport, ee.leftBounds), V(M.viewport, ee.rightBounds)
        }
        return F(), b
    }, this.getCamera = function () {
        return b
    }, this.getFoveation = function () {
        return 1
    }, this.setFoveation = function (j) {
        j !== 1 && console.warn("THREE.WebVRManager: setFoveation() not used in WebVR.")
    }, this.getEnvironmentBlendMode = function () {
        if (o.isPresenting) return "opaque"
    }, this.getStandingMatrix = function () {
        return x
    }, this.isPresenting = !1;
    var U = new kS;
    this.setAnimationLoop = function (j) {
        U.setAnimationLoop(j), this.isPresenting && U.start()
    }, this.submitFrame = function () {
        this.isPresenting && c.submitFrame()
    }, this.dispose = function () {
        typeof window < "u" && window.removeEventListener("vrdisplaypresentchange", I)
    }, this.setFrameOfReferenceType = function () {
        console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
    }
}

Object.assign(GS.prototype, {
    addEventListener: Gc.prototype.addEventListener,
    hasEventListener: Gc.prototype.hasEventListener,
    removeEventListener: Gc.prototype.removeEventListener,
    dispatchEvent: Gc.prototype.dispatchEvent
});

class VS extends ES {
    constructor(t, i, o, c = {}) {
        super(t, i, c), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = o
    }

    copy(t) {
        return super.copy(t), this.numViews = t.numViews, this
    }
}

VS.prototype.isWebGLMultiviewRenderTarget = !0;

class HS extends rs {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new ao, this.environmentIntensity = 1, this.environmentRotation = new ao, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
    }

    copy(t, i) {
        return super.copy(t, i), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
    }

    toJSON(t) {
        const i = super.toJSON(t);
        return this.fog !== null && (i.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (i.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (i.object.backgroundIntensity = this.backgroundIntensity), i.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (i.object.environmentIntensity = this.environmentIntensity), i.object.environmentRotation = this.environmentRotation.toArray(), i
    }
}

const r2 = new ft, s2 = new Zs, o2 = new Zs, QS = new ft, a2 = new $n, $g = new ft, Fy = new cf, l2 = new $n,
    Ny = new R1;

class Mw extends Tu {
    constructor(t, i) {
        super(t, i), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = _C, this.bindMatrix = new $n, this.bindMatrixInverse = new $n, this.boundingBox = null, this.boundingSphere = null
    }

    computeBoundingBox() {
        const t = this.geometry;
        this.boundingBox === null && (this.boundingBox = new lf), this.boundingBox.makeEmpty();
        const i = t.getAttribute("position");
        for (let o = 0; o < i.count; o++) this.getVertexPosition(o, $g), this.boundingBox.expandByPoint($g)
    }

    computeBoundingSphere() {
        const t = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new cf), this.boundingSphere.makeEmpty();
        const i = t.getAttribute("position");
        for (let o = 0; o < i.count; o++) this.getVertexPosition(o, $g), this.boundingSphere.expandByPoint($g)
    }

    copy(t, i) {
        return super.copy(t, i), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this
    }

    raycast(t, i) {
        const o = this.material, c = this.matrixWorld;
        o !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Fy.copy(this.boundingSphere), Fy.applyMatrix4(c), t.ray.intersectsSphere(Fy) !== !1 && (l2.copy(c).invert(), Ny.copy(t.ray).applyMatrix4(l2), !(this.boundingBox !== null && Ny.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(t, i, Ny)))
    }

    getVertexPosition(t, i) {
        return super.getVertexPosition(t, i), this.applyBoneTransform(t, i), i
    }

    bind(t, i) {
        this.skeleton = t, i === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), i = this.matrixWorld), this.bindMatrix.copy(i), this.bindMatrixInverse.copy(i).invert()
    }

    pose() {
        this.skeleton.pose()
    }

    normalizeSkinWeights() {
        const t = new Zs, i = this.geometry.attributes.skinWeight;
        for (let o = 0, c = i.count; o < c; o++) {
            t.fromBufferAttribute(i, o);
            const f = 1 / t.manhattanLength();
            f !== 1 / 0 ? t.multiplyScalar(f) : t.set(1, 0, 0, 0), i.setXYZW(o, t.x, t.y, t.z, t.w)
        }
    }

    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.bindMode === _C ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === H3 ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }

    applyBoneTransform(t, i) {
        const o = this.skeleton, c = this.geometry;
        s2.fromBufferAttribute(c.attributes.skinIndex, t), o2.fromBufferAttribute(c.attributes.skinWeight, t), r2.copy(i).applyMatrix4(this.bindMatrix), i.set(0, 0, 0);
        for (let f = 0; f < 4; f++) {
            const T = o2.getComponent(f);
            if (T !== 0) {
                const m = s2.getComponent(f);
                a2.multiplyMatrices(o.bones[m].matrixWorld, o.boneInverses[m]), i.addScaledVector(QS.copy(r2).applyMatrix4(a2), T)
            }
        }
        return i.applyMatrix4(this.bindMatrixInverse)
    }
}

class x0 extends rs {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}

class Sw extends ya {
    constructor(t = null, i = 1, o = 1, c, f, T, m, x, h = v0, g = v0, w, v) {
        super(null, T, m, x, h, g, c, f, w, v), this.isDataTexture = !0, this.image = {
            data: t,
            width: i,
            height: o
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}

const c2 = new $n, jS = new $n;

class B0 {
    constructor(t = [], i = []) {
        this.uuid = Pu(), this.bones = t.slice(0), this.boneInverses = i, this.boneMatrices = null, this.boneTexture = null, this.init()
    }

    init() {
        const t = this.bones, i = this.boneInverses;
        if (this.boneMatrices = new Float32Array(t.length * 16), i.length === 0) this.calculateInverses(); else if (t.length !== i.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let o = 0, c = this.bones.length; o < c; o++) this.boneInverses.push(new $n)
        }
    }

    calculateInverses() {
        this.boneInverses.length = 0;
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const o = new $n;
            this.bones[t] && o.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(o)
        }
    }

    pose() {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const o = this.bones[t];
            o && o.matrixWorld.copy(this.boneInverses[t]).invert()
        }
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const o = this.bones[t];
            o && (o.parent && o.parent.isBone ? (o.matrix.copy(o.parent.matrixWorld).invert(), o.matrix.multiply(o.matrixWorld)) : o.matrix.copy(o.matrixWorld), o.matrix.decompose(o.position, o.quaternion, o.scale))
        }
    }

    update() {
        const t = this.bones, i = this.boneInverses, o = this.boneMatrices, c = this.boneTexture;
        for (let f = 0, T = t.length; f < T; f++) {
            const m = t[f] ? t[f].matrixWorld : jS;
            c2.multiplyMatrices(m, i[f]), c2.toArray(o, f * 16)
        }
        c !== null && (c.needsUpdate = !0)
    }

    clone() {
        return new B0(this.bones, this.boneInverses)
    }

    computeBoneTexture() {
        let t = Math.sqrt(this.bones.length * 4);
        t = Math.ceil(t / 4) * 4, t = Math.max(t, 4);
        const i = new Float32Array(t * t * 4);
        i.set(this.boneMatrices);
        const o = new Sw(i, t, t, vw, gw);
        return o.needsUpdate = !0, this.boneMatrices = i, this.boneTexture = o, this
    }

    getBoneByName(t) {
        for (let i = 0, o = this.bones.length; i < o; i++) {
            const c = this.bones[i];
            if (c.name === t) return c
        }
    }

    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }

    fromJSON(t, i) {
        this.uuid = t.uuid;
        for (let o = 0, c = t.bones.length; o < c; o++) {
            const f = t.bones[o];
            let T = i[f];
            T === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", f), T = new x0), this.bones.push(T), this.boneInverses.push(new $n().fromArray(t.boneInverses[o]))
        }
        return this.init(), this
    }

    toJSON() {
        const t = {
            metadata: {version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON"},
            bones: [],
            boneInverses: []
        };
        t.uuid = this.uuid;
        const i = this.bones, o = this.boneInverses;
        for (let c = 0, f = i.length; c < f; c++) {
            const T = i[c];
            t.bones.push(T.uuid);
            const m = o[c];
            t.boneInverses.push(m.toArray())
        }
        return t
    }
}

class dm extends R0 {
    constructor(t) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new xs(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
    }
}

const C0 = new ft, w0 = new ft, u2 = new $n, $p = new R1, e0 = new cf, Uy = new ft, h2 = new ft;

class L0 extends rs {
    constructor(t = new il, i = new dm) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = i, this.updateMorphTargets()
    }

    copy(t, i) {
        return super.copy(t, i), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
    }

    computeLineDistances() {
        const t = this.geometry;
        if (t.index === null) {
            const i = t.attributes.position, o = [0];
            for (let c = 1, f = i.count; c < f; c++) C0.fromBufferAttribute(i, c - 1), w0.fromBufferAttribute(i, c), o[c] = o[c - 1], o[c] += C0.distanceTo(w0);
            t.setAttribute("lineDistance", new Cs(o, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }

    raycast(t, i) {
        const o = this.geometry, c = this.matrixWorld, f = t.params.Line.threshold, T = o.drawRange;
        if (o.boundingSphere === null && o.computeBoundingSphere(), e0.copy(o.boundingSphere), e0.applyMatrix4(c), e0.radius += f, t.ray.intersectsSphere(e0) === !1) return;
        u2.copy(c).invert(), $p.copy(t.ray).applyMatrix4(u2);
        const m = f / ((this.scale.x + this.scale.y + this.scale.z) / 3), x = m * m, h = this.isLineSegments ? 2 : 1,
            g = o.index, v = o.attributes.position;
        if (g !== null) {
            const E = Math.max(0, T.start), p = Math.min(g.count, T.start + T.count);
            for (let C = E, M = p - 1; C < M; C += h) {
                const b = g.getX(C), B = g.getX(C + 1), R = t0(this, t, $p, x, b, B);
                R && i.push(R)
            }
            if (this.isLineLoop) {
                const C = g.getX(p - 1), M = g.getX(E), b = t0(this, t, $p, x, C, M);
                b && i.push(b)
            }
        } else {
            const E = Math.max(0, T.start), p = Math.min(v.count, T.start + T.count);
            for (let C = E, M = p - 1; C < M; C += h) {
                const b = t0(this, t, $p, x, C, C + 1);
                b && i.push(b)
            }
            if (this.isLineLoop) {
                const C = t0(this, t, $p, x, p - 1, E);
                C && i.push(C)
            }
        }
    }

    updateMorphTargets() {
        const i = this.geometry.morphAttributes, o = Object.keys(i);
        if (o.length > 0) {
            const c = i[o[0]];
            if (c !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let f = 0, T = c.length; f < T; f++) {
                    const m = c[f].name || String(f);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[m] = f
                }
            }
        }
    }
}

function t0(A, t, i, o, c, f) {
    const T = A.geometry.attributes.position;
    if (C0.fromBufferAttribute(T, c), w0.fromBufferAttribute(T, f), i.distanceSqToSegment(C0, w0, Uy, h2) > o) return;
    Uy.applyMatrix4(A.matrixWorld);
    const x = t.ray.origin.distanceTo(Uy);
    if (!(x < t.near || x > t.far)) return {
        distance: x,
        point: h2.clone().applyMatrix4(A.matrixWorld),
        index: c,
        face: null,
        faceIndex: null,
        object: A
    }
}

const d2 = new ft, f2 = new ft;

class WS extends L0 {
    constructor(t, i) {
        super(t, i), this.isLineSegments = !0, this.type = "LineSegments"
    }

    computeLineDistances() {
        const t = this.geometry;
        if (t.index === null) {
            const i = t.attributes.position, o = [];
            for (let c = 0, f = i.count; c < f; c += 2) d2.fromBufferAttribute(i, c), f2.fromBufferAttribute(i, c + 1), o[c] = c === 0 ? 0 : o[c - 1], o[c + 1] = o[c] + d2.distanceTo(f2);
            t.setAttribute("lineDistance", new Cs(o, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}

class KS {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }

    getPointAt(t, i) {
        const o = this.getUtoTmapping(t);
        return this.getPoint(o, i)
    }

    getPoints(t = 5) {
        const i = [];
        for (let o = 0; o <= t; o++) i.push(this.getPoint(o / t));
        return i
    }

    getSpacedPoints(t = 5) {
        const i = [];
        for (let o = 0; o <= t; o++) i.push(this.getPointAt(o / t));
        return i
    }

    getLength() {
        const t = this.getLengths();
        return t[t.length - 1]
    }

    getLengths(t = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const i = [];
        let o, c = this.getPoint(0), f = 0;
        i.push(0);
        for (let T = 1; T <= t; T++) o = this.getPoint(T / t), f += o.distanceTo(c), i.push(f), c = o;
        return this.cacheArcLengths = i, i
    }

    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }

    getUtoTmapping(t, i) {
        const o = this.getLengths();
        let c = 0;
        const f = o.length;
        let T;
        i ? T = i : T = t * o[f - 1];
        let m = 0, x = f - 1, h;
        for (; m <= x;) if (c = Math.floor(m + (x - m) / 2), h = o[c] - T, h < 0) m = c + 1; else if (h > 0) x = c - 1; else {
            x = c;
            break
        }
        if (c = x, o[c] === T) return c / (f - 1);
        const g = o[c], v = o[c + 1] - g, E = (T - g) / v;
        return (c + E) / (f - 1)
    }

    getTangent(t, i) {
        let c = t - 1e-4, f = t + 1e-4;
        c < 0 && (c = 0), f > 1 && (f = 1);
        const T = this.getPoint(c), m = this.getPoint(f), x = i || (T.isVector2 ? new es : new ft);
        return x.copy(m).sub(T).normalize(), x
    }

    getTangentAt(t, i) {
        const o = this.getUtoTmapping(t);
        return this.getTangent(o, i)
    }

    computeFrenetFrames(t, i) {
        const o = new ft, c = [], f = [], T = [], m = new ft, x = new $n;
        for (let E = 0; E <= t; E++) {
            const p = E / t;
            c[E] = this.getTangentAt(p, new ft)
        }
        f[0] = new ft, T[0] = new ft;
        let h = Number.MAX_VALUE;
        const g = Math.abs(c[0].x), w = Math.abs(c[0].y), v = Math.abs(c[0].z);
        g <= h && (h = g, o.set(1, 0, 0)), w <= h && (h = w, o.set(0, 1, 0)), v <= h && o.set(0, 0, 1), m.crossVectors(c[0], o).normalize(), f[0].crossVectors(c[0], m), T[0].crossVectors(c[0], f[0]);
        for (let E = 1; E <= t; E++) {
            if (f[E] = f[E - 1].clone(), T[E] = T[E - 1].clone(), m.crossVectors(c[E - 1], c[E]), m.length() > Number.EPSILON) {
                m.normalize();
                const p = Math.acos(Ro(c[E - 1].dot(c[E]), -1, 1));
                f[E].applyMatrix4(x.makeRotationAxis(m, p))
            }
            T[E].crossVectors(c[E], f[E])
        }
        if (i === !0) {
            let E = Math.acos(Ro(f[0].dot(f[t]), -1, 1));
            E /= t, c[0].dot(m.crossVectors(f[0], f[t])) > 0 && (E = -E);
            for (let p = 1; p <= t; p++) f[p].applyMatrix4(x.makeRotationAxis(c[p], E * p)), T[p].crossVectors(c[p], f[p])
        }
        return {tangents: c, normals: f, binormals: T}
    }

    clone() {
        return new this.constructor().copy(this)
    }

    copy(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
    }

    toJSON() {
        const t = {metadata: {version: 4.6, type: "Curve", generator: "Curve.toJSON"}};
        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
    }

    fromJSON(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
    }
}

const XS = {
    triangulate: function (A, t, i = 2) {
        const o = t && t.length, c = o ? t[0] * i : A.length;
        let f = Tw(A, 0, c, i, !0);
        const T = [];
        if (!f || f.next === f.prev) return T;
        let m, x, h, g, w, v, E;
        if (o && (f = $S(A, t, f, i)), A.length > 80 * i) {
            m = h = A[0], x = g = A[1];
            for (let p = i; p < c; p += i) w = A[p], v = A[p + 1], w < m && (m = w), v < x && (x = v), w > h && (h = w), v > g && (g = v);
            E = Math.max(h - m, g - x), E = E !== 0 ? 32767 / E : 0
        }
        return fm(f, T, i, m, x, E, 0), T
    }
};

function Tw(A, t, i, o, c) {
    let f, T;
    if (c === uT(A, t, i, o) > 0) for (f = t; f < i; f += o) T = p2(f, A[f], A[f + 1], T); else for (f = i - o; f >= t; f -= o) T = p2(f, A[f], A[f + 1], T);
    return T && D0(T, T.next) && (mm(T), T = T.next), T
}

function kh(A, t) {
    if (!A) return A;
    t || (t = A);
    let i = A, o;
    do if (o = !1, !i.steiner && (D0(i, i.next) || fs(i.prev, i, i.next) === 0)) {
        if (mm(i), i = t = i.prev, i === i.next) break;
        o = !0
    } else i = i.next; while (o || i !== t);
    return t
}

function fm(A, t, i, o, c, f, T) {
    if (!A) return;
    !T && f && rT(A, o, c, f);
    let m = A, x, h;
    for (; A.prev !== A.next;) {
        if (x = A.prev, h = A.next, f ? qS(A, o, c, f) : YS(A)) {
            t.push(x.i / i | 0), t.push(A.i / i | 0), t.push(h.i / i | 0), mm(A), A = h.next, m = h.next;
            continue
        }
        if (A = h, A === m) {
            T ? T === 1 ? (A = JS(kh(A), t, i), fm(A, t, i, o, c, f, 2)) : T === 2 && ZS(A, t, i, o, c, f) : fm(kh(A), t, i, o, c, f, 1);
            break
        }
    }
}

function YS(A) {
    const t = A.prev, i = A, o = A.next;
    if (fs(t, i, o) >= 0) return !1;
    const c = t.x, f = i.x, T = o.x, m = t.y, x = i.y, h = o.y, g = c < f ? c < T ? c : T : f < T ? f : T,
        w = m < x ? m < h ? m : h : x < h ? x : h, v = c > f ? c > T ? c : T : f > T ? f : T,
        E = m > x ? m > h ? m : h : x > h ? x : h;
    let p = o.next;
    for (; p !== t;) {
        if (p.x >= g && p.x <= v && p.y >= w && p.y <= E && sf(c, m, f, x, T, h, p.x, p.y) && fs(p.prev, p, p.next) >= 0) return !1;
        p = p.next
    }
    return !0
}

function qS(A, t, i, o) {
    const c = A.prev, f = A, T = A.next;
    if (fs(c, f, T) >= 0) return !1;
    const m = c.x, x = f.x, h = T.x, g = c.y, w = f.y, v = T.y, E = m < x ? m < h ? m : h : x < h ? x : h,
        p = g < w ? g < v ? g : v : w < v ? w : v, C = m > x ? m > h ? m : h : x > h ? x : h,
        M = g > w ? g > v ? g : v : w > v ? w : v, b = A1(E, p, t, i, o), B = A1(C, M, t, i, o);
    let R = A.prevZ, I = A.nextZ;
    for (; R && R.z >= b && I && I.z <= B;) {
        if (R.x >= E && R.x <= C && R.y >= p && R.y <= M && R !== c && R !== T && sf(m, g, x, w, h, v, R.x, R.y) && fs(R.prev, R, R.next) >= 0 || (R = R.prevZ, I.x >= E && I.x <= C && I.y >= p && I.y <= M && I !== c && I !== T && sf(m, g, x, w, h, v, I.x, I.y) && fs(I.prev, I, I.next) >= 0)) return !1;
        I = I.nextZ
    }
    for (; R && R.z >= b;) {
        if (R.x >= E && R.x <= C && R.y >= p && R.y <= M && R !== c && R !== T && sf(m, g, x, w, h, v, R.x, R.y) && fs(R.prev, R, R.next) >= 0) return !1;
        R = R.prevZ
    }
    for (; I && I.z <= B;) {
        if (I.x >= E && I.x <= C && I.y >= p && I.y <= M && I !== c && I !== T && sf(m, g, x, w, h, v, I.x, I.y) && fs(I.prev, I, I.next) >= 0) return !1;
        I = I.nextZ
    }
    return !0
}

function JS(A, t, i) {
    let o = A;
    do {
        const c = o.prev, f = o.next.next;
        !D0(c, f) && Iw(c, o, o.next, f) && pm(c, f) && pm(f, c) && (t.push(c.i / i | 0), t.push(o.i / i | 0), t.push(f.i / i | 0), mm(o), mm(o.next), o = A = f), o = o.next
    } while (o !== A);
    return kh(o)
}

function ZS(A, t, i, o, c, f) {
    let T = A;
    do {
        let m = T.next.next;
        for (; m !== T.prev;) {
            if (T.i !== m.i && aT(T, m)) {
                let x = Rw(T, m);
                T = kh(T, T.next), x = kh(x, x.next), fm(T, t, i, o, c, f, 0), fm(x, t, i, o, c, f, 0);
                return
            }
            m = m.next
        }
        T = T.next
    } while (T !== A)
}

function $S(A, t, i, o) {
    const c = [];
    let f, T, m, x, h;
    for (f = 0, T = t.length; f < T; f++) m = t[f] * o, x = f < T - 1 ? t[f + 1] * o : A.length, h = Tw(A, m, x, o, !1), h === h.next && (h.steiner = !0), c.push(oT(h));
    for (c.sort(eT), f = 0; f < c.length; f++) i = tT(c[f], i);
    return i
}

function eT(A, t) {
    return A.x - t.x
}

function tT(A, t) {
    const i = nT(A, t);
    if (!i) return t;
    const o = Rw(i, A);
    return kh(o, o.next), kh(i, i.next)
}

function nT(A, t) {
    let i = t, o = -1 / 0, c;
    const f = A.x, T = A.y;
    do {
        if (T <= i.y && T >= i.next.y && i.next.y !== i.y) {
            const v = i.x + (T - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
            if (v <= f && v > o && (o = v, c = i.x < i.next.x ? i : i.next, v === f)) return c
        }
        i = i.next
    } while (i !== t);
    if (!c) return null;
    const m = c, x = c.x, h = c.y;
    let g = 1 / 0, w;
    i = c;
    do f >= i.x && i.x >= x && f !== i.x && sf(T < h ? f : o, T, x, h, T < h ? o : f, T, i.x, i.y) && (w = Math.abs(T - i.y) / (f - i.x), pm(i, A) && (w < g || w === g && (i.x > c.x || i.x === c.x && iT(c, i))) && (c = i, g = w)), i = i.next; while (i !== m);
    return c
}

function iT(A, t) {
    return fs(A.prev, A, t.prev) < 0 && fs(t.next, A, A.next) < 0
}

function rT(A, t, i, o) {
    let c = A;
    do c.z === 0 && (c.z = A1(c.x, c.y, t, i, o)), c.prevZ = c.prev, c.nextZ = c.next, c = c.next; while (c !== A);
    c.prevZ.nextZ = null, c.prevZ = null, sT(c)
}

function sT(A) {
    let t, i, o, c, f, T, m, x, h = 1;
    do {
        for (i = A, A = null, f = null, T = 0; i;) {
            for (T++, o = i, m = 0, t = 0; t < h && (m++, o = o.nextZ, !!o); t++) ;
            for (x = h; m > 0 || x > 0 && o;) m !== 0 && (x === 0 || !o || i.z <= o.z) ? (c = i, i = i.nextZ, m--) : (c = o, o = o.nextZ, x--), f ? f.nextZ = c : A = c, c.prevZ = f, f = c;
            i = o
        }
        f.nextZ = null, h *= 2
    } while (T > 1);
    return A
}

function A1(A, t, i, o, c) {
    return A = (A - i) * c | 0, t = (t - o) * c | 0, A = (A | A << 8) & 16711935, A = (A | A << 4) & 252645135, A = (A | A << 2) & 858993459, A = (A | A << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, A | t << 1
}

function oT(A) {
    let t = A, i = A;
    do (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next; while (t !== A);
    return i
}

function sf(A, t, i, o, c, f, T, m) {
    return (c - T) * (t - m) >= (A - T) * (f - m) && (A - T) * (o - m) >= (i - T) * (t - m) && (i - T) * (f - m) >= (c - T) * (o - m)
}

function aT(A, t) {
    return A.next.i !== t.i && A.prev.i !== t.i && !lT(A, t) && (pm(A, t) && pm(t, A) && cT(A, t) && (fs(A.prev, A, t.prev) || fs(A, t.prev, t)) || D0(A, t) && fs(A.prev, A, A.next) > 0 && fs(t.prev, t, t.next) > 0)
}

function fs(A, t, i) {
    return (t.y - A.y) * (i.x - t.x) - (t.x - A.x) * (i.y - t.y)
}

function D0(A, t) {
    return A.x === t.x && A.y === t.y
}

function Iw(A, t, i, o) {
    const c = i0(fs(A, t, i)), f = i0(fs(A, t, o)), T = i0(fs(i, o, A)), m = i0(fs(i, o, t));
    return !!(c !== f && T !== m || c === 0 && n0(A, i, t) || f === 0 && n0(A, o, t) || T === 0 && n0(i, A, o) || m === 0 && n0(i, t, o))
}

function n0(A, t, i) {
    return t.x <= Math.max(A.x, i.x) && t.x >= Math.min(A.x, i.x) && t.y <= Math.max(A.y, i.y) && t.y >= Math.min(A.y, i.y)
}

function i0(A) {
    return A > 0 ? 1 : A < 0 ? -1 : 0
}

function lT(A, t) {
    let i = A;
    do {
        if (i.i !== A.i && i.next.i !== A.i && i.i !== t.i && i.next.i !== t.i && Iw(i, i.next, A, t)) return !0;
        i = i.next
    } while (i !== A);
    return !1
}

function pm(A, t) {
    return fs(A.prev, A, A.next) < 0 ? fs(A, t, A.next) >= 0 && fs(A, A.prev, t) >= 0 : fs(A, t, A.prev) < 0 || fs(A, A.next, t) < 0
}

function cT(A, t) {
    let i = A, o = !1;
    const c = (A.x + t.x) / 2, f = (A.y + t.y) / 2;
    do i.y > f != i.next.y > f && i.next.y !== i.y && c < (i.next.x - i.x) * (f - i.y) / (i.next.y - i.y) + i.x && (o = !o), i = i.next; while (i !== A);
    return o
}

function Rw(A, t) {
    const i = new g1(A.i, A.x, A.y), o = new g1(t.i, t.x, t.y), c = A.next, f = t.prev;
    return A.next = t, t.prev = A, i.next = c, c.prev = i, o.next = i, i.prev = o, f.next = o, o.prev = f, o
}

function p2(A, t, i, o) {
    const c = new g1(A, t, i);
    return o ? (c.next = o.next, c.prev = o, o.next.prev = c, o.next = c) : (c.prev = c, c.next = c), c
}

function mm(A) {
    A.next.prev = A.prev, A.prev.next = A.next, A.prevZ && (A.prevZ.nextZ = A.nextZ), A.nextZ && (A.nextZ.prevZ = A.prevZ)
}

function g1(A, t, i) {
    this.i = A, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

function uT(A, t, i, o) {
    let c = 0;
    for (let f = t, T = i - o; f < i; f += o) c += (A[T] - A[f]) * (A[f + 1] + A[T + 1]), T = f;
    return c
}

class L1 {
    static area(t) {
        const i = t.length;
        let o = 0;
        for (let c = i - 1, f = 0; f < i; c = f++) o += t[c].x * t[f].y - t[f].x * t[c].y;
        return o * .5
    }

    static isClockWise(t) {
        return L1.area(t) < 0
    }

    static triangulateShape(t, i) {
        const o = [], c = [], f = [];
        m2(t), A2(o, t);
        let T = t.length;
        i.forEach(m2);
        for (let x = 0; x < i.length; x++) c.push(T), T += i[x].length, A2(o, i[x]);
        const m = XS.triangulate(o, c);
        for (let x = 0; x < m.length; x += 3) f.push(m.slice(x, x + 3));
        return f
    }
}

function m2(A) {
    const t = A.length;
    t > 2 && A[t - 1].equals(A[0]) && A.pop()
}

function A2(A, t) {
    for (let i = 0; i < t.length; i++) A.push(t[i].x), A.push(t[i].y)
}

class b0 extends il {
    constructor(t = 1, i = 32, o = 16, c = 0, f = Math.PI * 2, T = 0, m = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: i,
            heightSegments: o,
            phiStart: c,
            phiLength: f,
            thetaStart: T,
            thetaLength: m
        }, i = Math.max(3, Math.floor(i)), o = Math.max(2, Math.floor(o));
        const x = Math.min(T + m, Math.PI);
        let h = 0;
        const g = [], w = new ft, v = new ft, E = [], p = [], C = [], M = [];
        for (let b = 0; b <= o; b++) {
            const B = [], R = b / o;
            let I = 0;
            b === 0 && T === 0 ? I = .5 / i : b === o && x === Math.PI && (I = -.5 / i);
            for (let L = 0; L <= i; L++) {
                const O = L / i;
                w.x = -t * Math.cos(c + O * f) * Math.sin(T + R * m), w.y = t * Math.cos(T + R * m), w.z = t * Math.sin(c + O * f) * Math.sin(T + R * m), p.push(w.x, w.y, w.z), v.copy(w).normalize(), C.push(v.x, v.y, v.z), M.push(O + I, 1 - R), B.push(h++)
            }
            g.push(B)
        }
        for (let b = 0; b < o; b++) for (let B = 0; B < i; B++) {
            const R = g[b][B + 1], I = g[b][B], L = g[b + 1][B], O = g[b + 1][B + 1];
            (b !== 0 || T > 0) && E.push(R, I, O), (b !== o - 1 || x < Math.PI) && E.push(I, L, O)
        }
        this.setIndex(E), this.setAttribute("position", new Cs(p, 3)), this.setAttribute("normal", new Cs(C, 3)), this.setAttribute("uv", new Cs(M, 2))
    }

    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }

    static fromJSON(t) {
        return new b0(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
    }
}

class am extends R0 {
    constructor(t) {
        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new xs(16777215), this.specular = new xs(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xs(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yw, this.normalScale = new es(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ao, this.combine = M1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}

class Bw extends R0 {
    constructor(t) {
        super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new xs(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xs(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = yw, this.normalScale = new es(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ao, this.combine = M1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
    }

    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}

function r0(A, t, i) {
    return !A || !i && A.constructor === t ? A : typeof t.BYTES_PER_ELEMENT == "number" ? new t(A) : Array.prototype.slice.call(A)
}

function hT(A) {
    return ArrayBuffer.isView(A) && !(A instanceof DataView)
}

function dT(A) {
    function t(c, f) {
        return A[c] - A[f]
    }

    const i = A.length, o = new Array(i);
    for (let c = 0; c !== i; ++c) o[c] = c;
    return o.sort(t), o
}

function g2(A, t, i) {
    const o = A.length, c = new A.constructor(o);
    for (let f = 0, T = 0; T !== o; ++f) {
        const m = i[f] * t;
        for (let x = 0; x !== t; ++x) c[T++] = A[m + x]
    }
    return c
}

function Lw(A, t, i, o) {
    let c = 1, f = A[0];
    for (; f !== void 0 && f[o] === void 0;) f = A[c++];
    if (f === void 0) return;
    let T = f[o];
    if (T !== void 0) if (Array.isArray(T)) do T = f[o], T !== void 0 && (t.push(f.time), i.push.apply(i, T)), f = A[c++]; while (f !== void 0); else if (T.toArray !== void 0) do T = f[o], T !== void 0 && (t.push(f.time), T.toArray(i, i.length)), f = A[c++]; while (f !== void 0); else do T = f[o], T !== void 0 && (t.push(f.time), i.push(T)), f = A[c++]; while (f !== void 0)
}

class P0 {
    constructor(t, i, o, c) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = c !== void 0 ? c : new i.constructor(o), this.sampleValues = i, this.valueSize = o, this.settings = null, this.DefaultSettings_ = {}
    }

    evaluate(t) {
        const i = this.parameterPositions;
        let o = this._cachedIndex, c = i[o], f = i[o - 1];
        e:{
            t:{
                let T;
                n:{
                    i:if (!(t < c)) {
                        for (let m = o + 2; ;) {
                            if (c === void 0) {
                                if (t < f) break i;
                                return o = i.length, this._cachedIndex = o, this.copySampleValue_(o - 1)
                            }
                            if (o === m) break;
                            if (f = c, c = i[++o], t < c) break t
                        }
                        T = i.length;
                        break n
                    }
                    if (!(t >= f)) {
                        const m = i[1];
                        t < m && (o = 2, f = m);
                        for (let x = o - 2; ;) {
                            if (f === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (o === x) break;
                            if (c = f, f = i[--o - 1], t >= f) break t
                        }
                        T = o, o = 0;
                        break n
                    }
                    break e
                }
                for (; o < T;) {
                    const m = o + T >>> 1;
                    t < i[m] ? T = m : o = m + 1
                }
                if (c = i[o], f = i[o - 1], f === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (c === void 0) return o = i.length, this._cachedIndex = o, this.copySampleValue_(o - 1)
            }
            this._cachedIndex = o, this.intervalChanged_(o, f, c)
        }
        return this.interpolate_(o, f, t, c)
    }

    getSettings_() {
        return this.settings || this.DefaultSettings_
    }

    copySampleValue_(t) {
        const i = this.resultBuffer, o = this.sampleValues, c = this.valueSize, f = t * c;
        for (let T = 0; T !== c; ++T) i[T] = o[f + T];
        return i
    }

    interpolate_() {
        throw new Error("call to abstract method")
    }

    intervalChanged_() {
    }
}

class fT extends P0 {
    constructor(t, i, o, c) {
        super(t, i, o, c), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: TC,
            endingEnd: TC
        }
    }

    intervalChanged_(t, i, o) {
        const c = this.parameterPositions;
        let f = t - 2, T = t + 1, m = c[f], x = c[T];
        if (m === void 0) switch (this.getSettings_().endingStart) {
            case IC:
                f = t, m = 2 * i - o;
                break;
            case RC:
                f = c.length - 2, m = i + c[f] - c[f + 1];
                break;
            default:
                f = t, m = o
        }
        if (x === void 0) switch (this.getSettings_().endingEnd) {
            case IC:
                T = t, x = 2 * o - i;
                break;
            case RC:
                T = 1, x = o + c[1] - c[0];
                break;
            default:
                T = t - 1, x = i
        }
        const h = (o - i) * .5, g = this.valueSize;
        this._weightPrev = h / (i - m), this._weightNext = h / (x - o), this._offsetPrev = f * g, this._offsetNext = T * g
    }

    interpolate_(t, i, o, c) {
        const f = this.resultBuffer, T = this.sampleValues, m = this.valueSize, x = t * m, h = x - m,
            g = this._offsetPrev, w = this._offsetNext, v = this._weightPrev, E = this._weightNext,
            p = (o - i) / (c - i), C = p * p, M = C * p, b = -v * M + 2 * v * C - v * p,
            B = (1 + v) * M + (-1.5 - 2 * v) * C + (-.5 + v) * p + 1, R = (-1 - E) * M + (1.5 + E) * C + .5 * p,
            I = E * M - E * C;
        for (let L = 0; L !== m; ++L) f[L] = b * T[g + L] + B * T[h + L] + R * T[x + L] + I * T[w + L];
        return f
    }
}

class pT extends P0 {
    constructor(t, i, o, c) {
        super(t, i, o, c)
    }

    interpolate_(t, i, o, c) {
        const f = this.resultBuffer, T = this.sampleValues, m = this.valueSize, x = t * m, h = x - m,
            g = (o - i) / (c - i), w = 1 - g;
        for (let v = 0; v !== m; ++v) f[v] = T[h + v] * w + T[x + v] * g;
        return f
    }
}

class mT extends P0 {
    constructor(t, i, o, c) {
        super(t, i, o, c)
    }

    interpolate_(t) {
        return this.copySampleValue_(t - 1)
    }
}

class Zl {
    constructor(t, i, o, c) {
        if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (i === void 0 || i.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = r0(i, this.TimeBufferType), this.values = r0(o, this.ValueBufferType), this.setInterpolation(c || this.DefaultInterpolation)
    }

    static toJSON(t) {
        const i = t.constructor;
        let o;
        if (i.toJSON !== this.toJSON) o = i.toJSON(t); else {
            o = {name: t.name, times: r0(t.times, Array), values: r0(t.values, Array)};
            const c = t.getInterpolation();
            c !== t.DefaultInterpolation && (o.interpolation = c)
        }
        return o.type = t.ValueTypeName, o
    }

    InterpolantFactoryMethodDiscrete(t) {
        return new mT(this.times, this.values, this.getValueSize(), t)
    }

    InterpolantFactoryMethodLinear(t) {
        return new pT(this.times, this.values, this.getValueSize(), t)
    }

    InterpolantFactoryMethodSmooth(t) {
        return new fT(this.times, this.values, this.getValueSize(), t)
    }

    setInterpolation(t) {
        let i;
        switch (t) {
            case y0:
                i = this.InterpolantFactoryMethodDiscrete;
                break;
            case E0:
                i = this.InterpolantFactoryMethodLinear;
                break;
            case vy:
                i = this.InterpolantFactoryMethodSmooth;
                break
        }
        if (i === void 0) {
            const o = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(o);
            return console.warn("THREE.KeyframeTrack:", o), this
        }
        return this.createInterpolant = i, this
    }

    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return y0;
            case this.InterpolantFactoryMethodLinear:
                return E0;
            case this.InterpolantFactoryMethodSmooth:
                return vy
        }
    }

    getValueSize() {
        return this.values.length / this.times.length
    }

    shift(t) {
        if (t !== 0) {
            const i = this.times;
            for (let o = 0, c = i.length; o !== c; ++o) i[o] += t
        }
        return this
    }

    scale(t) {
        if (t !== 1) {
            const i = this.times;
            for (let o = 0, c = i.length; o !== c; ++o) i[o] *= t
        }
        return this
    }

    trim(t, i) {
        const o = this.times, c = o.length;
        let f = 0, T = c - 1;
        for (; f !== c && o[f] < t;) ++f;
        for (; T !== -1 && o[T] > i;) --T;
        if (++T, f !== 0 || T !== c) {
            f >= T && (T = Math.max(T, 1), f = T - 1);
            const m = this.getValueSize();
            this.times = o.slice(f, T), this.values = this.values.slice(f * m, T * m)
        }
        return this
    }

    validate() {
        let t = !0;
        const i = this.getValueSize();
        i - Math.floor(i) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
        const o = this.times, c = this.values, f = o.length;
        f === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
        let T = null;
        for (let m = 0; m !== f; m++) {
            const x = o[m];
            if (typeof x == "number" && isNaN(x)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, m, x), t = !1;
                break
            }
            if (T !== null && T > x) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, m, x, T), t = !1;
                break
            }
            T = x
        }
        if (c !== void 0 && hT(c)) for (let m = 0, x = c.length; m !== x; ++m) {
            const h = c[m];
            if (isNaN(h)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, m, h), t = !1;
                break
            }
        }
        return t
    }

    optimize() {
        const t = this.times.slice(), i = this.values.slice(), o = this.getValueSize(),
            c = this.getInterpolation() === vy, f = t.length - 1;
        let T = 1;
        for (let m = 1; m < f; ++m) {
            let x = !1;
            const h = t[m], g = t[m + 1];
            if (h !== g && (m !== 1 || h !== t[0])) if (c) x = !0; else {
                const w = m * o, v = w - o, E = w + o;
                for (let p = 0; p !== o; ++p) {
                    const C = i[w + p];
                    if (C !== i[v + p] || C !== i[E + p]) {
                        x = !0;
                        break
                    }
                }
            }
            if (x) {
                if (m !== T) {
                    t[T] = t[m];
                    const w = m * o, v = T * o;
                    for (let E = 0; E !== o; ++E) i[v + E] = i[w + E]
                }
                ++T
            }
        }
        if (f > 0) {
            t[T] = t[f];
            for (let m = f * o, x = T * o, h = 0; h !== o; ++h) i[x + h] = i[m + h];
            ++T
        }
        return T !== t.length ? (this.times = t.slice(0, T), this.values = i.slice(0, T * o)) : (this.times = t, this.values = i), this
    }

    clone() {
        const t = this.times.slice(), i = this.values.slice(), o = this.constructor, c = new o(this.name, t, i);
        return c.createInterpolant = this.createInterpolant, c
    }
}

Zl.prototype.TimeBufferType = Float32Array;
Zl.prototype.ValueBufferType = Float32Array;
Zl.prototype.DefaultInterpolation = E0;

class uf extends Zl {
}

uf.prototype.ValueTypeName = "bool";
uf.prototype.ValueBufferType = Array;
uf.prototype.DefaultInterpolation = y0;
uf.prototype.InterpolantFactoryMethodLinear = void 0;
uf.prototype.InterpolantFactoryMethodSmooth = void 0;

class Dw extends Zl {
}

Dw.prototype.ValueTypeName = "color";

class Am extends Zl {
}

Am.prototype.ValueTypeName = "number";

class AT extends P0 {
    constructor(t, i, o, c) {
        super(t, i, o, c)
    }

    interpolate_(t, i, o, c) {
        const f = this.resultBuffer, T = this.sampleValues, m = this.valueSize, x = (o - i) / (c - i);
        let h = t * m;
        for (let g = h + m; h !== g; h += 4) Ho.slerpFlat(f, 0, T, h - m, T, h, x);
        return f
    }
}

class Lu extends Zl {
    InterpolantFactoryMethodLinear(t) {
        return new AT(this.times, this.values, this.getValueSize(), t)
    }
}

Lu.prototype.ValueTypeName = "quaternion";
Lu.prototype.DefaultInterpolation = E0;
Lu.prototype.InterpolantFactoryMethodSmooth = void 0;

class hf extends Zl {
}

hf.prototype.ValueTypeName = "string";
hf.prototype.ValueBufferType = Array;
hf.prototype.DefaultInterpolation = y0;
hf.prototype.InterpolantFactoryMethodLinear = void 0;
hf.prototype.InterpolantFactoryMethodSmooth = void 0;

class Fh extends Zl {
}

Fh.prototype.ValueTypeName = "vector";

class v1 {
    constructor(t = "", i = -1, o = [], c = X3) {
        this.name = t, this.tracks = o, this.duration = i, this.blendMode = c, this.uuid = Pu(), this.duration < 0 && this.resetDuration()
    }

    static parse(t) {
        const i = [], o = t.tracks, c = 1 / (t.fps || 1);
        for (let T = 0, m = o.length; T !== m; ++T) i.push(vT(o[T]).scale(c));
        const f = new this(t.name, t.duration, i, t.blendMode);
        return f.uuid = t.uuid, f
    }

    static toJSON(t) {
        const i = [], o = t.tracks,
            c = {name: t.name, duration: t.duration, tracks: i, uuid: t.uuid, blendMode: t.blendMode};
        for (let f = 0, T = o.length; f !== T; ++f) i.push(Zl.toJSON(o[f]));
        return c
    }

    static CreateFromMorphTargetSequence(t, i, o, c) {
        const f = i.length, T = [];
        for (let m = 0; m < f; m++) {
            let x = [], h = [];
            x.push((m + f - 1) % f, m, (m + 1) % f), h.push(0, 1, 0);
            const g = dT(x);
            x = g2(x, 1, g), h = g2(h, 1, g), !c && x[0] === 0 && (x.push(f), h.push(h[0])), T.push(new Am(".morphTargetInfluences[" + i[m].name + "]", x, h).scale(1 / o))
        }
        return new this(t, -1, T)
    }

    static findByName(t, i) {
        let o = t;
        if (!Array.isArray(t)) {
            const c = t;
            o = c.geometry && c.geometry.animations || c.animations
        }
        for (let c = 0; c < o.length; c++) if (o[c].name === i) return o[c];
        return null
    }

    static CreateClipsFromMorphTargetSequences(t, i, o) {
        const c = {}, f = /^([\w-]*?)([\d]+)$/;
        for (let m = 0, x = t.length; m < x; m++) {
            const h = t[m], g = h.name.match(f);
            if (g && g.length > 1) {
                const w = g[1];
                let v = c[w];
                v || (c[w] = v = []), v.push(h)
            }
        }
        const T = [];
        for (const m in c) T.push(this.CreateFromMorphTargetSequence(m, c[m], i, o));
        return T
    }

    static parseAnimation(t, i) {
        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const o = function (w, v, E, p, C) {
            if (E.length !== 0) {
                const M = [], b = [];
                Lw(E, M, b, p), M.length !== 0 && C.push(new w(v, M, b))
            }
        }, c = [], f = t.name || "default", T = t.fps || 30, m = t.blendMode;
        let x = t.length || -1;
        const h = t.hierarchy || [];
        for (let w = 0; w < h.length; w++) {
            const v = h[w].keys;
            if (!(!v || v.length === 0)) if (v[0].morphTargets) {
                const E = {};
                let p;
                for (p = 0; p < v.length; p++) if (v[p].morphTargets) for (let C = 0; C < v[p].morphTargets.length; C++) E[v[p].morphTargets[C]] = -1;
                for (const C in E) {
                    const M = [], b = [];
                    for (let B = 0; B !== v[p].morphTargets.length; ++B) {
                        const R = v[p];
                        M.push(R.time), b.push(R.morphTarget === C ? 1 : 0)
                    }
                    c.push(new Am(".morphTargetInfluence[" + C + "]", M, b))
                }
                x = E.length * T
            } else {
                const E = ".bones[" + i[w].name + "]";
                o(Fh, E + ".position", v, "pos", c), o(Lu, E + ".quaternion", v, "rot", c), o(Fh, E + ".scale", v, "scl", c)
            }
        }
        return c.length === 0 ? null : new this(f, x, c, m)
    }

    resetDuration() {
        const t = this.tracks;
        let i = 0;
        for (let o = 0, c = t.length; o !== c; ++o) {
            const f = this.tracks[o];
            i = Math.max(i, f.times[f.times.length - 1])
        }
        return this.duration = i, this
    }

    trim() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
        return this
    }

    validate() {
        let t = !0;
        for (let i = 0; i < this.tracks.length; i++) t = t && this.tracks[i].validate();
        return t
    }

    optimize() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this
    }

    clone() {
        const t = [];
        for (let i = 0; i < this.tracks.length; i++) t.push(this.tracks[i].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode)
    }

    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function gT(A) {
    switch (A.toLowerCase()) {
        case"scalar":
        case"double":
        case"float":
        case"number":
        case"integer":
            return Am;
        case"vector":
        case"vector2":
        case"vector3":
        case"vector4":
            return Fh;
        case"color":
            return Dw;
        case"quaternion":
            return Lu;
        case"bool":
        case"boolean":
            return uf;
        case"string":
            return hf
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + A)
}

function vT(A) {
    if (A.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t = gT(A.type);
    if (A.times === void 0) {
        const i = [], o = [];
        Lw(A.keys, i, o, "value"), A.times = i, A.values = o
    }
    return t.parse !== void 0 ? t.parse(A) : new t(A.name, A.times, A.values, A.interpolation)
}

const _0 = {
    enabled: !1, files: {}, add: function (A, t) {
        this.enabled !== !1 && (this.files[A] = t)
    }, get: function (A) {
        if (this.enabled !== !1) return this.files[A]
    }, remove: function (A) {
        delete this.files[A]
    }, clear: function () {
        this.files = {}
    }
};

class yT {
    constructor(t, i, o) {
        const c = this;
        let f = !1, T = 0, m = 0, x;
        const h = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = i, this.onError = o, this.itemStart = function (g) {
            m++, f === !1 && c.onStart !== void 0 && c.onStart(g, T, m), f = !0
        }, this.itemEnd = function (g) {
            T++, c.onProgress !== void 0 && c.onProgress(g, T, m), T === m && (f = !1, c.onLoad !== void 0 && c.onLoad())
        }, this.itemError = function (g) {
            c.onError !== void 0 && c.onError(g)
        }, this.resolveURL = function (g) {
            return x ? x(g) : g
        }, this.setURLModifier = function (g) {
            return x = g, this
        }, this.addHandler = function (g, w) {
            return h.push(g, w), this
        }, this.removeHandler = function (g) {
            const w = h.indexOf(g);
            return w !== -1 && h.splice(w, 2), this
        }, this.getHandler = function (g) {
            for (let w = 0, v = h.length; w < v; w += 2) {
                const E = h[w], p = h[w + 1];
                if (E.global && (E.lastIndex = 0), E.test(g)) return p
            }
            return null
        }
    }
}

const ET = new yT;

class Yl {
    constructor(t) {
        this.manager = t !== void 0 ? t : ET, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }

    load() {
    }

    loadAsync(t, i) {
        const o = this;
        return new Promise(function (c, f) {
            o.load(t, c, i, f)
        })
    }

    parse() {
    }

    setCrossOrigin(t) {
        return this.crossOrigin = t, this
    }

    setWithCredentials(t) {
        return this.withCredentials = t, this
    }

    setPath(t) {
        return this.path = t, this
    }

    setResourcePath(t) {
        return this.resourcePath = t, this
    }

    setRequestHeader(t) {
        return this.requestHeader = t, this
    }
}

Yl.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const zc = {};

class xT extends Error {
    constructor(t, i) {
        super(t), this.response = i
    }
}

class D1 extends Yl {
    constructor(t) {
        super(t)
    }

    load(t, i, o, c) {
        t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
        const f = _0.get(t);
        if (f !== void 0) return this.manager.itemStart(t), setTimeout(() => {
            i && i(f), this.manager.itemEnd(t)
        }, 0), f;
        if (zc[t] !== void 0) {
            zc[t].push({onLoad: i, onProgress: o, onError: c});
            return
        }
        zc[t] = [], zc[t].push({onLoad: i, onProgress: o, onError: c});
        const T = new Request(t, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        }), m = this.mimeType, x = this.responseType;
        fetch(T).then(h => {
            if (h.status === 200 || h.status === 0) {
                if (h.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || h.body === void 0 || h.body.getReader === void 0) return h;
                const g = zc[t], w = h.body.getReader(),
                    v = h.headers.get("X-File-Size") || h.headers.get("Content-Length"), E = v ? parseInt(v) : 0,
                    p = E !== 0;
                let C = 0;
                const M = new ReadableStream({
                    start(b) {
                        B();

                        function B() {
                            w.read().then(({done: R, value: I}) => {
                                if (R) b.close(); else {
                                    C += I.byteLength;
                                    const L = new ProgressEvent("progress", {lengthComputable: p, loaded: C, total: E});
                                    for (let O = 0, N = g.length; O < N; O++) {
                                        const F = g[O];
                                        F.onProgress && F.onProgress(L)
                                    }
                                    b.enqueue(I), B()
                                }
                            })
                        }
                    }
                });
                return new Response(M)
            } else throw new xT(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`, h)
        }).then(h => {
            switch (x) {
                case"arraybuffer":
                    return h.arrayBuffer();
                case"blob":
                    return h.blob();
                case"document":
                    return h.text().then(g => new DOMParser().parseFromString(g, m));
                case"json":
                    return h.json();
                default:
                    if (m === void 0) return h.text();
                {
                    const w = /charset="?([^;"\s]*)"?/i.exec(m), v = w && w[1] ? w[1].toLowerCase() : void 0,
                        E = new TextDecoder(v);
                    return h.arrayBuffer().then(p => E.decode(p))
                }
            }
        }).then(h => {
            _0.add(t, h);
            const g = zc[t];
            delete zc[t];
            for (let w = 0, v = g.length; w < v; w++) {
                const E = g[w];
                E.onLoad && E.onLoad(h)
            }
        }).catch(h => {
            const g = zc[t];
            if (g === void 0) throw this.manager.itemError(t), h;
            delete zc[t];
            for (let w = 0, v = g.length; w < v; w++) {
                const E = g[w];
                E.onError && E.onError(h)
            }
            this.manager.itemError(t)
        }).finally(() => {
            this.manager.itemEnd(t)
        }), this.manager.itemStart(t)
    }

    setResponseType(t) {
        return this.responseType = t, this
    }

    setMimeType(t) {
        return this.mimeType = t, this
    }
}

class CT extends Yl {
    constructor(t) {
        super(t)
    }

    load(t, i, o, c) {
        this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
        const f = this, T = _0.get(t);
        if (T !== void 0) return f.manager.itemStart(t), setTimeout(function () {
            i && i(T), f.manager.itemEnd(t)
        }, 0), T;
        const m = m1("img");

        function x() {
            g(), _0.add(t, this), i && i(this), f.manager.itemEnd(t)
        }

        function h(w) {
            g(), c && c(w), f.manager.itemError(t), f.manager.itemEnd(t)
        }

        function g() {
            m.removeEventListener("load", x, !1), m.removeEventListener("error", h, !1)
        }

        return m.addEventListener("load", x, !1), m.addEventListener("error", h, !1), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (m.crossOrigin = this.crossOrigin), f.manager.itemStart(t), m.src = t, m
    }
}

class wT extends Yl {
    constructor(t) {
        super(t)
    }

    load(t, i, o, c) {
        const f = this, T = new Sw, m = new D1(this.manager);
        return m.setResponseType("arraybuffer"), m.setRequestHeader(this.requestHeader), m.setPath(this.path), m.setWithCredentials(f.withCredentials), m.load(t, function (x) {
            let h;
            try {
                h = f.parse(x)
            } catch (g) {
                if (c !== void 0) c(g); else {
                    console.error(g);
                    return
                }
            }
            h.image !== void 0 ? T.image = h.image : h.data !== void 0 && (T.image.width = h.width, T.image.height = h.height, T.image.data = h.data), T.wrapS = h.wrapS !== void 0 ? h.wrapS : Xl, T.wrapT = h.wrapT !== void 0 ? h.wrapT : Xl, T.magFilter = h.magFilter !== void 0 ? h.magFilter : im, T.minFilter = h.minFilter !== void 0 ? h.minFilter : im, T.anisotropy = h.anisotropy !== void 0 ? h.anisotropy : 1, h.colorSpace !== void 0 && (T.colorSpace = h.colorSpace), h.flipY !== void 0 && (T.flipY = h.flipY), h.format !== void 0 && (T.format = h.format), h.type !== void 0 && (T.type = h.type), h.mipmaps !== void 0 && (T.mipmaps = h.mipmaps, T.minFilter = S1), h.mipmapCount === 1 && (T.minFilter = im), h.generateMipmaps !== void 0 && (T.generateMipmaps = h.generateMipmaps), T.needsUpdate = !0, i && i(T, h)
        }, o, c), T
    }
}

class Pw extends Yl {
    constructor(t) {
        super(t)
    }

    load(t, i, o, c) {
        const f = new ya, T = new CT(this.manager);
        return T.setCrossOrigin(this.crossOrigin), T.setPath(this.path), T.load(t, function (m) {
            f.image = m, f.needsUpdate = !0, i !== void 0 && i(f)
        }, o, c), f
    }
}

class O0 extends rs {
    constructor(t, i = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new xs(t), this.intensity = i
    }

    dispose() {
    }

    copy(t, i) {
        return super.copy(t, i), this.color.copy(t.color), this.intensity = t.intensity, this
    }

    toJSON(t) {
        const i = super.toJSON(t);
        return i.object.color = this.color.getHex(), i.object.intensity = this.intensity, this.groundColor !== void 0 && (i.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (i.object.distance = this.distance), this.angle !== void 0 && (i.object.angle = this.angle), this.decay !== void 0 && (i.object.decay = this.decay), this.penumbra !== void 0 && (i.object.penumbra = this.penumbra), this.shadow !== void 0 && (i.object.shadow = this.shadow.toJSON()), i
    }
}

const zy = new $n, v2 = new ft, y2 = new ft;

class P1 {
    constructor(t) {
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new es(512, 512), this.map = null, this.mapPass = null, this.matrix = new $n, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new OS, this._frameExtents = new es(1, 1), this._viewportCount = 1, this._viewports = [new Zs(0, 0, 1, 1)]
    }

    getViewportCount() {
        return this._viewportCount
    }

    getFrustum() {
        return this._frustum
    }

    updateMatrices(t) {
        const i = this.camera, o = this.matrix;
        v2.setFromMatrixPosition(t.matrixWorld), i.position.copy(v2), y2.setFromMatrixPosition(t.target.matrixWorld), i.lookAt(y2), i.updateMatrixWorld(), zy.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(zy), o.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), o.multiply(zy)
    }

    getViewport(t) {
        return this._viewports[t]
    }

    getFrameExtents() {
        return this._frameExtents
    }

    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }

    copy(t) {
        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
    }

    clone() {
        return new this.constructor().copy(this)
    }

    toJSON() {
        const t = {};
        return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
    }
}

class bT extends P1 {
    constructor() {
        super(new Bu(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
    }

    updateMatrices(t) {
        const i = this.camera, o = um * 2 * t.angle * this.focus, c = this.mapSize.width / this.mapSize.height,
            f = t.distance || i.far;
        (o !== i.fov || c !== i.aspect || f !== i.far) && (i.fov = o, i.aspect = c, i.far = f, i.updateProjectionMatrix()), super.updateMatrices(t)
    }

    copy(t) {
        return super.copy(t), this.focus = t.focus, this
    }
}

class Ow extends O0 {
    constructor(t, i, o = 0, c = Math.PI / 3, f = 0, T = 2) {
        super(t, i), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(rs.DEFAULT_UP), this.updateMatrix(), this.target = new rs, this.distance = o, this.angle = c, this.penumbra = f, this.decay = T, this.map = null, this.shadow = new bT
    }

    get power() {
        return this.intensity * Math.PI
    }

    set power(t) {
        this.intensity = t / Math.PI
    }

    dispose() {
        this.shadow.dispose()
    }

    copy(t, i) {
        return super.copy(t, i), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}

const E2 = new $n, em = new ft, Gy = new ft;

class _T extends P1 {
    constructor() {
        super(new Bu(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new es(4, 2), this._viewportCount = 6, this._viewports = [new Zs(2, 1, 1, 1), new Zs(0, 1, 1, 1), new Zs(3, 1, 1, 1), new Zs(1, 1, 1, 1), new Zs(3, 0, 1, 1), new Zs(1, 0, 1, 1)], this._cubeDirections = [new ft(1, 0, 0), new ft(-1, 0, 0), new ft(0, 0, 1), new ft(0, 0, -1), new ft(0, 1, 0), new ft(0, -1, 0)], this._cubeUps = [new ft(0, 1, 0), new ft(0, 1, 0), new ft(0, 1, 0), new ft(0, 1, 0), new ft(0, 0, 1), new ft(0, 0, -1)]
    }

    updateMatrices(t, i = 0) {
        const o = this.camera, c = this.matrix, f = t.distance || o.far;
        f !== o.far && (o.far = f, o.updateProjectionMatrix()), em.setFromMatrixPosition(t.matrixWorld), o.position.copy(em), Gy.copy(o.position), Gy.add(this._cubeDirections[i]), o.up.copy(this._cubeUps[i]), o.lookAt(Gy), o.updateMatrixWorld(), c.makeTranslation(-em.x, -em.y, -em.z), E2.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse), this._frustum.setFromProjectionMatrix(E2)
    }
}

class y1 extends O0 {
    constructor(t, i, o = 0, c = 2) {
        super(t, i), this.isPointLight = !0, this.type = "PointLight", this.distance = o, this.decay = c, this.shadow = new _T
    }

    get power() {
        return this.intensity * 4 * Math.PI
    }

    set power(t) {
        this.intensity = t / (4 * Math.PI)
    }

    dispose() {
        this.shadow.dispose()
    }

    copy(t, i) {
        return super.copy(t, i), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
    }
}

class MT extends P1 {
    constructor() {
        super(new B1(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}

class kw extends O0 {
    constructor(t, i) {
        super(t, i), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(rs.DEFAULT_UP), this.updateMatrix(), this.target = new rs, this.shadow = new MT
    }

    dispose() {
        this.shadow.dispose()
    }

    copy(t) {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}

class Fw extends O0 {
    constructor(t, i) {
        super(t, i), this.isAmbientLight = !0, this.type = "AmbientLight"
    }
}

class Nw {
    static decodeText(t) {
        if (typeof TextDecoder < "u") return new TextDecoder().decode(t);
        let i = "";
        for (let o = 0, c = t.length; o < c; o++) i += String.fromCharCode(t[o]);
        try {
            return decodeURIComponent(escape(i))
        } catch {
            return i
        }
    }

    static extractUrlBase(t) {
        const i = t.lastIndexOf("/");
        return i === -1 ? "./" : t.slice(0, i + 1)
    }

    static resolveURL(t, i) {
        return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(i) && /^\//.test(t) && (i = i.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : i + t)
    }
}

const O1 = "\\[\\]\\.:\\/", ST = new RegExp("[" + O1 + "]", "g"), k1 = "[^" + O1 + "]",
    TT = "[^" + O1.replace("\\.", "") + "]", IT = /((?:WC+[\/:])*)/.source.replace("WC", k1),
    RT = /(WCOD+)?/.source.replace("WCOD", TT), BT = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", k1),
    LT = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", k1), DT = new RegExp("^" + IT + RT + BT + LT + "$"),
    PT = ["material", "materials", "bones", "map"];

class OT {
    constructor(t, i, o) {
        const c = o || br.parseTrackName(i);
        this._targetGroup = t, this._bindings = t.subscribe_(i, c)
    }

    getValue(t, i) {
        this.bind();
        const o = this._targetGroup.nCachedObjects_, c = this._bindings[o];
        c !== void 0 && c.getValue(t, i)
    }

    setValue(t, i) {
        const o = this._bindings;
        for (let c = this._targetGroup.nCachedObjects_, f = o.length; c !== f; ++c) o[c].setValue(t, i)
    }

    bind() {
        const t = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, o = t.length; i !== o; ++i) t[i].bind()
    }

    unbind() {
        const t = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, o = t.length; i !== o; ++i) t[i].unbind()
    }
}

class br {
    constructor(t, i, o) {
        this.path = i, this.parsedPath = o || br.parseTrackName(i), this.node = br.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }

    static create(t, i, o) {
        return t && t.isAnimationObjectGroup ? new br.Composite(t, i, o) : new br(t, i, o)
    }

    static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(ST, "")
    }

    static parseTrackName(t) {
        const i = DT.exec(t);
        if (i === null) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const o = {nodeName: i[2], objectName: i[3], objectIndex: i[4], propertyName: i[5], propertyIndex: i[6]},
            c = o.nodeName && o.nodeName.lastIndexOf(".");
        if (c !== void 0 && c !== -1) {
            const f = o.nodeName.substring(c + 1);
            PT.indexOf(f) !== -1 && (o.nodeName = o.nodeName.substring(0, c), o.objectName = f)
        }
        if (o.propertyName === null || o.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return o
    }

    static findNode(t, i) {
        if (i === void 0 || i === "" || i === "." || i === -1 || i === t.name || i === t.uuid) return t;
        if (t.skeleton) {
            const o = t.skeleton.getBoneByName(i);
            if (o !== void 0) return o
        }
        if (t.children) {
            const o = function (f) {
                for (let T = 0; T < f.length; T++) {
                    const m = f[T];
                    if (m.name === i || m.uuid === i) return m;
                    const x = o(m.children);
                    if (x) return x
                }
                return null
            }, c = o(t.children);
            if (c) return c
        }
        return null
    }

    _getValue_unavailable() {
    }

    _setValue_unavailable() {
    }

    _getValue_direct(t, i) {
        t[i] = this.targetObject[this.propertyName]
    }

    _getValue_array(t, i) {
        const o = this.resolvedProperty;
        for (let c = 0, f = o.length; c !== f; ++c) t[i++] = o[c]
    }

    _getValue_arrayElement(t, i) {
        t[i] = this.resolvedProperty[this.propertyIndex]
    }

    _getValue_toArray(t, i) {
        this.resolvedProperty.toArray(t, i)
    }

    _setValue_direct(t, i) {
        this.targetObject[this.propertyName] = t[i]
    }

    _setValue_direct_setNeedsUpdate(t, i) {
        this.targetObject[this.propertyName] = t[i], this.targetObject.needsUpdate = !0
    }

    _setValue_direct_setMatrixWorldNeedsUpdate(t, i) {
        this.targetObject[this.propertyName] = t[i], this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_array(t, i) {
        const o = this.resolvedProperty;
        for (let c = 0, f = o.length; c !== f; ++c) o[c] = t[i++]
    }

    _setValue_array_setNeedsUpdate(t, i) {
        const o = this.resolvedProperty;
        for (let c = 0, f = o.length; c !== f; ++c) o[c] = t[i++];
        this.targetObject.needsUpdate = !0
    }

    _setValue_array_setMatrixWorldNeedsUpdate(t, i) {
        const o = this.resolvedProperty;
        for (let c = 0, f = o.length; c !== f; ++c) o[c] = t[i++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_arrayElement(t, i) {
        this.resolvedProperty[this.propertyIndex] = t[i]
    }

    _setValue_arrayElement_setNeedsUpdate(t, i) {
        this.resolvedProperty[this.propertyIndex] = t[i], this.targetObject.needsUpdate = !0
    }

    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, i) {
        this.resolvedProperty[this.propertyIndex] = t[i], this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_fromArray(t, i) {
        this.resolvedProperty.fromArray(t, i)
    }

    _setValue_fromArray_setNeedsUpdate(t, i) {
        this.resolvedProperty.fromArray(t, i), this.targetObject.needsUpdate = !0
    }

    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, i) {
        this.resolvedProperty.fromArray(t, i), this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _getValue_unbound(t, i) {
        this.bind(), this.getValue(t, i)
    }

    _setValue_unbound(t, i) {
        this.bind(), this.setValue(t, i)
    }

    bind() {
        let t = this.node;
        const i = this.parsedPath, o = i.objectName, c = i.propertyName;
        let f = i.propertyIndex;
        if (t || (t = br.findNode(this.rootNode, i.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (o) {
            let h = i.objectIndex;
            switch (o) {
                case"materials":
                    if (!t.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!t.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return
                    }
                    t = t.material.materials;
                    break;
                case"bones":
                    if (!t.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return
                    }
                    t = t.skeleton.bones;
                    for (let g = 0; g < t.length; g++) if (t[g].name === h) {
                        h = g;
                        break
                    }
                    break;
                case"map":
                    if ("map" in t) {
                        t = t.map;
                        break
                    }
                    if (!t.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!t.material.map) {
                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        return
                    }
                    t = t.material.map;
                    break;
                default:
                    if (t[o] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return
                    }
                    t = t[o]
            }
            if (h !== void 0) {
                if (t[h] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                    return
                }
                t = t[h]
            }
        }
        const T = t[c];
        if (T === void 0) {
            const h = i.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + c + " but it wasn't found.", t);
            return
        }
        let m = this.Versioning.None;
        this.targetObject = t, t.needsUpdate !== void 0 ? m = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (m = this.Versioning.MatrixWorldNeedsUpdate);
        let x = this.BindingType.Direct;
        if (f !== void 0) {
            if (c === "morphTargetInfluences") {
                if (!t.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!t.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                t.morphTargetDictionary[f] !== void 0 && (f = t.morphTargetDictionary[f])
            }
            x = this.BindingType.ArrayElement, this.resolvedProperty = T, this.propertyIndex = f
        } else T.fromArray !== void 0 && T.toArray !== void 0 ? (x = this.BindingType.HasFromToArray, this.resolvedProperty = T) : Array.isArray(T) ? (x = this.BindingType.EntireArray, this.resolvedProperty = T) : this.propertyName = c;
        this.getValue = this.GetterByBindingType[x], this.setValue = this.SetterByBindingTypeAndVersioning[x][m]
    }

    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}

br.Composite = OT;
br.prototype.BindingType = {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3};
br.prototype.Versioning = {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2};
br.prototype.GetterByBindingType = [br.prototype._getValue_direct, br.prototype._getValue_array, br.prototype._getValue_arrayElement, br.prototype._getValue_toArray];
br.prototype.SetterByBindingTypeAndVersioning = [[br.prototype._setValue_direct, br.prototype._setValue_direct_setNeedsUpdate, br.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [br.prototype._setValue_array, br.prototype._setValue_array_setNeedsUpdate, br.prototype._setValue_array_setMatrixWorldNeedsUpdate], [br.prototype._setValue_arrayElement, br.prototype._setValue_arrayElement_setNeedsUpdate, br.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [br.prototype._setValue_fromArray, br.prototype._setValue_fromArray_setNeedsUpdate, br.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: mw}}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = mw);

class x2 extends wT {
    constructor(t) {
        super(t)
    }

    parse(t) {
        function i(ue) {
            switch (ue.image_type) {
                case v:
                case C:
                    if (ue.colormap_length > 256 || ue.colormap_size !== 24 || ue.colormap_type !== 1) throw new Error("THREE.TGALoader: Invalid type colormap data for indexed type.");
                    break;
                case E:
                case p:
                case M:
                case b:
                    if (ue.colormap_type) throw new Error("THREE.TGALoader: Invalid type colormap data for colormap type.");
                    break;
                case w:
                    throw new Error("THREE.TGALoader: No data.");
                default:
                    throw new Error("THREE.TGALoader: Invalid type " + ue.image_type)
            }
            if (ue.width <= 0 || ue.height <= 0) throw new Error("THREE.TGALoader: Invalid image size.");
            if (ue.pixel_size !== 8 && ue.pixel_size !== 16 && ue.pixel_size !== 24 && ue.pixel_size !== 32) throw new Error("THREE.TGALoader: Invalid pixel size " + ue.pixel_size)
        }

        function o(ue, he, Z, H, ae) {
            let ee, me;
            const Re = Z.pixel_size >> 3, ke = Z.width * Z.height * Re;
            if (he && (me = ae.subarray(H, H += Z.colormap_length * (Z.colormap_size >> 3))), ue) {
                ee = new Uint8Array(ke);
                let Ve, He, ot, gt = 0;
                const Bt = new Uint8Array(Re);
                for (; gt < ke;) if (Ve = ae[H++], He = (Ve & 127) + 1, Ve & 128) {
                    for (ot = 0; ot < Re; ++ot) Bt[ot] = ae[H++];
                    for (ot = 0; ot < He; ++ot) ee.set(Bt, gt + ot * Re);
                    gt += Re * He
                } else {
                    for (He *= Re, ot = 0; ot < He; ++ot) ee[gt + ot] = ae[H++];
                    gt += He
                }
            } else ee = ae.subarray(H, H += he ? Z.width * Z.height : ke);
            return {pixel_data: ee, palettes: me}
        }

        function c(ue, he, Z, H, ae, ee, me, Re, ke) {
            const Ve = ke;
            let He, ot = 0, gt, Bt;
            const Rt = U.width;
            for (Bt = he; Bt !== H; Bt += Z) for (gt = ae; gt !== me; gt += ee, ot++) He = Re[ot], ue[(gt + Rt * Bt) * 4 + 3] = 255, ue[(gt + Rt * Bt) * 4 + 2] = Ve[He * 3 + 0], ue[(gt + Rt * Bt) * 4 + 1] = Ve[He * 3 + 1], ue[(gt + Rt * Bt) * 4 + 0] = Ve[He * 3 + 2];
            return ue
        }

        function f(ue, he, Z, H, ae, ee, me, Re) {
            let ke, Ve = 0, He, ot;
            const gt = U.width;
            for (ot = he; ot !== H; ot += Z) for (He = ae; He !== me; He += ee, Ve += 2) ke = Re[Ve + 0] + (Re[Ve + 1] << 8), ue[(He + gt * ot) * 4 + 0] = (ke & 31744) >> 7, ue[(He + gt * ot) * 4 + 1] = (ke & 992) >> 2, ue[(He + gt * ot) * 4 + 2] = (ke & 31) << 3, ue[(He + gt * ot) * 4 + 3] = ke & 32768 ? 0 : 255;
            return ue
        }

        function T(ue, he, Z, H, ae, ee, me, Re) {
            let ke = 0, Ve, He;
            const ot = U.width;
            for (He = he; He !== H; He += Z) for (Ve = ae; Ve !== me; Ve += ee, ke += 3) ue[(Ve + ot * He) * 4 + 3] = 255, ue[(Ve + ot * He) * 4 + 2] = Re[ke + 0], ue[(Ve + ot * He) * 4 + 1] = Re[ke + 1], ue[(Ve + ot * He) * 4 + 0] = Re[ke + 2];
            return ue
        }

        function m(ue, he, Z, H, ae, ee, me, Re) {
            let ke = 0, Ve, He;
            const ot = U.width;
            for (He = he; He !== H; He += Z) for (Ve = ae; Ve !== me; Ve += ee, ke += 4) ue[(Ve + ot * He) * 4 + 2] = Re[ke + 0], ue[(Ve + ot * He) * 4 + 1] = Re[ke + 1], ue[(Ve + ot * He) * 4 + 0] = Re[ke + 2], ue[(Ve + ot * He) * 4 + 3] = Re[ke + 3];
            return ue
        }

        function x(ue, he, Z, H, ae, ee, me, Re) {
            let ke, Ve = 0, He, ot;
            const gt = U.width;
            for (ot = he; ot !== H; ot += Z) for (He = ae; He !== me; He += ee, Ve++) ke = Re[Ve], ue[(He + gt * ot) * 4 + 0] = ke, ue[(He + gt * ot) * 4 + 1] = ke, ue[(He + gt * ot) * 4 + 2] = ke, ue[(He + gt * ot) * 4 + 3] = 255;
            return ue
        }

        function h(ue, he, Z, H, ae, ee, me, Re) {
            let ke = 0, Ve, He;
            const ot = U.width;
            for (He = he; He !== H; He += Z) for (Ve = ae; Ve !== me; Ve += ee, ke += 2) ue[(Ve + ot * He) * 4 + 0] = Re[ke + 0], ue[(Ve + ot * He) * 4 + 1] = Re[ke + 0], ue[(Ve + ot * He) * 4 + 2] = Re[ke + 0], ue[(Ve + ot * He) * 4 + 3] = Re[ke + 1];
            return ue
        }

        function g(ue, he, Z, H, ae) {
            let ee, me, Re, ke, Ve, He;
            switch ((U.flags & B) >> R) {
                default:
                case O:
                    ee = 0, Re = 1, Ve = he, me = 0, ke = 1, He = Z;
                    break;
                case I:
                    ee = 0, Re = 1, Ve = he, me = Z - 1, ke = -1, He = -1;
                    break;
                case N:
                    ee = he - 1, Re = -1, Ve = -1, me = 0, ke = 1, He = Z;
                    break;
                case L:
                    ee = he - 1, Re = -1, Ve = -1, me = Z - 1, ke = -1, He = -1;
                    break
            }
            if (fe) switch (U.pixel_size) {
                case 8:
                    x(ue, me, ke, He, ee, Re, Ve, H);
                    break;
                case 16:
                    h(ue, me, ke, He, ee, Re, Ve, H);
                    break;
                default:
                    throw new Error("THREE.TGALoader: Format not supported.")
            } else switch (U.pixel_size) {
                case 8:
                    c(ue, me, ke, He, ee, Re, Ve, H, ae);
                    break;
                case 16:
                    f(ue, me, ke, He, ee, Re, Ve, H);
                    break;
                case 24:
                    T(ue, me, ke, He, ee, Re, Ve, H);
                    break;
                case 32:
                    m(ue, me, ke, He, ee, Re, Ve, H);
                    break;
                default:
                    throw new Error("THREE.TGALoader: Format not supported.")
            }
            return ue
        }

        const w = 0, v = 1, E = 2, p = 3, C = 9, M = 10, b = 11, B = 48, R = 4, I = 0, L = 1, O = 2, N = 3;
        if (t.length < 19) throw new Error("THREE.TGALoader: Not enough data to contain header.");
        let F = 0;
        const V = new Uint8Array(t), U = {
            id_length: V[F++],
            colormap_type: V[F++],
            image_type: V[F++],
            colormap_index: V[F++] | V[F++] << 8,
            colormap_length: V[F++] | V[F++] << 8,
            colormap_size: V[F++],
            origin: [V[F++] | V[F++] << 8, V[F++] | V[F++] << 8],
            width: V[F++] | V[F++] << 8,
            height: V[F++] | V[F++] << 8,
            pixel_size: V[F++],
            flags: V[F++]
        };
        if (i(U), U.id_length + F > t.length) throw new Error("THREE.TGALoader: No data.");
        F += U.id_length;
        let j = !1, Y = !1, fe = !1;
        switch (U.image_type) {
            case C:
                j = !0, Y = !0;
                break;
            case v:
                Y = !0;
                break;
            case M:
                j = !0;
                break;
            case E:
                break;
            case b:
                j = !0, fe = !0;
                break;
            case p:
                fe = !0;
                break
        }
        const se = new Uint8Array(U.width * U.height * 4), pe = o(j, Y, U, F, V);
        return g(se, U.width, U.height, pe.pixel_data, pe.palettes), {
            data: se,
            width: U.width,
            height: U.height,
            flipY: !0,
            generateMipmaps: !0,
            minFilter: S1
        }
    }
}

class kT extends Yl {
    load(t, i, o, c) {
        const f = this, T = f.path === "" ? Nw.extractUrlBase(t) : f.path, m = new D1(f.manager);
        m.setPath(f.path), m.setRequestHeader(f.requestHeader), m.setWithCredentials(f.withCredentials), m.load(t, function (x) {
            try {
                i(f.parse(x, T))
            } catch (h) {
                c ? c(h) : console.error(h), f.manager.itemError(t)
            }
        }, o, c)
    }

    parse(t, i) {
        function o(ce, de) {
            const we = [], Ee = ce.childNodes;
            for (let Me = 0, st = Ee.length; Me < st; Me++) {
                const ut = Ee[Me];
                ut.nodeName === de && we.push(ut)
            }
            return we
        }

        function c(ce) {
            if (ce.length === 0) return [];
            const de = ce.trim().split(/\s+/), we = new Array(de.length);
            for (let Ee = 0, Me = de.length; Ee < Me; Ee++) we[Ee] = de[Ee];
            return we
        }

        function f(ce) {
            if (ce.length === 0) return [];
            const de = ce.trim().split(/\s+/), we = new Array(de.length);
            for (let Ee = 0, Me = de.length; Ee < Me; Ee++) we[Ee] = parseFloat(de[Ee]);
            return we
        }

        function T(ce) {
            if (ce.length === 0) return [];
            const de = ce.trim().split(/\s+/), we = new Array(de.length);
            for (let Ee = 0, Me = de.length; Ee < Me; Ee++) we[Ee] = parseInt(de[Ee]);
            return we
        }

        function m(ce) {
            return ce.substring(1)
        }

        function x() {
            return "three_default_" + kt++
        }

        function h(ce) {
            return Object.keys(ce).length === 0
        }

        function g(ce) {
            return {unit: w(o(ce, "unit")[0]), upAxis: v(o(ce, "up_axis")[0])}
        }

        function w(ce) {
            return ce !== void 0 && ce.hasAttribute("meter") === !0 ? parseFloat(ce.getAttribute("meter")) : 1
        }

        function v(ce) {
            return ce !== void 0 ? ce.textContent : "Y_UP"
        }

        function E(ce, de, we, Ee) {
            const Me = o(ce, de)[0];
            if (Me !== void 0) {
                const st = o(Me, we);
                for (let ut = 0; ut < st.length; ut++) Ee(st[ut])
            }
        }

        function p(ce, de) {
            for (const we in ce) {
                const Ee = ce[we];
                Ee.build = de(ce[we])
            }
        }

        function C(ce, de) {
            return ce.build !== void 0 || (ce.build = de(ce)), ce.build
        }

        function M(ce) {
            const de = {sources: {}, samplers: {}, channels: {}};
            let we = !1;
            for (let Ee = 0, Me = ce.childNodes.length; Ee < Me; Ee++) {
                const st = ce.childNodes[Ee];
                if (st.nodeType !== 1) continue;
                let ut;
                switch (st.nodeName) {
                    case"source":
                        ut = st.getAttribute("id"), de.sources[ut] = je(st);
                        break;
                    case"sampler":
                        ut = st.getAttribute("id"), de.samplers[ut] = b(st);
                        break;
                    case"channel":
                        ut = st.getAttribute("target"), de.channels[ut] = B(st);
                        break;
                    case"animation":
                        M(st), we = !0;
                        break;
                    default:
                        console.log(st)
                }
            }
            we === !1 && (et.animations[ce.getAttribute("id") || Js.generateUUID()] = de)
        }

        function b(ce) {
            const de = {inputs: {}};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"input":
                        const st = m(Me.getAttribute("source")), ut = Me.getAttribute("semantic");
                        de.inputs[ut] = st;
                        break
                }
            }
            return de
        }

        function B(ce) {
            const de = {};
            let Ee = ce.getAttribute("target").split("/");
            const Me = Ee.shift();
            let st = Ee.shift();
            const ut = st.indexOf("(") !== -1, Vt = st.indexOf(".") !== -1;
            if (Vt) Ee = st.split("."), st = Ee.shift(), de.member = Ee.shift(); else if (ut) {
                const Ft = st.split("(");
                st = Ft.shift();
                for (let Jt = 0; Jt < Ft.length; Jt++) Ft[Jt] = parseInt(Ft[Jt].replace(/\)/, ""));
                de.indices = Ft
            }
            return de.id = Me, de.sid = st, de.arraySyntax = ut, de.memberSyntax = Vt, de.sampler = m(ce.getAttribute("source")), de
        }

        function R(ce) {
            const de = [], we = ce.channels, Ee = ce.samplers, Me = ce.sources;
            for (const st in we) if (we.hasOwnProperty(st)) {
                const ut = we[st], Vt = Ee[ut.sampler], Ft = Vt.inputs.INPUT, Jt = Vt.inputs.OUTPUT, sn = Me[Ft],
                    Pt = Me[Jt], gn = L(ut, sn, Pt);
                U(gn, de)
            }
            return de
        }

        function I(ce) {
            return C(et.animations[ce], R)
        }

        function L(ce, de, we) {
            const Ee = et.nodes[ce.id], Me = Wi(Ee.id), st = Ee.transforms[ce.sid], ut = Ee.matrix.clone().transpose();
            let Vt, Ft, Jt, sn, Pt, gn;
            const un = {};
            switch (st) {
                case"matrix":
                    for (Jt = 0, sn = de.array.length; Jt < sn; Jt++) if (Vt = de.array[Jt], Ft = Jt * we.stride, un[Vt] === void 0 && (un[Vt] = {}), ce.arraySyntax === !0) {
                        const bi = we.array[Ft], Ii = ce.indices[0] + 4 * ce.indices[1];
                        un[Vt][Ii] = bi
                    } else for (Pt = 0, gn = we.stride; Pt < gn; Pt++) un[Vt][Pt] = we.array[Ft + Pt];
                    break;
                case"translate":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', st);
                    break;
                case"rotate":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', st);
                    break;
                case"scale":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', st);
                    break
            }
            const _n = O(un, ut);
            return {name: Me.uuid, keyframes: _n}
        }

        function O(ce, de) {
            const we = [];
            for (const Me in ce) we.push({time: parseFloat(Me), value: ce[Me]});
            we.sort(Ee);
            for (let Me = 0; Me < 16; Me++) j(we, Me, de.elements[Me]);
            return we;

            function Ee(Me, st) {
                return Me.time - st.time
            }
        }

        const N = new ft, F = new ft, V = new Ho;

        function U(ce, de) {
            const we = ce.keyframes, Ee = ce.name, Me = [], st = [], ut = [], Vt = [];
            for (let Ft = 0, Jt = we.length; Ft < Jt; Ft++) {
                const sn = we[Ft], Pt = sn.time, gn = sn.value;
                rt.fromArray(gn).transpose(), rt.decompose(N, V, F), Me.push(Pt), st.push(N.x, N.y, N.z), ut.push(V.x, V.y, V.z, V.w), Vt.push(F.x, F.y, F.z)
            }
            return st.length > 0 && de.push(new Fh(Ee + ".position", Me, st)), ut.length > 0 && de.push(new Lu(Ee + ".quaternion", Me, ut)), Vt.length > 0 && de.push(new Fh(Ee + ".scale", Me, Vt)), de
        }

        function j(ce, de, we) {
            let Ee, Me = !0, st, ut;
            for (st = 0, ut = ce.length; st < ut; st++) Ee = ce[st], Ee.value[de] === void 0 ? Ee.value[de] = null : Me = !1;
            if (Me === !0) for (st = 0, ut = ce.length; st < ut; st++) Ee = ce[st], Ee.value[de] = we; else Y(ce, de)
        }

        function Y(ce, de) {
            let we, Ee;
            for (let Me = 0, st = ce.length; Me < st; Me++) {
                const ut = ce[Me];
                if (ut.value[de] === null) {
                    if (we = fe(ce, Me, de), Ee = se(ce, Me, de), we === null) {
                        ut.value[de] = Ee.value[de];
                        continue
                    }
                    if (Ee === null) {
                        ut.value[de] = we.value[de];
                        continue
                    }
                    pe(ut, we, Ee, de)
                }
            }
        }

        function fe(ce, de, we) {
            for (; de >= 0;) {
                const Ee = ce[de];
                if (Ee.value[we] !== null) return Ee;
                de--
            }
            return null
        }

        function se(ce, de, we) {
            for (; de < ce.length;) {
                const Ee = ce[de];
                if (Ee.value[we] !== null) return Ee;
                de++
            }
            return null
        }

        function pe(ce, de, we, Ee) {
            if (we.time - de.time === 0) {
                ce.value[Ee] = de.value[Ee];
                return
            }
            ce.value[Ee] = (ce.time - de.time) * (we.value[Ee] - de.value[Ee]) / (we.time - de.time) + de.value[Ee]
        }

        function ue(ce) {
            const de = {
                name: ce.getAttribute("id") || "default",
                start: parseFloat(ce.getAttribute("start") || 0),
                end: parseFloat(ce.getAttribute("end") || 0),
                animations: []
            };
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"instance_animation":
                        de.animations.push(m(Me.getAttribute("url")));
                        break
                }
            }
            et.clips[ce.getAttribute("id")] = de
        }

        function he(ce) {
            const de = [], we = ce.name, Ee = ce.end - ce.start || -1, Me = ce.animations;
            for (let st = 0, ut = Me.length; st < ut; st++) {
                const Vt = I(Me[st]);
                for (let Ft = 0, Jt = Vt.length; Ft < Jt; Ft++) de.push(Vt[Ft])
            }
            return new v1(we, Ee, de)
        }

        function Z(ce) {
            return C(et.clips[ce], he)
        }

        function H(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"skin":
                        de.id = m(Me.getAttribute("source")), de.skin = ae(Me);
                        break;
                    case"morph":
                        de.id = m(Me.getAttribute("source")), console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
                        break
                }
            }
            et.controllers[ce.getAttribute("id")] = de
        }

        function ae(ce) {
            const de = {sources: {}};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"bind_shape_matrix":
                        de.bindShapeMatrix = f(Me.textContent);
                        break;
                    case"source":
                        const st = Me.getAttribute("id");
                        de.sources[st] = je(Me);
                        break;
                    case"joints":
                        de.joints = ee(Me);
                        break;
                    case"vertex_weights":
                        de.vertexWeights = me(Me);
                        break
                }
            }
            return de
        }

        function ee(ce) {
            const de = {inputs: {}};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"input":
                        const st = Me.getAttribute("semantic"), ut = m(Me.getAttribute("source"));
                        de.inputs[st] = ut;
                        break
                }
            }
            return de
        }

        function me(ce) {
            const de = {inputs: {}};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"input":
                        const st = Me.getAttribute("semantic"), ut = m(Me.getAttribute("source")),
                            Vt = parseInt(Me.getAttribute("offset"));
                        de.inputs[st] = {id: ut, offset: Vt};
                        break;
                    case"vcount":
                        de.vcount = T(Me.textContent);
                        break;
                    case"v":
                        de.v = T(Me.textContent);
                        break
                }
            }
            return de
        }

        function Re(ce) {
            const de = {id: ce.id}, we = et.geometries[de.id];
            return ce.skin !== void 0 && (de.skin = ke(ce.skin), we.sources.skinIndices = de.skin.indices, we.sources.skinWeights = de.skin.weights), de
        }

        function ke(ce) {
            const we = {joints: [], indices: {array: [], stride: 4}, weights: {array: [], stride: 4}}, Ee = ce.sources,
                Me = ce.vertexWeights, st = Me.vcount, ut = Me.v, Vt = Me.inputs.JOINT.offset,
                Ft = Me.inputs.WEIGHT.offset, Jt = ce.sources[ce.joints.inputs.JOINT],
                sn = ce.sources[ce.joints.inputs.INV_BIND_MATRIX], Pt = Ee[Me.inputs.WEIGHT.id].array;
            let gn = 0, un, _n, yn;
            for (un = 0, yn = st.length; un < yn; un++) {
                const Ii = st[un], _i = [];
                for (_n = 0; _n < Ii; _n++) {
                    const gi = ut[gn + Vt], Yr = ut[gn + Ft], Mr = Pt[Yr];
                    _i.push({index: gi, weight: Mr}), gn += 2
                }
                for (_i.sort(bi), _n = 0; _n < 4; _n++) {
                    const gi = _i[_n];
                    gi !== void 0 ? (we.indices.array.push(gi.index), we.weights.array.push(gi.weight)) : (we.indices.array.push(0), we.weights.array.push(0))
                }
            }
            for (ce.bindShapeMatrix ? we.bindMatrix = new $n().fromArray(ce.bindShapeMatrix).transpose() : we.bindMatrix = new $n().identity(), un = 0, yn = Jt.array.length; un < yn; un++) {
                const Ii = Jt.array[un], _i = new $n().fromArray(sn.array, un * sn.stride).transpose();
                we.joints.push({name: Ii, boneInverse: _i})
            }
            return we;

            function bi(Ii, _i) {
                return _i.weight - Ii.weight
            }
        }

        function Ve(ce) {
            return C(et.controllers[ce], Re)
        }

        function He(ce) {
            const de = {init_from: o(ce, "init_from")[0].textContent};
            et.images[ce.getAttribute("id")] = de
        }

        function ot(ce) {
            return ce.build !== void 0 ? ce.build : ce.init_from
        }

        function gt(ce) {
            const de = et.images[ce];
            return de !== void 0 ? C(de, ot) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:", ce), null)
        }

        function Bt(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"profile_COMMON":
                        de.profile = Rt(Me);
                        break
                }
            }
            et.effects[ce.getAttribute("id")] = de
        }

        function Rt(ce) {
            const de = {surfaces: {}, samplers: {}};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"newparam":
                        an(Me, de);
                        break;
                    case"technique":
                        de.technique = oi(Me);
                        break;
                    case"extra":
                        de.extra = Oi(Me);
                        break
                }
            }
            return de
        }

        function an(ce, de) {
            const we = ce.getAttribute("sid");
            for (let Ee = 0, Me = ce.childNodes.length; Ee < Me; Ee++) {
                const st = ce.childNodes[Ee];
                if (st.nodeType === 1) switch (st.nodeName) {
                    case"surface":
                        de.surfaces[we] = En(st);
                        break;
                    case"sampler2D":
                        de.samplers[we] = Nn(st);
                        break
                }
            }
        }

        function En(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"init_from":
                        de.init_from = Me.textContent;
                        break
                }
            }
            return de
        }

        function Nn(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"source":
                        de.source = Me.textContent;
                        break
                }
            }
            return de
        }

        function oi(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"constant":
                    case"lambert":
                    case"blinn":
                    case"phong":
                        de.type = Me.nodeName, de.parameters = pi(Me);
                        break;
                    case"extra":
                        de.extra = Oi(Me);
                        break
                }
            }
            return de
        }

        function pi(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"emission":
                    case"diffuse":
                    case"specular":
                    case"bump":
                    case"ambient":
                    case"shininess":
                    case"transparency":
                        de[Me.nodeName] = hi(Me);
                        break;
                    case"transparent":
                        de[Me.nodeName] = {
                            opaque: Me.hasAttribute("opaque") ? Me.getAttribute("opaque") : "A_ONE",
                            data: hi(Me)
                        };
                        break
                }
            }
            return de
        }

        function hi(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"color":
                        de[Me.nodeName] = f(Me.textContent);
                        break;
                    case"float":
                        de[Me.nodeName] = parseFloat(Me.textContent);
                        break;
                    case"texture":
                        de[Me.nodeName] = {id: Me.getAttribute("texture"), extra: Vn(Me)};
                        break
                }
            }
            return de
        }

        function Vn(ce) {
            const de = {technique: {}};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"extra":
                        yi(Me, de);
                        break
                }
            }
            return de
        }

        function yi(ce, de) {
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"technique":
                        nr(Me, de);
                        break
                }
            }
        }

        function nr(ce, de) {
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"repeatU":
                    case"repeatV":
                    case"offsetU":
                    case"offsetV":
                        de.technique[Me.nodeName] = parseFloat(Me.textContent);
                        break;
                    case"wrapU":
                    case"wrapV":
                        Me.textContent.toUpperCase() === "TRUE" ? de.technique[Me.nodeName] = 1 : Me.textContent.toUpperCase() === "FALSE" ? de.technique[Me.nodeName] = 0 : de.technique[Me.nodeName] = parseInt(Me.textContent);
                        break;
                    case"bump":
                        de[Me.nodeName] = Ji(Me);
                        break
                }
            }
        }

        function Oi(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"technique":
                        de.technique = Rr(Me);
                        break
                }
            }
            return de
        }

        function Rr(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"double_sided":
                        de[Me.nodeName] = parseInt(Me.textContent);
                        break;
                    case"bump":
                        de[Me.nodeName] = Ji(Me);
                        break
                }
            }
            return de
        }

        function Ji(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"texture":
                        de[Me.nodeName] = {
                            id: Me.getAttribute("texture"),
                            texcoord: Me.getAttribute("texcoord"),
                            extra: Vn(Me)
                        };
                        break
                }
            }
            return de
        }

        function Pi(ce) {
            return ce
        }

        function Br(ce) {
            return C(et.effects[ce], Pi)
        }

        function cr(ce) {
            const de = {name: ce.getAttribute("name")};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"instance_effect":
                        de.url = m(Me.getAttribute("url"));
                        break
                }
            }
            et.materials[ce.getAttribute("id")] = de
        }

        function ss(ce) {
            let de, we = ce.slice((ce.lastIndexOf(".") - 1 >>> 0) + 2);
            switch (we = we.toLowerCase(), we) {
                case"tga":
                    de = Oe;
                    break;
                default:
                    de = xe
            }
            return de
        }

        function Nr(ce) {
            const de = Br(ce.url), we = de.profile.technique;
            let Ee;
            switch (we.type) {
                case"phong":
                case"blinn":
                    Ee = new am;
                    break;
                case"lambert":
                    Ee = new Bw;
                    break;
                default:
                    Ee = new Su;
                    break
            }
            Ee.name = ce.name || "";

            function Me(Ft, Jt = null) {
                const sn = de.profile.samplers[Ft.id];
                let Pt = null;
                if (sn !== void 0) {
                    const gn = de.profile.surfaces[sn.source];
                    Pt = gt(gn.init_from)
                } else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."), Pt = gt(Ft.id);
                if (Pt !== null) {
                    const gn = ss(Pt);
                    if (gn !== void 0) {
                        const un = gn.load(Pt), _n = Ft.extra;
                        if (_n !== void 0 && _n.technique !== void 0 && h(_n.technique) === !1) {
                            const yn = _n.technique;
                            un.wrapS = yn.wrapU ? Iu : Xl, un.wrapT = yn.wrapV ? Iu : Xl, un.offset.set(yn.offsetU || 0, yn.offsetV || 0), un.repeat.set(yn.repeatU || 1, yn.repeatV || 1)
                        } else un.wrapS = Iu, un.wrapT = Iu;
                        return Jt !== null && (un.colorSpace = Jt), un
                    } else return console.warn("THREE.ColladaLoader: Loader for texture %s not found.", Pt), null
                } else return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", Ft.id), null
            }

            const st = we.parameters;
            for (const Ft in st) {
                const Jt = st[Ft];
                switch (Ft) {
                    case"diffuse":
                        Jt.color && Ee.color.fromArray(Jt.color), Jt.texture && (Ee.map = Me(Jt.texture, ca));
                        break;
                    case"specular":
                        Jt.color && Ee.specular && Ee.specular.fromArray(Jt.color), Jt.texture && (Ee.specularMap = Me(Jt.texture));
                        break;
                    case"bump":
                        Jt.texture && (Ee.normalMap = Me(Jt.texture));
                        break;
                    case"ambient":
                        Jt.texture && (Ee.lightMap = Me(Jt.texture, ca));
                        break;
                    case"shininess":
                        Jt.float && Ee.shininess && (Ee.shininess = Jt.float);
                        break;
                    case"emission":
                        Jt.color && Ee.emissive && Ee.emissive.fromArray(Jt.color), Jt.texture && (Ee.emissiveMap = Me(Jt.texture, ca));
                        break
                }
            }
            Ee.color.convertSRGBToLinear(), Ee.specular && Ee.specular.convertSRGBToLinear(), Ee.emissive && Ee.emissive.convertSRGBToLinear();
            let ut = st.transparent, Vt = st.transparency;
            if (Vt === void 0 && ut && (Vt = {float: 1}), ut === void 0 && Vt && (ut = {
                opaque: "A_ONE",
                data: {color: [1, 1, 1, 1]}
            }), ut && Vt) if (ut.data.texture) Ee.transparent = !0; else {
                const Ft = ut.data.color;
                switch (ut.opaque) {
                    case"A_ONE":
                        Ee.opacity = Ft[3] * Vt.float;
                        break;
                    case"RGB_ZERO":
                        Ee.opacity = 1 - Ft[0] * Vt.float;
                        break;
                    case"A_ZERO":
                        Ee.opacity = 1 - Ft[3] * Vt.float;
                        break;
                    case"RGB_ONE":
                        Ee.opacity = Ft[0] * Vt.float;
                        break;
                    default:
                        console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', ut.opaque)
                }
                Ee.opacity < 1 && (Ee.transparent = !0)
            }
            if (we.extra !== void 0 && we.extra.technique !== void 0) {
                const Ft = we.extra.technique;
                for (const Jt in Ft) {
                    const sn = Ft[Jt];
                    switch (Jt) {
                        case"double_sided":
                            Ee.side = sn === 1 ? V3 : g0;
                            break;
                        case"bump":
                            Ee.normalMap = Me(sn.texture), Ee.normalScale = new es(1, 1);
                            break
                    }
                }
            }
            return Ee
        }

        function ir(ce) {
            return C(et.materials[ce], Nr)
        }

        function jt(ce) {
            const de = {name: ce.getAttribute("name")};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"optics":
                        de.optics = Se(Me);
                        break
                }
            }
            et.cameras[ce.getAttribute("id")] = de
        }

        function Se(ce) {
            for (let de = 0; de < ce.childNodes.length; de++) {
                const we = ce.childNodes[de];
                switch (we.nodeName) {
                    case"technique_common":
                        return _e(we)
                }
            }
            return {}
        }

        function _e(ce) {
            const de = {};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                switch (Ee.nodeName) {
                    case"perspective":
                    case"orthographic":
                        de.technique = Ee.nodeName, de.parameters = Ge(Ee);
                        break
                }
            }
            return de
        }

        function Ge(ce) {
            const de = {};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                switch (Ee.nodeName) {
                    case"xfov":
                    case"yfov":
                    case"xmag":
                    case"ymag":
                    case"znear":
                    case"zfar":
                    case"aspect_ratio":
                        de[Ee.nodeName] = parseFloat(Ee.textContent);
                        break
                }
            }
            return de
        }

        function Le(ce) {
            let de;
            switch (ce.optics.technique) {
                case"perspective":
                    de = new Bu(ce.optics.parameters.yfov, ce.optics.parameters.aspect_ratio, ce.optics.parameters.znear, ce.optics.parameters.zfar);
                    break;
                case"orthographic":
                    let we = ce.optics.parameters.ymag, Ee = ce.optics.parameters.xmag;
                    const Me = ce.optics.parameters.aspect_ratio;
                    Ee = Ee === void 0 ? we * Me : Ee, we = we === void 0 ? Ee / Me : we, Ee *= .5, we *= .5, de = new B1(-Ee, Ee, we, -we, ce.optics.parameters.znear, ce.optics.parameters.zfar);
                    break;
                default:
                    de = new Bu;
                    break
            }
            return de.name = ce.name || "", de
        }

        function Ue(ce) {
            const de = et.cameras[ce];
            return de !== void 0 ? C(de, Le) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", ce), null)
        }

        function Qe(ce) {
            let de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"technique_common":
                        de = oe(Me);
                        break
                }
            }
            et.lights[ce.getAttribute("id")] = de
        }

        function oe(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"directional":
                    case"point":
                    case"spot":
                    case"ambient":
                        de.technique = Me.nodeName, de.parameters = G(Me)
                }
            }
            return de
        }

        function G(ce) {
            const de = {};
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"color":
                        const st = f(Me.textContent);
                        de.color = new xs().fromArray(st).convertSRGBToLinear();
                        break;
                    case"falloff_angle":
                        de.falloffAngle = parseFloat(Me.textContent);
                        break;
                    case"quadratic_attenuation":
                        const ut = parseFloat(Me.textContent);
                        de.distance = ut ? Math.sqrt(1 / ut) : 0;
                        break
                }
            }
            return de
        }

        function X(ce) {
            let de;
            switch (ce.technique) {
                case"directional":
                    de = new kw;
                    break;
                case"point":
                    de = new y1;
                    break;
                case"spot":
                    de = new Ow;
                    break;
                case"ambient":
                    de = new Fw;
                    break
            }
            return ce.parameters.color && de.color.copy(ce.parameters.color), ce.parameters.distance && (de.distance = ce.parameters.distance), de
        }

        function ve(ce) {
            const de = et.lights[ce];
            return de !== void 0 ? C(de, X) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:", ce), null)
        }

        function Be(ce) {
            const de = {name: ce.getAttribute("name"), sources: {}, vertices: {}, primitives: []},
                we = o(ce, "mesh")[0];
            if (we !== void 0) {
                for (let Ee = 0; Ee < we.childNodes.length; Ee++) {
                    const Me = we.childNodes[Ee];
                    if (Me.nodeType !== 1) continue;
                    const st = Me.getAttribute("id");
                    switch (Me.nodeName) {
                        case"source":
                            de.sources[st] = je(Me);
                            break;
                        case"vertices":
                            de.vertices = tt(Me);
                            break;
                        case"polygons":
                            console.warn("THREE.ColladaLoader: Unsupported primitive type: ", Me.nodeName);
                            break;
                        case"lines":
                        case"linestrips":
                        case"polylist":
                        case"triangles":
                            de.primitives.push(Yt(Me));
                            break;
                        default:
                            console.log(Me)
                    }
                }
                et.geometries[ce.getAttribute("id")] = de
            }
        }

        function je(ce) {
            const de = {array: [], stride: 3};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"float_array":
                        de.array = f(Ee.textContent);
                        break;
                    case"Name_array":
                        de.array = c(Ee.textContent);
                        break;
                    case"technique_common":
                        const Me = o(Ee, "accessor")[0];
                        Me !== void 0 && (de.stride = parseInt(Me.getAttribute("stride")));
                        break
                }
            }
            return de
        }

        function tt(ce) {
            const de = {};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                Ee.nodeType === 1 && (de[Ee.getAttribute("semantic")] = m(Ee.getAttribute("source")))
            }
            return de
        }

        function Yt(ce) {
            const de = {
                type: ce.nodeName,
                material: ce.getAttribute("material"),
                count: parseInt(ce.getAttribute("count")),
                inputs: {},
                stride: 0,
                hasUV: !1
            };
            for (let we = 0, Ee = ce.childNodes.length; we < Ee; we++) {
                const Me = ce.childNodes[we];
                if (Me.nodeType === 1) switch (Me.nodeName) {
                    case"input":
                        const st = m(Me.getAttribute("source")), ut = Me.getAttribute("semantic"),
                            Vt = parseInt(Me.getAttribute("offset")), Ft = parseInt(Me.getAttribute("set")),
                            Jt = Ft > 0 ? ut + Ft : ut;
                        de.inputs[Jt] = {
                            id: st,
                            offset: Vt
                        }, de.stride = Math.max(de.stride, Vt + 1), ut === "TEXCOORD" && (de.hasUV = !0);
                        break;
                    case"vcount":
                        de.vcount = T(Me.textContent);
                        break;
                    case"p":
                        de.p = T(Me.textContent);
                        break
                }
            }
            return de
        }

        function cn(ce) {
            const de = {};
            for (let we = 0; we < ce.length; we++) {
                const Ee = ce[we];
                de[Ee.type] === void 0 && (de[Ee.type] = []), de[Ee.type].push(Ee)
            }
            return de
        }

        function $t(ce) {
            let de = 0;
            for (let we = 0, Ee = ce.length; we < Ee; we++) ce[we].hasUV === !0 && de++;
            de > 0 && de < ce.length && (ce.uvsNeedsFix = !0)
        }

        function en(ce) {
            const de = {}, we = ce.sources, Ee = ce.vertices, Me = ce.primitives;
            if (Me.length === 0) return {};
            const st = cn(Me);
            for (const ut in st) {
                const Vt = st[ut];
                $t(Vt), de[ut] = Sn(Vt, we, Ee)
            }
            return de
        }

        function Sn(ce, de, we) {
            const Ee = {}, Me = {array: [], stride: 0}, st = {array: [], stride: 0}, ut = {array: [], stride: 0},
                Vt = {array: [], stride: 0}, Ft = {array: [], stride: 0}, Jt = {array: [], stride: 4},
                sn = {array: [], stride: 4}, Pt = new il, gn = [];
            let un = 0;
            for (let _n = 0; _n < ce.length; _n++) {
                const yn = ce[_n], bi = yn.inputs;
                let Ii = 0;
                switch (yn.type) {
                    case"lines":
                    case"linestrips":
                        Ii = yn.count * 2;
                        break;
                    case"triangles":
                        Ii = yn.count * 3;
                        break;
                    case"polylist":
                        for (let _i = 0; _i < yn.count; _i++) {
                            const gi = yn.vcount[_i];
                            switch (gi) {
                                case 3:
                                    Ii += 3;
                                    break;
                                case 4:
                                    Ii += 6;
                                    break;
                                default:
                                    Ii += (gi - 2) * 3;
                                    break
                            }
                        }
                        break;
                    default:
                        console.warn("THREE.ColladaLoader: Unknow primitive type:", yn.type)
                }
                Pt.addGroup(un, Ii, _n), un += Ii, yn.material && gn.push(yn.material);
                for (const _i in bi) {
                    const gi = bi[_i];
                    switch (_i) {
                        case"VERTEX":
                            for (const Yr in we) {
                                const Mr = we[Yr];
                                switch (Yr) {
                                    case"POSITION":
                                        const _s = Me.array.length;
                                        if (Gi(yn, de[Mr], gi.offset, Me.array), Me.stride = de[Mr].stride, de.skinWeights && de.skinIndices && (Gi(yn, de.skinIndices, gi.offset, Jt.array), Gi(yn, de.skinWeights, gi.offset, sn.array)), yn.hasUV === !1 && ce.uvsNeedsFix === !0) {
                                            const ha = (Me.array.length - _s) / Me.stride;
                                            for (let jo = 0; jo < ha; jo++) ut.array.push(0, 0)
                                        }
                                        break;
                                    case"NORMAL":
                                        Gi(yn, de[Mr], gi.offset, st.array), st.stride = de[Mr].stride;
                                        break;
                                    case"COLOR":
                                        Gi(yn, de[Mr], gi.offset, Ft.array), Ft.stride = de[Mr].stride;
                                        break;
                                    case"TEXCOORD":
                                        Gi(yn, de[Mr], gi.offset, ut.array), ut.stride = de[Mr].stride;
                                        break;
                                    case"TEXCOORD1":
                                        Gi(yn, de[Mr], gi.offset, Vt.array), ut.stride = de[Mr].stride;
                                        break;
                                    default:
                                        console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', Yr)
                                }
                            }
                            break;
                        case"NORMAL":
                            Gi(yn, de[gi.id], gi.offset, st.array), st.stride = de[gi.id].stride;
                            break;
                        case"COLOR":
                            Gi(yn, de[gi.id], gi.offset, Ft.array, !0), Ft.stride = de[gi.id].stride;
                            break;
                        case"TEXCOORD":
                            Gi(yn, de[gi.id], gi.offset, ut.array), ut.stride = de[gi.id].stride;
                            break;
                        case"TEXCOORD1":
                            Gi(yn, de[gi.id], gi.offset, Vt.array), Vt.stride = de[gi.id].stride;
                            break
                    }
                }
            }
            return Me.array.length > 0 && Pt.setAttribute("position", new Cs(Me.array, Me.stride)), st.array.length > 0 && Pt.setAttribute("normal", new Cs(st.array, st.stride)), Ft.array.length > 0 && Pt.setAttribute("color", new Cs(Ft.array, Ft.stride)), ut.array.length > 0 && Pt.setAttribute("uv", new Cs(ut.array, ut.stride)), Vt.array.length > 0 && Pt.setAttribute("uv1", new Cs(Vt.array, Vt.stride)), Jt.array.length > 0 && Pt.setAttribute("skinIndex", new Cs(Jt.array, Jt.stride)), sn.array.length > 0 && Pt.setAttribute("skinWeight", new Cs(sn.array, sn.stride)), Ee.data = Pt, Ee.type = ce[0].type, Ee.materialKeys = gn, Ee
        }

        function Gi(ce, de, we, Ee, Me = !1) {
            const st = ce.p, ut = ce.stride, Vt = ce.vcount;

            function Ft(Pt) {
                let gn = st[Pt + we] * sn;
                const un = gn + sn;
                for (; gn < un; gn++) Ee.push(Jt[gn]);
                if (Me) {
                    const _n = Ee.length - sn - 1;
                    Ze.setRGB(Ee[_n + 0], Ee[_n + 1], Ee[_n + 2]).convertSRGBToLinear(), Ee[_n + 0] = Ze.r, Ee[_n + 1] = Ze.g, Ee[_n + 2] = Ze.b
                }
            }

            const Jt = de.array, sn = de.stride;
            if (ce.vcount !== void 0) {
                let Pt = 0;
                for (let gn = 0, un = Vt.length; gn < un; gn++) {
                    const _n = Vt[gn];
                    if (_n === 4) {
                        const yn = Pt + ut * 0, bi = Pt + ut * 1, Ii = Pt + ut * 2, _i = Pt + ut * 3;
                        Ft(yn), Ft(bi), Ft(_i), Ft(bi), Ft(Ii), Ft(_i)
                    } else if (_n === 3) {
                        const yn = Pt + ut * 0, bi = Pt + ut * 1, Ii = Pt + ut * 2;
                        Ft(yn), Ft(bi), Ft(Ii)
                    } else if (_n > 4) for (let yn = 1, bi = _n - 2; yn <= bi; yn++) {
                        const Ii = Pt + ut * 0, _i = Pt + ut * yn, gi = Pt + ut * (yn + 1);
                        Ft(Ii), Ft(_i), Ft(gi)
                    }
                    Pt += ut * _n
                }
            } else for (let Pt = 0, gn = st.length; Pt < gn; Pt += ut) Ft(Pt)
        }

        function qn(ce) {
            return C(et.geometries[ce], en)
        }

        function fr(ce) {
            const de = {name: ce.getAttribute("name") || "", joints: {}, links: []};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"technique_common":
                        co(Ee, de);
                        break
                }
            }
            et.kinematicsModels[ce.getAttribute("id")] = de
        }

        function Vi(ce) {
            return ce.build !== void 0 ? ce.build : ce
        }

        function Zi(ce) {
            return C(et.kinematicsModels[ce], Vi)
        }

        function co(ce, de) {
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"joint":
                        de.joints[Ee.getAttribute("sid")] = pr(Ee);
                        break;
                    case"link":
                        de.links.push(Or(Ee));
                        break
                }
            }
        }

        function pr(ce) {
            let de;
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"prismatic":
                    case"revolute":
                        de = $s(Ee);
                        break
                }
            }
            return de
        }

        function $s(ce) {
            const de = {
                sid: ce.getAttribute("sid"),
                name: ce.getAttribute("name") || "",
                axis: new ft,
                limits: {min: 0, max: 0},
                type: ce.nodeName,
                static: !1,
                zeroPosition: 0,
                middlePosition: 0
            };
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"axis":
                        const Me = f(Ee.textContent);
                        de.axis.fromArray(Me);
                        break;
                    case"limits":
                        const st = Ee.getElementsByTagName("max")[0], ut = Ee.getElementsByTagName("min")[0];
                        de.limits.max = parseFloat(st.textContent), de.limits.min = parseFloat(ut.textContent);
                        break
                }
            }
            return de.limits.min >= de.limits.max && (de.static = !0), de.middlePosition = (de.limits.min + de.limits.max) / 2, de
        }

        function Or(ce) {
            const de = {
                sid: ce.getAttribute("sid"),
                name: ce.getAttribute("name") || "",
                attachments: [],
                transforms: []
            };
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"attachment_full":
                        de.attachments.push(ws(Ee));
                        break;
                    case"matrix":
                    case"translate":
                    case"rotate":
                        de.transforms.push(Eo(Ee));
                        break
                }
            }
            return de
        }

        function ws(ce) {
            const de = {joint: ce.getAttribute("joint").split("/").pop(), transforms: [], links: []};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"link":
                        de.links.push(Or(Ee));
                        break;
                    case"matrix":
                    case"translate":
                    case"rotate":
                        de.transforms.push(Eo(Ee));
                        break
                }
            }
            return de
        }

        function Eo(ce) {
            const de = {type: ce.nodeName}, we = f(ce.textContent);
            switch (de.type) {
                case"matrix":
                    de.obj = new $n, de.obj.fromArray(we).transpose();
                    break;
                case"translate":
                    de.obj = new ft, de.obj.fromArray(we);
                    break;
                case"rotate":
                    de.obj = new ft, de.obj.fromArray(we), de.angle = Js.degToRad(we[3]);
                    break
            }
            return de
        }

        function bs(ce) {
            const de = {name: ce.getAttribute("name") || "", rigidBodies: {}};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"rigid_body":
                        de.rigidBodies[Ee.getAttribute("name")] = {}, kr(Ee, de.rigidBodies[Ee.getAttribute("name")]);
                        break
                }
            }
            et.physicsModels[ce.getAttribute("id")] = de
        }

        function kr(ce, de) {
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"technique_common":
                        Hi(Ee, de);
                        break
                }
            }
        }

        function Hi(ce, de) {
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"inertia":
                        de.inertia = f(Ee.textContent);
                        break;
                    case"mass":
                        de.mass = f(Ee.textContent)[0];
                        break
                }
            }
        }

        function Qr(ce) {
            const de = {bindJointAxis: []};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"bind_joint_axis":
                        de.bindJointAxis.push(ua(Ee));
                        break
                }
            }
            et.kinematicsScenes[m(ce.getAttribute("url"))] = de
        }

        function ua(ce) {
            const de = {target: ce.getAttribute("target").split("/").pop()};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType === 1) switch (Ee.nodeName) {
                    case"axis":
                        const Me = Ee.getElementsByTagName("param")[0];
                        de.axis = Me.textContent;
                        const st = de.axis.split("inst_").pop().split("axis")[0];
                        de.jointIndex = st.substring(0, st.length - 1);
                        break
                }
            }
            return de
        }

        function xo(ce) {
            return ce.build !== void 0 ? ce.build : ce
        }

        function Ea(ce) {
            return C(et.kinematicsScenes[ce], xo)
        }

        function Qo() {
            const ce = Object.keys(et.kinematicsModels)[0], de = Object.keys(et.kinematicsScenes)[0],
                we = Object.keys(et.visualScenes)[0];
            if (ce === void 0 || de === void 0) return;
            const Ee = Zi(ce), Me = Ea(de), st = yr(we), ut = Me.bindJointAxis, Vt = {};
            for (let sn = 0, Pt = ut.length; sn < Pt; sn++) {
                const gn = ut[sn], un = ri.querySelector('[sid="' + gn.target + '"]');
                if (un) {
                    const _n = un.parentElement;
                    Ft(gn.jointIndex, _n)
                }
            }

            function Ft(sn, Pt) {
                const gn = Pt.getAttribute("name"), un = Ee.joints[sn];
                st.traverse(function (_n) {
                    _n.name === gn && (Vt[sn] = {object: _n, transforms: De(Pt), joint: un, position: un.zeroPosition})
                })
            }

            const Jt = new $n;
            wt = {
                joints: Ee && Ee.joints, getJointValue: function (sn) {
                    const Pt = Vt[sn];
                    if (Pt) return Pt.position;
                    console.warn("THREE.ColladaLoader: Joint " + sn + " doesn't exist.")
                }, setJointValue: function (sn, Pt) {
                    const gn = Vt[sn];
                    if (gn) {
                        const un = gn.joint;
                        if (Pt > un.limits.max || Pt < un.limits.min) console.warn("THREE.ColladaLoader: Joint " + sn + " value " + Pt + " outside of limits (min: " + un.limits.min + ", max: " + un.limits.max + ")."); else if (un.static) console.warn("THREE.ColladaLoader: Joint " + sn + " is static."); else {
                            const _n = gn.object, yn = un.axis, bi = gn.transforms;
                            rt.identity();
                            for (let Ii = 0; Ii < bi.length; Ii++) {
                                const _i = bi[Ii];
                                if (_i.sid && _i.sid.indexOf(sn) !== -1) switch (un.type) {
                                    case"revolute":
                                        rt.multiply(Jt.makeRotationAxis(yn, Js.degToRad(Pt)));
                                        break;
                                    case"prismatic":
                                        rt.multiply(Jt.makeTranslation(yn.x * Pt, yn.y * Pt, yn.z * Pt));
                                        break;
                                    default:
                                        console.warn("THREE.ColladaLoader: Unknown joint type: " + un.type);
                                        break
                                } else switch (_i.type) {
                                    case"matrix":
                                        rt.multiply(_i.obj);
                                        break;
                                    case"translate":
                                        rt.multiply(Jt.makeTranslation(_i.obj.x, _i.obj.y, _i.obj.z));
                                        break;
                                    case"scale":
                                        rt.scale(_i.obj);
                                        break;
                                    case"rotate":
                                        rt.multiply(Jt.makeRotationAxis(_i.obj, _i.angle));
                                        break
                                }
                            }
                            _n.matrix.copy(rt), _n.matrix.decompose(_n.position, _n.quaternion, _n.scale), Vt[sn].position = Pt
                        }
                    } else console.log("THREE.ColladaLoader: " + sn + " does not exist.")
                }
            }
        }

        function De(ce) {
            const de = [], we = ri.querySelector('[id="' + ce.id + '"]');
            for (let Ee = 0; Ee < we.childNodes.length; Ee++) {
                const Me = we.childNodes[Ee];
                if (Me.nodeType !== 1) continue;
                let st, ut;
                switch (Me.nodeName) {
                    case"matrix":
                        st = f(Me.textContent);
                        const Vt = new $n().fromArray(st).transpose();
                        de.push({sid: Me.getAttribute("sid"), type: Me.nodeName, obj: Vt});
                        break;
                    case"translate":
                    case"scale":
                        st = f(Me.textContent), ut = new ft().fromArray(st), de.push({
                            sid: Me.getAttribute("sid"),
                            type: Me.nodeName,
                            obj: ut
                        });
                        break;
                    case"rotate":
                        st = f(Me.textContent), ut = new ft().fromArray(st);
                        const Ft = Js.degToRad(st[3]);
                        de.push({sid: Me.getAttribute("sid"), type: Me.nodeName, obj: ut, angle: Ft});
                        break
                }
            }
            return de
        }

        function Ke(ce) {
            const de = ce.getElementsByTagName("node");
            for (let we = 0; we < de.length; we++) {
                const Ee = de[we];
                Ee.hasAttribute("id") === !1 && Ee.setAttribute("id", x())
            }
        }

        const rt = new $n, Ct = new ft;

        function dt(ce) {
            const de = {
                name: ce.getAttribute("name") || "",
                type: ce.getAttribute("type"),
                id: ce.getAttribute("id"),
                sid: ce.getAttribute("sid"),
                matrix: new $n,
                nodes: [],
                instanceCameras: [],
                instanceControllers: [],
                instanceLights: [],
                instanceGeometries: [],
                instanceNodes: [],
                transforms: {}
            };
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                if (Ee.nodeType !== 1) continue;
                let Me;
                switch (Ee.nodeName) {
                    case"node":
                        de.nodes.push(Ee.getAttribute("id")), dt(Ee);
                        break;
                    case"instance_camera":
                        de.instanceCameras.push(m(Ee.getAttribute("url")));
                        break;
                    case"instance_controller":
                        de.instanceControllers.push(Lt(Ee));
                        break;
                    case"instance_light":
                        de.instanceLights.push(m(Ee.getAttribute("url")));
                        break;
                    case"instance_geometry":
                        de.instanceGeometries.push(Lt(Ee));
                        break;
                    case"instance_node":
                        de.instanceNodes.push(m(Ee.getAttribute("url")));
                        break;
                    case"matrix":
                        Me = f(Ee.textContent), de.matrix.multiply(rt.fromArray(Me).transpose()), de.transforms[Ee.getAttribute("sid")] = Ee.nodeName;
                        break;
                    case"translate":
                        Me = f(Ee.textContent), Ct.fromArray(Me), de.matrix.multiply(rt.makeTranslation(Ct.x, Ct.y, Ct.z)), de.transforms[Ee.getAttribute("sid")] = Ee.nodeName;
                        break;
                    case"rotate":
                        Me = f(Ee.textContent);
                        const st = Js.degToRad(Me[3]);
                        de.matrix.multiply(rt.makeRotationAxis(Ct.fromArray(Me), st)), de.transforms[Ee.getAttribute("sid")] = Ee.nodeName;
                        break;
                    case"scale":
                        Me = f(Ee.textContent), de.matrix.scale(Ct.fromArray(Me)), de.transforms[Ee.getAttribute("sid")] = Ee.nodeName;
                        break;
                    case"extra":
                        break;
                    default:
                        console.log(Ee)
                }
            }
            return Wn(de.id) ? console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", de.id) : et.nodes[de.id] = de, de
        }

        function Lt(ce) {
            const de = {id: m(ce.getAttribute("url")), materials: {}, skeletons: []};
            for (let we = 0; we < ce.childNodes.length; we++) {
                const Ee = ce.childNodes[we];
                switch (Ee.nodeName) {
                    case"bind_material":
                        const Me = Ee.getElementsByTagName("instance_material");
                        for (let st = 0; st < Me.length; st++) {
                            const ut = Me[st], Vt = ut.getAttribute("symbol"), Ft = ut.getAttribute("target");
                            de.materials[Vt] = m(Ft)
                        }
                        break;
                    case"skeleton":
                        de.skeletons.push(m(Ee.textContent));
                        break
                }
            }
            return de
        }

        function Kt(ce, de) {
            const we = [], Ee = [];
            let Me, st, ut;
            for (Me = 0; Me < ce.length; Me++) {
                const Jt = ce[Me];
                let sn;
                if (Wn(Jt)) sn = Wi(Jt), Rn(sn, de, we); else if (ki(Jt)) {
                    const gn = et.visualScenes[Jt].children;
                    for (let un = 0; un < gn.length; un++) {
                        const _n = gn[un];
                        if (_n.type === "JOINT") {
                            const yn = Wi(_n.id);
                            Rn(yn, de, we)
                        }
                    }
                } else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", Jt)
            }
            for (Me = 0; Me < de.length; Me++) for (st = 0; st < we.length; st++) if (ut = we[st], ut.bone.name === de[Me].name) {
                Ee[Me] = ut, ut.processed = !0;
                break
            }
            for (Me = 0; Me < we.length; Me++) ut = we[Me], ut.processed === !1 && (Ee.push(ut), ut.processed = !0);
            const Vt = [], Ft = [];
            for (Me = 0; Me < Ee.length; Me++) ut = Ee[Me], Vt.push(ut.bone), Ft.push(ut.boneInverse);
            return new B0(Vt, Ft)
        }

        function Rn(ce, de, we) {
            ce.traverse(function (Ee) {
                if (Ee.isBone === !0) {
                    let Me;
                    for (let st = 0; st < de.length; st++) {
                        const ut = de[st];
                        if (ut.name === Ee.name) {
                            Me = ut.boneInverse;
                            break
                        }
                    }
                    Me === void 0 && (Me = new $n), we.push({bone: Ee, boneInverse: Me, processed: !1})
                }
            })
        }

        function xn(ce) {
            const de = [], we = ce.matrix, Ee = ce.nodes, Me = ce.type, st = ce.instanceCameras,
                ut = ce.instanceControllers, Vt = ce.instanceLights, Ft = ce.instanceGeometries, Jt = ce.instanceNodes;
            for (let Pt = 0, gn = Ee.length; Pt < gn; Pt++) de.push(Wi(Ee[Pt]));
            for (let Pt = 0, gn = st.length; Pt < gn; Pt++) {
                const un = Ue(st[Pt]);
                un !== null && de.push(un.clone())
            }
            for (let Pt = 0, gn = ut.length; Pt < gn; Pt++) {
                const un = ut[Pt], _n = Ve(un.id), yn = qn(_n.id), bi = jn(yn, un.materials), Ii = un.skeletons,
                    _i = _n.skin.joints, gi = Kt(Ii, _i);
                for (let Yr = 0, Mr = bi.length; Yr < Mr; Yr++) {
                    const _s = bi[Yr];
                    _s.isSkinnedMesh && (_s.bind(gi, _n.skin.bindMatrix), _s.normalizeSkinWeights()), de.push(_s)
                }
            }
            for (let Pt = 0, gn = Vt.length; Pt < gn; Pt++) {
                const un = ve(Vt[Pt]);
                un !== null && de.push(un.clone())
            }
            for (let Pt = 0, gn = Ft.length; Pt < gn; Pt++) {
                const un = Ft[Pt], _n = qn(un.id), yn = jn(_n, un.materials);
                for (let bi = 0, Ii = yn.length; bi < Ii; bi++) de.push(yn[bi])
            }
            for (let Pt = 0, gn = Jt.length; Pt < gn; Pt++) de.push(Wi(Jt[Pt]).clone());
            let sn;
            if (Ee.length === 0 && de.length === 1) sn = de[0]; else {
                sn = Me === "JOINT" ? new x0 : new hm;
                for (let Pt = 0; Pt < de.length; Pt++) sn.add(de[Pt])
            }
            return sn.name = Me === "JOINT" ? ce.sid : ce.name, sn.matrix.copy(we), sn.matrix.decompose(sn.position, sn.quaternion, sn.scale), sn
        }

        const Dt = new Su({name: Yl.DEFAULT_MATERIAL_NAME, color: 16711935});

        function Hn(ce, de) {
            const we = [];
            for (let Ee = 0, Me = ce.length; Ee < Me; Ee++) {
                const st = de[ce[Ee]];
                st === void 0 ? (console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", ce[Ee]), we.push(Dt)) : we.push(ir(st))
            }
            return we
        }

        function jn(ce, de) {
            const we = [];
            for (const Ee in ce) {
                const Me = ce[Ee], st = Hn(Me.materialKeys, de);
                if (st.length === 0 && (Ee === "lines" || Ee === "linestrips" ? st.push(new dm) : st.push(new am)), Ee === "lines" || Ee === "linestrips") for (let Jt = 0, sn = st.length; Jt < sn; Jt++) {
                    const Pt = st[Jt];
                    if (Pt.isMeshPhongMaterial === !0 || Pt.isMeshLambertMaterial === !0) {
                        const gn = new dm;
                        gn.color.copy(Pt.color), gn.opacity = Pt.opacity, gn.transparent = Pt.transparent, st[Jt] = gn
                    }
                }
                const ut = Me.data.attributes.skinIndex !== void 0, Vt = st.length === 1 ? st[0] : st;
                let Ft;
                switch (Ee) {
                    case"lines":
                        Ft = new WS(Me.data, Vt);
                        break;
                    case"linestrips":
                        Ft = new L0(Me.data, Vt);
                        break;
                    case"triangles":
                    case"polylist":
                        ut ? Ft = new Mw(Me.data, Vt) : Ft = new Tu(Me.data, Vt);
                        break
                }
                we.push(Ft)
            }
            return we
        }

        function Wn(ce) {
            return et.nodes[ce] !== void 0
        }

        function Wi(ce) {
            return C(et.nodes[ce], xn)
        }

        function li(ce) {
            const de = {name: ce.getAttribute("name"), children: []};
            Ke(ce);
            const we = o(ce, "node");
            for (let Ee = 0; Ee < we.length; Ee++) de.children.push(dt(we[Ee]));
            et.visualScenes[ce.getAttribute("id")] = de
        }

        function mi(ce) {
            const de = new hm;
            de.name = ce.name;
            const we = ce.children;
            for (let Ee = 0; Ee < we.length; Ee++) {
                const Me = we[Ee];
                de.add(Wi(Me.id))
            }
            return de
        }

        function ki(ce) {
            return et.visualScenes[ce] !== void 0
        }

        function yr(ce) {
            return C(et.visualScenes[ce], mi)
        }

        function Ur(ce) {
            const de = o(ce, "instance_visual_scene")[0];
            return yr(m(de.getAttribute("url")))
        }

        function Cn() {
            const ce = et.clips;
            if (h(ce) === !0) {
                if (h(et.animations) === !1) {
                    const de = [];
                    for (const we in et.animations) {
                        const Ee = I(we);
                        for (let Me = 0, st = Ee.length; Me < st; Me++) de.push(Ee[Me])
                    }
                    at.push(new v1("default", -1, de))
                }
            } else for (const de in ce) at.push(Z(de))
        }

        function Ai(ce) {
            let de = "";
            const we = [ce];
            for (; we.length;) {
                const Ee = we.shift();
                Ee.nodeType === Node.TEXT_NODE ? de += Ee.textContent : (de += `
`, we.push.apply(we, Ee.childNodes))
            }
            return de.trim()
        }

        if (t.length === 0) return {scene: new HS};
        const _r = new DOMParser().parseFromString(t, "application/xml"), ri = o(_r, "COLLADA")[0],
            $ = _r.getElementsByTagName("parsererror")[0];
        if ($ !== void 0) {
            const ce = o($, "div")[0];
            let de;
            return ce ? de = ce.textContent : de = Ai($), console.error(`THREE.ColladaLoader: Failed to parse collada file.
`, de), null
        }
        const re = ri.getAttribute("version");
        console.debug("THREE.ColladaLoader: File version", re);
        const Ae = g(o(ri, "asset")[0]), xe = new Pw(this.manager);
        xe.setPath(this.resourcePath || i).setCrossOrigin(this.crossOrigin);
        let Oe;
        x2 && (Oe = new x2(this.manager), Oe.setPath(this.resourcePath || i));
        const Ze = new xs, at = [];
        let wt = {}, kt = 0;
        const et = {
            animations: {},
            clips: {},
            controllers: {},
            images: {},
            effects: {},
            materials: {},
            cameras: {},
            lights: {},
            geometries: {},
            nodes: {},
            visualScenes: {},
            kinematicsModels: {},
            physicsModels: {},
            kinematicsScenes: {}
        };
        E(ri, "library_animations", "animation", M), E(ri, "library_animation_clips", "animation_clip", ue), E(ri, "library_controllers", "controller", H), E(ri, "library_images", "image", He), E(ri, "library_effects", "effect", Bt), E(ri, "library_materials", "material", cr), E(ri, "library_cameras", "camera", jt), E(ri, "library_lights", "light", Qe), E(ri, "library_geometries", "geometry", Be), E(ri, "library_nodes", "node", dt), E(ri, "library_visual_scenes", "visual_scene", li), E(ri, "library_kinematics_models", "kinematics_model", fr), E(ri, "library_physics_models", "physics_model", bs), E(ri, "scene", "instance_kinematics_scene", Qr), p(et.animations, R), p(et.clips, he), p(et.controllers, Re), p(et.images, ot), p(et.effects, Pi), p(et.materials, Nr), p(et.cameras, Le), p(et.lights, X), p(et.geometries, en), p(et.visualScenes, mi), Cn(), Qo();
        const _t = Ur(o(ri, "scene")[0]);
        return _t.animations = at, Ae.upAxis === "Z_UP" && (console.warn("THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289."), _t.rotation.set(-Math.PI / 2, 0, 0)), _t.scale.multiplyScalar(Ae.unit), {
            get animations() {
                return console.warn("THREE.ColladaLoader: Please access animations over scene.animations now."), at
            }, kinematics: wt, library: et, scene: _t
        }
    }
}

THREE.ColladaLoader = kT;
AFRAME.registerComponent("collada-model-legacy", {
    schema: {type: "asset"}, init: function () {
        this.model = null, this.loader = new THREE.ColladaLoader
    }, update: function () {
        var A = this, t = this.el, i = this.data, o = this.el.sceneEl.systems.renderer;
        i && (this.remove(), this.loader.load(i, function (c) {
            A.model = c.scene, A.model.traverse(function (f) {
                if (f.isMesh) {
                    var T = f.material;
                    T.color && o.applyColorCorrection(T.color), T.map && o.applyColorCorrection(T.map), T.emissive && o.applyColorCorrection(T.emissive), T.emissiveMap && o.applyColorCorrection(T.emissiveMap)
                }
            }), t.setObject3D("mesh", A.model), t.emit("model-loaded", {format: "collada", model: A.model})
        }))
    }, remove: function () {
        this.model && this.el.removeObject3D("mesh")
    }
});/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/
var nl = Uint8Array, of = Uint16Array, FT = Int32Array,
    Uw = new nl([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
    zw = new nl([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
    NT = new nl([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Gw = function (A, t) {
        for (var i = new of(31), o = 0; o < 31; ++o) i[o] = t += 1 << A[o - 1];
        for (var c = new FT(i[30]), o = 1; o < 30; ++o) for (var f = i[o]; f < i[o + 1]; ++f) c[f] = f - i[o] << 5 | o;
        return {b: i, r: c}
    }, Vw = Gw(Uw, 2), Hw = Vw.b, UT = Vw.r;
Hw[28] = 258, UT[258] = 28;
var zT = Gw(zw, 0), GT = zT.b, E1 = new of(32768);
for (var $r = 0; $r < 32768; ++$r) {
    var bu = ($r & 43690) >> 1 | ($r & 21845) << 1;
    bu = (bu & 52428) >> 2 | (bu & 13107) << 2, bu = (bu & 61680) >> 4 | (bu & 3855) << 4, E1[$r] = ((bu & 65280) >> 8 | (bu & 255) << 8) >> 1
}
var lm = function (A, t, i) {
    for (var o = A.length, c = 0, f = new of(t); c < o; ++c) A[c] && ++f[A[c] - 1];
    var T = new of(t);
    for (c = 1; c < t; ++c) T[c] = T[c - 1] + f[c - 1] << 1;
    var m;
    if (i) {
        m = new of(1 << t);
        var x = 15 - t;
        for (c = 0; c < o; ++c) if (A[c]) for (var h = c << 4 | A[c], g = t - A[c], w = T[A[c] - 1]++ << g, v = w | (1 << g) - 1; w <= v; ++w) m[E1[w] >> x] = h
    } else for (m = new of(o), c = 0; c < o; ++c) A[c] && (m[c] = E1[T[A[c] - 1]++] >> 15 - A[c]);
    return m
}, Em = new nl(288);
for (var $r = 0; $r < 144; ++$r) Em[$r] = 8;
for (var $r = 144; $r < 256; ++$r) Em[$r] = 9;
for (var $r = 256; $r < 280; ++$r) Em[$r] = 7;
for (var $r = 280; $r < 288; ++$r) Em[$r] = 8;
var Qw = new nl(32);
for (var $r = 0; $r < 32; ++$r) Qw[$r] = 5;
var VT = lm(Em, 9, 1), HT = lm(Qw, 5, 1), Vy = function (A) {
        for (var t = A[0], i = 1; i < A.length; ++i) A[i] > t && (t = A[i]);
        return t
    }, xl = function (A, t, i) {
        var o = t / 8 | 0;
        return (A[o] | A[o + 1] << 8) >> (t & 7) & i
    }, Hy = function (A, t) {
        var i = t / 8 | 0;
        return (A[i] | A[i + 1] << 8 | A[i + 2] << 16) >> (t & 7)
    }, QT = function (A) {
        return (A + 7) / 8 | 0
    }, jT = function (A, t, i) {
        return (i == null || i > A.length) && (i = A.length), new nl(A.subarray(t, i))
    },
    WT = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"],
    Cl = function (A, t, i) {
        var o = new Error(t || WT[A]);
        if (o.code = A, Error.captureStackTrace && Error.captureStackTrace(o, Cl), !i) throw o;
        return o
    }, KT = function (A, t, i, o) {
        var c = A.length, f = 0;
        if (!c || t.f && !t.l) return i || new nl(0);
        var T = !i, m = T || t.i != 2, x = t.i;
        T && (i = new nl(c * 3));
        var h = function (an) {
            var En = i.length;
            if (an > En) {
                var Nn = new nl(Math.max(En * 2, an));
                Nn.set(i), i = Nn
            }
        }, g = t.f || 0, w = t.p || 0, v = t.b || 0, E = t.l, p = t.d, C = t.m, M = t.n, b = c * 8;
        do {
            if (!E) {
                g = xl(A, w, 1);
                var B = xl(A, w + 1, 3);
                if (w += 3, B) if (B == 1) E = VT, p = HT, C = 9, M = 5; else if (B == 2) {
                    var O = xl(A, w, 31) + 257, N = xl(A, w + 10, 15) + 4, F = O + xl(A, w + 5, 31) + 1;
                    w += 14;
                    for (var V = new nl(F), U = new nl(19), j = 0; j < N; ++j) U[NT[j]] = xl(A, w + j * 3, 7);
                    w += N * 3;
                    for (var Y = Vy(U), fe = (1 << Y) - 1, se = lm(U, Y, 1), j = 0; j < F;) {
                        var pe = se[xl(A, w, fe)];
                        w += pe & 15;
                        var R = pe >> 4;
                        if (R < 16) V[j++] = R; else {
                            var ue = 0, he = 0;
                            for (R == 16 ? (he = 3 + xl(A, w, 3), w += 2, ue = V[j - 1]) : R == 17 ? (he = 3 + xl(A, w, 7), w += 3) : R == 18 && (he = 11 + xl(A, w, 127), w += 7); he--;) V[j++] = ue
                        }
                    }
                    var Z = V.subarray(0, O), H = V.subarray(O);
                    C = Vy(Z), M = Vy(H), E = lm(Z, C, 1), p = lm(H, M, 1)
                } else Cl(1); else {
                    var R = QT(w) + 4, I = A[R - 4] | A[R - 3] << 8, L = R + I;
                    if (L > c) {
                        x && Cl(0);
                        break
                    }
                    m && h(v + I), i.set(A.subarray(R, L), v), t.b = v += I, t.p = w = L * 8, t.f = g;
                    continue
                }
                if (w > b) {
                    x && Cl(0);
                    break
                }
            }
            m && h(v + 131072);
            for (var ae = (1 << C) - 1, ee = (1 << M) - 1, me = w; ; me = w) {
                var ue = E[Hy(A, w) & ae], Re = ue >> 4;
                if (w += ue & 15, w > b) {
                    x && Cl(0);
                    break
                }
                if (ue || Cl(2), Re < 256) i[v++] = Re; else if (Re == 256) {
                    me = w, E = null;
                    break
                } else {
                    var ke = Re - 254;
                    if (Re > 264) {
                        var j = Re - 257, Ve = Uw[j];
                        ke = xl(A, w, (1 << Ve) - 1) + Hw[j], w += Ve
                    }
                    var He = p[Hy(A, w) & ee], ot = He >> 4;
                    He || Cl(3), w += He & 15;
                    var H = GT[ot];
                    if (ot > 3) {
                        var Ve = zw[ot];
                        H += Hy(A, w) & (1 << Ve) - 1, w += Ve
                    }
                    if (w > b) {
                        x && Cl(0);
                        break
                    }
                    m && h(v + 131072);
                    var gt = v + ke;
                    if (v < H) {
                        var Bt = f - H, Rt = Math.min(H, gt);
                        for (Bt + v < 0 && Cl(3); v < Rt; ++v) i[v] = o[Bt + v]
                    }
                    for (; v < gt; ++v) i[v] = i[v - H]
                }
            }
            t.l = E, t.p = me, t.b = v, t.f = g, E && (g = 1, t.m = C, t.d = p, t.n = M)
        } while (!g);
        return v != i.length && T ? jT(i, 0, v) : i.subarray(0, v)
    }, XT = new nl(0), YT = function (A, t) {
        return ((A[0] & 15) != 8 || A[0] >> 4 > 7 || (A[0] << 8 | A[1]) % 31) && Cl(6, "invalid zlib data"), (A[1] >> 5 & 1) == +!t && Cl(6, "invalid zlib data: " + (A[1] & 32 ? "need" : "unexpected") + " dictionary"), (A[1] >> 3 & 4) + 2
    };

function qT(A, t) {
    return KT(A.subarray(YT(A, t), -4), {i: 2}, t, t)
}

var JT = typeof TextDecoder < "u" && new TextDecoder, ZT = 0;
try {
    JT.decode(XT, {stream: !0}), ZT = 1
} catch {
}

function jw(A, t, i) {
    const o = i.length - A - 1;
    if (t >= i[o]) return o - 1;
    if (t <= i[A]) return A;
    let c = A, f = o, T = Math.floor((c + f) / 2);
    for (; t < i[T] || t >= i[T + 1];) t < i[T] ? f = T : c = T, T = Math.floor((c + f) / 2);
    return T
}

function $T(A, t, i, o) {
    const c = [], f = [], T = [];
    c[0] = 1;
    for (let m = 1; m <= i; ++m) {
        f[m] = t - o[A + 1 - m], T[m] = o[A + m] - t;
        let x = 0;
        for (let h = 0; h < m; ++h) {
            const g = T[h + 1], w = f[m - h], v = c[h] / (g + w);
            c[h] = x + g * v, x = w * v
        }
        c[m] = x
    }
    return c
}

function eI(A, t, i, o) {
    const c = jw(A, o, t), f = $T(c, o, A, t), T = new Zs(0, 0, 0, 0);
    for (let m = 0; m <= A; ++m) {
        const x = i[c - A + m], h = f[m], g = x.w * h;
        T.x += x.x * g, T.y += x.y * g, T.z += x.z * g, T.w += x.w * h
    }
    return T
}

function tI(A, t, i, o, c) {
    const f = [];
    for (let w = 0; w <= i; ++w) f[w] = 0;
    const T = [];
    for (let w = 0; w <= o; ++w) T[w] = f.slice(0);
    const m = [];
    for (let w = 0; w <= i; ++w) m[w] = f.slice(0);
    m[0][0] = 1;
    const x = f.slice(0), h = f.slice(0);
    for (let w = 1; w <= i; ++w) {
        x[w] = t - c[A + 1 - w], h[w] = c[A + w] - t;
        let v = 0;
        for (let E = 0; E < w; ++E) {
            const p = h[E + 1], C = x[w - E];
            m[w][E] = p + C;
            const M = m[E][w - 1] / m[w][E];
            m[E][w] = v + p * M, v = C * M
        }
        m[w][w] = v
    }
    for (let w = 0; w <= i; ++w) T[0][w] = m[w][i];
    for (let w = 0; w <= i; ++w) {
        let v = 0, E = 1;
        const p = [];
        for (let C = 0; C <= i; ++C) p[C] = f.slice(0);
        p[0][0] = 1;
        for (let C = 1; C <= o; ++C) {
            let M = 0;
            const b = w - C, B = i - C;
            w >= C && (p[E][0] = p[v][0] / m[B + 1][b], M = p[E][0] * m[b][B]);
            const R = b >= -1 ? 1 : -b, I = w - 1 <= B ? C - 1 : i - w;
            for (let O = R; O <= I; ++O) p[E][O] = (p[v][O] - p[v][O - 1]) / m[B + 1][b + O], M += p[E][O] * m[b + O][B];
            w <= B && (p[E][C] = -p[v][C - 1] / m[B + 1][w], M += p[E][C] * m[w][B]), T[C][w] = M;
            const L = v;
            v = E, E = L
        }
    }
    let g = i;
    for (let w = 1; w <= o; ++w) {
        for (let v = 0; v <= i; ++v) T[w][v] *= g;
        g *= i - w
    }
    return T
}

function nI(A, t, i, o, c) {
    const f = c < A ? c : A, T = [], m = jw(A, o, t), x = tI(m, o, A, f, t), h = [];
    for (let g = 0; g < i.length; ++g) {
        const w = i[g].clone(), v = w.w;
        w.x *= v, w.y *= v, w.z *= v, h[g] = w
    }
    for (let g = 0; g <= f; ++g) {
        const w = h[m - A].clone().multiplyScalar(x[g][0]);
        for (let v = 1; v <= A; ++v) w.add(h[m - A + v].clone().multiplyScalar(x[g][v]));
        T[g] = w
    }
    for (let g = f + 1; g <= c + 1; ++g) T[g] = new Zs(0, 0, 0);
    return T
}

function iI(A, t) {
    let i = 1;
    for (let c = 2; c <= A; ++c) i *= c;
    let o = 1;
    for (let c = 2; c <= t; ++c) o *= c;
    for (let c = 2; c <= A - t; ++c) o *= c;
    return i / o
}

function rI(A) {
    const t = A.length, i = [], o = [];
    for (let f = 0; f < t; ++f) {
        const T = A[f];
        i[f] = new ft(T.x, T.y, T.z), o[f] = T.w
    }
    const c = [];
    for (let f = 0; f < t; ++f) {
        const T = i[f].clone();
        for (let m = 1; m <= f; ++m) T.sub(c[f - m].clone().multiplyScalar(iI(f, m) * o[m]));
        c[f] = T.divideScalar(o[0])
    }
    return c
}

function sI(A, t, i, o, c) {
    const f = nI(A, t, i, o, c);
    return rI(f)
}

class oI extends KS {
    constructor(t, i, o, c, f) {
        super(), this.degree = t, this.knots = i, this.controlPoints = [], this.startKnot = c || 0, this.endKnot = f || this.knots.length - 1;
        for (let T = 0; T < o.length; ++T) {
            const m = o[T];
            this.controlPoints[T] = new Zs(m.x, m.y, m.z, m.w)
        }
    }

    getPoint(t, i = new ft) {
        const o = i, c = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]),
            f = eI(this.degree, this.knots, this.controlPoints, c);
        return f.w !== 1 && f.divideScalar(f.w), o.set(f.x, f.y, f.z)
    }

    getTangent(t, i = new ft) {
        const o = i, c = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]),
            f = sI(this.degree, this.knots, this.controlPoints, c, 1);
        return o.copy(f[1]).normalize(), o
    }
}

let qi, Fs, la;

class aI extends Yl {
    constructor(t) {
        super(t)
    }

    load(t, i, o, c) {
        const f = this, T = f.path === "" ? Nw.extractUrlBase(t) : f.path, m = new D1(this.manager);
        m.setPath(f.path), m.setResponseType("arraybuffer"), m.setRequestHeader(f.requestHeader), m.setWithCredentials(f.withCredentials), m.load(t, function (x) {
            try {
                i(f.parse(x, T))
            } catch (h) {
                c ? c(h) : console.error(h), f.manager.itemError(t)
            }
        }, o, c)
    }

    parse(t, i) {
        if (fI(t)) qi = new dI().parse(t); else {
            const c = Yw(t);
            if (!pI(c)) throw new Error("THREE.FBXLoader: Unknown format.");
            if (w2(c) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + w2(c));
            qi = new hI().parse(c)
        }
        const o = new Pw(this.manager).setPath(this.resourcePath || i).setCrossOrigin(this.crossOrigin);
        return new lI(o, this.manager).parse(qi)
    }
}

class lI {
    constructor(t, i) {
        this.textureLoader = t, this.manager = i
    }

    parse() {
        Fs = this.parseConnections();
        const t = this.parseImages(), i = this.parseTextures(t), o = this.parseMaterials(i), c = this.parseDeformers(),
            f = new cI().parse(c);
        return this.parseScene(c, f, o), la
    }

    parseConnections() {
        const t = new Map;
        return "Connections" in qi && qi.Connections.connections.forEach(function (o) {
            const c = o[0], f = o[1], T = o[2];
            t.has(c) || t.set(c, {parents: [], children: []});
            const m = {ID: f, relationship: T};
            t.get(c).parents.push(m), t.has(f) || t.set(f, {parents: [], children: []});
            const x = {ID: c, relationship: T};
            t.get(f).children.push(x)
        }), t
    }

    parseImages() {
        const t = {}, i = {};
        if ("Video" in qi.Objects) {
            const o = qi.Objects.Video;
            for (const c in o) {
                const f = o[c], T = parseInt(c);
                if (t[T] = f.RelativeFilename || f.Filename, "Content" in f) {
                    const m = f.Content instanceof ArrayBuffer && f.Content.byteLength > 0,
                        x = typeof f.Content == "string" && f.Content !== "";
                    if (m || x) {
                        const h = this.parseImage(o[c]);
                        i[f.RelativeFilename || f.Filename] = h
                    }
                }
            }
        }
        for (const o in t) {
            const c = t[o];
            i[c] !== void 0 ? t[o] = i[c] : t[o] = t[o].split("\\").pop()
        }
        return t
    }

    parseImage(t) {
        const i = t.Content, o = t.RelativeFilename || t.Filename, c = o.slice(o.lastIndexOf(".") + 1).toLowerCase();
        let f;
        switch (c) {
            case"bmp":
                f = "image/bmp";
                break;
            case"jpg":
            case"jpeg":
                f = "image/jpeg";
                break;
            case"png":
                f = "image/png";
                break;
            case"tif":
                f = "image/tiff";
                break;
            case"tga":
                this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", o), f = "image/tga";
                break;
            default:
                console.warn('FBXLoader: Image type "' + c + '" is not supported.');
                return
        }
        if (typeof i == "string") return "data:" + f + ";base64," + i;
        {
            const T = new Uint8Array(i);
            return window.URL.createObjectURL(new Blob([T], {type: f}))
        }
    }

    parseTextures(t) {
        const i = new Map;
        if ("Texture" in qi.Objects) {
            const o = qi.Objects.Texture;
            for (const c in o) {
                const f = this.parseTexture(o[c], t);
                i.set(parseInt(c), f)
            }
        }
        return i
    }

    parseTexture(t, i) {
        const o = this.loadTexture(t, i);
        o.ID = t.id, o.name = t.attrName;
        const c = t.WrapModeU, f = t.WrapModeV, T = c !== void 0 ? c.value : 0, m = f !== void 0 ? f.value : 0;
        if (o.wrapS = T === 0 ? Iu : Xl, o.wrapT = m === 0 ? Iu : Xl, "Scaling" in t) {
            const x = t.Scaling.value;
            o.repeat.x = x[0], o.repeat.y = x[1]
        }
        if ("Translation" in t) {
            const x = t.Translation.value;
            o.offset.x = x[0], o.offset.y = x[1]
        }
        return o
    }

    loadTexture(t, i) {
        let o;
        const c = this.textureLoader.path, f = Fs.get(t.id).children;
        f !== void 0 && f.length > 0 && i[f[0].ID] !== void 0 && (o = i[f[0].ID], (o.indexOf("blob:") === 0 || o.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
        let T;
        const m = t.FileName.slice(-3).toLowerCase();
        if (m === "tga") {
            const x = this.manager.getHandler(".tga");
            x === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", t.RelativeFilename), T = new ya) : (x.setPath(this.textureLoader.path), T = x.load(o))
        } else if (m === "dds") {
            const x = this.manager.getHandler(".dds");
            x === null ? (console.warn("FBXLoader: DDS loader not found, creating placeholder texture for", t.RelativeFilename), T = new ya) : (x.setPath(this.textureLoader.path), T = x.load(o))
        } else m === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", t.RelativeFilename), T = new ya) : T = this.textureLoader.load(o);
        return this.textureLoader.setPath(c), T
    }

    parseMaterials(t) {
        const i = new Map;
        if ("Material" in qi.Objects) {
            const o = qi.Objects.Material;
            for (const c in o) {
                const f = this.parseMaterial(o[c], t);
                f !== null && i.set(parseInt(c), f)
            }
        }
        return i
    }

    parseMaterial(t, i) {
        const o = t.id, c = t.attrName;
        let f = t.ShadingModel;
        if (typeof f == "object" && (f = f.value), !Fs.has(o)) return null;
        const T = this.parseParameters(t, i, o);
        let m;
        switch (f.toLowerCase()) {
            case"phong":
                m = new am;
                break;
            case"lambert":
                m = new Bw;
                break;
            default:
                console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', f), m = new am;
                break
        }
        return m.setValues(T), m.name = c, m
    }

    parseParameters(t, i, o) {
        const c = {};
        t.BumpFactor && (c.bumpScale = t.BumpFactor.value), t.Diffuse ? c.color = new xs().fromArray(t.Diffuse.value).convertSRGBToLinear() : t.DiffuseColor && (t.DiffuseColor.type === "Color" || t.DiffuseColor.type === "ColorRGB") && (c.color = new xs().fromArray(t.DiffuseColor.value).convertSRGBToLinear()), t.DisplacementFactor && (c.displacementScale = t.DisplacementFactor.value), t.Emissive ? c.emissive = new xs().fromArray(t.Emissive.value).convertSRGBToLinear() : t.EmissiveColor && (t.EmissiveColor.type === "Color" || t.EmissiveColor.type === "ColorRGB") && (c.emissive = new xs().fromArray(t.EmissiveColor.value).convertSRGBToLinear()), t.EmissiveFactor && (c.emissiveIntensity = parseFloat(t.EmissiveFactor.value)), t.Opacity && (c.opacity = parseFloat(t.Opacity.value)), c.opacity < 1 && (c.transparent = !0), t.ReflectionFactor && (c.reflectivity = t.ReflectionFactor.value), t.Shininess && (c.shininess = t.Shininess.value), t.Specular ? c.specular = new xs().fromArray(t.Specular.value).convertSRGBToLinear() : t.SpecularColor && t.SpecularColor.type === "Color" && (c.specular = new xs().fromArray(t.SpecularColor.value).convertSRGBToLinear());
        const f = this;
        return Fs.get(o).children.forEach(function (T) {
            const m = T.relationship;
            switch (m) {
                case"Bump":
                    c.bumpMap = f.getTexture(i, T.ID);
                    break;
                case"Maya|TEX_ao_map":
                    c.aoMap = f.getTexture(i, T.ID);
                    break;
                case"DiffuseColor":
                case"Maya|TEX_color_map":
                    c.map = f.getTexture(i, T.ID), c.map !== void 0 && (c.map.colorSpace = ca);
                    break;
                case"DisplacementColor":
                    c.displacementMap = f.getTexture(i, T.ID);
                    break;
                case"EmissiveColor":
                    c.emissiveMap = f.getTexture(i, T.ID), c.emissiveMap !== void 0 && (c.emissiveMap.colorSpace = ca);
                    break;
                case"NormalMap":
                case"Maya|TEX_normal_map":
                    c.normalMap = f.getTexture(i, T.ID);
                    break;
                case"ReflectionColor":
                    c.envMap = f.getTexture(i, T.ID), c.envMap !== void 0 && (c.envMap.mapping = Q3, c.envMap.colorSpace = ca);
                    break;
                case"SpecularColor":
                    c.specularMap = f.getTexture(i, T.ID), c.specularMap !== void 0 && (c.specularMap.colorSpace = ca);
                    break;
                case"TransparentColor":
                case"TransparencyFactor":
                    c.alphaMap = f.getTexture(i, T.ID), c.transparent = !0;
                    break;
                case"AmbientColor":
                case"ShininessExponent":
                case"SpecularFactor":
                case"VectorDisplacementColor":
                default:
                    console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", m);
                    break
            }
        }), c
    }

    getTexture(t, i) {
        return "LayeredTexture" in qi.Objects && i in qi.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), i = Fs.get(i).children[0].ID), t.get(i)
    }

    parseDeformers() {
        const t = {}, i = {};
        if ("Deformer" in qi.Objects) {
            const o = qi.Objects.Deformer;
            for (const c in o) {
                const f = o[c], T = Fs.get(parseInt(c));
                if (f.attrType === "Skin") {
                    const m = this.parseSkeleton(T, o);
                    m.ID = c, T.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), m.geometryID = T.parents[0].ID, t[c] = m
                } else if (f.attrType === "BlendShape") {
                    const m = {id: c};
                    m.rawTargets = this.parseMorphTargets(T, o), m.id = c, T.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), i[c] = m
                }
            }
        }
        return {skeletons: t, morphTargets: i}
    }

    parseSkeleton(t, i) {
        const o = [];
        return t.children.forEach(function (c) {
            const f = i[c.ID];
            if (f.attrType !== "Cluster") return;
            const T = {ID: c.ID, indices: [], weights: [], transformLink: new $n().fromArray(f.TransformLink.a)};
            "Indexes" in f && (T.indices = f.Indexes.a, T.weights = f.Weights.a), o.push(T)
        }), {rawBones: o, bones: []}
    }

    parseMorphTargets(t, i) {
        const o = [];
        for (let c = 0; c < t.children.length; c++) {
            const f = t.children[c], T = i[f.ID],
                m = {name: T.attrName, initialWeight: T.DeformPercent, id: T.id, fullWeights: T.FullWeights.a};
            if (T.attrType !== "BlendShapeChannel") return;
            m.geoID = Fs.get(parseInt(f.ID)).children.filter(function (x) {
                return x.relationship === void 0
            })[0].ID, o.push(m)
        }
        return o
    }

    parseScene(t, i, o) {
        la = new hm;
        const c = this.parseModels(t.skeletons, i, o), f = qi.Objects.Model, T = this;
        c.forEach(function (x) {
            const h = f[x.ID];
            T.setLookAtProperties(x, h), Fs.get(x.ID).parents.forEach(function (w) {
                const v = c.get(w.ID);
                v !== void 0 && v.add(x)
            }), x.parent === null && la.add(x)
        }), this.bindSkeleton(t.skeletons, i, c), this.addGlobalSceneSettings(), la.traverse(function (x) {
            if (x.userData.transformData) {
                x.parent && (x.userData.transformData.parentMatrix = x.parent.matrix, x.userData.transformData.parentMatrixWorld = x.parent.matrixWorld);
                const h = Kw(x.userData.transformData);
                x.applyMatrix4(h), x.updateWorldMatrix()
            }
        });
        const m = new uI().parse();
        la.children.length === 1 && la.children[0].isGroup && (la.children[0].animations = m, la = la.children[0]), la.animations = m
    }

    parseModels(t, i, o) {
        const c = new Map, f = qi.Objects.Model;
        for (const T in f) {
            const m = parseInt(T), x = f[T], h = Fs.get(m);
            let g = this.buildSkeleton(h, t, m, x.attrName);
            if (!g) {
                switch (x.attrType) {
                    case"Camera":
                        g = this.createCamera(h);
                        break;
                    case"Light":
                        g = this.createLight(h);
                        break;
                    case"Mesh":
                        g = this.createMesh(h, i, o);
                        break;
                    case"NurbsCurve":
                        g = this.createCurve(h, i);
                        break;
                    case"LimbNode":
                    case"Root":
                        g = new x0;
                        break;
                    case"Null":
                    default:
                        g = new hm;
                        break
                }
                g.name = x.attrName ? br.sanitizeNodeName(x.attrName) : "", g.userData.originalName = x.attrName, g.ID = m
            }
            this.getTransformData(g, x), c.set(m, g)
        }
        return c
    }

    buildSkeleton(t, i, o, c) {
        let f = null;
        return t.parents.forEach(function (T) {
            for (const m in i) {
                const x = i[m];
                x.rawBones.forEach(function (h, g) {
                    if (h.ID === T.ID) {
                        const w = f;
                        f = new x0, f.matrixWorld.copy(h.transformLink), f.name = c ? br.sanitizeNodeName(c) : "", f.userData.originalName = c, f.ID = o, x.bones[g] = f, w !== null && f.add(w)
                    }
                })
            }
        }), f
    }

    createCamera(t) {
        let i, o;
        if (t.children.forEach(function (c) {
            const f = qi.Objects.NodeAttribute[c.ID];
            f !== void 0 && (o = f)
        }), o === void 0) i = new rs; else {
            let c = 0;
            o.CameraProjectionType !== void 0 && o.CameraProjectionType.value === 1 && (c = 1);
            let f = 1;
            o.NearPlane !== void 0 && (f = o.NearPlane.value / 1e3);
            let T = 1e3;
            o.FarPlane !== void 0 && (T = o.FarPlane.value / 1e3);
            let m = window.innerWidth, x = window.innerHeight;
            o.AspectWidth !== void 0 && o.AspectHeight !== void 0 && (m = o.AspectWidth.value, x = o.AspectHeight.value);
            const h = m / x;
            let g = 45;
            o.FieldOfView !== void 0 && (g = o.FieldOfView.value);
            const w = o.FocalLength ? o.FocalLength.value : null;
            switch (c) {
                case 0:
                    i = new Bu(g, h, f, T), w !== null && i.setFocalLength(w);
                    break;
                case 1:
                    i = new B1(-m / 2, m / 2, x / 2, -x / 2, f, T);
                    break;
                default:
                    console.warn("THREE.FBXLoader: Unknown camera type " + c + "."), i = new rs;
                    break
            }
        }
        return i
    }

    createLight(t) {
        let i, o;
        if (t.children.forEach(function (c) {
            const f = qi.Objects.NodeAttribute[c.ID];
            f !== void 0 && (o = f)
        }), o === void 0) i = new rs; else {
            let c;
            o.LightType === void 0 ? c = 0 : c = o.LightType.value;
            let f = 16777215;
            o.Color !== void 0 && (f = new xs().fromArray(o.Color.value).convertSRGBToLinear());
            let T = o.Intensity === void 0 ? 1 : o.Intensity.value / 100;
            o.CastLightOnObject !== void 0 && o.CastLightOnObject.value === 0 && (T = 0);
            let m = 0;
            o.FarAttenuationEnd !== void 0 && (o.EnableFarAttenuation !== void 0 && o.EnableFarAttenuation.value === 0 ? m = 0 : m = o.FarAttenuationEnd.value);
            const x = 1;
            switch (c) {
                case 0:
                    i = new y1(f, T, m, x);
                    break;
                case 1:
                    i = new kw(f, T);
                    break;
                case 2:
                    let h = Math.PI / 3;
                    o.InnerAngle !== void 0 && (h = Js.degToRad(o.InnerAngle.value));
                    let g = 0;
                    o.OuterAngle !== void 0 && (g = Js.degToRad(o.OuterAngle.value), g = Math.max(g, 1)), i = new Ow(f, T, m, h, g, x);
                    break;
                default:
                    console.warn("THREE.FBXLoader: Unknown light type " + o.LightType.value + ", defaulting to a PointLight."), i = new y1(f, T);
                    break
            }
            o.CastShadows !== void 0 && o.CastShadows.value === 1 && (i.castShadow = !0)
        }
        return i
    }

    createMesh(t, i, o) {
        let c, f = null, T = null;
        const m = [];
        return t.children.forEach(function (x) {
            i.has(x.ID) && (f = i.get(x.ID)), o.has(x.ID) && m.push(o.get(x.ID))
        }), m.length > 1 ? T = m : m.length > 0 ? T = m[0] : (T = new am({
            name: Yl.DEFAULT_MATERIAL_NAME,
            color: 13421772
        }), m.push(T)), "color" in f.attributes && m.forEach(function (x) {
            x.vertexColors = !0
        }), f.FBX_Deformer ? (c = new Mw(f, T), c.normalizeSkinWeights()) : c = new Tu(f, T), c
    }

    createCurve(t, i) {
        const o = t.children.reduce(function (f, T) {
            return i.has(T.ID) && (f = i.get(T.ID)), f
        }, null), c = new dm({name: Yl.DEFAULT_MATERIAL_NAME, color: 3342591, linewidth: 1});
        return new L0(o, c)
    }

    getTransformData(t, i) {
        const o = {};
        "InheritType" in i && (o.inheritType = parseInt(i.InheritType.value)), "RotationOrder" in i ? o.eulerOrder = Xw(i.RotationOrder.value) : o.eulerOrder = "ZYX", "Lcl_Translation" in i && (o.translation = i.Lcl_Translation.value), "PreRotation" in i && (o.preRotation = i.PreRotation.value), "Lcl_Rotation" in i && (o.rotation = i.Lcl_Rotation.value), "PostRotation" in i && (o.postRotation = i.PostRotation.value), "Lcl_Scaling" in i && (o.scale = i.Lcl_Scaling.value), "ScalingOffset" in i && (o.scalingOffset = i.ScalingOffset.value), "ScalingPivot" in i && (o.scalingPivot = i.ScalingPivot.value), "RotationOffset" in i && (o.rotationOffset = i.RotationOffset.value), "RotationPivot" in i && (o.rotationPivot = i.RotationPivot.value), t.userData.transformData = o
    }

    setLookAtProperties(t, i) {
        "LookAtProperty" in i && Fs.get(t.ID).children.forEach(function (c) {
            if (c.relationship === "LookAtProperty") {
                const f = qi.Objects.Model[c.ID];
                if ("Lcl_Translation" in f) {
                    const T = f.Lcl_Translation.value;
                    t.target !== void 0 ? (t.target.position.fromArray(T), la.add(t.target)) : t.lookAt(new ft().fromArray(T))
                }
            }
        })
    }

    bindSkeleton(t, i, o) {
        const c = this.parsePoseNodes();
        for (const f in t) {
            const T = t[f];
            Fs.get(parseInt(T.ID)).parents.forEach(function (x) {
                if (i.has(x.ID)) {
                    const h = x.ID;
                    Fs.get(h).parents.forEach(function (w) {
                        o.has(w.ID) && o.get(w.ID).bind(new B0(T.bones), c[w.ID])
                    })
                }
            })
        }
    }

    parsePoseNodes() {
        const t = {};
        if ("Pose" in qi.Objects) {
            const i = qi.Objects.Pose;
            for (const o in i) if (i[o].attrType === "BindPose" && i[o].NbPoseNodes > 0) {
                const c = i[o].PoseNode;
                Array.isArray(c) ? c.forEach(function (f) {
                    t[f.Node] = new $n().fromArray(f.Matrix.a)
                }) : t[c.Node] = new $n().fromArray(c.Matrix.a)
            }
        }
        return t
    }

    addGlobalSceneSettings() {
        if ("GlobalSettings" in qi) {
            if ("AmbientColor" in qi.GlobalSettings) {
                const t = qi.GlobalSettings.AmbientColor.value, i = t[0], o = t[1], c = t[2];
                if (i !== 0 || o !== 0 || c !== 0) {
                    const f = new xs(i, o, c).convertSRGBToLinear();
                    la.add(new Fw(f, 1))
                }
            }
            "UnitScaleFactor" in qi.GlobalSettings && (la.userData.unitScaleFactor = qi.GlobalSettings.UnitScaleFactor.value)
        }
    }
}

class cI {
    constructor() {
        this.negativeMaterialIndices = !1
    }

    parse(t) {
        const i = new Map;
        if ("Geometry" in qi.Objects) {
            const o = qi.Objects.Geometry;
            for (const c in o) {
                const f = Fs.get(parseInt(c)), T = this.parseGeometry(f, o[c], t);
                i.set(parseInt(c), T)
            }
        }
        return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), i
    }

    parseGeometry(t, i, o) {
        switch (i.attrType) {
            case"Mesh":
                return this.parseMeshGeometry(t, i, o);
            case"NurbsCurve":
                return this.parseNurbsGeometry(i)
        }
    }

    parseMeshGeometry(t, i, o) {
        const c = o.skeletons, f = [], T = t.parents.map(function (w) {
            return qi.Objects.Model[w.ID]
        });
        if (T.length === 0) return;
        const m = t.children.reduce(function (w, v) {
            return c[v.ID] !== void 0 && (w = c[v.ID]), w
        }, null);
        t.children.forEach(function (w) {
            o.morphTargets[w.ID] !== void 0 && f.push(o.morphTargets[w.ID])
        });
        const x = T[0], h = {};
        "RotationOrder" in x && (h.eulerOrder = Xw(x.RotationOrder.value)), "InheritType" in x && (h.inheritType = parseInt(x.InheritType.value)), "GeometricTranslation" in x && (h.translation = x.GeometricTranslation.value), "GeometricRotation" in x && (h.rotation = x.GeometricRotation.value), "GeometricScaling" in x && (h.scale = x.GeometricScaling.value);
        const g = Kw(h);
        return this.genGeometry(i, m, f, g)
    }

    genGeometry(t, i, o, c) {
        const f = new il;
        t.attrName && (f.name = t.attrName);
        const T = this.parseGeoNode(t, i), m = this.genBuffers(T), x = new Cs(m.vertex, 3);
        if (x.applyMatrix4(c), f.setAttribute("position", x), m.colors.length > 0 && f.setAttribute("color", new Cs(m.colors, 3)), i && (f.setAttribute("skinIndex", new bw(m.weightsIndices, 4)), f.setAttribute("skinWeight", new Cs(m.vertexWeights, 4)), f.FBX_Deformer = i), m.normal.length > 0) {
            const h = new Jl().getNormalMatrix(c), g = new Cs(m.normal, 3);
            g.applyNormalMatrix(h), f.setAttribute("normal", g)
        }
        if (m.uvs.forEach(function (h, g) {
            const w = g === 0 ? "uv" : `uv${g}`;
            f.setAttribute(w, new Cs(m.uvs[g], 2))
        }), T.material && T.material.mappingType !== "AllSame") {
            let h = m.materialIndex[0], g = 0;
            if (m.materialIndex.forEach(function (w, v) {
                w !== h && (f.addGroup(g, v - g, h), h = w, g = v)
            }), f.groups.length > 0) {
                const w = f.groups[f.groups.length - 1], v = w.start + w.count;
                v !== m.materialIndex.length && f.addGroup(v, m.materialIndex.length - v, h)
            }
            f.groups.length === 0 && f.addGroup(0, m.materialIndex.length, m.materialIndex[0])
        }
        return this.addMorphTargets(f, t, o, c), f
    }

    parseGeoNode(t, i) {
        const o = {};
        if (o.vertexPositions = t.Vertices !== void 0 ? t.Vertices.a : [], o.vertexIndices = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (o.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (o.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (o.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) {
            o.uv = [];
            let c = 0;
            for (; t.LayerElementUV[c];) t.LayerElementUV[c].UV && o.uv.push(this.parseUVs(t.LayerElementUV[c])), c++
        }
        return o.weightTable = {}, i !== null && (o.skeleton = i, i.rawBones.forEach(function (c, f) {
            c.indices.forEach(function (T, m) {
                o.weightTable[T] === void 0 && (o.weightTable[T] = []), o.weightTable[T].push({
                    id: f,
                    weight: c.weights[m]
                })
            })
        })), o
    }

    genBuffers(t) {
        const i = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
        };
        let o = 0, c = 0, f = !1, T = [], m = [], x = [], h = [], g = [], w = [];
        const v = this;
        return t.vertexIndices.forEach(function (E, p) {
            let C, M = !1;
            E < 0 && (E = E ^ -1, M = !0);
            let b = [], B = [];
            if (T.push(E * 3, E * 3 + 1, E * 3 + 2), t.color) {
                const R = s0(p, o, E, t.color);
                x.push(R[0], R[1], R[2])
            }
            if (t.skeleton) {
                if (t.weightTable[E] !== void 0 && t.weightTable[E].forEach(function (R) {
                    B.push(R.weight), b.push(R.id)
                }), B.length > 4) {
                    f || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), f = !0);
                    const R = [0, 0, 0, 0], I = [0, 0, 0, 0];
                    B.forEach(function (L, O) {
                        let N = L, F = b[O];
                        I.forEach(function (V, U, j) {
                            if (N > V) {
                                j[U] = N, N = V;
                                const Y = R[U];
                                R[U] = F, F = Y
                            }
                        })
                    }), b = R, B = I
                }
                for (; B.length < 4;) B.push(0), b.push(0);
                for (let R = 0; R < 4; ++R) g.push(B[R]), w.push(b[R])
            }
            if (t.normal) {
                const R = s0(p, o, E, t.normal);
                m.push(R[0], R[1], R[2])
            }
            t.material && t.material.mappingType !== "AllSame" && (C = s0(p, o, E, t.material)[0], C < 0 && (v.negativeMaterialIndices = !0, C = 0)), t.uv && t.uv.forEach(function (R, I) {
                const L = s0(p, o, E, R);
                h[I] === void 0 && (h[I] = []), h[I].push(L[0]), h[I].push(L[1])
            }), c++, M && (v.genFace(i, t, T, C, m, x, h, g, w, c), o++, c = 0, T = [], m = [], x = [], h = [], g = [], w = [])
        }), i
    }

    getNormalNewell(t) {
        const i = new ft(0, 0, 0);
        for (let o = 0; o < t.length; o++) {
            const c = t[o], f = t[(o + 1) % t.length];
            i.x += (c.y - f.y) * (c.z + f.z), i.y += (c.z - f.z) * (c.x + f.x), i.z += (c.x - f.x) * (c.y + f.y)
        }
        return i.normalize(), i
    }

    getNormalTangentAndBitangent(t) {
        const i = this.getNormalNewell(t),
            c = (Math.abs(i.z) > .5 ? new ft(0, 1, 0) : new ft(0, 0, 1)).cross(i).normalize(),
            f = i.clone().cross(c).normalize();
        return {normal: i, tangent: c, bitangent: f}
    }

    flattenVertex(t, i, o) {
        return new es(t.dot(i), t.dot(o))
    }

    genFace(t, i, o, c, f, T, m, x, h, g) {
        let w;
        if (g > 3) {
            const v = [];
            for (let M = 0; M < o.length; M += 3) v.push(new ft(i.vertexPositions[o[M]], i.vertexPositions[o[M + 1]], i.vertexPositions[o[M + 2]]));
            const {tangent: E, bitangent: p} = this.getNormalTangentAndBitangent(v), C = [];
            for (const M of v) C.push(this.flattenVertex(M, E, p));
            w = L1.triangulateShape(C, [])
        } else w = [[0, 1, 2]];
        for (const [v, E, p] of w) t.vertex.push(i.vertexPositions[o[v * 3]]), t.vertex.push(i.vertexPositions[o[v * 3 + 1]]), t.vertex.push(i.vertexPositions[o[v * 3 + 2]]), t.vertex.push(i.vertexPositions[o[E * 3]]), t.vertex.push(i.vertexPositions[o[E * 3 + 1]]), t.vertex.push(i.vertexPositions[o[E * 3 + 2]]), t.vertex.push(i.vertexPositions[o[p * 3]]), t.vertex.push(i.vertexPositions[o[p * 3 + 1]]), t.vertex.push(i.vertexPositions[o[p * 3 + 2]]), i.skeleton && (t.vertexWeights.push(x[v * 4]), t.vertexWeights.push(x[v * 4 + 1]), t.vertexWeights.push(x[v * 4 + 2]), t.vertexWeights.push(x[v * 4 + 3]), t.vertexWeights.push(x[E * 4]), t.vertexWeights.push(x[E * 4 + 1]), t.vertexWeights.push(x[E * 4 + 2]), t.vertexWeights.push(x[E * 4 + 3]), t.vertexWeights.push(x[p * 4]), t.vertexWeights.push(x[p * 4 + 1]), t.vertexWeights.push(x[p * 4 + 2]), t.vertexWeights.push(x[p * 4 + 3]), t.weightsIndices.push(h[v * 4]), t.weightsIndices.push(h[v * 4 + 1]), t.weightsIndices.push(h[v * 4 + 2]), t.weightsIndices.push(h[v * 4 + 3]), t.weightsIndices.push(h[E * 4]), t.weightsIndices.push(h[E * 4 + 1]), t.weightsIndices.push(h[E * 4 + 2]), t.weightsIndices.push(h[E * 4 + 3]), t.weightsIndices.push(h[p * 4]), t.weightsIndices.push(h[p * 4 + 1]), t.weightsIndices.push(h[p * 4 + 2]), t.weightsIndices.push(h[p * 4 + 3])), i.color && (t.colors.push(T[v * 3]), t.colors.push(T[v * 3 + 1]), t.colors.push(T[v * 3 + 2]), t.colors.push(T[E * 3]), t.colors.push(T[E * 3 + 1]), t.colors.push(T[E * 3 + 2]), t.colors.push(T[p * 3]), t.colors.push(T[p * 3 + 1]), t.colors.push(T[p * 3 + 2])), i.material && i.material.mappingType !== "AllSame" && (t.materialIndex.push(c), t.materialIndex.push(c), t.materialIndex.push(c)), i.normal && (t.normal.push(f[v * 3]), t.normal.push(f[v * 3 + 1]), t.normal.push(f[v * 3 + 2]), t.normal.push(f[E * 3]), t.normal.push(f[E * 3 + 1]), t.normal.push(f[E * 3 + 2]), t.normal.push(f[p * 3]), t.normal.push(f[p * 3 + 1]), t.normal.push(f[p * 3 + 2])), i.uv && i.uv.forEach(function (C, M) {
            t.uvs[M] === void 0 && (t.uvs[M] = []), t.uvs[M].push(m[M][v * 2]), t.uvs[M].push(m[M][v * 2 + 1]), t.uvs[M].push(m[M][E * 2]), t.uvs[M].push(m[M][E * 2 + 1]), t.uvs[M].push(m[M][p * 2]), t.uvs[M].push(m[M][p * 2 + 1])
        })
    }

    addMorphTargets(t, i, o, c) {
        if (o.length === 0) return;
        t.morphTargetsRelative = !0, t.morphAttributes.position = [];
        const f = this;
        o.forEach(function (T) {
            T.rawTargets.forEach(function (m) {
                const x = qi.Objects.Geometry[m.geoID];
                x !== void 0 && f.genMorphGeometry(t, i, x, c, m.name)
            })
        })
    }

    genMorphGeometry(t, i, o, c, f) {
        const T = i.PolygonVertexIndex !== void 0 ? i.PolygonVertexIndex.a : [],
            m = o.Vertices !== void 0 ? o.Vertices.a : [], x = o.Indexes !== void 0 ? o.Indexes.a : [],
            h = t.attributes.position.count * 3, g = new Float32Array(h);
        for (let p = 0; p < x.length; p++) {
            const C = x[p] * 3;
            g[C] = m[p * 3], g[C + 1] = m[p * 3 + 1], g[C + 2] = m[p * 3 + 2]
        }
        const w = {vertexIndices: T, vertexPositions: g}, v = this.genBuffers(w), E = new Cs(v.vertex, 3);
        E.name = f || o.attrName, E.applyMatrix4(c), t.morphAttributes.position.push(E)
    }

    parseNormals(t) {
        const i = t.MappingInformationType, o = t.ReferenceInformationType, c = t.Normals.a;
        let f = [];
        return o === "IndexToDirect" && ("NormalIndex" in t ? f = t.NormalIndex.a : "NormalsIndex" in t && (f = t.NormalsIndex.a)), {
            dataSize: 3,
            buffer: c,
            indices: f,
            mappingType: i,
            referenceType: o
        }
    }

    parseUVs(t) {
        const i = t.MappingInformationType, o = t.ReferenceInformationType, c = t.UV.a;
        let f = [];
        return o === "IndexToDirect" && (f = t.UVIndex.a), {
            dataSize: 2,
            buffer: c,
            indices: f,
            mappingType: i,
            referenceType: o
        }
    }

    parseVertexColors(t) {
        const i = t.MappingInformationType, o = t.ReferenceInformationType, c = t.Colors.a;
        let f = [];
        o === "IndexToDirect" && (f = t.ColorIndex.a);
        for (let T = 0, m = new xs; T < c.length; T += 4) m.fromArray(c, T).convertSRGBToLinear().toArray(c, T);
        return {dataSize: 4, buffer: c, indices: f, mappingType: i, referenceType: o}
    }

    parseMaterialIndices(t) {
        const i = t.MappingInformationType, o = t.ReferenceInformationType;
        if (i === "NoMappingInformation") return {
            dataSize: 1,
            buffer: [0],
            indices: [0],
            mappingType: "AllSame",
            referenceType: o
        };
        const c = t.Materials.a, f = [];
        for (let T = 0; T < c.length; ++T) f.push(T);
        return {dataSize: 1, buffer: c, indices: f, mappingType: i, referenceType: o}
    }

    parseNurbsGeometry(t) {
        const i = parseInt(t.Order);
        if (isNaN(i)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", t.Order, t.id), new il;
        const o = i - 1, c = t.KnotVector.a, f = [], T = t.Points.a;
        for (let w = 0, v = T.length; w < v; w += 4) f.push(new Zs().fromArray(T, w));
        let m, x;
        if (t.Form === "Closed") f.push(f[0]); else if (t.Form === "Periodic") {
            m = o, x = c.length - 1 - m;
            for (let w = 0; w < o; ++w) f.push(f[w])
        }
        const g = new oI(o, c, f, m, x).getPoints(f.length * 12);
        return new il().setFromPoints(g)
    }
}

class uI {
    parse() {
        const t = [], i = this.parseClips();
        if (i !== void 0) for (const o in i) {
            const c = i[o], f = this.addClip(c);
            t.push(f)
        }
        return t
    }

    parseClips() {
        if (qi.Objects.AnimationCurve === void 0) return;
        const t = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(t);
        const i = this.parseAnimationLayers(t);
        return this.parseAnimStacks(i)
    }

    parseAnimationCurveNodes() {
        const t = qi.Objects.AnimationCurveNode, i = new Map;
        for (const o in t) {
            const c = t[o];
            if (c.attrName.match(/S|R|T|DeformPercent/) !== null) {
                const f = {id: c.id, attr: c.attrName, curves: {}};
                i.set(f.id, f)
            }
        }
        return i
    }

    parseAnimationCurves(t) {
        const i = qi.Objects.AnimationCurve;
        for (const o in i) {
            const c = {id: i[o].id, times: i[o].KeyTime.a.map(mI), values: i[o].KeyValueFloat.a}, f = Fs.get(c.id);
            if (f !== void 0) {
                const T = f.parents[0].ID, m = f.parents[0].relationship;
                m.match(/X/) ? t.get(T).curves.x = c : m.match(/Y/) ? t.get(T).curves.y = c : m.match(/Z/) ? t.get(T).curves.z = c : m.match(/DeformPercent/) && t.has(T) && (t.get(T).curves.morph = c)
            }
        }
    }

    parseAnimationLayers(t) {
        const i = qi.Objects.AnimationLayer, o = new Map;
        for (const c in i) {
            const f = [], T = Fs.get(parseInt(c));
            T !== void 0 && (T.children.forEach(function (x, h) {
                if (t.has(x.ID)) {
                    const g = t.get(x.ID);
                    if (g.curves.x !== void 0 || g.curves.y !== void 0 || g.curves.z !== void 0) {
                        if (f[h] === void 0) {
                            const w = Fs.get(x.ID).parents.filter(function (v) {
                                return v.relationship !== void 0
                            })[0].ID;
                            if (w !== void 0) {
                                const v = qi.Objects.Model[w.toString()];
                                if (v === void 0) {
                                    console.warn("THREE.FBXLoader: Encountered a unused curve.", x);
                                    return
                                }
                                const E = {
                                    modelName: v.attrName ? br.sanitizeNodeName(v.attrName) : "",
                                    ID: v.id,
                                    initialPosition: [0, 0, 0],
                                    initialRotation: [0, 0, 0],
                                    initialScale: [1, 1, 1]
                                };
                                la.traverse(function (p) {
                                    p.ID === v.id && (E.transform = p.matrix, p.userData.transformData && (E.eulerOrder = p.userData.transformData.eulerOrder))
                                }), E.transform || (E.transform = new $n), "PreRotation" in v && (E.preRotation = v.PreRotation.value), "PostRotation" in v && (E.postRotation = v.PostRotation.value), f[h] = E
                            }
                        }
                        f[h] && (f[h][g.attr] = g)
                    } else if (g.curves.morph !== void 0) {
                        if (f[h] === void 0) {
                            const w = Fs.get(x.ID).parents.filter(function (b) {
                                    return b.relationship !== void 0
                                })[0].ID, v = Fs.get(w).parents[0].ID, E = Fs.get(v).parents[0].ID,
                                p = Fs.get(E).parents[0].ID, C = qi.Objects.Model[p], M = {
                                    modelName: C.attrName ? br.sanitizeNodeName(C.attrName) : "",
                                    morphName: qi.Objects.Deformer[w].attrName
                                };
                            f[h] = M
                        }
                        f[h][g.attr] = g
                    }
                }
            }), o.set(parseInt(c), f))
        }
        return o
    }

    parseAnimStacks(t) {
        const i = qi.Objects.AnimationStack, o = {};
        for (const c in i) {
            const f = Fs.get(parseInt(c)).children;
            f.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            const T = t.get(f[0].ID);
            o[c] = {name: i[c].attrName, layer: T}
        }
        return o
    }

    addClip(t) {
        let i = [];
        const o = this;
        return t.layer.forEach(function (c) {
            i = i.concat(o.generateTracks(c))
        }), new v1(t.name, -1, i)
    }

    generateTracks(t) {
        const i = [];
        let o = new ft, c = new ft;
        if (t.transform && t.transform.decompose(o, new Ho, c), o = o.toArray(), c = c.toArray(), t.T !== void 0 && Object.keys(t.T.curves).length > 0) {
            const f = this.generateVectorTrack(t.modelName, t.T.curves, o, "position");
            f !== void 0 && i.push(f)
        }
        if (t.R !== void 0 && Object.keys(t.R.curves).length > 0) {
            const f = this.generateRotationTrack(t.modelName, t.R.curves, t.preRotation, t.postRotation, t.eulerOrder);
            f !== void 0 && i.push(f)
        }
        if (t.S !== void 0 && Object.keys(t.S.curves).length > 0) {
            const f = this.generateVectorTrack(t.modelName, t.S.curves, c, "scale");
            f !== void 0 && i.push(f)
        }
        if (t.DeformPercent !== void 0) {
            const f = this.generateMorphTrack(t);
            f !== void 0 && i.push(f)
        }
        return i
    }

    generateVectorTrack(t, i, o, c) {
        const f = this.getTimesForAllAxes(i), T = this.getKeyframeTrackValues(f, i, o);
        return new Fh(t + "." + c, f, T)
    }

    generateRotationTrack(t, i, o, c, f) {
        let T, m;
        if (i.x !== void 0 && i.y !== void 0 && i.z !== void 0) {
            const w = this.interpolateRotations(i.x, i.y, i.z, f);
            T = w[0], m = w[1]
        }
        o !== void 0 && (o = o.map(Js.degToRad), o.push(f), o = new ao().fromArray(o), o = new Ho().setFromEuler(o)), c !== void 0 && (c = c.map(Js.degToRad), c.push(f), c = new ao().fromArray(c), c = new Ho().setFromEuler(c).invert());
        const x = new Ho, h = new ao, g = [];
        if (!m || !T) return new Lu(t + ".quaternion", [0], [0]);
        for (let w = 0; w < m.length; w += 3) h.set(m[w], m[w + 1], m[w + 2], f), x.setFromEuler(h), o !== void 0 && x.premultiply(o), c !== void 0 && x.multiply(c), w > 2 && new Ho().fromArray(g, (w - 3) / 3 * 4).dot(x) < 0 && x.set(-x.x, -x.y, -x.z, -x.w), x.toArray(g, w / 3 * 4);
        return new Lu(t + ".quaternion", T, g)
    }

    generateMorphTrack(t) {
        const i = t.DeformPercent.curves.morph, o = i.values.map(function (f) {
            return f / 100
        }), c = la.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];
        return new Am(t.modelName + ".morphTargetInfluences[" + c + "]", i.times, o)
    }

    getTimesForAllAxes(t) {
        let i = [];
        if (t.x !== void 0 && (i = i.concat(t.x.times)), t.y !== void 0 && (i = i.concat(t.y.times)), t.z !== void 0 && (i = i.concat(t.z.times)), i = i.sort(function (o, c) {
            return o - c
        }), i.length > 1) {
            let o = 1, c = i[0];
            for (let f = 1; f < i.length; f++) {
                const T = i[f];
                T !== c && (i[o] = T, c = T, o++)
            }
            i = i.slice(0, o)
        }
        return i
    }

    getKeyframeTrackValues(t, i, o) {
        const c = o, f = [];
        let T = -1, m = -1, x = -1;
        return t.forEach(function (h) {
            if (i.x && (T = i.x.times.indexOf(h)), i.y && (m = i.y.times.indexOf(h)), i.z && (x = i.z.times.indexOf(h)), T !== -1) {
                const g = i.x.values[T];
                f.push(g), c[0] = g
            } else f.push(c[0]);
            if (m !== -1) {
                const g = i.y.values[m];
                f.push(g), c[1] = g
            } else f.push(c[1]);
            if (x !== -1) {
                const g = i.z.values[x];
                f.push(g), c[2] = g
            } else f.push(c[2])
        }), f
    }

    interpolateRotations(t, i, o, c) {
        const f = [], T = [];
        f.push(t.times[0]), T.push(Js.degToRad(t.values[0])), T.push(Js.degToRad(i.values[0])), T.push(Js.degToRad(o.values[0]));
        for (let m = 1; m < t.values.length; m++) {
            const x = [t.values[m - 1], i.values[m - 1], o.values[m - 1]];
            if (isNaN(x[0]) || isNaN(x[1]) || isNaN(x[2])) continue;
            const h = x.map(Js.degToRad), g = [t.values[m], i.values[m], o.values[m]];
            if (isNaN(g[0]) || isNaN(g[1]) || isNaN(g[2])) continue;
            const w = g.map(Js.degToRad), v = [g[0] - x[0], g[1] - x[1], g[2] - x[2]],
                E = [Math.abs(v[0]), Math.abs(v[1]), Math.abs(v[2])];
            if (E[0] >= 180 || E[1] >= 180 || E[2] >= 180) {
                const C = Math.max(...E) / 180, M = new ao(...h, c), b = new ao(...w, c), B = new Ho().setFromEuler(M),
                    R = new Ho().setFromEuler(b);
                B.dot(R) && R.set(-R.x, -R.y, -R.z, -R.w);
                const I = t.times[m - 1], L = t.times[m] - I, O = new Ho, N = new ao;
                for (let F = 0; F < 1; F += 1 / C) O.copy(B.clone().slerp(R.clone(), F)), f.push(I + F * L), N.setFromQuaternion(O, c), T.push(N.x), T.push(N.y), T.push(N.z)
            } else f.push(t.times[m]), T.push(Js.degToRad(t.values[m])), T.push(Js.degToRad(i.values[m])), T.push(Js.degToRad(o.values[m]))
        }
        return [f, T]
    }
}

class hI {
    getPrevNode() {
        return this.nodeStack[this.currentIndent - 2]
    }

    getCurrentNode() {
        return this.nodeStack[this.currentIndent - 1]
    }

    getCurrentProp() {
        return this.currentProp
    }

    pushStack(t) {
        this.nodeStack.push(t), this.currentIndent += 1
    }

    popStack() {
        this.nodeStack.pop(), this.currentIndent -= 1
    }

    setCurrentProp(t, i) {
        this.currentProp = t, this.currentPropName = i
    }

    parse(t) {
        this.currentIndent = 0, this.allNodes = new Ww, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
        const i = this, o = t.split(/[\r\n]+/);
        return o.forEach(function (c, f) {
            const T = c.match(/^[\s\t]*;/), m = c.match(/^[\s\t]*$/);
            if (T || m) return;
            const x = c.match("^\\t{" + i.currentIndent + "}(\\w+):(.*){", ""),
                h = c.match("^\\t{" + i.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                g = c.match("^\\t{" + (i.currentIndent - 1) + "}}");
            x ? i.parseNodeBegin(c, x) : h ? i.parseNodeProperty(c, h, o[++f]) : g ? i.popStack() : c.match(/^[^\s\t}]/) && i.parseNodePropertyContinued(c)
        }), this.allNodes
    }

    parseNodeBegin(t, i) {
        const o = i[1].trim().replace(/^"/, "").replace(/"$/, ""), c = i[2].split(",").map(function (x) {
            return x.trim().replace(/^"/, "").replace(/"$/, "")
        }), f = {name: o}, T = this.parseNodeAttr(c), m = this.getCurrentNode();
        this.currentIndent === 0 ? this.allNodes.add(o, f) : o in m ? (o === "PoseNode" ? m.PoseNode.push(f) : m[o].id !== void 0 && (m[o] = {}, m[o][m[o].id] = m[o]), T.id !== "" && (m[o][T.id] = f)) : typeof T.id == "number" ? (m[o] = {}, m[o][T.id] = f) : o !== "Properties70" && (o === "PoseNode" ? m[o] = [f] : m[o] = f), typeof T.id == "number" && (f.id = T.id), T.name !== "" && (f.attrName = T.name), T.type !== "" && (f.attrType = T.type), this.pushStack(f)
    }

    parseNodeAttr(t) {
        let i = t[0];
        t[0] !== "" && (i = parseInt(t[0]), isNaN(i) && (i = t[0]));
        let o = "", c = "";
        return t.length > 1 && (o = t[1].replace(/^(\w+)::/, ""), c = t[2]), {id: i, name: o, type: c}
    }

    parseNodeProperty(t, i, o) {
        let c = i[1].replace(/^"/, "").replace(/"$/, "").trim(), f = i[2].replace(/^"/, "").replace(/"$/, "").trim();
        c === "Content" && f === "," && (f = o.replace(/"/g, "").replace(/,$/, "").trim());
        const T = this.getCurrentNode();
        if (T.name === "Properties70") {
            this.parseNodeSpecialProperty(t, c, f);
            return
        }
        if (c === "C") {
            const x = f.split(",").slice(1), h = parseInt(x[0]), g = parseInt(x[1]);
            let w = f.split(",").slice(3);
            w = w.map(function (v) {
                return v.trim().replace(/^"/, "")
            }), c = "connections", f = [h, g], gI(f, w), T[c] === void 0 && (T[c] = [])
        }
        c === "Node" && (T.id = f), c in T && Array.isArray(T[c]) ? T[c].push(f) : c !== "a" ? T[c] = f : T.a = f, this.setCurrentProp(T, c), c === "a" && f.slice(-1) !== "," && (T.a = jy(f))
    }

    parseNodePropertyContinued(t) {
        const i = this.getCurrentNode();
        i.a += t, t.slice(-1) !== "," && (i.a = jy(i.a))
    }

    parseNodeSpecialProperty(t, i, o) {
        const c = o.split('",').map(function (g) {
            return g.trim().replace(/^\"/, "").replace(/\s/, "_")
        }), f = c[0], T = c[1], m = c[2], x = c[3];
        let h = c[4];
        switch (T) {
            case"int":
            case"enum":
            case"bool":
            case"ULongLong":
            case"double":
            case"Number":
            case"FieldOfView":
                h = parseFloat(h);
                break;
            case"Color":
            case"ColorRGB":
            case"Vector3D":
            case"Lcl_Translation":
            case"Lcl_Rotation":
            case"Lcl_Scaling":
                h = jy(h);
                break
        }
        this.getPrevNode()[f] = {type: T, type2: m, flag: x, value: h}, this.setCurrentProp(this.getPrevNode(), f)
    }
}

class dI {
    parse(t) {
        const i = new C2(t);
        i.skip(23);
        const o = i.getUint32();
        if (o < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + o);
        const c = new Ww;
        for (; !this.endOfContent(i);) {
            const f = this.parseNode(i, o);
            f !== null && c.add(f.name, f)
        }
        return c
    }

    endOfContent(t) {
        return t.size() % 16 === 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size()
    }

    parseNode(t, i) {
        const o = {}, c = i >= 7500 ? t.getUint64() : t.getUint32(), f = i >= 7500 ? t.getUint64() : t.getUint32();
        i >= 7500 ? t.getUint64() : t.getUint32();
        const T = t.getUint8(), m = t.getString(T);
        if (c === 0) return null;
        const x = [];
        for (let v = 0; v < f; v++) x.push(this.parseProperty(t));
        const h = x.length > 0 ? x[0] : "", g = x.length > 1 ? x[1] : "", w = x.length > 2 ? x[2] : "";
        for (o.singleProperty = f === 1 && t.getOffset() === c; c > t.getOffset();) {
            const v = this.parseNode(t, i);
            v !== null && this.parseSubNode(m, o, v)
        }
        return o.propertyList = x, typeof h == "number" && (o.id = h), g !== "" && (o.attrName = g), w !== "" && (o.attrType = w), m !== "" && (o.name = m), o
    }

    parseSubNode(t, i, o) {
        if (o.singleProperty === !0) {
            const c = o.propertyList[0];
            Array.isArray(c) ? (i[o.name] = o, o.a = c) : i[o.name] = c
        } else if (t === "Connections" && o.name === "C") {
            const c = [];
            o.propertyList.forEach(function (f, T) {
                T !== 0 && c.push(f)
            }), i.connections === void 0 && (i.connections = []), i.connections.push(c)
        } else if (o.name === "Properties70") Object.keys(o).forEach(function (f) {
            i[f] = o[f]
        }); else if (t === "Properties70" && o.name === "P") {
            let c = o.propertyList[0], f = o.propertyList[1];
            const T = o.propertyList[2], m = o.propertyList[3];
            let x;
            c.indexOf("Lcl ") === 0 && (c = c.replace("Lcl ", "Lcl_")), f.indexOf("Lcl ") === 0 && (f = f.replace("Lcl ", "Lcl_")), f === "Color" || f === "ColorRGB" || f === "Vector" || f === "Vector3D" || f.indexOf("Lcl_") === 0 ? x = [o.propertyList[4], o.propertyList[5], o.propertyList[6]] : x = o.propertyList[4], i[c] = {
                type: f,
                type2: T,
                flag: m,
                value: x
            }
        } else i[o.name] === void 0 ? typeof o.id == "number" ? (i[o.name] = {}, i[o.name][o.id] = o) : i[o.name] = o : o.name === "PoseNode" ? (Array.isArray(i[o.name]) || (i[o.name] = [i[o.name]]), i[o.name].push(o)) : i[o.name][o.id] === void 0 && (i[o.name][o.id] = o)
    }

    parseProperty(t) {
        const i = t.getString(1);
        let o;
        switch (i) {
            case"C":
                return t.getBoolean();
            case"D":
                return t.getFloat64();
            case"F":
                return t.getFloat32();
            case"I":
                return t.getInt32();
            case"L":
                return t.getInt64();
            case"R":
                return o = t.getUint32(), t.getArrayBuffer(o);
            case"S":
                return o = t.getUint32(), t.getString(o);
            case"Y":
                return t.getInt16();
            case"b":
            case"c":
            case"d":
            case"f":
            case"i":
            case"l":
                const c = t.getUint32(), f = t.getUint32(), T = t.getUint32();
                if (f === 0) switch (i) {
                    case"b":
                    case"c":
                        return t.getBooleanArray(c);
                    case"d":
                        return t.getFloat64Array(c);
                    case"f":
                        return t.getFloat32Array(c);
                    case"i":
                        return t.getInt32Array(c);
                    case"l":
                        return t.getInt64Array(c)
                }
                const m = qT(new Uint8Array(t.getArrayBuffer(T))), x = new C2(m.buffer);
                switch (i) {
                    case"b":
                    case"c":
                        return x.getBooleanArray(c);
                    case"d":
                        return x.getFloat64Array(c);
                    case"f":
                        return x.getFloat32Array(c);
                    case"i":
                        return x.getInt32Array(c);
                    case"l":
                        return x.getInt64Array(c)
                }
                break;
            default:
                throw new Error("THREE.FBXLoader: Unknown property type " + i)
        }
    }
}

class C2 {
    constructor(t, i) {
        this.dv = new DataView(t), this.offset = 0, this.littleEndian = i !== void 0 ? i : !0, this._textDecoder = new TextDecoder
    }

    getOffset() {
        return this.offset
    }

    size() {
        return this.dv.buffer.byteLength
    }

    skip(t) {
        this.offset += t
    }

    getBoolean() {
        return (this.getUint8() & 1) === 1
    }

    getBooleanArray(t) {
        const i = [];
        for (let o = 0; o < t; o++) i.push(this.getBoolean());
        return i
    }

    getUint8() {
        const t = this.dv.getUint8(this.offset);
        return this.offset += 1, t
    }

    getInt16() {
        const t = this.dv.getInt16(this.offset, this.littleEndian);
        return this.offset += 2, t
    }

    getInt32() {
        const t = this.dv.getInt32(this.offset, this.littleEndian);
        return this.offset += 4, t
    }

    getInt32Array(t) {
        const i = [];
        for (let o = 0; o < t; o++) i.push(this.getInt32());
        return i
    }

    getUint32() {
        const t = this.dv.getUint32(this.offset, this.littleEndian);
        return this.offset += 4, t
    }

    getInt64() {
        let t, i;
        return this.littleEndian ? (t = this.getUint32(), i = this.getUint32()) : (i = this.getUint32(), t = this.getUint32()), i & 2147483648 ? (i = ~i & 4294967295, t = ~t & 4294967295, t === 4294967295 && (i = i + 1 & 4294967295), t = t + 1 & 4294967295, -(i * 4294967296 + t)) : i * 4294967296 + t
    }

    getInt64Array(t) {
        const i = [];
        for (let o = 0; o < t; o++) i.push(this.getInt64());
        return i
    }

    getUint64() {
        let t, i;
        return this.littleEndian ? (t = this.getUint32(), i = this.getUint32()) : (i = this.getUint32(), t = this.getUint32()), i * 4294967296 + t
    }

    getFloat32() {
        const t = this.dv.getFloat32(this.offset, this.littleEndian);
        return this.offset += 4, t
    }

    getFloat32Array(t) {
        const i = [];
        for (let o = 0; o < t; o++) i.push(this.getFloat32());
        return i
    }

    getFloat64() {
        const t = this.dv.getFloat64(this.offset, this.littleEndian);
        return this.offset += 8, t
    }

    getFloat64Array(t) {
        const i = [];
        for (let o = 0; o < t; o++) i.push(this.getFloat64());
        return i
    }

    getArrayBuffer(t) {
        const i = this.dv.buffer.slice(this.offset, this.offset + t);
        return this.offset += t, i
    }

    getString(t) {
        const i = this.offset;
        let o = new Uint8Array(this.dv.buffer, i, t);
        this.skip(t);
        const c = o.indexOf(0);
        return c >= 0 && (o = new Uint8Array(this.dv.buffer, i, c)), this._textDecoder.decode(o)
    }
}

class Ww {
    add(t, i) {
        this[t] = i
    }
}

function fI(A) {
    const t = "Kaydara FBX Binary  \0";
    return A.byteLength >= t.length && t === Yw(A, 0, t.length)
}

function pI(A) {
    const t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
    let i = 0;

    function o(c) {
        const f = A[c - 1];
        return A = A.slice(i + c), i++, f
    }

    for (let c = 0; c < t.length; ++c) if (o(1) === t[c]) return !1;
    return !0
}

function w2(A) {
    const t = /FBXVersion: (\d+)/, i = A.match(t);
    if (i) return parseInt(i[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
}

function mI(A) {
    return A / 46186158e3
}

const AI = [];

function s0(A, t, i, o) {
    let c;
    switch (o.mappingType) {
        case"ByPolygonVertex":
            c = A;
            break;
        case"ByPolygon":
            c = t;
            break;
        case"ByVertice":
            c = i;
            break;
        case"AllSame":
            c = o.indices[0];
            break;
        default:
            console.warn("THREE.FBXLoader: unknown attribute mapping type " + o.mappingType)
    }
    o.referenceType === "IndexToDirect" && (c = o.indices[c]);
    const f = c * o.dataSize, T = f + o.dataSize;
    return vI(AI, o.buffer, f, T)
}

const Qy = new ao, tf = new ft;

function Kw(A) {
    const t = new $n, i = new $n, o = new $n, c = new $n, f = new $n, T = new $n, m = new $n, x = new $n, h = new $n,
        g = new $n, w = new $n, v = new $n, E = A.inheritType ? A.inheritType : 0;
    if (A.translation && t.setPosition(tf.fromArray(A.translation)), A.preRotation) {
        const U = A.preRotation.map(Js.degToRad);
        U.push(A.eulerOrder || ao.DEFAULT_ORDER), i.makeRotationFromEuler(Qy.fromArray(U))
    }
    if (A.rotation) {
        const U = A.rotation.map(Js.degToRad);
        U.push(A.eulerOrder || ao.DEFAULT_ORDER), o.makeRotationFromEuler(Qy.fromArray(U))
    }
    if (A.postRotation) {
        const U = A.postRotation.map(Js.degToRad);
        U.push(A.eulerOrder || ao.DEFAULT_ORDER), c.makeRotationFromEuler(Qy.fromArray(U)), c.invert()
    }
    A.scale && f.scale(tf.fromArray(A.scale)), A.scalingOffset && m.setPosition(tf.fromArray(A.scalingOffset)), A.scalingPivot && T.setPosition(tf.fromArray(A.scalingPivot)), A.rotationOffset && x.setPosition(tf.fromArray(A.rotationOffset)), A.rotationPivot && h.setPosition(tf.fromArray(A.rotationPivot)), A.parentMatrixWorld && (w.copy(A.parentMatrix), g.copy(A.parentMatrixWorld));
    const p = i.clone().multiply(o).multiply(c), C = new $n;
    C.extractRotation(g);
    const M = new $n;
    M.copyPosition(g);
    const b = M.clone().invert().multiply(g), B = C.clone().invert().multiply(b), R = f, I = new $n;
    if (E === 0) I.copy(C).multiply(p).multiply(B).multiply(R); else if (E === 1) I.copy(C).multiply(B).multiply(p).multiply(R); else {
        const j = new $n().scale(new ft().setFromMatrixScale(w)).clone().invert(), Y = B.clone().multiply(j);
        I.copy(C).multiply(p).multiply(Y).multiply(R)
    }
    const L = h.clone().invert(), O = T.clone().invert();
    let N = t.clone().multiply(x).multiply(h).multiply(i).multiply(o).multiply(c).multiply(L).multiply(m).multiply(T).multiply(f).multiply(O);
    const F = new $n().copyPosition(N), V = g.clone().multiply(F);
    return v.copyPosition(V), N = v.clone().multiply(I), N.premultiply(g.invert()), N
}

function Xw(A) {
    A = A || 0;
    const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return A === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[A]
}

function jy(A) {
    return A.split(",").map(function (i) {
        return parseFloat(i)
    })
}

function Yw(A, t, i) {
    return t === void 0 && (t = 0), i === void 0 && (i = A.byteLength), new TextDecoder().decode(new Uint8Array(A, t, i))
}

function gI(A, t) {
    for (let i = 0, o = A.length, c = t.length; i < c; i++, o++) A[o] = t[i]
}

function vI(A, t, i, o) {
    for (let c = i, f = 0; c < o; c++, f++) A[f] = t[c];
    return A
}

THREE.FBXLoader = aI;
AFRAME.registerComponent("fbx-model", {
    schema: {src: {type: "asset"}, crossorigin: {default: ""}}, init: function () {
        this.model = null
    }, update: function () {
        const A = this.data;
        if (!A.src) return;
        this.remove();
        const t = new THREE.FBXLoader;
        A.crossorigin && t.setCrossOrigin(A.crossorigin), t.load(A.src, this.load.bind(this))
    }, load: function (A) {
        this.model = A, this.el.setObject3D("mesh", A), this.el.emit("model-loaded", {format: "fbx", model: A})
    }, remove: function () {
        this.model && this.el.removeObject3D("mesh")
    }
});
var Wy, b2;

function yI() {
    if (b2) return Wy;
    b2 = 1;

    function A() {
        return "script_" + Date.now() + "_" + Math.ceil(Math.random() * 1e5)
    }

    function t(T, m) {
        var x = document.createElement("script");
        return x.type = "text/javascript", x.async = !0, x.id = m, x.src = T, x
    }

    function i(T) {
        const m = document.getElementById(T), x = m.parentNode;
        try {
            x && x.removeChild(m)
        } catch {
        }
    }

    function o(T) {
        const m = document.getElementsByTagName("script")[0];
        m.parentNode.insertBefore(T, m)
    }

    function c(T, m, x) {
        return new x(function (h, g) {
            const w = m.timeout || 5e3, v = A(), E = t(T, v), p = setTimeout(function () {
                g(new Error("Script request to " + T + " timed out")), i(v)
            }, w), C = function (M) {
                clearTimeout(M)
            };
            E.addEventListener("load", function (M) {
                h({ok: !0}), C(p), i(v)
            }), E.addEventListener("error", function (M) {
                g(new Error("Script request to " + T + " failed " + M)), C(p), i(v)
            }), o(E)
        })
    }

    function f(T) {
        return T = T || {}, function (m, x) {
            return x = x || {}, c(m, x, T.Promise || Promise)
        }
    }

    return Wy = f, Wy
}

var Ky, _2;

function EI() {
    if (_2) return Ky;
    _2 = 1;
    const A = yI()(), t = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r86/examples/js/loaders/GLTFLoader.js",
        i = function () {
            let o;
            return function () {
                return o = o || A(t), o
            }
        }();
    return Ky = AFRAME.registerComponent("gltf-model-legacy", {
        schema: {type: "model"}, init: function () {
            this.model = null, this.loader = null, this.loaderPromise = i().then(() => {
                this.loader = new THREE.GLTFLoader, this.loader.setCrossOrigin("Anonymous")
            })
        }, update: function () {
            const o = this, c = this.el, f = this.data;
            f && (this.remove(), this.loaderPromise.then(() => {
                this.loader.load(f, function (m) {
                    o.model = m.scene, o.model.animations = m.animations, c.setObject3D("mesh", o.model), c.emit("model-loaded", {
                        format: "gltf",
                        model: o.model
                    })
                })
            }))
        }, remove: function () {
            this.model && this.el.removeObject3D("mesh")
        }
    }), Ky
}

var Xy, M2;

function xI() {
    return M2 || (M2 = 1, Xy = AFRAME.registerComponent("object-model", {
        schema: {
            src: {type: "asset"},
            crossorigin: {default: ""}
        }, init: function () {
            this.model = null
        }, update: function () {
            let A;
            const t = this.data;
            t.src && (this.remove(), A = new THREE.ObjectLoader, t.crossorigin && A.setCrossOrigin(t.crossorigin), A.load(t.src, i => {
                i.traverse(o => {
                    o instanceof THREE.SkinnedMesh && o.material && (o.material.skinning = !!(o.geometry && o.geometry.bones || []).length)
                }), this.load(i)
            }))
        }, load: function (A) {
            this.model = A, this.el.setObject3D("mesh", A), this.el.emit("model-loaded", {format: "json", model: A})
        }, remove: function () {
            this.model && this.el.removeObject3D("mesh")
        }
    })), Xy
}

var S2;

function CI() {
    return S2 || (S2 = 1, z3(), EI(), xI()), vC
}

var T2 = {}, Yy, I2;

function wI() {
    return I2 || (I2 = 1, Yy = AFRAME.registerComponent("checkpoint", {
        schema: {
            offset: {
                default: {x: 0, y: 0, z: 0},
                type: "vec3"
            }
        }, init: function () {
            this.active = !1, this.targetEl = null, this.fire = this.fire.bind(this), this.offset = new THREE.Vector3
        }, update: function () {
            this.offset.copy(this.data.offset)
        }, play: function () {
            this.el.addEventListener("click", this.fire)
        }, pause: function () {
            this.el.removeEventListener("click", this.fire)
        }, remove: function () {
            this.pause()
        }, fire: function () {
            const A = this.el.sceneEl.querySelector("[checkpoint-controls]");
            if (!A) throw new Error("No `checkpoint-controls` component found.");
            A.components["checkpoint-controls"].setCheckpoint(this.el)
        }, getOffset: function () {
            return this.offset.copy(this.data.offset)
        }
    })), Yy
}

var qy, R2;

function bI() {
    if (R2) return qy;
    R2 = 1;

    function A(i) {
        return i ? Array.isArray(i) ? i : i.materials ? i.materials : [i] : []
    }

    function t(i, o, c, f) {
        i && (o = o || [], i.traverse(T => {
            if (!T.isMesh) return;
            A(T.material).forEach(x => {
                x && !("envMap" in x) || o.length && o.indexOf(x.name) === -1 || (x.envMap = c, x.reflectivity = f, x.needsUpdate = !0)
            })
        }))
    }

    return qy = AFRAME.registerComponent("cube-env-map", {
        multiple: !0,
        schema: {
            path: {default: ""},
            extension: {default: "jpg", oneOf: ["jpg", "png"]},
            enableBackground: {default: !1},
            reflectivity: {default: 1, min: 0, max: 1},
            materials: {default: []}
        },
        init: function () {
            const i = this.data;
            this.texture = new THREE.CubeTextureLoader().load([i.path + "posx." + i.extension, i.path + "negx." + i.extension, i.path + "posy." + i.extension, i.path + "negy." + i.extension, i.path + "posz." + i.extension, i.path + "negz." + i.extension]), this.texture.format = THREE.RGBAFormat, this.object3dsetHandler = () => {
                const o = this.el.getObject3D("mesh"), c = this.data;
                t(o, c.materials, this.texture, c.reflectivity)
            }, this.object3dsetHandler(), this.el.addEventListener("object3dset", this.object3dsetHandler)
        },
        update: function (i) {
            const o = this.data, c = this.el.getObject3D("mesh");
            let f = [], T = [];
            if (o.materials.length && (i.materials ? (f = o.materials.filter(m => !i.materials.includes(m)), T = i.materials.filter(m => !o.materials.includes(m))) : f = o.materials), f.length && t(c, f, this.texture, o.reflectivity), T.length && t(c, T, null, 1), i.materials && o.reflectivity !== i.reflectivity) {
                const m = o.materials.filter(x => i.materials.includes(x));
                m.length && t(c, m, this.texture, o.reflectivity)
            }
            this.data.enableBackground && !i.enableBackground ? this.setBackground(this.texture) : !this.data.enableBackground && i.enableBackground && this.setBackground(null)
        },
        remove: function () {
            this.el.removeEventListener("object3dset", this.object3dsetHandler);
            const i = this.el.getObject3D("mesh"), o = this.data;
            t(i, o.materials, null, 1), o.enableBackground && this.setBackground(null)
        },
        setBackground: function (i) {
            this.el.sceneEl.object3D.background = i
        }
    }), qy
}

var Jy, B2;

function _I() {
    return B2 || (B2 = 1, Jy = AFRAME.registerComponent("grab", {
        init: function () {
            this.system = this.el.sceneEl.systems.physics, this.GRABBED_STATE = "grabbed", this.grabbing = !1, this.hitEl = null, this.physics = this.el.sceneEl.systems.physics, this.constraint = null, this.onHit = this.onHit.bind(this), this.onGripOpen = this.onGripOpen.bind(this), this.onGripClose = this.onGripClose.bind(this)
        }, play: function () {
            const A = this.el;
            A.addEventListener("hit", this.onHit), A.addEventListener("gripdown", this.onGripClose), A.addEventListener("gripup", this.onGripOpen), A.addEventListener("trackpaddown", this.onGripClose), A.addEventListener("trackpadup", this.onGripOpen), A.addEventListener("triggerdown", this.onGripClose), A.addEventListener("triggerup", this.onGripOpen)
        }, pause: function () {
            const A = this.el;
            A.removeEventListener("hit", this.onHit), A.removeEventListener("gripdown", this.onGripClose), A.removeEventListener("gripup", this.onGripOpen), A.removeEventListener("trackpaddown", this.onGripClose), A.removeEventListener("trackpadup", this.onGripOpen), A.removeEventListener("triggerdown", this.onGripClose), A.removeEventListener("triggerup", this.onGripOpen)
        }, onGripClose: function () {
            this.grabbing = !0
        }, onGripOpen: function () {
            const A = this.hitEl;
            this.grabbing = !1, A && (A.removeState(this.GRABBED_STATE), this.hitEl = void 0, this.system.removeConstraint(this.constraint), this.constraint = null)
        }, onHit: function (A) {
            const t = A.detail.el;
            t.is(this.GRABBED_STATE) || !this.grabbing || this.hitEl || (t.addState(this.GRABBED_STATE), this.hitEl = t, this.constraint = new CANNON.LockConstraint(this.el.body, t.body), this.system.addConstraint(this.constraint))
        }
    })), Jy
}

var Zy, L2;

function MI() {
    return L2 || (L2 = 1, Zy = AFRAME.registerComponent("normal-material", {
        init: function () {
            this.material = new THREE.MeshNormalMaterial({flatShading: !0}), this.applyMaterial = this.applyMaterial.bind(this), this.el.addEventListener("object3dset", this.applyMaterial), this.applyMaterial()
        }, remove: function () {
            this.el.removeEventListener("object3dset", this.applyMaterial)
        }, applyMaterial: function () {
            this.el.object3D.traverse(A => {
                A.isMesh && (A.material = this.material)
            })
        }
    })), Zy
}

var $y, D2;

function SI() {
    if (D2) return $y;
    D2 = 1, $y = AFRAME.registerComponent("sphere-collider", {
        schema: {
            enabled: {default: !0},
            interval: {default: 80},
            objects: {default: ""},
            state: {default: "collided"},
            radius: {default: .05},
            watch: {default: !0}
        }, init: function () {
            this.observer = null, this.els = [], this.collisions = [], this.prevCheckTime = void 0, this.eventDetail = {}, this.handleHit = this.handleHit.bind(this), this.handleHitEnd = this.handleHitEnd.bind(this)
        }, play: function () {
            const t = this.el.sceneEl;
            this.data.watch && (this.observer = new MutationObserver(this.update.bind(this, null)), this.observer.observe(t, {
                childList: !0,
                subtree: !0
            }))
        }, pause: function () {
            this.observer && (this.observer.disconnect(), this.observer = null)
        }, update: function () {
            const t = this.data;
            let i;
            t.objects ? i = this.el.sceneEl.querySelectorAll(t.objects) : i = this.el.sceneEl.children, this.els = Array.prototype.slice.call(i)
        }, tick: function () {
            const t = new THREE.Vector3, i = new THREE.Vector3, o = new THREE.Vector3, c = new THREE.Vector3,
                f = new THREE.Box3, T = [], m = new Map;
            return function (x) {
                if (!this.data.enabled) return;
                const h = this.prevCheckTime;
                if (h && x - h < this.data.interval) return;
                this.prevCheckTime = x;
                const g = this.el, w = this.data, v = g.getObject3D("mesh");
                let E;
                if (!v) return;
                T.length = 0, m.clear(), g.object3D.getWorldPosition(t), g.object3D.getWorldScale(o), E = w.radius * C(o), this.els.forEach(p), T.sort((M, b) => m.get(M) > m.get(b) ? 1 : -1).forEach(this.handleHit), this.collisions.filter(M => !m.has(M)).forEach(this.handleHitEnd), A(this.collisions, T);

                function p(M) {
                    let b, B, R, I;
                    M.isEntity && (B = M.getObject3D("mesh"), B && (f.setFromObject(B).getSize(c), I = Math.max(c.x, c.y, c.z) / 2, b = Math.sqrt(2 * I * I), f.getCenter(i), b && (R = t.distanceTo(i), R < b + E && (T.push(M), m.set(M, R)))))
                }

                function C(M) {
                    return Math.max(M.x, M.y, M.z)
                }
            }
        }(), handleHit: function (t) {
            t.emit("hit"), t.addState(this.data.state), this.eventDetail.el = t, this.el.emit("hit", this.eventDetail)
        }, handleHitEnd: function (t) {
            t.emit("hitend"), t.removeState(this.data.state), this.eventDetail.el = t, this.el.emit("hitend", this.eventDetail)
        }
    });

    function A(t, i) {
        t.length = 0;
        for (let o = 0; o < i.length; o++) t[o] = i[o]
    }

    return $y
}

var P2;

function TI() {
    return P2 || (P2 = 1, wI(), bI(), _I(), MI(), SI()), T2
}

var O2 = {}, e1, k2;

function II() {
    return k2 || (k2 = 1, e1 = AFRAME.registerComponent("nav-mesh", {
        schema: {nodeName: {type: "string"}},
        init: function () {
            this.system = this.el.sceneEl.systems.nav, this.hasLoadedNavMesh = !1, this.nodeName = this.data.nodeName, this.el.addEventListener("object3dset", this.loadNavMesh.bind(this))
        },
        play: function () {
            this.hasLoadedNavMesh || this.loadNavMesh()
        },
        loadNavMesh: function () {
            var A = this;
            const t = this.el.getObject3D("mesh");
            if (this.el.sceneEl.object3D, !t) return;
            let i;
            if (t.traverse(c => {
                c.isMesh && (!A.nodeName || c.name === A.nodeName) && (i = c)
            }), !i) return;
            const o = i.geometry.clone();
            i.updateWorldMatrix(!0, !1), o.applyMatrix4(i.matrixWorld), this.system.setNavMeshGeometry(o), this.hasLoadedNavMesh = !0
        }
    })), e1
}

var t1, F2;

function RI() {
    return F2 || (F2 = 1, t1 = AFRAME.registerComponent("nav-agent", {
        schema: {destination: {type: "vec3"}, active: {default: !1}, speed: {default: 2}}, init: function () {
            this.system = this.el.sceneEl.systems.nav, this.system.addAgent(this), this.group = null, this.path = [], this.raycaster = new THREE.Raycaster
        }, remove: function () {
            this.system.removeAgent(this)
        }, update: function () {
            this.path.length = 0
        }, updateNavLocation: function () {
            this.group = null, this.path = []
        }, tick: function () {
            const A = new THREE.Vector3, t = new THREE.Vector3, i = new THREE.Vector3;
            return function (o, c) {
                const f = this.el, T = this.data, m = this.raycaster, x = T.speed * c / 1e3;
                if (!T.active) return;
                if (!this.path.length) {
                    const p = this.el.object3D.position;
                    this.group = this.group || this.system.getGroup(p), this.path = this.system.getPath(p, A.copy(T.destination), this.group) || [], f.emit("navigation-start")
                }
                if (!this.path.length) {
                    console.warn("[nav] Unable to find path to %o.", T.destination), this.el.setAttribute("nav-agent", {active: !1}), f.emit("navigation-end");
                    return
                }
                const h = f.object3D.position, g = this.path[0];
                t.subVectors(g, h);
                const w = t.length();
                let v;
                if (w < x) {
                    if (this.path.shift(), !this.path.length) {
                        this.el.setAttribute("nav-agent", {active: !1}), f.emit("navigation-end");
                        return
                    }
                    i.copy(h), v = this.path[0]
                } else i.copy(t.setLength(x)).add(h), v = g;
                v.y = h.y, f.object3D.lookAt(v), m.ray.origin.copy(i), m.ray.origin.y += 1.5, m.ray.direction = {
                    x: 0,
                    y: -1,
                    z: 0
                };
                const E = m.intersectObject(this.system.getNavMesh());
                E.length ? (t.subVectors(E[0].point, h), h.add(t.setLength(x))) : h.copy(i)
            }
        }()
    })), t1
}

class Ns {
    static roundNumber(t, i) {
        const o = Math.pow(10, i);
        return Math.round(t * o) / o
    }

    static sample(t) {
        return t[Math.floor(Math.random() * t.length)]
    }

    static distanceToSquared(t, i) {
        var o = t.x - i.x, c = t.y - i.y, f = t.z - i.z;
        return o * o + c * c + f * f
    }

    static isPointInPoly(t, i) {
        for (var o = !1, c = -1, f = t.length, T = f - 1; ++c < f; T = c) (t[c].z <= i.z && i.z < t[T].z || t[T].z <= i.z && i.z < t[c].z) && i.x < (t[T].x - t[c].x) * (i.z - t[c].z) / (t[T].z - t[c].z) + t[c].x && (o = !o);
        return o
    }

    static isVectorInPolygon(t, i, o) {
        var c = 1e5, f = -1e5, T = [];
        return i.vertexIds.forEach(m => {
            c = Math.min(o[m].y, c), f = Math.max(o[m].y, f), T.push(o[m])
        }), !!(t.y < f + .5 && t.y > c - .5 && this.isPointInPoly(T, t))
    }

    static triarea2(t, i, o) {
        return (o.x - t.x) * (i.z - t.z) - (i.x - t.x) * (o.z - t.z)
    }

    static vequal(t, i) {
        return this.distanceToSquared(t, i) < 1e-5
    }

    static mergeVertices(t, i = 1e-4) {
        i = Math.max(i, Number.EPSILON);
        for (var o = {}, c = t.getIndex(), f = t.getAttribute("position"), T = c ? c.count : f.count, m = 0, x = [], h = [], g = Math.log10(1 / i), w = Math.pow(10, g), v = 0; v < T; v++) {
            var E = c ? c.getX(v) : v, p = "";
            p += ~~(f.getX(E) * w) + ",", p += ~~(f.getY(E) * w) + ",", (p += ~~(f.getZ(E) * w) + ",") in o ? x.push(o[p]) : (h.push(f.getX(E)), h.push(f.getY(E)), h.push(f.getZ(E)), o[p] = m, x.push(m), m++)
        }
        const C = new Ru(new Float32Array(h), f.itemSize, f.normalized), M = new il;
        return M.setAttribute("position", C), M.setIndex(x), M
    }
}

class BI {
    constructor(t) {
        this.content = [], this.scoreFunction = t
    }

    push(t) {
        this.content.push(t), this.sinkDown(this.content.length - 1)
    }

    pop() {
        const t = this.content[0], i = this.content.pop();
        return this.content.length > 0 && (this.content[0] = i, this.bubbleUp(0)), t
    }

    remove(t) {
        const i = this.content.indexOf(t), o = this.content.pop();
        i !== this.content.length - 1 && (this.content[i] = o, this.scoreFunction(o) < this.scoreFunction(t) ? this.sinkDown(i) : this.bubbleUp(i))
    }

    size() {
        return this.content.length
    }

    rescoreElement(t) {
        this.sinkDown(this.content.indexOf(t))
    }

    sinkDown(t) {
        const i = this.content[t];
        for (; t > 0;) {
            const o = (t + 1 >> 1) - 1, c = this.content[o];
            if (!(this.scoreFunction(i) < this.scoreFunction(c))) break;
            this.content[o] = i, this.content[t] = c, t = o
        }
    }

    bubbleUp(t) {
        const i = this.content.length, o = this.content[t], c = this.scoreFunction(o);
        for (; ;) {
            const f = t + 1 << 1, T = f - 1;
            let m, x = null;
            if (T < i && (m = this.scoreFunction(this.content[T]), m < c && (x = T)), f < i && this.scoreFunction(this.content[f]) < (x === null ? c : m) && (x = f), x === null) break;
            this.content[t] = this.content[x], this.content[x] = o, t = x
        }
    }
}

class LI {
    constructor() {
        this.portals = []
    }

    push(t, i) {
        i === void 0 && (i = t), this.portals.push({left: t, right: i})
    }

    stringPull() {
        const t = this.portals, i = [];
        let o, c, f, T = 0, m = 0, x = 0;
        o = t[0].left, c = t[0].left, f = t[0].right, i.push(o);
        for (let h = 1; h < t.length; h++) {
            const g = t[h].left, w = t[h].right;
            if (Ns.triarea2(o, f, w) <= 0) {
                if (!(Ns.vequal(o, f) || Ns.triarea2(o, c, w) > 0)) {
                    i.push(c), o = c, T = m, c = o, f = o, m = T, x = T, h = T;
                    continue
                }
                f = w, x = h
            }
            if (Ns.triarea2(o, c, g) >= 0) {
                if (!(Ns.vequal(o, c) || Ns.triarea2(o, f, g) < 0)) {
                    i.push(f), o = f, T = x, c = o, f = o, m = T, x = T, h = T;
                    continue
                }
                c = g, m = h
            }
        }
        return i.length !== 0 && Ns.vequal(i[i.length - 1], t[t.length - 1].left) || i.push(t[t.length - 1].left), this.path = i, i
    }
}

class x1 {
    constructor() {
        this.zones = {}
    }

    static createZone(t, i = 1e-4) {
        return (class {
            static buildZone(o, c) {
                const f = this._buildNavigationMesh(o, c), T = {};
                f.vertices.forEach(x => {
                    x.x = Ns.roundNumber(x.x, 2), x.y = Ns.roundNumber(x.y, 2), x.z = Ns.roundNumber(x.z, 2)
                }), T.vertices = f.vertices;
                const m = this._buildPolygonGroups(f);
                return T.groups = new Array(m.length), m.forEach((x, h) => {
                    const g = new Map;
                    x.forEach((v, E) => {
                        g.set(v, E)
                    });
                    const w = new Array(x.length);
                    x.forEach((v, E) => {
                        const p = [];
                        v.neighbours.forEach(b => p.push(g.get(b)));
                        const C = [];
                        v.neighbours.forEach(b => C.push(this._getSharedVerticesInOrder(v, b)));
                        const M = new ft(0, 0, 0);
                        M.add(T.vertices[v.vertexIds[0]]), M.add(T.vertices[v.vertexIds[1]]), M.add(T.vertices[v.vertexIds[2]]), M.divideScalar(3), M.x = Ns.roundNumber(M.x, 2), M.y = Ns.roundNumber(M.y, 2), M.z = Ns.roundNumber(M.z, 2), w[E] = {
                            id: E,
                            neighbours: p,
                            vertexIds: v.vertexIds,
                            centroid: M,
                            portals: C
                        }
                    }), T.groups[h] = w
                }), T
            }

            static _buildNavigationMesh(o, c) {
                return o = Ns.mergeVertices(o, c), this._buildPolygonsFromGeometry(o)
            }

            static _spreadGroupId(o) {
                let c = new Set([o]);
                for (; c.size > 0;) {
                    const f = c;
                    c = new Set, f.forEach(T => {
                        T.group = o.group, T.neighbours.forEach(m => {
                            m.group === void 0 && c.add(m)
                        })
                    })
                }
            }

            static _buildPolygonGroups(o) {
                const c = [];
                return o.polygons.forEach(f => {
                    f.group !== void 0 ? c[f.group].push(f) : (f.group = c.length, this._spreadGroupId(f), c.push([f]))
                }), c
            }

            static _buildPolygonNeighbours(o, c) {
                const f = new Set, T = c[o.vertexIds[1]], m = c[o.vertexIds[2]];
                return c[o.vertexIds[0]].forEach(x => {
                    x !== o && (T.includes(x) || m.includes(x)) && f.add(x)
                }), T.forEach(x => {
                    x !== o && m.includes(x) && f.add(x)
                }), f
            }

            static _buildPolygonsFromGeometry(o) {
                const c = [], f = [], T = o.attributes.position, m = o.index, x = [];
                for (let h = 0; h < T.count; h++) f.push(new ft().fromBufferAttribute(T, h)), x[h] = [];
                for (let h = 0; h < o.index.count; h += 3) {
                    const g = m.getX(h), w = m.getX(h + 1), v = m.getX(h + 2),
                        E = {vertexIds: [g, w, v], neighbours: null};
                    c.push(E), x[g].push(E), x[w].push(E), x[v].push(E)
                }
                return c.forEach(h => {
                    h.neighbours = this._buildPolygonNeighbours(h, x)
                }), {polygons: c, vertices: f}
            }

            static _getSharedVerticesInOrder(o, c) {
                const f = o.vertexIds, T = f[0], m = f[1], x = f[2], h = c.vertexIds, g = h.includes(T),
                    w = h.includes(m), v = h.includes(x);
                return g && w && v ? Array.from(f) : g && w ? [T, m] : w && v ? [m, x] : g && v ? [x, T] : (console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."), [])
            }
        }).buildZone(t, i)
    }

    setZoneData(t, i) {
        this.zones[t] = i
    }

    getRandomNode(t, i, o, c) {
        if (!this.zones[t]) return new ft;
        o = o || null, c = c || 0;
        const f = [];
        return this.zones[t].groups[i].forEach(T => {
            o && c ? Ns.distanceToSquared(o, T.centroid) < c * c && f.push(T.centroid) : f.push(T.centroid)
        }), Ns.sample(f) || new ft
    }

    getClosestNode(t, i, o, c = !1) {
        const f = this.zones[i].vertices;
        let T = null, m = 1 / 0;
        return this.zones[i].groups[o].forEach(x => {
            const h = Ns.distanceToSquared(x.centroid, t);
            h < m && (!c || Ns.isVectorInPolygon(t, x, f)) && (T = x, m = h)
        }), T
    }

    findPath(t, i, o, c) {
        const f = this.zones[o].groups[c], T = this.zones[o].vertices, m = this.getClosestNode(t, o, c, !0),
            x = this.getClosestNode(i, o, c, !0);
        if (!m || !x) return null;
        const h = (class {
            static init(E) {
                for (let p = 0; p < E.length; p++) {
                    const C = E[p];
                    C.f = 0, C.g = 0, C.h = 0, C.cost = 1, C.visited = !1, C.closed = !1, C.parent = null
                }
            }

            static cleanUp(E) {
                for (let p = 0; p < E.length; p++) {
                    const C = E[p];
                    delete C.f, delete C.g, delete C.h, delete C.cost, delete C.visited, delete C.closed, delete C.parent
                }
            }

            static heap() {
                return new BI(function (E) {
                    return E.f
                })
            }

            static search(E, p, C) {
                this.init(E);
                const M = this.heap();
                for (M.push(p); M.size() > 0;) {
                    const b = M.pop();
                    if (b === C) {
                        let R = b;
                        const I = [];
                        for (; R.parent;) I.push(R), R = R.parent;
                        return this.cleanUp(I), I.reverse()
                    }
                    b.closed = !0;
                    const B = this.neighbours(E, b);
                    for (let R = 0, I = B.length; R < I; R++) {
                        const L = B[R];
                        if (L.closed) continue;
                        const O = b.g + L.cost, N = L.visited;
                        if (!N || O < L.g) {
                            if (L.visited = !0, L.parent = b, !L.centroid || !C.centroid) throw new Error("Unexpected state");
                            L.h = L.h || this.heuristic(L.centroid, C.centroid), L.g = O, L.f = L.g + L.h, N ? M.rescoreElement(L) : M.push(L)
                        }
                    }
                }
                return []
            }

            static heuristic(E, p) {
                return Ns.distanceToSquared(E, p)
            }

            static neighbours(E, p) {
                const C = [];
                for (let M = 0; M < p.neighbours.length; M++) C.push(E[p.neighbours[M]]);
                return C
            }
        }).search(f, m, x), g = function (E, p) {
            for (var C = 0; C < E.neighbours.length; C++) if (E.neighbours[C] === p.id) return E.portals[C]
        }, w = new LI;
        w.push(t);
        for (let E = 0; E < h.length; E++) {
            const p = h[E], C = h[E + 1];
            if (C) {
                const M = g(p, C);
                w.push(T[M[0]], T[M[1]])
            }
        }
        w.push(i), w.stringPull();
        const v = w.path.map(E => new ft(E.x, E.y, E.z));
        return v.shift(), v
    }
}

x1.prototype.getGroup = function () {
    const A = new Mu;
    return function (t, i, o = !1) {
        if (!this.zones[t]) return null;
        let c = null, f = Math.pow(50, 2);
        const T = this.zones[t];
        for (let m = 0; m < T.groups.length; m++) {
            const x = T.groups[m];
            for (const h of x) {
                if (o && (A.setFromCoplanarPoints(T.vertices[h.vertexIds[0]], T.vertices[h.vertexIds[1]], T.vertices[h.vertexIds[2]]), Math.abs(A.distanceToPoint(i)) < .01) && Ns.isPointInPoly([T.vertices[h.vertexIds[0]], T.vertices[h.vertexIds[1]], T.vertices[h.vertexIds[2]]], i)) return m;
                const g = Ns.distanceToSquared(h.centroid, i);
                g < f && (c = m, f = g)
            }
        }
        return c
    }
}(), x1.prototype.clampStep = function () {
    const A = new ft, t = new Mu, i = new wl, o = new ft;
    let c, f, T = new ft;
    return function (m, x, h, g, w, v) {
        const E = this.zones[g].vertices, p = this.zones[g].groups[w], C = [h], M = {};
        M[h.id] = 0, c = void 0, T.set(0, 0, 0), f = 1 / 0, t.setFromCoplanarPoints(E[h.vertexIds[0]], E[h.vertexIds[1]], E[h.vertexIds[2]]), t.projectPoint(x, A), o.copy(A);
        for (let b = C.pop(); b; b = C.pop()) {
            i.set(E[b.vertexIds[0]], E[b.vertexIds[1]], E[b.vertexIds[2]]), i.closestPointToPoint(o, A), A.distanceToSquared(o) < f && (c = b, T.copy(A), f = A.distanceToSquared(o));
            const B = M[b.id];
            if (!(B > 2)) for (let R = 0; R < b.neighbours.length; R++) {
                const I = p[b.neighbours[R]];
                I.id in M || (C.push(I), M[I.id] = B + 1)
            }
        }
        return v.copy(T), c
    }
}();

class DI extends rs {
    constructor() {
        super(), this._playerMarker = new Tu(new b0(.25, 32, 32), new Su({color: 15631215})), this._targetMarker = new Tu(new om(.3, .3, .3), new Su({color: 14469912})), this._nodeMarker = new Tu(new om(.1, .8, .1), new Su({color: 4417387})), this._stepMarker = new Tu(new om(.1, 1, .1), new Su({color: 14472114})), this._pathMarker = new rs, this._pathLineMaterial = new dm({
            color: 41903,
            linewidth: 2
        }), this._pathPointMaterial = new Su({color: 41903}), this._pathPointGeometry = new b0(.08), this._markers = [this._playerMarker, this._targetMarker, this._nodeMarker, this._stepMarker, this._pathMarker], this._markers.forEach(t => {
            t.visible = !1, this.add(t)
        })
    }

    setPath(t) {
        for (; this._pathMarker.children.length;) this._pathMarker.children[0].visible = !1, this._pathMarker.remove(this._pathMarker.children[0]);
        t = [this._playerMarker.position].concat(t);
        const i = new il;
        i.setAttribute("position", new Ru(new Float32Array(3 * t.length), 3));
        for (let o = 0; o < t.length; o++) i.attributes.position.setXYZ(o, t[o].x, t[o].y + .2, t[o].z);
        this._pathMarker.add(new L0(i, this._pathLineMaterial));
        for (let o = 0; o < t.length - 1; o++) {
            const c = new Tu(this._pathPointGeometry, this._pathPointMaterial);
            c.position.copy(t[o]), c.position.y += .2, this._pathMarker.add(c)
        }
        return this._pathMarker.visible = !0, this
    }

    setPlayerPosition(t) {
        return this._playerMarker.position.copy(t), this._playerMarker.visible = !0, this
    }

    setTargetPosition(t) {
        return this._targetMarker.position.copy(t), this._targetMarker.visible = !0, this
    }

    setNodePosition(t) {
        return this._nodeMarker.position.copy(t), this._nodeMarker.visible = !0, this
    }

    setStepPosition(t) {
        return this._stepMarker.position.copy(t), this._stepMarker.visible = !0, this
    }

    reset() {
        for (; this._pathMarker.children.length;) this._pathMarker.children[0].visible = !1, this._pathMarker.remove(this._pathMarker.children[0]);
        return this._markers.forEach(t => {
            t.visible = !1
        }), this
    }
}

const PI = Object.freeze(Object.defineProperty({
    __proto__: null,
    Pathfinding: x1,
    PathfindingHelper: DI
}, Symbol.toStringTag, {value: "Module"})), OI = v3(PI);
var n1, N2;

function kI() {
    if (N2) return n1;
    N2 = 1;
    const {Pathfinding: A} = OI, t = new A, i = "level";
    return n1 = AFRAME.registerSystem("nav", {
        init: function () {
            this.navMesh = null, this.agents = new Set
        }, setNavMeshGeometry: function (o) {
            this.navMesh = new THREE.Mesh(o), t.setZoneData(i, A.createZone(o)), Array.from(this.agents).forEach(c => c.updateNavLocation())
        }, getNavMesh: function () {
            return this.navMesh
        }, addAgent: function (o) {
            this.agents.add(o)
        }, removeAgent: function (o) {
            this.agents.delete(o)
        }, getPath: function (o, c, f) {
            return this.navMesh ? t.findPath(o, c, i, f) : null
        }, getGroup: function (o) {
            return this.navMesh ? t.getGroup(i, o) : null
        }, getNode: function (o, c) {
            return this.navMesh ? t.getClosestNode(o, i, c, !0) : null
        }, clampStep: function (o, c, f, T, m) {
            if (this.navMesh) {
                if (!T) return m.copy(c), this.getNode(c, f)
            } else return m.copy(c), null;
            return t.clampStep(o, c, T, i, f, m)
        }
    }), n1
}

var U2;

function FI() {
    return U2 || (U2 = 1, II(), RI(), kI()), O2
}

var z2 = {}, i1, G2;

function NI() {
    return G2 || (G2 = 1, i1 = AFRAME.registerPrimitive("a-grid", {
        defaultComponents: {
            geometry: {
                primitive: "plane",
                width: 75,
                height: 75
            },
            rotation: {x: -90, y: 0, z: 0},
            material: {
                src: "url(https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v1.16.3/assets/grid.png)",
                repeat: "75 75"
            }
        }, mappings: {width: "geometry.width", height: "geometry.height", src: "material.src"}
    })), i1
}

var o0 = {}, V2;

function UI() {
    return V2 || (V2 = 1, o0.Primitive = AFRAME.registerPrimitive("a-ocean", {
        defaultComponents: {
            ocean: {},
            rotation: {x: -90, y: 0, z: 0}
        },
        mappings: {
            width: "ocean.width",
            depth: "ocean.depth",
            density: "ocean.density",
            amplitude: "ocean.amplitude",
            amplitudeVariance: "ocean.amplitudeVariance",
            speed: "ocean.speed",
            speedVariance: "ocean.speedVariance",
            color: "ocean.color",
            opacity: "ocean.opacity"
        }
    }), o0.Component = AFRAME.registerComponent("ocean", {
        schema: {
            width: {default: 10, min: 0},
            depth: {default: 10, min: 0},
            density: {default: 10},
            amplitude: {default: .1},
            amplitudeVariance: {default: .3},
            speed: {default: 1},
            speedVariance: {default: 2},
            color: {default: "#7AD2F7", type: "color"},
            opacity: {default: .8}
        }, play: function () {
            const A = this.el, t = this.data;
            let i = A.components.material;
            const o = new THREE.PlaneGeometry(t.width, t.depth, t.density, t.density);
            this.waves = [];
            const c = o.getAttribute("position");
            for (let f = 0; f < c.count; f++) this.waves.push({
                z: c.getZ(f),
                ang: Math.random() * Math.PI * 2,
                amp: t.amplitude + Math.random() * t.amplitudeVariance,
                speed: (t.speed + Math.random() * t.speedVariance) / 1e3
            });
            i || (i = {}, i.material = new THREE.MeshPhongMaterial({
                color: t.color,
                transparent: t.opacity < 1,
                opacity: t.opacity,
                flatShading: !0
            })), this.mesh = new THREE.Mesh(o, i.material), A.setObject3D("mesh", this.mesh)
        }, remove: function () {
            this.el.removeObject3D("mesh")
        }, tick: function (A, t) {
            if (!t) return;
            const i = this.mesh.geometry.getAttribute("position");
            for (let o = 0; o < i.count; o++) {
                const c = this.waves[o], f = c.z + Math.sin(c.ang) * c.amp;
                i.setZ(o, f), c.ang += c.speed * t
            }
            i.needsUpdate = !0
        }
    })), o0
}

var a0 = {}, H2;

function zI() {
    return H2 || (H2 = 1, a0.Primitive = AFRAME.registerPrimitive("a-tube", {
        defaultComponents: {tube: {}},
        mappings: {
            path: "tube.path",
            segments: "tube.segments",
            radius: "tube.radius",
            "radial-segments": "tube.radialSegments",
            closed: "tube.closed"
        }
    }), a0.Component = AFRAME.registerComponent("tube", {
        schema: {
            path: {default: []},
            segments: {default: 64},
            radius: {default: 1},
            radialSegments: {default: 8},
            closed: {default: !1}
        }, init: function () {
            const A = this.el, t = this.data;
            let i = A.components.material;
            if (!t.path.length) {
                console.error("[a-tube] `path` property expected but not found.");
                return
            }
            const o = new THREE.CatmullRomCurve3(t.path.map(function (f) {
                return f = f.split(" "), new THREE.Vector3(Number(f[0]), Number(f[1]), Number(f[2]))
            })), c = new THREE.TubeGeometry(o, t.segments, t.radius, t.radialSegments, t.closed);
            i || (i = {}, i.material = new THREE.MeshPhongMaterial), this.mesh = new THREE.Mesh(c, i.material), this.el.setObject3D("mesh", this.mesh)
        }, update: function (A) {
            Object.keys(A).length && (this.remove(), this.init())
        }, remove: function () {
            this.mesh && this.el.removeObject3D("mesh")
        }
    })), a0
}

var Q2;

function GI() {
    return Q2 || (Q2 = 1, NI(), UI(), zI()), z2
}

var j2;

function VI() {
    return j2 || (j2 = 1, U3(), CI(), TI(), FI(), GI()), $x
}

VI();
var W2 = {}, K2;

function HI() {
    if (K2) return W2;
    if (K2 = 1, AFRAME.registerGeometry("prism", {
        schema: {
            depth: {default: 1, min: 0},
            height: {default: 1, min: 0},
            width: {default: 1, min: 0}
        }, init: function (A) {
            const t = new THREE.Shape;
            t.moveTo(A.width / 2, 0), t.lineTo(0, A.height), t.lineTo(-A.width / 2, 0), t.lineTo(A.width / 2, 0);
            const i = {steps: 2, depth: A.depth, bevelEnabled: !1};
            this.geometry = new THREE.ExtrudeGeometry(t, i)
        }
    }), typeof AFRAME > "u") throw new Error("Component attempted to register before AFRAME was available.");
    return AFRAME.registerComponent("blink-controls", {
        schema: {
            button: {default: "", oneOf: ["trackpad", "trigger", "grip", "menu", "thumbstick"]},
            startEvents: {type: "array", default: []},
            endEvents: {type: "array", default: []},
            cancelEvents: {type: "array", default: []},
            collisionEntities: {default: ""},
            hitEntity: {type: "selector"},
            cameraRig: {type: "selector", default: "#player"},
            teleportOrigin: {type: "selector", default: "#camera"},
            hitCylinderColor: {type: "color", default: "#4d93fd"},
            hitCylinderRadius: {default: .25, min: 0},
            hitCylinderHeight: {default: .3, min: 0},
            interval: {default: 0},
            curveNumberPoints: {default: 60, min: 2},
            curveLineWidth: {default: .025},
            curveHitColor: {type: "color", default: "#4d93fd"},
            curveMissColor: {type: "color", default: "#ff0000"},
            curveShootingSpeed: {default: 10, min: 0},
            defaultPlaneSize: {default: 100},
            landingNormal: {type: "vec3", default: {x: 0, y: 1, z: 0}},
            landingMaxAngle: {default: "45", min: 0, max: 360},
            drawIncrementally: {default: !0},
            incrementalDrawMs: {default: 300},
            missOpacity: {default: .8},
            hitOpacity: {default: .8},
            snapTurn: {default: !0},
            rotateOnTeleport: {default: !0}
        },
        init: function () {
            const A = this.data, t = this.el;
            let i;
            this.active = !1, this.obj = t.object3D, this.controllerPosition = new THREE.Vector3, this.hitEntityQuaternion = new THREE.Quaternion, this.teleportOriginQuaternion = new THREE.Quaternion, this.hitPoint = new THREE.Vector3, this.collisionObjectNormalMatrix = new THREE.Matrix3, this.collisionWorldNormal = new THREE.Vector3, this.rigWorldPosition = new THREE.Vector3, this.newRigWorldPosition = new THREE.Vector3, this.teleportEventDetail = {
                oldPosition: this.rigWorldPosition,
                newPosition: this.newRigWorldPosition,
                hitPoint: this.hitPoint,
                rotationQuaternion: this.hitEntityQuaternion
            }, this.hit = !1, this.prevCheckTime = void 0, this.referenceNormal = new THREE.Vector3, this.curveMissColor = new THREE.Color, this.curveHitColor = new THREE.Color, this.raycaster = new THREE.Raycaster, this.defaultPlane = this.createDefaultPlane(this.data.defaultPlaneSize), this.defaultCollisionMeshes = [this.defaultPlane];
            const o = this.teleportEntity = document.createElement("a-entity");
            if (o.classList.add("teleportRay"), o.setAttribute("visible", !1), t.sceneEl.appendChild(this.teleportEntity), this.onButtonDown = this.onButtonDown.bind(this), this.onButtonUp = this.onButtonUp.bind(this), this.cancel = this.cancel.bind(this), this.handleThumbstickAxis = this.handleThumbstickAxis.bind(this), this.teleportOrigin = this.data.teleportOrigin, this.cameraRig = this.data.cameraRig, this.snapturnRotation = THREE.MathUtils.degToRad(45), this.canSnapturn = !0, this.addedEvents = [], this.data.startEvents.length && this.data.endEvents.length) {
                for (i = 0; i < this.data.startEvents.length; i++) this.addedEvents.push([this.data.startEvents[i], this.onButtonDown]), t.addEventListener(this.data.startEvents[i], this.onButtonDown);
                for (i = 0; i < this.data.endEvents.length; i++) this.addedEvents.push([this.data.endEvents[i], this.onButtonUp]), t.addEventListener(this.data.endEvents[i], this.onButtonUp)
            } else A.button ? (this.addedEvents.push([A.button + "down", this.onButtonDown]), this.addedEvents.push([A.button + "up", this.onButtonUp]), t.addEventListener(A.button + "down", this.onButtonDown), t.addEventListener(A.button + "up", this.onButtonUp)) : this.thumbstickAxisActivation = !0;
            for (i = 0; i < this.data.cancelEvents.length; i++) this.addedEvents.push([this.data.cancelEvents[i], this.cancel]), t.addEventListener(this.data.cancelEvents[i], this.cancel);
            this.addedEvents.push(["thumbstickmoved", this.handleThumbstickAxis]), t.addEventListener("thumbstickmoved", this.handleThumbstickAxis), this.queryCollisionEntities()
        },
        handleSnapturn: function (A, t) {
            t < .5 && (this.canSnapturn = !0), this.canSnapturn && t > .95 && (Math.abs(A - Math.PI / 2) < .6 ? (this.cameraRig.object3D.rotateY(+this.snapturnRotation), this.canSnapturn = !1) : Math.abs(A - 1.5 * Math.PI) < .6 && (this.cameraRig.object3D.rotateY(-this.snapturnRotation), this.canSnapturn = !1))
        },
        handleThumbstickAxis: function (A) {
            if (A.detail.x !== void 0 && A.detail.y !== void 0) {
                const t = Math.atan2(A.detail.x, A.detail.y) + Math.PI,
                    i = Math.sqrt(A.detail.x ** 2 + A.detail.y ** 2);
                this.active ? (i > .95 && (this.obj.getWorldPosition(this.controllerPosition), this.controllerPosition.setComponent(1, this.hitEntity.object3D.position.y), this.hitEntity.object3D.visible = !1, this.hitEntity.object3D.lookAt(this.controllerPosition), this.hitEntity.object3D.rotateY(t), this.hitEntity.object3D.visible = !0, this.hitEntity.object3D.getWorldQuaternion(this.hitEntityQuaternion)), Math.abs(A.detail.x) === 0 && Math.abs(A.detail.y) === 0 && this.onButtonUp()) : this.thumbstickAxisActivation && i > .95 && (t < .5 || t > 5.78) ? this.onButtonDown() : this.data.snapTurn && this.handleSnapturn(t, i)
            }
        },
        update: function (A) {
            const t = this.data, i = AFRAME.utils.diff(t, A);
            this.referenceNormal.copy(t.landingNormal), this.curveMissColor.set(t.curveMissColor), this.curveHitColor.set(t.curveHitColor), (!this.line || "curveLineWidth" in i || "curveNumberPoints" in i || "type" in i) && (this.line = this.createLine(t), this.line.material.opacity = this.data.hitOpacity, this.line.material.transparent = this.data.hitOpacity < 1, this.numActivePoints = t.curveNumberPoints, this.teleportEntity.setObject3D("mesh", this.line.mesh)), t.hitEntity ? this.hitEntity = t.hitEntity : (!this.hitEntity || "hitCylinderColor" in i || "hitCylinderHeight" in i || "hitCylinderRadius" in i) && (this.hitEntity && this.hitEntity.parentNode.removeChild(this.hitEntity), this.hitEntity = this.createHitEntity(t), this.el.sceneEl.appendChild(this.hitEntity)), this.hitEntity.setAttribute("visible", !1), t.hitEntity || this.hitEntity.lastElementChild.setAttribute("visible", t.rotateOnTeleport), "collisionEntities" in i && this.queryCollisionEntities()
        },
        remove: function () {
            const A = this.el, t = this.hitEntity, i = this.teleportEntity;
            t && t.parentNode.removeChild(t), i && i.parentNode.removeChild(i), A.sceneEl.removeEventListener("child-attached", this.childAttachHandler), A.sceneEl.removeEventListener("child-detached", this.childDetachHandler);
            for (const [o, c] of this.addedEvents) A.removeEventListener(o, c)
        },
        tick: function () {
            const A = new THREE.Vector3, t = new THREE.Vector3, i = -9.8, o = new THREE.Vector3(0, i, 0),
                c = new THREE.Vector3, f = new THREE.Vector3, T = new THREE.Quaternion, m = new THREE.Vector3,
                x = new THREE.Vector3, h = new THREE.Vector3, g = new THREE.Vector3, w = new THREE.Vector3;
            let v = 0;
            return function (E, p) {
                if (!this.active || (this.data.drawIncrementally && this.redrawLine && (this.redrawLine = !1, v = 0), v += p, this.numActivePoints = this.data.curveNumberPoints * v / this.data.incrementalDrawMs, this.numActivePoints > this.data.curveNumberPoints && (this.numActivePoints = this.data.curveNumberPoints), this.prevCheckTime && E - this.prevCheckTime < this.data.interval)) return;
                this.prevCheckTime = E, this.obj.matrixWorld.decompose(m, T, x);
                const M = h.set(0, 0, -1).applyQuaternion(T).normalize();
                this.line.setDirection(w.copy(M)), this.obj.getWorldPosition(A), f.copy(A), this.teleportEntity.setAttribute("visible", !0), v < this.data.incrementalDrawMs ? this.line.material.color.set(this.curveHitColor) : this.line.material.color.set(this.curveMissColor), this.line.material.opacity = this.data.missOpacity, this.line.material.transparent = this.data.missOpacity < 1, this.hitEntity.setAttribute("visible", !1), this.hit = !1, t.copy(M).multiplyScalar(this.data.curveShootingSpeed), this.lastDrawnIndex = 0;
                const b = this.data.drawIncrementally ? this.numActivePoints : this.line.numPoints;
                for (let B = 0; B < b + 1; B++) {
                    let R;
                    B === Math.floor(b + 1) ? R = b / (this.line.numPoints - 1) : R = B / (this.line.numPoints - 1);
                    const I = this.parabolicCurveMaxRoot(A, t, o);
                    R = R * Math.max(1, 1.5 * I), this.parabolicCurve(A, t, o, R, c);
                    const L = g.copy(c).sub(f).normalize();
                    if (this.raycaster.far = L.length(), this.raycaster.set(f, L), this.lastDrawnPoint = c, this.lastDrawnIndex = B, this.checkMeshCollisions(B, f, c)) break;
                    f.copy(c)
                }
                for (let B = this.lastDrawnIndex + 1; B < this.line.numPoints; B++) this.line.setPoint(B, this.lastDrawnPoint, this.lastDrawnPoint)
            }
        }(),
        queryCollisionEntities: function () {
            const A = this.data, t = this.el;
            if (!A.collisionEntities) {
                this.collisionEntities = [];
                return
            }
            const i = [].slice.call(t.sceneEl.querySelectorAll(A.collisionEntities));
            this.collisionEntities = i, this.childAttachHandler = function (c) {
                c.detail.el.matches(A.collisionEntities) && i.push(c.detail.el)
            }, t.sceneEl.addEventListener("child-attached", this.childAttachHandler), this.childDetachHandler = function (c) {
                if (!c.detail.el.matches(A.collisionEntities)) return;
                const f = i.indexOf(c.detail.el);
                f !== -1 && i.splice(f, 1)
            }, t.sceneEl.addEventListener("child-detached", this.childDetachHandler)
        },
        onButtonDown: function () {
            this.active = !0, this.redrawLine = !0
        },
        onButtonUp: function () {
            const A = new THREE.Vector3, t = [new THREE.Vector3, new THREE.Vector3], i = new THREE.Vector3;
            return function (o) {
                if (!this.active || (this.active = !1, this.hitEntity.setAttribute("visible", !1), this.teleportEntity.setAttribute("visible", !1), !this.hit)) return;
                const c = this.data.cameraRig || this.el.sceneEl.camera.el;
                if (c.object3D.getWorldPosition(this.rigWorldPosition), this.newRigWorldPosition.copy(this.hitPoint), A.copy(this.newRigWorldPosition), c.object3D.parent && c.object3D.parent.worldToLocal(A), c.setAttribute("position", A), this.data.rotateOnTeleport && (this.teleportOriginQuaternion.setFromEuler(new THREE.Euler(0, this.teleportOrigin.object3D.rotation.y, 0)), this.teleportOriginQuaternion.invert(), this.teleportOriginQuaternion.multiply(this.hitEntityQuaternion), this.cameraRig.object3D.setRotationFromQuaternion(this.teleportOriginQuaternion)), !this.data.cameraRig) {
                    const f = document.querySelectorAll("a-entity[tracked-controls]");
                    for (let T = 0; T < f.length; T++) f[T].object3D.getWorldPosition(i), t[T].copy(this.newRigWorldPosition).sub(this.rigWorldPosition).add(i), f[T].setAttribute("position", t[T])
                }
                this.el.emit("teleported", this.teleportEventDetail)
            }
        }(),
        cancel: function () {
            this.active = !1, this.hitEntity.setAttribute("visible", !1), this.teleportEntity.setAttribute("visible", !1)
        },
        checkMeshCollisions: function (A, t, i) {
            let o;
            this.data.collisionEntities ? (o = this.collisionEntities.map(function (f) {
                return f.getObject3D("mesh")
            }).filter(function (f) {
                return f
            }), o = o.length ? o : this.defaultCollisionMeshes) : o = this.defaultCollisionMeshes;
            const c = this.raycaster.intersectObjects(o, !0);
            if (c.length > 0 && !this.hit && this.isValidNormalsAngle(c[0].face.normal, c[0].object)) {
                const f = c[0].point;
                this.line.material.color.set(this.curveHitColor), this.line.material.opacity = this.data.hitOpacity, this.line.material.transparent = this.data.hitOpacity < 1, this.hitEntity.setAttribute("position", f), this.hitEntity.setAttribute("visible", !0), this.hit = !0, this.hitPoint.copy(c[0].point);
                for (let T = A; T < this.line.numPoints; T++) this.line.setPoint(T, t, this.hitPoint);
                return !0
            } else return this.line.setPoint(A, t, i), !1
        },
        isValidNormalsAngle: function (A, t) {
            this.collisionObjectNormalMatrix.getNormalMatrix(t.matrixWorld), this.collisionWorldNormal.copy(A).applyMatrix3(this.collisionObjectNormalMatrix).normalize();
            const i = this.referenceNormal.angleTo(this.collisionWorldNormal);
            return THREE.MathUtils.RAD2DEG * i <= this.data.landingMaxAngle
        },
        parabolicCurveScalar: function (A, t, i, o) {
            return A + t * o + .5 * i * o * o
        },
        parabolicCurve: function (A, t, i, o, c) {
            return c.x = this.parabolicCurveScalar(A.x, t.x, i.x, o), c.y = this.parabolicCurveScalar(A.y, t.y, i.y, o), c.z = this.parabolicCurveScalar(A.z, t.z, i.z, o), c
        },
        parabolicCurveMaxRoot: function (A, t, i) {
            return (-t.y - Math.sqrt(t.y ** 2 - 4 * (.5 * i.y) * A.y)) / (1 * i.y)
        },
        createLine: function (A) {
            const t = A.type === "line" ? 2 : A.curveNumberPoints;
            return new AFRAME.utils.RayCurve(t, A.curveLineWidth)
        },
        createHitEntity: function (A) {
            const t = document.createElement("a-entity");
            t.className = "hitEntity";
            const i = document.createElement("a-entity");
            i.setAttribute("geometry", {
                primitive: "torus",
                radius: A.hitCylinderRadius,
                radiusTubular: .01
            }), i.setAttribute("rotation", {x: 90, y: 0, z: 0}), i.setAttribute("material", {
                shader: "flat",
                color: A.hitCylinderColor,
                side: "double",
                depthTest: !1
            }), t.appendChild(i);
            const o = document.createElement("a-entity");
            o.setAttribute("position", {
                x: 0,
                y: A.hitCylinderHeight / 2,
                z: 0
            }), o.setAttribute("geometry", {
                primitive: "cylinder",
                segmentsHeight: 1,
                radius: A.hitCylinderRadius,
                height: A.hitCylinderHeight,
                openEnded: !0
            }), o.setAttribute("material", {
                shader: "flat",
                color: A.hitCylinderColor,
                opacity: .5,
                side: "double",
                src: this.cylinderTexture,
                transparent: !0,
                depthTest: !1
            }), t.appendChild(o);
            const c = document.createElement("a-entity");
            return c.setAttribute("position", {
                x: 0,
                y: .05,
                z: A.hitCylinderRadius * -1.5
            }), c.setAttribute("rotation", {x: 90, y: 180, z: 0}), c.setAttribute("geometry", {
                primitive: "prism",
                height: .2,
                width: .2,
                depth: .05
            }), c.setAttribute("material", {
                shader: "flat",
                color: A.hitCylinderColor,
                side: "double",
                transparent: !0,
                opacity: .6,
                depthTest: !1
            }), t.appendChild(c), t
        },
        createDefaultPlane: function (A) {
            const t = new THREE.PlaneGeometry(100, 100);
            t.rotateX(-Math.PI / 2);
            const i = new THREE.MeshBasicMaterial({color: 16776960});
            return new THREE.Mesh(t, i)
        },
        cylinderTexture: "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAQCAYAAADXnxW3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAADJJREFUeNpEx7ENgDAAAzArK0JA6f8X9oewlcWStU1wBGdwB08wgjeYm79jc2nbYH0DAC/+CORJxO5fAAAAAElFTkSuQmCC)"
    }), AFRAME.utils.RayCurve = function (A, t) {
        this.geometry = new THREE.BufferGeometry, this.vertices = new Float32Array(A * 3 * 6), this.uvs = new Float32Array(A * 2 * 6), this.width = t, this.geometry.setAttribute("position", new THREE.BufferAttribute(this.vertices, 3).setUsage(THREE.DynamicDrawUsage)), this.material = new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
            color: 16711680
        }), this.mesh = new THREE.Mesh(this.geometry, this.material), this.mesh.frustumCulled = !1, this.mesh.vertices = this.vertices, this.direction = new THREE.Vector3, this.numPoints = A
    }, AFRAME.utils.RayCurve.prototype = {
        setDirection: function (A) {
            const t = new THREE.Vector3(0, 1, 0);
            this.direction.copy(A).cross(t).normalize().multiplyScalar(this.width / 2)
        }, setWidth: function (A) {
            this.width = A
        }, setPoint: function () {
            const A = new THREE.Vector3, t = new THREE.Vector3, i = new THREE.Vector3, o = new THREE.Vector3;
            return function (c, f, T) {
                A.copy(f).add(this.direction), t.copy(f).sub(this.direction), i.copy(T).add(this.direction), o.copy(T).sub(this.direction);
                let m = 6 * 3 * c;
                this.vertices[m++] = A.x, this.vertices[m++] = A.y, this.vertices[m++] = A.z, this.vertices[m++] = t.x, this.vertices[m++] = t.y, this.vertices[m++] = t.z, this.vertices[m++] = i.x, this.vertices[m++] = i.y, this.vertices[m++] = i.z, this.vertices[m++] = i.x, this.vertices[m++] = i.y, this.vertices[m++] = i.z, this.vertices[m++] = t.x, this.vertices[m++] = t.y, this.vertices[m++] = t.z, this.vertices[m++] = o.x, this.vertices[m++] = o.y, this.vertices[m++] = o.z, this.geometry.attributes.position.needsUpdate = !0
            }
        }()
    }, W2
}

HI();
var h0 = {exports: {}}, QI = h0.exports, X2;

function jI() {
    return X2 || (X2 = 1, function (A, t) {
        (function (o, c) {
            A.exports = c()
        })(QI, function () {
            return function (i) {
                var o = {};

                function c(f) {
                    if (o[f]) return o[f].exports;
                    var T = o[f] = {exports: {}, id: f, loaded: !1};
                    return i[f].call(T.exports, T, T.exports, c), T.loaded = !0, T.exports
                }

                return c.m = i, c.c = o, c.p = "", c(0)
            }([function (i, o) {
                var c = AFRAME.utils.styleParser;
                if (typeof AFRAME > "u") throw new Error("Component attempted to register before AFRAME was available.");
                AFRAME.registerComponent("event-set", {
                    schema: {
                        default: "", parse: function (f) {
                            return c.parse(f)
                        }, stringify: function (f) {
                            return c.stringify(f)
                        }
                    }, multiple: !0, init: function () {
                        this.eventHandler = null, this.eventName = null
                    }, update: function (f) {
                        this.removeEventListener(), this.updateEventListener(), this.addEventListener()
                    }, pause: function () {
                        this.removeEventListener()
                    }, play: function () {
                        this.addEventListener()
                    }, updateEventListener: function () {
                        var f = this.data, T = this.el, m, x, h;
                        m = f._event || this.id, x = f._target, h = x ? T.sceneEl.querySelector(x) : T, this.eventName = m;
                        const g = () => {
                            var w;
                            for (w in f) w === "_event" || w === "_target" || AFRAME.utils.entity.setComponentProperty.call(this, h, w, f[w])
                        };
                        isNaN(f._delay) ? this.eventHandler = g : this.eventHandler = () => {
                            setTimeout(g, parseFloat(f._delay))
                        }
                    }, addEventListener: function () {
                        this.el.addEventListener(this.eventName, this.eventHandler)
                    }, removeEventListener: function () {
                        this.el.removeEventListener(this.eventName, this.eventHandler)
                    }
                })
            }])
        })
    }(h0)), h0.exports
}

jI();
var Y2 = {}, q2;

function WI() {
    return q2 || (q2 = 1, function (A) {
        var t = {};

        function i(o) {
            if (t[o]) return t[o].exports;
            var c = t[o] = {exports: {}, id: o, loaded: !1};
            return A[o].call(c.exports, c, c.exports, i), c.loaded = !0, c.exports
        }

        return i.m = A, i.c = t, i.p = "", i(0)
    }([function (A, t, i) {
        var o = i(1), c = f(o);

        function f(m) {
            return m && m.__esModule ? m : {default: m}
        }

        if (typeof AFRAME > "u") throw "mouse-cursor Component attempted to register before AFRAME was available.";
        var T = AFRAME.utils.device.isMobile() || window.hasNonPolyfillWebVRSupport;
        AFRAME.registerComponent("mouse-cursor", {
            schema: {}, init: function () {
                this._raycaster = new THREE.Raycaster, this._mouse = new THREE.Vector2, this._isMobile = this.el.sceneEl.isMobile, this._isStereo = !1, this._active = !1, this._isDown = !1, this._intersectedEl = null, this._attachEventListeners(), this._canvasSize = !1, this.__getCanvasPos = this._getCanvasPos.bind(this), this.__getCanvasPos = this._getCanvasPos.bind(this), this.__onEnterVR = this._onEnterVR.bind(this), this.__onExitVR = this._onExitVR.bind(this), this.__onDown = this._onDown.bind(this), this.__onClick = this._onClick.bind(this), this.__onMouseMove = this._onMouseMove.bind(this), this.__onRelease = this._onRelease.bind(this), this.__onTouchMove = this._onTouchMove.bind(this), this.__onComponentChanged = this._onComponentChanged.bind(this)
            }, update: function (x) {
            }, remove: function () {
                this._removeEventListeners(), this._raycaster = null
            }, pause: function () {
                this._active = !1
            }, play: function () {
                this._active = !0
            }, _attachEventListeners: function () {
                var x = this.el, h = x.sceneEl, g = h.canvas;
                if (!g) {
                    x.sceneEl.addEventListener("render-target-loaded", this._attachEventListeners.bind(this));
                    return
                }
                window.addEventListener("resize", this.__getCanvasPos), document.addEventListener("scroll", this.__getCanvasPos), this._getCanvasPos(), h.addEventListener("enter-vr", this.__onEnterVR), h.addEventListener("exit-vr", this.__onExitVR), g.addEventListener("mousedown", this.__onDown), g.addEventListener("mousemove", this.__onMouseMove), g.addEventListener("mouseup", this.__onRelease), g.addEventListener("mouseout", this.__onRelease), g.addEventListener("touchstart", this.__onDown), g.addEventListener("touchmove", this.__onTouchMove), g.addEventListener("touchend", this.__onRelease), g.addEventListener("click", this.__onClick), x.addEventListener("componentchanged", this.__onComponentChanged)
            }, _removeEventListeners: function () {
                var x = this.el, h = x.sceneEl, g = h.canvas;
                g && (window.removeEventListener("resize", this.__getCanvasPos), document.removeEventListener("scroll", this.__getCanvasPos), h.removeEventListener("enter-vr", this.__onEnterVR), h.removeEventListener("exit-vr", this.__onExitVR), g.removeEventListener("mousedown", this.__onDown), g.removeEventListener("mousemove", this.__onMouseMove), g.removeEventListener("mouseup", this.__onRelease), g.removeEventListener("mouseout", this.__onRelease), g.removeEventListener("touchstart", this.__onDown), g.removeEventListener("touchmove", this.__onTouchMove), g.removeEventListener("touchend", this.__onRelease), g.removeEventListener("click", this.__onClick), x.removeEventListener("componentchanged", this.__onComponentChanged))
            }, _isActive: function () {
                return !!(this._active || this._raycaster)
            }, _onDown: function (x) {
                this._isActive() && (this._isDown = !0, this._updateMouse(x), this._updateIntersectObject(), this._isMobile || this._setInitMousePosition(x), this._intersectedEl && this._emit("mousedown"))
            }, _onClick: function (x) {
                this._isActive() && (this._updateMouse(x), this._updateIntersectObject(), this._intersectedEl && this._emit("click"))
            }, _onRelease: function () {
                if (this._isActive()) {
                    if (this._defMousePosition) {
                        var x = Math.abs(this._initMousePosition.x - this._defMousePosition.x),
                            h = Math.abs(this._initMousePosition.y - this._defMousePosition.y), g = Math.max(x, h);
                        g > .04 && (this._isDown = !1)
                    }
                    this._isDown && this._intersectedEl && this._emit("mouseup"), this._isDown = !1, this._resetMousePosition()
                }
            }, _onMouseMove: function (x) {
                this._isActive() && (this._updateMouse(x), this._updateIntersectObject(), this._isDown && this._setMousePosition(x))
            }, _onTouchMove: function (x) {
                this._isActive() && (this._isDown = !1)
            }, _onEnterVR: function () {
                T && (this._isStereo = !0), this._getCanvasPos()
            }, _onExitVR: function () {
                this._isStereo = !1, this._getCanvasPos()
            }, _onComponentChanged: function (x) {
                x.detail.name === "position" && this._updateIntersectObject()
            }, _getPosition: function (x) {
                var h = this._canvasSize, g = h.width, w = h.height, v = h.left, E = h.top, p = void 0, C = void 0;
                if (this._isMobile) {
                    var M = x.touches;
                    if (!M || M.length !== 1) return;
                    var b = M[0];
                    p = b.clientX, C = b.clientY
                } else p = x.clientX, C = x.clientY;
                p = p - v, C = C - E, this._isStereo && (p = p % (g / 2) * 2);
                var B = p / g * 2 - 1, R = -(C / w) * 2 + 1;
                return {x: B, y: R}
            }, _updateMouse: function (x) {
                var h = this._getPosition(x);
                h && (this._mouse.x = h.x, this._mouse.y = h.y)
            }, _setMousePosition: function (x) {
                this._defMousePosition = this._getPosition(x)
            }, _setInitMousePosition: function (x) {
                this._initMousePosition = this._getPosition(x)
            }, _resetMousePosition: function () {
                this._initMousePosition = this._defMousePosition = null
            }, _getCanvasPos: function () {
                this._canvasSize = this.el.sceneEl.canvas.getBoundingClientRect()
            }, _getChildren: function (x) {
                var h = this;
                return x.children.map(function (g) {
                    return g.type === "Group" ? h._getChildren(g) : g
                })
            }, _getAllChildren: function () {
                var x = this._getChildren(this.el.sceneEl.object3D);
                return (0, c.default)(x)
            }, _updateIntersectObject: function () {
                var x = this._raycaster, h = this.el, g = this._mouse;
                h.sceneEl.object3D;
                var w = this.el.getObject3D("camera");
                this._getAllChildren(), x.ray.origin.setFromMatrixPosition(w.matrixWorld), x.ray.direction.set(g.x, g.y, .5).unproject(w).sub(x.ray.origin).normalize();
                var v = this._getAllChildren(), E = x.intersectObjects(v);
                if (E.length > 0) {
                    var p = void 0;
                    if (E.every(function (M) {
                        return M.object.parent.visible === !0 ? (p = M.object, !1) : !0
                    }), !p) {
                        this._clearIntersectObject();
                        return
                    }
                    var C = p.parent.el;
                    if (this._intersectedEl === C) return;
                    this._clearIntersectObject(), this._setIntersectObject(C)
                } else this._clearIntersectObject()
            }, _setIntersectObject: function (x) {
                this._intersectedEl = x, !this._isMobile && (x.addState("hovered"), x.emit("mouseenter"), this.el.addState("hovering"))
            }, _clearIntersectObject: function () {
                var x = this._intersectedEl;
                x && !this._isMobile && (x.removeState("hovered"), x.emit("mouseleave"), this.el.removeState("hovering")), this._intersectedEl = null
            }, _emit: function (x) {
                var h = this._intersectedEl;
                this.el.emit(x, {target: h}), h && h.emit(x)
            }
        })
    }, function (A, t) {
        (function (i) {
            var o = 1 / 0, c = 9007199254740991, f = "[object Arguments]", T = "[object Function]",
                m = "[object GeneratorFunction]", x = typeof i == "object" && i && i.Object === Object && i,
                h = typeof self == "object" && self && self.Object === Object && self,
                g = x || h || Function("return this")(), w = Object.prototype, v = w.hasOwnProperty, E = w.toString,
                p = g.Symbol, C = w.propertyIsEnumerable, M = p ? p.isConcatSpreadable : void 0;

            function b(Y, fe, se, pe, ue) {
                var he = -1, Z = Y.length;
                for (se || (se = B), ue || (ue = []); ++he < Z;) {
                    var H = Y[he];
                    se(H) ? b(H, fe - 1, se, pe, ue) : ue[ue.length] = H
                }
                return ue
            }

            function B(Y) {
                return L(Y) || I(Y) || !!(M && Y && Y[M])
            }

            function R(Y) {
                var fe = Y ? Y.length : 0;
                return fe ? b(Y, o) : []
            }

            function I(Y) {
                return N(Y) && v.call(Y, "callee") && (!C.call(Y, "callee") || E.call(Y) == f)
            }

            var L = Array.isArray;

            function O(Y) {
                return Y != null && V(Y.length) && !F(Y)
            }

            function N(Y) {
                return j(Y) && O(Y)
            }

            function F(Y) {
                var fe = U(Y) ? E.call(Y) : "";
                return fe == T || fe == m
            }

            function V(Y) {
                return typeof Y == "number" && Y > -1 && Y % 1 == 0 && Y <= c
            }

            function U(Y) {
                var fe = typeof Y;
                return !!Y && (fe == "object" || fe == "function")
            }

            function j(Y) {
                return !!Y && typeof Y == "object"
            }

            A.exports = R
        }).call(t, function () {
            return this
        }())
    }])), Y2
}

WI();
var r1 = {exports: {}}, tr = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var J2;

function KI() {
    if (J2) return tr;
    J2 = 1;
    var A = Symbol.for("react.element"), t = Symbol.for("react.portal"), i = Symbol.for("react.fragment"),
        o = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), f = Symbol.for("react.provider"),
        T = Symbol.for("react.context"), m = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"),
        h = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), w = Symbol.iterator;

    function v(ee) {
        return ee === null || typeof ee != "object" ? null : (ee = w && ee[w] || ee["@@iterator"], typeof ee == "function" ? ee : null)
    }

    var E = {
        isMounted: function () {
            return !1
        }, enqueueForceUpdate: function () {
        }, enqueueReplaceState: function () {
        }, enqueueSetState: function () {
        }
    }, p = Object.assign, C = {};

    function M(ee, me, Re) {
        this.props = ee, this.context = me, this.refs = C, this.updater = Re || E
    }

    M.prototype.isReactComponent = {}, M.prototype.setState = function (ee, me) {
        if (typeof ee != "object" && typeof ee != "function" && ee != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, ee, me, "setState")
    }, M.prototype.forceUpdate = function (ee) {
        this.updater.enqueueForceUpdate(this, ee, "forceUpdate")
    };

    function b() {
    }

    b.prototype = M.prototype;

    function B(ee, me, Re) {
        this.props = ee, this.context = me, this.refs = C, this.updater = Re || E
    }

    var R = B.prototype = new b;
    R.constructor = B, p(R, M.prototype), R.isPureReactComponent = !0;
    var I = Array.isArray, L = Object.prototype.hasOwnProperty, O = {current: null},
        N = {key: !0, ref: !0, __self: !0, __source: !0};

    function F(ee, me, Re) {
        var ke, Ve = {}, He = null, ot = null;
        if (me != null) for (ke in me.ref !== void 0 && (ot = me.ref), me.key !== void 0 && (He = "" + me.key), me) L.call(me, ke) && !N.hasOwnProperty(ke) && (Ve[ke] = me[ke]);
        var gt = arguments.length - 2;
        if (gt === 1) Ve.children = Re; else if (1 < gt) {
            for (var Bt = Array(gt), Rt = 0; Rt < gt; Rt++) Bt[Rt] = arguments[Rt + 2];
            Ve.children = Bt
        }
        if (ee && ee.defaultProps) for (ke in gt = ee.defaultProps, gt) Ve[ke] === void 0 && (Ve[ke] = gt[ke]);
        return {$$typeof: A, type: ee, key: He, ref: ot, props: Ve, _owner: O.current}
    }

    function V(ee, me) {
        return {$$typeof: A, type: ee.type, key: me, ref: ee.ref, props: ee.props, _owner: ee._owner}
    }

    function U(ee) {
        return typeof ee == "object" && ee !== null && ee.$$typeof === A
    }

    function j(ee) {
        var me = {"=": "=0", ":": "=2"};
        return "$" + ee.replace(/[=:]/g, function (Re) {
            return me[Re]
        })
    }

    var Y = /\/+/g;

    function fe(ee, me) {
        return typeof ee == "object" && ee !== null && ee.key != null ? j("" + ee.key) : me.toString(36)
    }

    function se(ee, me, Re, ke, Ve) {
        var He = typeof ee;
        (He === "undefined" || He === "boolean") && (ee = null);
        var ot = !1;
        if (ee === null) ot = !0; else switch (He) {
            case"string":
            case"number":
                ot = !0;
                break;
            case"object":
                switch (ee.$$typeof) {
                    case A:
                    case t:
                        ot = !0
                }
        }
        if (ot) return ot = ee, Ve = Ve(ot), ee = ke === "" ? "." + fe(ot, 0) : ke, I(Ve) ? (Re = "", ee != null && (Re = ee.replace(Y, "$&/") + "/"), se(Ve, me, Re, "", function (Rt) {
            return Rt
        })) : Ve != null && (U(Ve) && (Ve = V(Ve, Re + (!Ve.key || ot && ot.key === Ve.key ? "" : ("" + Ve.key).replace(Y, "$&/") + "/") + ee)), me.push(Ve)), 1;
        if (ot = 0, ke = ke === "" ? "." : ke + ":", I(ee)) for (var gt = 0; gt < ee.length; gt++) {
            He = ee[gt];
            var Bt = ke + fe(He, gt);
            ot += se(He, me, Re, Bt, Ve)
        } else if (Bt = v(ee), typeof Bt == "function") for (ee = Bt.call(ee), gt = 0; !(He = ee.next()).done;) He = He.value, Bt = ke + fe(He, gt++), ot += se(He, me, Re, Bt, Ve); else if (He === "object") throw me = String(ee), Error("Objects are not valid as a React child (found: " + (me === "[object Object]" ? "object with keys {" + Object.keys(ee).join(", ") + "}" : me) + "). If you meant to render a collection of children, use an array instead.");
        return ot
    }

    function pe(ee, me, Re) {
        if (ee == null) return ee;
        var ke = [], Ve = 0;
        return se(ee, ke, "", "", function (He) {
            return me.call(Re, He, Ve++)
        }), ke
    }

    function ue(ee) {
        if (ee._status === -1) {
            var me = ee._result;
            me = me(), me.then(function (Re) {
                (ee._status === 0 || ee._status === -1) && (ee._status = 1, ee._result = Re)
            }, function (Re) {
                (ee._status === 0 || ee._status === -1) && (ee._status = 2, ee._result = Re)
            }), ee._status === -1 && (ee._status = 0, ee._result = me)
        }
        if (ee._status === 1) return ee._result.default;
        throw ee._result
    }

    var he = {current: null}, Z = {transition: null},
        H = {ReactCurrentDispatcher: he, ReactCurrentBatchConfig: Z, ReactCurrentOwner: O};

    function ae() {
        throw Error("act(...) is not supported in production builds of React.")
    }

    return tr.Children = {
        map: pe, forEach: function (ee, me, Re) {
            pe(ee, function () {
                me.apply(this, arguments)
            }, Re)
        }, count: function (ee) {
            var me = 0;
            return pe(ee, function () {
                me++
            }), me
        }, toArray: function (ee) {
            return pe(ee, function (me) {
                return me
            }) || []
        }, only: function (ee) {
            if (!U(ee)) throw Error("React.Children.only expected to receive a single React element child.");
            return ee
        }
    }, tr.Component = M, tr.Fragment = i, tr.Profiler = c, tr.PureComponent = B, tr.StrictMode = o, tr.Suspense = x, tr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = H, tr.act = ae, tr.cloneElement = function (ee, me, Re) {
        if (ee == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + ee + ".");
        var ke = p({}, ee.props), Ve = ee.key, He = ee.ref, ot = ee._owner;
        if (me != null) {
            if (me.ref !== void 0 && (He = me.ref, ot = O.current), me.key !== void 0 && (Ve = "" + me.key), ee.type && ee.type.defaultProps) var gt = ee.type.defaultProps;
            for (Bt in me) L.call(me, Bt) && !N.hasOwnProperty(Bt) && (ke[Bt] = me[Bt] === void 0 && gt !== void 0 ? gt[Bt] : me[Bt])
        }
        var Bt = arguments.length - 2;
        if (Bt === 1) ke.children = Re; else if (1 < Bt) {
            gt = Array(Bt);
            for (var Rt = 0; Rt < Bt; Rt++) gt[Rt] = arguments[Rt + 2];
            ke.children = gt
        }
        return {$$typeof: A, type: ee.type, key: Ve, ref: He, props: ke, _owner: ot}
    }, tr.createContext = function (ee) {
        return ee = {
            $$typeof: T,
            _currentValue: ee,
            _currentValue2: ee,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        }, ee.Provider = {$$typeof: f, _context: ee}, ee.Consumer = ee
    }, tr.createElement = F, tr.createFactory = function (ee) {
        var me = F.bind(null, ee);
        return me.type = ee, me
    }, tr.createRef = function () {
        return {current: null}
    }, tr.forwardRef = function (ee) {
        return {$$typeof: m, render: ee}
    }, tr.isValidElement = U, tr.lazy = function (ee) {
        return {$$typeof: g, _payload: {_status: -1, _result: ee}, _init: ue}
    }, tr.memo = function (ee, me) {
        return {$$typeof: h, type: ee, compare: me === void 0 ? null : me}
    }, tr.startTransition = function (ee) {
        var me = Z.transition;
        Z.transition = {};
        try {
            ee()
        } finally {
            Z.transition = me
        }
    }, tr.unstable_act = ae, tr.useCallback = function (ee, me) {
        return he.current.useCallback(ee, me)
    }, tr.useContext = function (ee) {
        return he.current.useContext(ee)
    }, tr.useDebugValue = function () {
    }, tr.useDeferredValue = function (ee) {
        return he.current.useDeferredValue(ee)
    }, tr.useEffect = function (ee, me) {
        return he.current.useEffect(ee, me)
    }, tr.useId = function () {
        return he.current.useId()
    }, tr.useImperativeHandle = function (ee, me, Re) {
        return he.current.useImperativeHandle(ee, me, Re)
    }, tr.useInsertionEffect = function (ee, me) {
        return he.current.useInsertionEffect(ee, me)
    }, tr.useLayoutEffect = function (ee, me) {
        return he.current.useLayoutEffect(ee, me)
    }, tr.useMemo = function (ee, me) {
        return he.current.useMemo(ee, me)
    }, tr.useReducer = function (ee, me, Re) {
        return he.current.useReducer(ee, me, Re)
    }, tr.useRef = function (ee) {
        return he.current.useRef(ee)
    }, tr.useState = function (ee) {
        return he.current.useState(ee)
    }, tr.useSyncExternalStore = function (ee, me, Re) {
        return he.current.useSyncExternalStore(ee, me, Re)
    }, tr.useTransition = function () {
        return he.current.useTransition()
    }, tr.version = "18.3.1", tr
}

var Z2;

function qw() {
    return Z2 || (Z2 = 1, r1.exports = KI()), r1.exports
}

var Nt = qw();
const ii = dw(Nt);
var l0 = {}, s1 = {exports: {}}, va = {}, o1 = {exports: {}}, a1 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $2;

function XI() {
    return $2 || ($2 = 1, function (A) {
        function t(Z, H) {
            var ae = Z.length;
            Z.push(H);
            e:for (; 0 < ae;) {
                var ee = ae - 1 >>> 1, me = Z[ee];
                if (0 < c(me, H)) Z[ee] = H, Z[ae] = me, ae = ee; else break e
            }
        }

        function i(Z) {
            return Z.length === 0 ? null : Z[0]
        }

        function o(Z) {
            if (Z.length === 0) return null;
            var H = Z[0], ae = Z.pop();
            if (ae !== H) {
                Z[0] = ae;
                e:for (var ee = 0, me = Z.length, Re = me >>> 1; ee < Re;) {
                    var ke = 2 * (ee + 1) - 1, Ve = Z[ke], He = ke + 1, ot = Z[He];
                    if (0 > c(Ve, ae)) He < me && 0 > c(ot, Ve) ? (Z[ee] = ot, Z[He] = ae, ee = He) : (Z[ee] = Ve, Z[ke] = ae, ee = ke); else if (He < me && 0 > c(ot, ae)) Z[ee] = ot, Z[He] = ae, ee = He; else break e
                }
            }
            return H
        }

        function c(Z, H) {
            var ae = Z.sortIndex - H.sortIndex;
            return ae !== 0 ? ae : Z.id - H.id
        }

        if (typeof performance == "object" && typeof performance.now == "function") {
            var f = performance;
            A.unstable_now = function () {
                return f.now()
            }
        } else {
            var T = Date, m = T.now();
            A.unstable_now = function () {
                return T.now() - m
            }
        }
        var x = [], h = [], g = 1, w = null, v = 3, E = !1, p = !1, C = !1,
            M = typeof setTimeout == "function" ? setTimeout : null,
            b = typeof clearTimeout == "function" ? clearTimeout : null,
            B = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

        function R(Z) {
            for (var H = i(h); H !== null;) {
                if (H.callback === null) o(h); else if (H.startTime <= Z) o(h), H.sortIndex = H.expirationTime, t(x, H); else break;
                H = i(h)
            }
        }

        function I(Z) {
            if (C = !1, R(Z), !p) if (i(x) !== null) p = !0, ue(L); else {
                var H = i(h);
                H !== null && he(I, H.startTime - Z)
            }
        }

        function L(Z, H) {
            p = !1, C && (C = !1, b(F), F = -1), E = !0;
            var ae = v;
            try {
                for (R(H), w = i(x); w !== null && (!(w.expirationTime > H) || Z && !j());) {
                    var ee = w.callback;
                    if (typeof ee == "function") {
                        w.callback = null, v = w.priorityLevel;
                        var me = ee(w.expirationTime <= H);
                        H = A.unstable_now(), typeof me == "function" ? w.callback = me : w === i(x) && o(x), R(H)
                    } else o(x);
                    w = i(x)
                }
                if (w !== null) var Re = !0; else {
                    var ke = i(h);
                    ke !== null && he(I, ke.startTime - H), Re = !1
                }
                return Re
            } finally {
                w = null, v = ae, E = !1
            }
        }

        var O = !1, N = null, F = -1, V = 5, U = -1;

        function j() {
            return !(A.unstable_now() - U < V)
        }

        function Y() {
            if (N !== null) {
                var Z = A.unstable_now();
                U = Z;
                var H = !0;
                try {
                    H = N(!0, Z)
                } finally {
                    H ? fe() : (O = !1, N = null)
                }
            } else O = !1
        }

        var fe;
        if (typeof B == "function") fe = function () {
            B(Y)
        }; else if (typeof MessageChannel < "u") {
            var se = new MessageChannel, pe = se.port2;
            se.port1.onmessage = Y, fe = function () {
                pe.postMessage(null)
            }
        } else fe = function () {
            M(Y, 0)
        };

        function ue(Z) {
            N = Z, O || (O = !0, fe())
        }

        function he(Z, H) {
            F = M(function () {
                Z(A.unstable_now())
            }, H)
        }

        A.unstable_IdlePriority = 5, A.unstable_ImmediatePriority = 1, A.unstable_LowPriority = 4, A.unstable_NormalPriority = 3, A.unstable_Profiling = null, A.unstable_UserBlockingPriority = 2, A.unstable_cancelCallback = function (Z) {
            Z.callback = null
        }, A.unstable_continueExecution = function () {
            p || E || (p = !0, ue(L))
        }, A.unstable_forceFrameRate = function (Z) {
            0 > Z || 125 < Z ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : V = 0 < Z ? Math.floor(1e3 / Z) : 5
        }, A.unstable_getCurrentPriorityLevel = function () {
            return v
        }, A.unstable_getFirstCallbackNode = function () {
            return i(x)
        }, A.unstable_next = function (Z) {
            switch (v) {
                case 1:
                case 2:
                case 3:
                    var H = 3;
                    break;
                default:
                    H = v
            }
            var ae = v;
            v = H;
            try {
                return Z()
            } finally {
                v = ae
            }
        }, A.unstable_pauseExecution = function () {
        }, A.unstable_requestPaint = function () {
        }, A.unstable_runWithPriority = function (Z, H) {
            switch (Z) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    Z = 3
            }
            var ae = v;
            v = Z;
            try {
                return H()
            } finally {
                v = ae
            }
        }, A.unstable_scheduleCallback = function (Z, H, ae) {
            var ee = A.unstable_now();
            switch (typeof ae == "object" && ae !== null ? (ae = ae.delay, ae = typeof ae == "number" && 0 < ae ? ee + ae : ee) : ae = ee, Z) {
                case 1:
                    var me = -1;
                    break;
                case 2:
                    me = 250;
                    break;
                case 5:
                    me = 1073741823;
                    break;
                case 4:
                    me = 1e4;
                    break;
                default:
                    me = 5e3
            }
            return me = ae + me, Z = {
                id: g++,
                callback: H,
                priorityLevel: Z,
                startTime: ae,
                expirationTime: me,
                sortIndex: -1
            }, ae > ee ? (Z.sortIndex = ae, t(h, Z), i(x) === null && Z === i(h) && (C ? (b(F), F = -1) : C = !0, he(I, ae - ee))) : (Z.sortIndex = me, t(x, Z), p || E || (p = !0, ue(L))), Z
        }, A.unstable_shouldYield = j, A.unstable_wrapCallback = function (Z) {
            var H = v;
            return function () {
                var ae = v;
                v = H;
                try {
                    return Z.apply(this, arguments)
                } finally {
                    v = ae
                }
            }
        }
    }(a1)), a1
}

var ew;

function YI() {
    return ew || (ew = 1, o1.exports = XI()), o1.exports
}

/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var tw;

function qI() {
    if (tw) return va;
    tw = 1;
    var A = qw(), t = YI();

    function i(s) {
        for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, _ = 1; _ < arguments.length; _++) l += "&args[]=" + encodeURIComponent(arguments[_]);
        return "Minified React error #" + s + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }

    var o = new Set, c = {};

    function f(s, l) {
        T(s, l), T(s + "Capture", l)
    }

    function T(s, l) {
        for (c[s] = l, s = 0; s < l.length; s++) o.add(l[s])
    }

    var m = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
        x = Object.prototype.hasOwnProperty,
        h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
        g = {}, w = {};

    function v(s) {
        return x.call(w, s) ? !0 : x.call(g, s) ? !1 : h.test(s) ? w[s] = !0 : (g[s] = !0, !1)
    }

    function E(s, l, _, k) {
        if (_ !== null && _.type === 0) return !1;
        switch (typeof l) {
            case"function":
            case"symbol":
                return !0;
            case"boolean":
                return k ? !1 : _ !== null ? !_.acceptsBooleans : (s = s.toLowerCase().slice(0, 5), s !== "data-" && s !== "aria-");
            default:
                return !1
        }
    }

    function p(s, l, _, k) {
        if (l === null || typeof l > "u" || E(s, l, _, k)) return !0;
        if (k) return !1;
        if (_ !== null) switch (_.type) {
            case 3:
                return !l;
            case 4:
                return l === !1;
            case 5:
                return isNaN(l);
            case 6:
                return isNaN(l) || 1 > l
        }
        return !1
    }

    function C(s, l, _, k, W, ie, be) {
        this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = k, this.attributeNamespace = W, this.mustUseProperty = _, this.propertyName = s, this.type = l, this.sanitizeURL = ie, this.removeEmptyString = be
    }

    var M = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (s) {
        M[s] = new C(s, 0, !1, s, null, !1, !1)
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (s) {
        var l = s[0];
        M[l] = new C(l, 1, !1, s[1], null, !1, !1)
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (s) {
        M[s] = new C(s, 2, !1, s.toLowerCase(), null, !1, !1)
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (s) {
        M[s] = new C(s, 2, !1, s, null, !1, !1)
    }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (s) {
        M[s] = new C(s, 3, !1, s.toLowerCase(), null, !1, !1)
    }), ["checked", "multiple", "muted", "selected"].forEach(function (s) {
        M[s] = new C(s, 3, !0, s, null, !1, !1)
    }), ["capture", "download"].forEach(function (s) {
        M[s] = new C(s, 4, !1, s, null, !1, !1)
    }), ["cols", "rows", "size", "span"].forEach(function (s) {
        M[s] = new C(s, 6, !1, s, null, !1, !1)
    }), ["rowSpan", "start"].forEach(function (s) {
        M[s] = new C(s, 5, !1, s.toLowerCase(), null, !1, !1)
    });
    var b = /[\-:]([a-z])/g;

    function B(s) {
        return s[1].toUpperCase()
    }

    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (s) {
        var l = s.replace(b, B);
        M[l] = new C(l, 1, !1, s, null, !1, !1)
    }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (s) {
        var l = s.replace(b, B);
        M[l] = new C(l, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1)
    }), ["xml:base", "xml:lang", "xml:space"].forEach(function (s) {
        var l = s.replace(b, B);
        M[l] = new C(l, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1)
    }), ["tabIndex", "crossOrigin"].forEach(function (s) {
        M[s] = new C(s, 1, !1, s.toLowerCase(), null, !1, !1)
    }), M.xlinkHref = new C("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (s) {
        M[s] = new C(s, 1, !1, s.toLowerCase(), null, !0, !0)
    });

    function R(s, l, _, k) {
        var W = M.hasOwnProperty(l) ? M[l] : null;
        (W !== null ? W.type !== 0 : k || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (p(l, _, W, k) && (_ = null), k || W === null ? v(l) && (_ === null ? s.removeAttribute(l) : s.setAttribute(l, "" + _)) : W.mustUseProperty ? s[W.propertyName] = _ === null ? W.type === 3 ? !1 : "" : _ : (l = W.attributeName, k = W.attributeNamespace, _ === null ? s.removeAttribute(l) : (W = W.type, _ = W === 3 || W === 4 && _ === !0 ? "" : "" + _, k ? s.setAttributeNS(k, l, _) : s.setAttribute(l, _))))
    }

    var I = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, L = Symbol.for("react.element"),
        O = Symbol.for("react.portal"), N = Symbol.for("react.fragment"), F = Symbol.for("react.strict_mode"),
        V = Symbol.for("react.profiler"), U = Symbol.for("react.provider"), j = Symbol.for("react.context"),
        Y = Symbol.for("react.forward_ref"), fe = Symbol.for("react.suspense"), se = Symbol.for("react.suspense_list"),
        pe = Symbol.for("react.memo"), ue = Symbol.for("react.lazy"), he = Symbol.for("react.offscreen"),
        Z = Symbol.iterator;

    function H(s) {
        return s === null || typeof s != "object" ? null : (s = Z && s[Z] || s["@@iterator"], typeof s == "function" ? s : null)
    }

    var ae = Object.assign, ee;

    function me(s) {
        if (ee === void 0) try {
            throw Error()
        } catch (_) {
            var l = _.stack.trim().match(/\n( *(at )?)/);
            ee = l && l[1] || ""
        }
        return `
` + ee + s
    }

    var Re = !1;

    function ke(s, l) {
        if (!s || Re) return "";
        Re = !0;
        var _ = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (l) if (l = function () {
                throw Error()
            }, Object.defineProperty(l.prototype, "props", {
                set: function () {
                    throw Error()
                }
            }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(l, [])
                } catch (Et) {
                    var k = Et
                }
                Reflect.construct(s, [], l)
            } else {
                try {
                    l.call()
                } catch (Et) {
                    k = Et
                }
                s.call(l.prototype)
            } else {
                try {
                    throw Error()
                } catch (Et) {
                    k = Et
                }
                s()
            }
        } catch (Et) {
            if (Et && k && typeof Et.stack == "string") {
                for (var W = Et.stack.split(`
`), ie = k.stack.split(`
`), be = W.length - 1, Xe = ie.length - 1; 1 <= be && 0 <= Xe && W[be] !== ie[Xe];) Xe--;
                for (; 1 <= be && 0 <= Xe; be--, Xe--) if (W[be] !== ie[Xe]) {
                    if (be !== 1 || Xe !== 1) do if (be--, Xe--, 0 > Xe || W[be] !== ie[Xe]) {
                        var nt = `
` + W[be].replace(" at new ", " at ");
                        return s.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", s.displayName)), nt
                    } while (1 <= be && 0 <= Xe);
                    break
                }
            }
        } finally {
            Re = !1, Error.prepareStackTrace = _
        }
        return (s = s ? s.displayName || s.name : "") ? me(s) : ""
    }

    function Ve(s) {
        switch (s.tag) {
            case 5:
                return me(s.type);
            case 16:
                return me("Lazy");
            case 13:
                return me("Suspense");
            case 19:
                return me("SuspenseList");
            case 0:
            case 2:
            case 15:
                return s = ke(s.type, !1), s;
            case 11:
                return s = ke(s.type.render, !1), s;
            case 1:
                return s = ke(s.type, !0), s;
            default:
                return ""
        }
    }

    function He(s) {
        if (s == null) return null;
        if (typeof s == "function") return s.displayName || s.name || null;
        if (typeof s == "string") return s;
        switch (s) {
            case N:
                return "Fragment";
            case O:
                return "Portal";
            case V:
                return "Profiler";
            case F:
                return "StrictMode";
            case fe:
                return "Suspense";
            case se:
                return "SuspenseList"
        }
        if (typeof s == "object") switch (s.$$typeof) {
            case j:
                return (s.displayName || "Context") + ".Consumer";
            case U:
                return (s._context.displayName || "Context") + ".Provider";
            case Y:
                var l = s.render;
                return s = s.displayName, s || (s = l.displayName || l.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
            case pe:
                return l = s.displayName || null, l !== null ? l : He(s.type) || "Memo";
            case ue:
                l = s._payload, s = s._init;
                try {
                    return He(s(l))
                } catch {
                }
        }
        return null
    }

    function ot(s) {
        var l = s.type;
        switch (s.tag) {
            case 24:
                return "Cache";
            case 9:
                return (l.displayName || "Context") + ".Consumer";
            case 10:
                return (l._context.displayName || "Context") + ".Provider";
            case 18:
                return "DehydratedFragment";
            case 11:
                return s = l.render, s = s.displayName || s.name || "", l.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
            case 7:
                return "Fragment";
            case 5:
                return l;
            case 4:
                return "Portal";
            case 3:
                return "Root";
            case 6:
                return "Text";
            case 16:
                return He(l);
            case 8:
                return l === F ? "StrictMode" : "Mode";
            case 22:
                return "Offscreen";
            case 12:
                return "Profiler";
            case 21:
                return "Scope";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 25:
                return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof l == "function") return l.displayName || l.name || null;
                if (typeof l == "string") return l
        }
        return null
    }

    function gt(s) {
        switch (typeof s) {
            case"boolean":
            case"number":
            case"string":
            case"undefined":
                return s;
            case"object":
                return s;
            default:
                return ""
        }
    }

    function Bt(s) {
        var l = s.type;
        return (s = s.nodeName) && s.toLowerCase() === "input" && (l === "checkbox" || l === "radio")
    }

    function Rt(s) {
        var l = Bt(s) ? "checked" : "value", _ = Object.getOwnPropertyDescriptor(s.constructor.prototype, l),
            k = "" + s[l];
        if (!s.hasOwnProperty(l) && typeof _ < "u" && typeof _.get == "function" && typeof _.set == "function") {
            var W = _.get, ie = _.set;
            return Object.defineProperty(s, l, {
                configurable: !0, get: function () {
                    return W.call(this)
                }, set: function (be) {
                    k = "" + be, ie.call(this, be)
                }
            }), Object.defineProperty(s, l, {enumerable: _.enumerable}), {
                getValue: function () {
                    return k
                }, setValue: function (be) {
                    k = "" + be
                }, stopTracking: function () {
                    s._valueTracker = null, delete s[l]
                }
            }
        }
    }

    function an(s) {
        s._valueTracker || (s._valueTracker = Rt(s))
    }

    function En(s) {
        if (!s) return !1;
        var l = s._valueTracker;
        if (!l) return !0;
        var _ = l.getValue(), k = "";
        return s && (k = Bt(s) ? s.checked ? "true" : "false" : s.value), s = k, s !== _ ? (l.setValue(s), !0) : !1
    }

    function Nn(s) {
        if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
        try {
            return s.activeElement || s.body
        } catch {
            return s.body
        }
    }

    function oi(s, l) {
        var _ = l.checked;
        return ae({}, l, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: _ ?? s._wrapperState.initialChecked
        })
    }

    function pi(s, l) {
        var _ = l.defaultValue == null ? "" : l.defaultValue, k = l.checked != null ? l.checked : l.defaultChecked;
        _ = gt(l.value != null ? l.value : _), s._wrapperState = {
            initialChecked: k,
            initialValue: _,
            controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null
        }
    }

    function hi(s, l) {
        l = l.checked, l != null && R(s, "checked", l, !1)
    }

    function Vn(s, l) {
        hi(s, l);
        var _ = gt(l.value), k = l.type;
        if (_ != null) k === "number" ? (_ === 0 && s.value === "" || s.value != _) && (s.value = "" + _) : s.value !== "" + _ && (s.value = "" + _); else if (k === "submit" || k === "reset") {
            s.removeAttribute("value");
            return
        }
        l.hasOwnProperty("value") ? nr(s, l.type, _) : l.hasOwnProperty("defaultValue") && nr(s, l.type, gt(l.defaultValue)), l.checked == null && l.defaultChecked != null && (s.defaultChecked = !!l.defaultChecked)
    }

    function yi(s, l, _) {
        if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
            var k = l.type;
            if (!(k !== "submit" && k !== "reset" || l.value !== void 0 && l.value !== null)) return;
            l = "" + s._wrapperState.initialValue, _ || l === s.value || (s.value = l), s.defaultValue = l
        }
        _ = s.name, _ !== "" && (s.name = ""), s.defaultChecked = !!s._wrapperState.initialChecked, _ !== "" && (s.name = _)
    }

    function nr(s, l, _) {
        (l !== "number" || Nn(s.ownerDocument) !== s) && (_ == null ? s.defaultValue = "" + s._wrapperState.initialValue : s.defaultValue !== "" + _ && (s.defaultValue = "" + _))
    }

    var Oi = Array.isArray;

    function Rr(s, l, _, k) {
        if (s = s.options, l) {
            l = {};
            for (var W = 0; W < _.length; W++) l["$" + _[W]] = !0;
            for (_ = 0; _ < s.length; _++) W = l.hasOwnProperty("$" + s[_].value), s[_].selected !== W && (s[_].selected = W), W && k && (s[_].defaultSelected = !0)
        } else {
            for (_ = "" + gt(_), l = null, W = 0; W < s.length; W++) {
                if (s[W].value === _) {
                    s[W].selected = !0, k && (s[W].defaultSelected = !0);
                    return
                }
                l !== null || s[W].disabled || (l = s[W])
            }
            l !== null && (l.selected = !0)
        }
    }

    function Ji(s, l) {
        if (l.dangerouslySetInnerHTML != null) throw Error(i(91));
        return ae({}, l, {value: void 0, defaultValue: void 0, children: "" + s._wrapperState.initialValue})
    }

    function Pi(s, l) {
        var _ = l.value;
        if (_ == null) {
            if (_ = l.children, l = l.defaultValue, _ != null) {
                if (l != null) throw Error(i(92));
                if (Oi(_)) {
                    if (1 < _.length) throw Error(i(93));
                    _ = _[0]
                }
                l = _
            }
            l == null && (l = ""), _ = l
        }
        s._wrapperState = {initialValue: gt(_)}
    }

    function Br(s, l) {
        var _ = gt(l.value), k = gt(l.defaultValue);
        _ != null && (_ = "" + _, _ !== s.value && (s.value = _), l.defaultValue == null && s.defaultValue !== _ && (s.defaultValue = _)), k != null && (s.defaultValue = "" + k)
    }

    function cr(s) {
        var l = s.textContent;
        l === s._wrapperState.initialValue && l !== "" && l !== null && (s.value = l)
    }

    function ss(s) {
        switch (s) {
            case"svg":
                return "http://www.w3.org/2000/svg";
            case"math":
                return "http://www.w3.org/1998/Math/MathML";
            default:
                return "http://www.w3.org/1999/xhtml"
        }
    }

    function Nr(s, l) {
        return s == null || s === "http://www.w3.org/1999/xhtml" ? ss(l) : s === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s
    }

    var ir, jt = function (s) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (l, _, k, W) {
            MSApp.execUnsafeLocalFunction(function () {
                return s(l, _, k, W)
            })
        } : s
    }(function (s, l) {
        if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s) s.innerHTML = l; else {
            for (ir = ir || document.createElement("div"), ir.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = ir.firstChild; s.firstChild;) s.removeChild(s.firstChild);
            for (; l.firstChild;) s.appendChild(l.firstChild)
        }
    });

    function Se(s, l) {
        if (l) {
            var _ = s.firstChild;
            if (_ && _ === s.lastChild && _.nodeType === 3) {
                _.nodeValue = l;
                return
            }
        }
        s.textContent = l
    }

    var _e = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }, Ge = ["Webkit", "ms", "Moz", "O"];
    Object.keys(_e).forEach(function (s) {
        Ge.forEach(function (l) {
            l = l + s.charAt(0).toUpperCase() + s.substring(1), _e[l] = _e[s]
        })
    });

    function Le(s, l, _) {
        return l == null || typeof l == "boolean" || l === "" ? "" : _ || typeof l != "number" || l === 0 || _e.hasOwnProperty(s) && _e[s] ? ("" + l).trim() : l + "px"
    }

    function Ue(s, l) {
        s = s.style;
        for (var _ in l) if (l.hasOwnProperty(_)) {
            var k = _.indexOf("--") === 0, W = Le(_, l[_], k);
            _ === "float" && (_ = "cssFloat"), k ? s.setProperty(_, W) : s[_] = W
        }
    }

    var Qe = ae({menuitem: !0}, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });

    function oe(s, l) {
        if (l) {
            if (Qe[s] && (l.children != null || l.dangerouslySetInnerHTML != null)) throw Error(i(137, s));
            if (l.dangerouslySetInnerHTML != null) {
                if (l.children != null) throw Error(i(60));
                if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML)) throw Error(i(61))
            }
            if (l.style != null && typeof l.style != "object") throw Error(i(62))
        }
    }

    function G(s, l) {
        if (s.indexOf("-") === -1) return typeof l.is == "string";
        switch (s) {
            case"annotation-xml":
            case"color-profile":
            case"font-face":
            case"font-face-src":
            case"font-face-uri":
            case"font-face-format":
            case"font-face-name":
            case"missing-glyph":
                return !1;
            default:
                return !0
        }
    }

    var X = null;

    function ve(s) {
        return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s
    }

    var Be = null, je = null, tt = null;

    function Yt(s) {
        if (s = to(s)) {
            if (typeof Be != "function") throw Error(i(280));
            var l = s.stateNode;
            l && (l = Ku(l), Be(s.stateNode, s.type, l))
        }
    }

    function cn(s) {
        je ? tt ? tt.push(s) : tt = [s] : je = s
    }

    function $t() {
        if (je) {
            var s = je, l = tt;
            if (tt = je = null, Yt(s), l) for (s = 0; s < l.length; s++) Yt(l[s])
        }
    }

    function en(s, l) {
        return s(l)
    }

    function Sn() {
    }

    var Gi = !1;

    function qn(s, l, _) {
        if (Gi) return s(l, _);
        Gi = !0;
        try {
            return en(s, l, _)
        } finally {
            Gi = !1, (je !== null || tt !== null) && (Sn(), $t())
        }
    }

    function fr(s, l) {
        var _ = s.stateNode;
        if (_ === null) return null;
        var k = Ku(_);
        if (k === null) return null;
        _ = k[l];
        e:switch (l) {
            case"onClick":
            case"onClickCapture":
            case"onDoubleClick":
            case"onDoubleClickCapture":
            case"onMouseDown":
            case"onMouseDownCapture":
            case"onMouseMove":
            case"onMouseMoveCapture":
            case"onMouseUp":
            case"onMouseUpCapture":
            case"onMouseEnter":
                (k = !k.disabled) || (s = s.type, k = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !k;
                break e;
            default:
                s = !1
        }
        if (s) return null;
        if (_ && typeof _ != "function") throw Error(i(231, l, typeof _));
        return _
    }

    var Vi = !1;
    if (m) try {
        var Zi = {};
        Object.defineProperty(Zi, "passive", {
            get: function () {
                Vi = !0
            }
        }), window.addEventListener("test", Zi, Zi), window.removeEventListener("test", Zi, Zi)
    } catch {
        Vi = !1
    }

    function co(s, l, _, k, W, ie, be, Xe, nt) {
        var Et = Array.prototype.slice.call(arguments, 3);
        try {
            l.apply(_, Et)
        } catch (Zt) {
            this.onError(Zt)
        }
    }

    var pr = !1, $s = null, Or = !1, ws = null, Eo = {
        onError: function (s) {
            pr = !0, $s = s
        }
    };

    function bs(s, l, _, k, W, ie, be, Xe, nt) {
        pr = !1, $s = null, co.apply(Eo, arguments)
    }

    function kr(s, l, _, k, W, ie, be, Xe, nt) {
        if (bs.apply(this, arguments), pr) {
            if (pr) {
                var Et = $s;
                pr = !1, $s = null
            } else throw Error(i(198));
            Or || (Or = !0, ws = Et)
        }
    }

    function Hi(s) {
        var l = s, _ = s;
        if (s.alternate) for (; l.return;) l = l.return; else {
            s = l;
            do l = s, l.flags & 4098 && (_ = l.return), s = l.return; while (s)
        }
        return l.tag === 3 ? _ : null
    }

    function Qr(s) {
        if (s.tag === 13) {
            var l = s.memoizedState;
            if (l === null && (s = s.alternate, s !== null && (l = s.memoizedState)), l !== null) return l.dehydrated
        }
        return null
    }

    function ua(s) {
        if (Hi(s) !== s) throw Error(i(188))
    }

    function xo(s) {
        var l = s.alternate;
        if (!l) {
            if (l = Hi(s), l === null) throw Error(i(188));
            return l !== s ? null : s
        }
        for (var _ = s, k = l; ;) {
            var W = _.return;
            if (W === null) break;
            var ie = W.alternate;
            if (ie === null) {
                if (k = W.return, k !== null) {
                    _ = k;
                    continue
                }
                break
            }
            if (W.child === ie.child) {
                for (ie = W.child; ie;) {
                    if (ie === _) return ua(W), s;
                    if (ie === k) return ua(W), l;
                    ie = ie.sibling
                }
                throw Error(i(188))
            }
            if (_.return !== k.return) _ = W, k = ie; else {
                for (var be = !1, Xe = W.child; Xe;) {
                    if (Xe === _) {
                        be = !0, _ = W, k = ie;
                        break
                    }
                    if (Xe === k) {
                        be = !0, k = W, _ = ie;
                        break
                    }
                    Xe = Xe.sibling
                }
                if (!be) {
                    for (Xe = ie.child; Xe;) {
                        if (Xe === _) {
                            be = !0, _ = ie, k = W;
                            break
                        }
                        if (Xe === k) {
                            be = !0, k = ie, _ = W;
                            break
                        }
                        Xe = Xe.sibling
                    }
                    if (!be) throw Error(i(189))
                }
            }
            if (_.alternate !== k) throw Error(i(190))
        }
        if (_.tag !== 3) throw Error(i(188));
        return _.stateNode.current === _ ? s : l
    }

    function Ea(s) {
        return s = xo(s), s !== null ? Qo(s) : null
    }

    function Qo(s) {
        if (s.tag === 5 || s.tag === 6) return s;
        for (s = s.child; s !== null;) {
            var l = Qo(s);
            if (l !== null) return l;
            s = s.sibling
        }
        return null
    }

    var De = t.unstable_scheduleCallback, Ke = t.unstable_cancelCallback, rt = t.unstable_shouldYield,
        Ct = t.unstable_requestPaint, dt = t.unstable_now, Lt = t.unstable_getCurrentPriorityLevel,
        Kt = t.unstable_ImmediatePriority, Rn = t.unstable_UserBlockingPriority, xn = t.unstable_NormalPriority,
        Dt = t.unstable_LowPriority, Hn = t.unstable_IdlePriority, jn = null, Wn = null;

    function Wi(s) {
        if (Wn && typeof Wn.onCommitFiberRoot == "function") try {
            Wn.onCommitFiberRoot(jn, s, void 0, (s.current.flags & 128) === 128)
        } catch {
        }
    }

    var li = Math.clz32 ? Math.clz32 : yr, mi = Math.log, ki = Math.LN2;

    function yr(s) {
        return s >>>= 0, s === 0 ? 32 : 31 - (mi(s) / ki | 0) | 0
    }

    var Ur = 64, Cn = 4194304;

    function Ai(s) {
        switch (s & -s) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return s & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return s & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return s
        }
    }

    function _r(s, l) {
        var _ = s.pendingLanes;
        if (_ === 0) return 0;
        var k = 0, W = s.suspendedLanes, ie = s.pingedLanes, be = _ & 268435455;
        if (be !== 0) {
            var Xe = be & ~W;
            Xe !== 0 ? k = Ai(Xe) : (ie &= be, ie !== 0 && (k = Ai(ie)))
        } else be = _ & ~W, be !== 0 ? k = Ai(be) : ie !== 0 && (k = Ai(ie));
        if (k === 0) return 0;
        if (l !== 0 && l !== k && !(l & W) && (W = k & -k, ie = l & -l, W >= ie || W === 16 && (ie & 4194240) !== 0)) return l;
        if (k & 4 && (k |= _ & 16), l = s.entangledLanes, l !== 0) for (s = s.entanglements, l &= k; 0 < l;) _ = 31 - li(l), W = 1 << _, k |= s[_], l &= ~W;
        return k
    }

    function ri(s, l) {
        switch (s) {
            case 1:
            case 2:
            case 4:
                return l + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return l + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1
        }
    }

    function $(s, l) {
        for (var _ = s.suspendedLanes, k = s.pingedLanes, W = s.expirationTimes, ie = s.pendingLanes; 0 < ie;) {
            var be = 31 - li(ie), Xe = 1 << be, nt = W[be];
            nt === -1 ? (!(Xe & _) || Xe & k) && (W[be] = ri(Xe, l)) : nt <= l && (s.expiredLanes |= Xe), ie &= ~Xe
        }
    }

    function re(s) {
        return s = s.pendingLanes & -1073741825, s !== 0 ? s : s & 1073741824 ? 1073741824 : 0
    }

    function Ae() {
        var s = Ur;
        return Ur <<= 1, !(Ur & 4194240) && (Ur = 64), s
    }

    function xe(s) {
        for (var l = [], _ = 0; 31 > _; _++) l.push(s);
        return l
    }

    function Oe(s, l, _) {
        s.pendingLanes |= l, l !== 536870912 && (s.suspendedLanes = 0, s.pingedLanes = 0), s = s.eventTimes, l = 31 - li(l), s[l] = _
    }

    function Ze(s, l) {
        var _ = s.pendingLanes & ~l;
        s.pendingLanes = l, s.suspendedLanes = 0, s.pingedLanes = 0, s.expiredLanes &= l, s.mutableReadLanes &= l, s.entangledLanes &= l, l = s.entanglements;
        var k = s.eventTimes;
        for (s = s.expirationTimes; 0 < _;) {
            var W = 31 - li(_), ie = 1 << W;
            l[W] = 0, k[W] = -1, s[W] = -1, _ &= ~ie
        }
    }

    function at(s, l) {
        var _ = s.entangledLanes |= l;
        for (s = s.entanglements; _;) {
            var k = 31 - li(_), W = 1 << k;
            W & l | s[k] & l && (s[k] |= l), _ &= ~W
        }
    }

    var wt = 0;

    function kt(s) {
        return s &= -s, 1 < s ? 4 < s ? s & 268435455 ? 16 : 536870912 : 4 : 1
    }

    var et, _t, ce, de, we, Ee = !1, Me = [], st = null, ut = null, Vt = null, Ft = new Map, Jt = new Map, sn = [],
        Pt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

    function gn(s, l) {
        switch (s) {
            case"focusin":
            case"focusout":
                st = null;
                break;
            case"dragenter":
            case"dragleave":
                ut = null;
                break;
            case"mouseover":
            case"mouseout":
                Vt = null;
                break;
            case"pointerover":
            case"pointerout":
                Ft.delete(l.pointerId);
                break;
            case"gotpointercapture":
            case"lostpointercapture":
                Jt.delete(l.pointerId)
        }
    }

    function un(s, l, _, k, W, ie) {
        return s === null || s.nativeEvent !== ie ? (s = {
            blockedOn: l,
            domEventName: _,
            eventSystemFlags: k,
            nativeEvent: ie,
            targetContainers: [W]
        }, l !== null && (l = to(l), l !== null && _t(l)), s) : (s.eventSystemFlags |= k, l = s.targetContainers, W !== null && l.indexOf(W) === -1 && l.push(W), s)
    }

    function _n(s, l, _, k, W) {
        switch (l) {
            case"focusin":
                return st = un(st, s, l, _, k, W), !0;
            case"dragenter":
                return ut = un(ut, s, l, _, k, W), !0;
            case"mouseover":
                return Vt = un(Vt, s, l, _, k, W), !0;
            case"pointerover":
                var ie = W.pointerId;
                return Ft.set(ie, un(Ft.get(ie) || null, s, l, _, k, W)), !0;
            case"gotpointercapture":
                return ie = W.pointerId, Jt.set(ie, un(Jt.get(ie) || null, s, l, _, k, W)), !0
        }
        return !1
    }

    function yn(s) {
        var l = Qa(s.target);
        if (l !== null) {
            var _ = Hi(l);
            if (_ !== null) {
                if (l = _.tag, l === 13) {
                    if (l = Qr(_), l !== null) {
                        s.blockedOn = l, we(s.priority, function () {
                            ce(_)
                        });
                        return
                    }
                } else if (l === 3 && _.stateNode.current.memoizedState.isDehydrated) {
                    s.blockedOn = _.tag === 3 ? _.stateNode.containerInfo : null;
                    return
                }
            }
        }
        s.blockedOn = null
    }

    function bi(s) {
        if (s.blockedOn !== null) return !1;
        for (var l = s.targetContainers; 0 < l.length;) {
            var _ = Ms(s.domEventName, s.eventSystemFlags, l[0], s.nativeEvent);
            if (_ === null) {
                _ = s.nativeEvent;
                var k = new _.constructor(_.type, _);
                X = k, _.target.dispatchEvent(k), X = null
            } else return l = to(_), l !== null && _t(l), s.blockedOn = _, !1;
            l.shift()
        }
        return !0
    }

    function Ii(s, l, _) {
        bi(s) && _.delete(l)
    }

    function _i() {
        Ee = !1, st !== null && bi(st) && (st = null), ut !== null && bi(ut) && (ut = null), Vt !== null && bi(Vt) && (Vt = null), Ft.forEach(Ii), Jt.forEach(Ii)
    }

    function gi(s, l) {
        s.blockedOn === l && (s.blockedOn = null, Ee || (Ee = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, _i)))
    }

    function Yr(s) {
        function l(W) {
            return gi(W, s)
        }

        if (0 < Me.length) {
            gi(Me[0], s);
            for (var _ = 1; _ < Me.length; _++) {
                var k = Me[_];
                k.blockedOn === s && (k.blockedOn = null)
            }
        }
        for (st !== null && gi(st, s), ut !== null && gi(ut, s), Vt !== null && gi(Vt, s), Ft.forEach(l), Jt.forEach(l), _ = 0; _ < sn.length; _++) k = sn[_], k.blockedOn === s && (k.blockedOn = null);
        for (; 0 < sn.length && (_ = sn[0], _.blockedOn === null);) yn(_), _.blockedOn === null && sn.shift()
    }

    var Mr = I.ReactCurrentBatchConfig, _s = !0;

    function ha(s, l, _, k) {
        var W = wt, ie = Mr.transition;
        Mr.transition = null;
        try {
            wt = 1, zs(s, l, _, k)
        } finally {
            wt = W, Mr.transition = ie
        }
    }

    function jo(s, l, _, k) {
        var W = wt, ie = Mr.transition;
        Mr.transition = null;
        try {
            wt = 4, zs(s, l, _, k)
        } finally {
            wt = W, Mr.transition = ie
        }
    }

    function zs(s, l, _, k) {
        if (_s) {
            var W = Ms(s, l, _, k);
            if (W === null) ms(s, l, k, Wo, _), gn(s, k); else if (_n(W, s, l, _, k)) k.stopPropagation(); else if (gn(s, k), l & 4 && -1 < Pt.indexOf(s)) {
                for (; W !== null;) {
                    var ie = to(W);
                    if (ie !== null && et(ie), ie = Ms(s, l, _, k), ie === null && ms(s, l, k, Wo, _), ie === W) break;
                    W = ie
                }
                W !== null && k.stopPropagation()
            } else ms(s, l, k, null, _)
        }
    }

    var Wo = null;

    function Ms(s, l, _, k) {
        if (Wo = null, s = ve(k), s = Qa(s), s !== null) if (l = Hi(s), l === null) s = null; else if (_ = l.tag, _ === 13) {
            if (s = Qr(l), s !== null) return s;
            s = null
        } else if (_ === 3) {
            if (l.stateNode.current.memoizedState.isDehydrated) return l.tag === 3 ? l.stateNode.containerInfo : null;
            s = null
        } else l !== s && (s = null);
        return Wo = s, null
    }

    function rr(s) {
        switch (s) {
            case"cancel":
            case"click":
            case"close":
            case"contextmenu":
            case"copy":
            case"cut":
            case"auxclick":
            case"dblclick":
            case"dragend":
            case"dragstart":
            case"drop":
            case"focusin":
            case"focusout":
            case"input":
            case"invalid":
            case"keydown":
            case"keypress":
            case"keyup":
            case"mousedown":
            case"mouseup":
            case"paste":
            case"pause":
            case"play":
            case"pointercancel":
            case"pointerdown":
            case"pointerup":
            case"ratechange":
            case"reset":
            case"resize":
            case"seeked":
            case"submit":
            case"touchcancel":
            case"touchend":
            case"touchstart":
            case"volumechange":
            case"change":
            case"selectionchange":
            case"textInput":
            case"compositionstart":
            case"compositionend":
            case"compositionupdate":
            case"beforeblur":
            case"afterblur":
            case"beforeinput":
            case"blur":
            case"fullscreenchange":
            case"focus":
            case"hashchange":
            case"popstate":
            case"select":
            case"selectstart":
                return 1;
            case"drag":
            case"dragenter":
            case"dragexit":
            case"dragleave":
            case"dragover":
            case"mousemove":
            case"mouseout":
            case"mouseover":
            case"pointermove":
            case"pointerout":
            case"pointerover":
            case"scroll":
            case"toggle":
            case"touchmove":
            case"wheel":
            case"mouseenter":
            case"mouseleave":
            case"pointerenter":
            case"pointerleave":
                return 4;
            case"message":
                switch (Lt()) {
                    case Kt:
                        return 1;
                    case Rn:
                        return 4;
                    case xn:
                    case Dt:
                        return 16;
                    case Hn:
                        return 536870912;
                    default:
                        return 16
                }
            default:
                return 16
        }
    }

    var Gs = null, bl = null, ka = null;

    function _l() {
        if (ka) return ka;
        var s, l = bl, _ = l.length, k, W = "value" in Gs ? Gs.value : Gs.textContent, ie = W.length;
        for (s = 0; s < _ && l[s] === W[s]; s++) ;
        var be = _ - s;
        for (k = 1; k <= be && l[_ - k] === W[ie - k]; k++) ;
        return ka = W.slice(s, 1 < k ? 1 - k : void 0)
    }

    function mr(s) {
        var l = s.keyCode;
        return "charCode" in s ? (s = s.charCode, s === 0 && l === 13 && (s = 13)) : s = l, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0
    }

    function Fa() {
        return !0
    }

    function Ml() {
        return !1
    }

    function Co(s) {
        function l(_, k, W, ie, be) {
            this._reactName = _, this._targetInst = W, this.type = k, this.nativeEvent = ie, this.target = be, this.currentTarget = null;
            for (var Xe in s) s.hasOwnProperty(Xe) && (_ = s[Xe], this[Xe] = _ ? _(ie) : ie[Xe]);
            return this.isDefaultPrevented = (ie.defaultPrevented != null ? ie.defaultPrevented : ie.returnValue === !1) ? Fa : Ml, this.isPropagationStopped = Ml, this
        }

        return ae(l.prototype, {
            preventDefault: function () {
                this.defaultPrevented = !0;
                var _ = this.nativeEvent;
                _ && (_.preventDefault ? _.preventDefault() : typeof _.returnValue != "unknown" && (_.returnValue = !1), this.isDefaultPrevented = Fa)
            }, stopPropagation: function () {
                var _ = this.nativeEvent;
                _ && (_.stopPropagation ? _.stopPropagation() : typeof _.cancelBubble != "unknown" && (_.cancelBubble = !0), this.isPropagationStopped = Fa)
            }, persist: function () {
            }, isPersistent: Fa
        }), l
    }

    var Bo = {
            eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (s) {
                return s.timeStamp || Date.now()
            }, defaultPrevented: 0, isTrusted: 0
        }, Ou = Co(Bo), tc = ae({}, Bo, {view: 0, detail: 0}), pf = Co(tc), ku, Fu, nc, Qc = ae({}, tc, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: rl,
            button: 0,
            buttons: 0,
            relatedTarget: function (s) {
                return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget
            },
            movementX: function (s) {
                return "movementX" in s ? s.movementX : (s !== nc && (nc && s.type === "mousemove" ? (ku = s.screenX - nc.screenX, Fu = s.screenY - nc.screenY) : Fu = ku = 0, nc = s), ku)
            },
            movementY: function (s) {
                return "movementY" in s ? s.movementY : Fu
            }
        }), Uh = Co(Qc), mf = ae({}, Qc, {dataTransfer: 0}), Af = Co(mf), gf = ae({}, tc, {relatedTarget: 0}), Nu = Co(gf),
        vf = ae({}, Bo, {animationName: 0, elapsedTime: 0, pseudoElement: 0}), Uu = Co(vf), zh = ae({}, Bo, {
            clipboardData: function (s) {
                return "clipboardData" in s ? s.clipboardData : window.clipboardData
            }
        }), Gh = Co(zh), Vh = ae({}, Bo, {data: 0}), jc = Co(Vh), Hh = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        }, Qh = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        }, jh = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};

    function Wh(s) {
        var l = this.nativeEvent;
        return l.getModifierState ? l.getModifierState(s) : (s = jh[s]) ? !!l[s] : !1
    }

    function rl() {
        return Wh
    }

    var yf = ae({}, tc, {
            key: function (s) {
                if (s.key) {
                    var l = Hh[s.key] || s.key;
                    if (l !== "Unidentified") return l
                }
                return s.type === "keypress" ? (s = mr(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? Qh[s.keyCode] || "Unidentified" : ""
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: rl,
            charCode: function (s) {
                return s.type === "keypress" ? mr(s) : 0
            },
            keyCode: function (s) {
                return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
            },
            which: function (s) {
                return s.type === "keypress" ? mr(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
            }
        }), Ef = Co(yf), xf = ae({}, Qc, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        }), Kh = Co(xf), Cf = ae({}, tc, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: rl
        }), wf = Co(Cf), bf = ae({}, Bo, {propertyName: 0, elapsedTime: 0, pseudoElement: 0}), _f = Co(bf),
        Mf = ae({}, Qc, {
            deltaX: function (s) {
                return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0
            }, deltaY: function (s) {
                return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0
            }, deltaZ: 0, deltaMode: 0
        }), zu = Co(Mf), da = [9, 13, 27, 32], sl = m && "CompositionEvent" in window, Ss = null;
    m && "documentMode" in document && (Ss = document.documentMode);
    var Vs = m && "TextEvent" in window && !Ss, Gu = m && (!sl || Ss && 8 < Ss && 11 >= Ss), Na = " ", ol = !1;

    function uo(s, l) {
        switch (s) {
            case"keyup":
                return da.indexOf(l.keyCode) !== -1;
            case"keydown":
                return l.keyCode !== 229;
            case"keypress":
            case"mousedown":
            case"focusout":
                return !0;
            default:
                return !1
        }
    }

    function Hr(s) {
        return s = s.detail, typeof s == "object" && "data" in s ? s.data : null
    }

    var Ua = !1;

    function Sf(s, l) {
        switch (s) {
            case"compositionend":
                return Hr(l);
            case"keypress":
                return l.which !== 32 ? null : (ol = !0, Na);
            case"textInput":
                return s = l.data, s === Na && ol ? null : s;
            default:
                return null
        }
    }

    function Tf(s, l) {
        if (Ua) return s === "compositionend" || !sl && uo(s, l) ? (s = _l(), ka = bl = Gs = null, Ua = !1, s) : null;
        switch (s) {
            case"paste":
                return null;
            case"keypress":
                if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
                    if (l.char && 1 < l.char.length) return l.char;
                    if (l.which) return String.fromCharCode(l.which)
                }
                return null;
            case"compositionend":
                return Gu && l.locale !== "ko" ? null : l.data;
            default:
                return null
        }
    }

    var ic = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };

    function Xh(s) {
        var l = s && s.nodeName && s.nodeName.toLowerCase();
        return l === "input" ? !!ic[s.type] : l === "textarea"
    }

    function Yh(s, l, _, k) {
        cn(k), l = As(l, "onChange"), 0 < l.length && (_ = new Ou("onChange", "change", null, _, k), s.push({
            event: _,
            listeners: l
        }))
    }

    var rc = null, sc = null;

    function If(s) {
        qr(s, 0)
    }

    function Wc(s) {
        var l = hc(s);
        if (En(l)) return s
    }

    function Rf(s, l) {
        if (s === "change") return l
    }

    var qh = !1;
    if (m) {
        var Vu;
        if (m) {
            var Hu = "oninput" in document;
            if (!Hu) {
                var Jh = document.createElement("div");
                Jh.setAttribute("oninput", "return;"), Hu = typeof Jh.oninput == "function"
            }
            Vu = Hu
        } else Vu = !1;
        qh = Vu && (!document.documentMode || 9 < document.documentMode)
    }

    function Zh() {
        rc && (rc.detachEvent("onpropertychange", $h), sc = rc = null)
    }

    function $h(s) {
        if (s.propertyName === "value" && Wc(sc)) {
            var l = [];
            Yh(l, sc, s, ve(s)), qn(If, l)
        }
    }

    function Bf(s, l, _) {
        s === "focusin" ? (Zh(), rc = l, sc = _, rc.attachEvent("onpropertychange", $h)) : s === "focusout" && Zh()
    }

    function eo(s) {
        if (s === "selectionchange" || s === "keyup" || s === "keydown") return Wc(sc)
    }

    function Ri(s, l) {
        if (s === "click") return Wc(l)
    }

    function Lf(s, l) {
        if (s === "input" || s === "change") return Wc(l)
    }

    function zt(s, l) {
        return s === l && (s !== 0 || 1 / s === 1 / l) || s !== s && l !== l
    }

    var ai = typeof Object.is == "function" ? Object.is : zt;

    function al(s, l) {
        if (ai(s, l)) return !0;
        if (typeof s != "object" || s === null || typeof l != "object" || l === null) return !1;
        var _ = Object.keys(s), k = Object.keys(l);
        if (_.length !== k.length) return !1;
        for (k = 0; k < _.length; k++) {
            var W = _[k];
            if (!x.call(l, W) || !ai(s[W], l[W])) return !1
        }
        return !0
    }

    function Qu(s) {
        for (; s && s.firstChild;) s = s.firstChild;
        return s
    }

    function ed(s, l) {
        var _ = Qu(s);
        s = 0;
        for (var k; _;) {
            if (_.nodeType === 3) {
                if (k = s + _.textContent.length, s <= l && k >= l) return {node: _, offset: l - s};
                s = k
            }
            e:{
                for (; _;) {
                    if (_.nextSibling) {
                        _ = _.nextSibling;
                        break e
                    }
                    _ = _.parentNode
                }
                _ = void 0
            }
            _ = Qu(_)
        }
    }

    function ll(s, l) {
        return s && l ? s === l ? !0 : s && s.nodeType === 3 ? !1 : l && l.nodeType === 3 ? ll(s, l.parentNode) : "contains" in s ? s.contains(l) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(l) & 16) : !1 : !1
    }

    function Sl() {
        for (var s = window, l = Nn(); l instanceof s.HTMLIFrameElement;) {
            try {
                var _ = typeof l.contentWindow.location.href == "string"
            } catch {
                _ = !1
            }
            if (_) s = l.contentWindow; else break;
            l = Nn(s.document)
        }
        return l
    }

    function Kc(s) {
        var l = s && s.nodeName && s.nodeName.toLowerCase();
        return l && (l === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || l === "textarea" || s.contentEditable === "true")
    }

    function td(s) {
        var l = Sl(), _ = s.focusedElem, k = s.selectionRange;
        if (l !== _ && _ && _.ownerDocument && ll(_.ownerDocument.documentElement, _)) {
            if (k !== null && Kc(_)) {
                if (l = k.start, s = k.end, s === void 0 && (s = l), "selectionStart" in _) _.selectionStart = l, _.selectionEnd = Math.min(s, _.value.length); else if (s = (l = _.ownerDocument || document) && l.defaultView || window, s.getSelection) {
                    s = s.getSelection();
                    var W = _.textContent.length, ie = Math.min(k.start, W);
                    k = k.end === void 0 ? ie : Math.min(k.end, W), !s.extend && ie > k && (W = k, k = ie, ie = W), W = ed(_, ie);
                    var be = ed(_, k);
                    W && be && (s.rangeCount !== 1 || s.anchorNode !== W.node || s.anchorOffset !== W.offset || s.focusNode !== be.node || s.focusOffset !== be.offset) && (l = l.createRange(), l.setStart(W.node, W.offset), s.removeAllRanges(), ie > k ? (s.addRange(l), s.extend(be.node, be.offset)) : (l.setEnd(be.node, be.offset), s.addRange(l)))
                }
            }
            for (l = [], s = _; s = s.parentNode;) s.nodeType === 1 && l.push({
                element: s,
                left: s.scrollLeft,
                top: s.scrollTop
            });
            for (typeof _.focus == "function" && _.focus(), _ = 0; _ < l.length; _++) s = l[_], s.element.scrollLeft = s.left, s.element.scrollTop = s.top
        }
    }

    var nd = m && "documentMode" in document && 11 >= document.documentMode, cl = null, Xc = null, za = null, ju = !1;

    function ur(s, l, _) {
        var k = _.window === _ ? _.document : _.nodeType === 9 ? _ : _.ownerDocument;
        ju || cl == null || cl !== Nn(k) || (k = cl, "selectionStart" in k && Kc(k) ? k = {
            start: k.selectionStart,
            end: k.selectionEnd
        } : (k = (k.ownerDocument && k.ownerDocument.defaultView || window).getSelection(), k = {
            anchorNode: k.anchorNode,
            anchorOffset: k.anchorOffset,
            focusNode: k.focusNode,
            focusOffset: k.focusOffset
        }), za && al(za, k) || (za = k, k = As(Xc, "onSelect"), 0 < k.length && (l = new Ou("onSelect", "select", null, l, _), s.push({
            event: l,
            listeners: k
        }), l.target = cl)))
    }

    function xa(s, l) {
        var _ = {};
        return _[s.toLowerCase()] = l.toLowerCase(), _["Webkit" + s] = "webkit" + l, _["Moz" + s] = "moz" + l, _
    }

    var Ga = {
        animationend: xa("Animation", "AnimationEnd"),
        animationiteration: xa("Animation", "AnimationIteration"),
        animationstart: xa("Animation", "AnimationStart"),
        transitionend: xa("Transition", "TransitionEnd")
    }, Ca = {}, ul = {};
    m && (ul = document.createElement("div").style, "AnimationEvent" in window || (delete Ga.animationend.animation, delete Ga.animationiteration.animation, delete Ga.animationstart.animation), "TransitionEvent" in window || delete Ga.transitionend.transition);

    function oc(s) {
        if (Ca[s]) return Ca[s];
        if (!Ga[s]) return s;
        var l = Ga[s], _;
        for (_ in l) if (l.hasOwnProperty(_) && _ in ul) return Ca[s] = l[_];
        return s
    }

    var zr = oc("animationend"), ac = oc("animationiteration"), Wu = oc("animationstart"), Lr = oc("transitionend"),
        ar = new Map,
        lc = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

    function os(s, l) {
        ar.set(s, l), f(l, [s])
    }

    for (var Tl = 0; Tl < lc.length; Tl++) {
        var Pn = lc[Tl], Mi = Pn.toLowerCase(), sr = Pn[0].toUpperCase() + Pn.slice(1);
        os(Mi, "on" + sr)
    }
    os(zr, "onAnimationEnd"), os(ac, "onAnimationIteration"), os(Wu, "onAnimationStart"), os("dblclick", "onDoubleClick"), os("focusin", "onFocus"), os("focusout", "onBlur"), os(Lr, "onTransitionEnd"), T("onMouseEnter", ["mouseout", "mouseover"]), T("onMouseLeave", ["mouseout", "mouseover"]), T("onPointerEnter", ["pointerout", "pointerover"]), T("onPointerLeave", ["pointerout", "pointerover"]), f("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), f("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), f("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), f("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var $i = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
        Ne = new Set("cancel close invalid load scroll toggle".split(" ").concat($i));

    function Lo(s, l, _) {
        var k = s.type || "unknown-event";
        s.currentTarget = _, kr(k, l, void 0, s), s.currentTarget = null
    }

    function qr(s, l) {
        l = (l & 4) !== 0;
        for (var _ = 0; _ < s.length; _++) {
            var k = s[_], W = k.event;
            k = k.listeners;
            e:{
                var ie = void 0;
                if (l) for (var be = k.length - 1; 0 <= be; be--) {
                    var Xe = k[be], nt = Xe.instance, Et = Xe.currentTarget;
                    if (Xe = Xe.listener, nt !== ie && W.isPropagationStopped()) break e;
                    Lo(W, Xe, Et), ie = nt
                } else for (be = 0; be < k.length; be++) {
                    if (Xe = k[be], nt = Xe.instance, Et = Xe.currentTarget, Xe = Xe.listener, nt !== ie && W.isPropagationStopped()) break e;
                    Lo(W, Xe, Et), ie = nt
                }
            }
        }
        if (Or) throw s = ws, Or = !1, ws = null, s
    }

    function Ei(s, l) {
        var _ = l[Df];
        _ === void 0 && (_ = l[Df] = new Set);
        var k = s + "__bubble";
        _.has(k) || (wo(l, s, 2, !1), _.add(k))
    }

    function Ni(s, l, _) {
        var k = 0;
        l && (k |= 4), wo(_, s, k, l)
    }

    var Ts = "_reactListening" + Math.random().toString(36).slice(2);

    function Do(s) {
        if (!s[Ts]) {
            s[Ts] = !0, o.forEach(function (_) {
                _ !== "selectionchange" && (Ne.has(_) || Ni(_, !1, s), Ni(_, !0, s))
            });
            var l = s.nodeType === 9 ? s : s.ownerDocument;
            l === null || l[Ts] || (l[Ts] = !0, Ni("selectionchange", !1, l))
        }
    }

    function wo(s, l, _, k) {
        switch (rr(l)) {
            case 1:
                var W = ha;
                break;
            case 4:
                W = jo;
                break;
            default:
                W = zs
        }
        _ = W.bind(null, l, _, s), W = void 0, !Vi || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (W = !0), k ? W !== void 0 ? s.addEventListener(l, _, {
            capture: !0,
            passive: W
        }) : s.addEventListener(l, _, !0) : W !== void 0 ? s.addEventListener(l, _, {passive: W}) : s.addEventListener(l, _, !1)
    }

    function ms(s, l, _, k, W) {
        var ie = k;
        if (!(l & 1) && !(l & 2) && k !== null) e:for (; ;) {
            if (k === null) return;
            var be = k.tag;
            if (be === 3 || be === 4) {
                var Xe = k.stateNode.containerInfo;
                if (Xe === W || Xe.nodeType === 8 && Xe.parentNode === W) break;
                if (be === 4) for (be = k.return; be !== null;) {
                    var nt = be.tag;
                    if ((nt === 3 || nt === 4) && (nt = be.stateNode.containerInfo, nt === W || nt.nodeType === 8 && nt.parentNode === W)) return;
                    be = be.return
                }
                for (; Xe !== null;) {
                    if (be = Qa(Xe), be === null) return;
                    if (nt = be.tag, nt === 5 || nt === 6) {
                        k = ie = be;
                        continue e
                    }
                    Xe = Xe.parentNode
                }
            }
            k = k.return
        }
        qn(function () {
            var Et = ie, Zt = ve(_), rn = [];
            e:{
                var qt = ar.get(s);
                if (qt !== void 0) {
                    var Ln = Ou, Qn = s;
                    switch (s) {
                        case"keypress":
                            if (mr(_) === 0) break e;
                        case"keydown":
                        case"keyup":
                            Ln = Ef;
                            break;
                        case"focusin":
                            Qn = "focus", Ln = Nu;
                            break;
                        case"focusout":
                            Qn = "blur", Ln = Nu;
                            break;
                        case"beforeblur":
                        case"afterblur":
                            Ln = Nu;
                            break;
                        case"click":
                            if (_.button === 2) break e;
                        case"auxclick":
                        case"dblclick":
                        case"mousedown":
                        case"mousemove":
                        case"mouseup":
                        case"mouseout":
                        case"mouseover":
                        case"contextmenu":
                            Ln = Uh;
                            break;
                        case"drag":
                        case"dragend":
                        case"dragenter":
                        case"dragexit":
                        case"dragleave":
                        case"dragover":
                        case"dragstart":
                        case"drop":
                            Ln = Af;
                            break;
                        case"touchcancel":
                        case"touchend":
                        case"touchmove":
                        case"touchstart":
                            Ln = wf;
                            break;
                        case zr:
                        case ac:
                        case Wu:
                            Ln = Uu;
                            break;
                        case Lr:
                            Ln = _f;
                            break;
                        case"scroll":
                            Ln = pf;
                            break;
                        case"wheel":
                            Ln = zu;
                            break;
                        case"copy":
                        case"cut":
                        case"paste":
                            Ln = Gh;
                            break;
                        case"gotpointercapture":
                        case"lostpointercapture":
                        case"pointercancel":
                        case"pointerdown":
                        case"pointermove":
                        case"pointerout":
                        case"pointerover":
                        case"pointerup":
                            Ln = Kh
                    }
                    var Yn = (l & 4) !== 0, us = !Yn && s === "scroll",
                        vt = Yn ? qt !== null ? qt + "Capture" : null : qt;
                    Yn = [];
                    for (var ct = Et, yt; ct !== null;) {
                        yt = ct;
                        var hn = yt.stateNode;
                        if (yt.tag === 5 && hn !== null && (yt = hn, vt !== null && (hn = fr(ct, vt), hn != null && Yn.push(Si(ct, hn, yt)))), us) break;
                        ct = ct.return
                    }
                    0 < Yn.length && (qt = new Ln(qt, Qn, null, _, Zt), rn.push({event: qt, listeners: Yn}))
                }
            }
            if (!(l & 7)) {
                e:{
                    if (qt = s === "mouseover" || s === "pointerover", Ln = s === "mouseout" || s === "pointerout", qt && _ !== X && (Qn = _.relatedTarget || _.fromElement) && (Qa(Qn) || Qn[ts])) break e;
                    if ((Ln || qt) && (qt = Zt.window === Zt ? Zt : (qt = Zt.ownerDocument) ? qt.defaultView || qt.parentWindow : window, Ln ? (Qn = _.relatedTarget || _.toElement, Ln = Et, Qn = Qn ? Qa(Qn) : null, Qn !== null && (us = Hi(Qn), Qn !== us || Qn.tag !== 5 && Qn.tag !== 6) && (Qn = null)) : (Ln = null, Qn = Et), Ln !== Qn)) {
                        if (Yn = Uh, hn = "onMouseLeave", vt = "onMouseEnter", ct = "mouse", (s === "pointerout" || s === "pointerover") && (Yn = Kh, hn = "onPointerLeave", vt = "onPointerEnter", ct = "pointer"), us = Ln == null ? qt : hc(Ln), yt = Qn == null ? qt : hc(Qn), qt = new Yn(hn, ct + "leave", Ln, _, Zt), qt.target = us, qt.relatedTarget = yt, hn = null, Qa(Zt) === Et && (Yn = new Yn(vt, ct + "enter", Qn, _, Zt), Yn.target = yt, Yn.relatedTarget = us, hn = Yn), us = hn, Ln && Qn) t:{
                            for (Yn = Ln, vt = Qn, ct = 0, yt = Yn; yt; yt = Hs(yt)) ct++;
                            for (yt = 0, hn = vt; hn; hn = Hs(hn)) yt++;
                            for (; 0 < ct - yt;) Yn = Hs(Yn), ct--;
                            for (; 0 < yt - ct;) vt = Hs(vt), yt--;
                            for (; ct--;) {
                                if (Yn === vt || vt !== null && Yn === vt.alternate) break t;
                                Yn = Hs(Yn), vt = Hs(vt)
                            }
                            Yn = null
                        } else Yn = null;
                        Ln !== null && Is(rn, qt, Ln, Yn, !1), Qn !== null && us !== null && Is(rn, us, Qn, Yn, !0)
                    }
                }
                e:{
                    if (qt = Et ? hc(Et) : window, Ln = qt.nodeName && qt.nodeName.toLowerCase(), Ln === "select" || Ln === "input" && qt.type === "file") var Zn = Rf; else if (Xh(qt)) if (qh) Zn = Lf; else {
                        Zn = eo;
                        var di = Bf
                    } else (Ln = qt.nodeName) && Ln.toLowerCase() === "input" && (qt.type === "checkbox" || qt.type === "radio") && (Zn = Ri);
                    if (Zn && (Zn = Zn(s, Et))) {
                        Yh(rn, Zn, _, Zt);
                        break e
                    }
                    di && di(s, qt, Et), s === "focusout" && (di = qt._wrapperState) && di.controlled && qt.type === "number" && nr(qt, "number", qt.value)
                }
                switch (di = Et ? hc(Et) : window, s) {
                    case"focusin":
                        (Xh(di) || di.contentEditable === "true") && (cl = di, Xc = Et, za = null);
                        break;
                    case"focusout":
                        za = Xc = cl = null;
                        break;
                    case"mousedown":
                        ju = !0;
                        break;
                    case"contextmenu":
                    case"mouseup":
                    case"dragend":
                        ju = !1, ur(rn, _, Zt);
                        break;
                    case"selectionchange":
                        if (nd) break;
                    case"keydown":
                    case"keyup":
                        ur(rn, _, Zt)
                }
                var fi;
                if (sl) e:{
                    switch (s) {
                        case"compositionstart":
                            var xi = "onCompositionStart";
                            break e;
                        case"compositionend":
                            xi = "onCompositionEnd";
                            break e;
                        case"compositionupdate":
                            xi = "onCompositionUpdate";
                            break e
                    }
                    xi = void 0
                } else Ua ? uo(s, _) && (xi = "onCompositionEnd") : s === "keydown" && _.keyCode === 229 && (xi = "onCompositionStart");
                xi && (Gu && _.locale !== "ko" && (Ua || xi !== "onCompositionStart" ? xi === "onCompositionEnd" && Ua && (fi = _l()) : (Gs = Zt, bl = "value" in Gs ? Gs.value : Gs.textContent, Ua = !0)), di = As(Et, xi), 0 < di.length && (xi = new jc(xi, s, null, _, Zt), rn.push({
                    event: xi,
                    listeners: di
                }), fi ? xi.data = fi : (fi = Hr(_), fi !== null && (xi.data = fi)))), (fi = Vs ? Sf(s, _) : Tf(s, _)) && (Et = As(Et, "onBeforeInput"), 0 < Et.length && (Zt = new jc("onBeforeInput", "beforeinput", null, _, Zt), rn.push({
                    event: Zt,
                    listeners: Et
                }), Zt.data = fi))
            }
            qr(rn, l)
        })
    }

    function Si(s, l, _) {
        return {instance: s, listener: l, currentTarget: _}
    }

    function As(s, l) {
        for (var _ = l + "Capture", k = []; s !== null;) {
            var W = s, ie = W.stateNode;
            W.tag === 5 && ie !== null && (W = ie, ie = fr(s, _), ie != null && k.unshift(Si(s, ie, W)), ie = fr(s, l), ie != null && k.push(Si(s, ie, W))), s = s.return
        }
        return k
    }

    function Hs(s) {
        if (s === null) return null;
        do s = s.return; while (s && s.tag !== 5);
        return s || null
    }

    function Is(s, l, _, k, W) {
        for (var ie = l._reactName, be = []; _ !== null && _ !== k;) {
            var Xe = _, nt = Xe.alternate, Et = Xe.stateNode;
            if (nt !== null && nt === k) break;
            Xe.tag === 5 && Et !== null && (Xe = Et, W ? (nt = fr(_, ie), nt != null && be.unshift(Si(_, nt, Xe))) : W || (nt = fr(_, ie), nt != null && be.push(Si(_, nt, Xe)))), _ = _.return
        }
        be.length !== 0 && s.push({event: l, listeners: be})
    }

    var lr = /\r\n?/g, Sr = /\u0000|\uFFFD/g;

    function Li(s) {
        return (typeof s == "string" ? s : "" + s).replace(lr, `
`).replace(Sr, "")
    }

    function Ki(s, l, _) {
        if (l = Li(l), Li(s) !== l && _) throw Error(i(425))
    }

    function Qs() {
    }

    var Va = null, wa = null;

    function Il(s, l) {
        return s === "textarea" || s === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null
    }

    var as = typeof setTimeout == "function" ? setTimeout : void 0,
        fa = typeof clearTimeout == "function" ? clearTimeout : void 0,
        cc = typeof Promise == "function" ? Promise : void 0,
        Yc = typeof queueMicrotask == "function" ? queueMicrotask : typeof cc < "u" ? function (s) {
            return cc.resolve(null).then(s).catch(Ha)
        } : as;

    function Ha(s) {
        setTimeout(function () {
            throw s
        })
    }

    function uc(s, l) {
        var _ = l, k = 0;
        do {
            var W = _.nextSibling;
            if (s.removeChild(_), W && W.nodeType === 8) if (_ = W.data, _ === "/$") {
                if (k === 0) {
                    s.removeChild(W), Yr(l);
                    return
                }
                k--
            } else _ !== "$" && _ !== "$?" && _ !== "$!" || k++;
            _ = W
        } while (_);
        Yr(l)
    }

    function Ko(s) {
        for (; s != null; s = s.nextSibling) {
            var l = s.nodeType;
            if (l === 1 || l === 3) break;
            if (l === 8) {
                if (l = s.data, l === "$" || l === "$!" || l === "$?") break;
                if (l === "/$") return null
            }
        }
        return s
    }

    function qc(s) {
        s = s.previousSibling;
        for (var l = 0; s;) {
            if (s.nodeType === 8) {
                var _ = s.data;
                if (_ === "$" || _ === "$!" || _ === "$?") {
                    if (l === 0) return s;
                    l--
                } else _ === "/$" && l++
            }
            s = s.previousSibling
        }
        return null
    }

    var jr = Math.random().toString(36).slice(2), Mn = "__reactFiber$" + jr, Xo = "__reactProps$" + jr,
        ts = "__reactContainer$" + jr, Df = "__reactEvents$" + jr, U0 = "__reactListeners$" + jr,
        Rl = "__reactHandles$" + jr;

    function Qa(s) {
        var l = s[Mn];
        if (l) return l;
        for (var _ = s.parentNode; _;) {
            if (l = _[ts] || _[Mn]) {
                if (_ = l.alternate, l.child !== null || _ !== null && _.child !== null) for (s = qc(s); s !== null;) {
                    if (_ = s[Mn]) return _;
                    s = qc(s)
                }
                return l
            }
            s = _, _ = s.parentNode
        }
        return null
    }

    function to(s) {
        return s = s[Mn] || s[ts], !s || s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3 ? null : s
    }

    function hc(s) {
        if (s.tag === 5 || s.tag === 6) return s.stateNode;
        throw Error(i(33))
    }

    function Ku(s) {
        return s[Xo] || null
    }

    var bo = [], hl = -1;

    function Bl(s) {
        return {current: s}
    }

    function Gr(s) {
        0 > hl || (s.current = bo[hl], bo[hl] = null, hl--)
    }

    function Ar(s, l) {
        hl++, bo[hl] = s.current, s.current = l
    }

    var ho = {}, Rs = Bl(ho), js = Bl(!1), dc = ho;

    function Jc(s, l) {
        var _ = s.type.contextTypes;
        if (!_) return ho;
        var k = s.stateNode;
        if (k && k.__reactInternalMemoizedUnmaskedChildContext === l) return k.__reactInternalMemoizedMaskedChildContext;
        var W = {}, ie;
        for (ie in _) W[ie] = l[ie];
        return k && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = l, s.__reactInternalMemoizedMaskedChildContext = W), W
    }

    function _o(s) {
        return s = s.childContextTypes, s != null
    }

    function Xu() {
        Gr(js), Gr(Rs)
    }

    function Pf(s, l, _) {
        if (Rs.current !== ho) throw Error(i(168));
        Ar(Rs, l), Ar(js, _)
    }

    function Of(s, l, _) {
        var k = s.stateNode;
        if (l = l.childContextTypes, typeof k.getChildContext != "function") return _;
        k = k.getChildContext();
        for (var W in k) if (!(W in l)) throw Error(i(108, ot(s) || "Unknown", W));
        return ae({}, _, k)
    }

    function id(s) {
        return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || ho, dc = Rs.current, Ar(Rs, s), Ar(js, js.current), !0
    }

    function fc(s, l, _) {
        var k = s.stateNode;
        if (!k) throw Error(i(169));
        _ ? (s = Of(s, l, dc), k.__reactInternalMemoizedMergedChildContext = s, Gr(js), Gr(Rs), Ar(Rs, s)) : Gr(js), Ar(js, _)
    }

    var ba = null, or = !1, Yo = !1;

    function ja(s) {
        ba === null ? ba = [s] : ba.push(s)
    }

    function kf(s) {
        or = !0, ja(s)
    }

    function fo() {
        if (!Yo && ba !== null) {
            Yo = !0;
            var s = 0, l = wt;
            try {
                var _ = ba;
                for (wt = 1; s < _.length; s++) {
                    var k = _[s];
                    do k = k(!0); while (k !== null)
                }
                ba = null, or = !1
            } catch (W) {
                throw ba !== null && (ba = ba.slice(s + 1)), De(Kt, fo), W
            } finally {
                wt = l, Yo = !1
            }
        }
        return null
    }

    var _a = [], Ma = 0, Yu = null, Zc = 0, Po = [], Oo = 0, Bs = null, Wa = 1, po = "";

    function Ka(s, l) {
        _a[Ma++] = Zc, _a[Ma++] = Yu, Yu = s, Zc = l
    }

    function rd(s, l, _) {
        Po[Oo++] = Wa, Po[Oo++] = po, Po[Oo++] = Bs, Bs = s;
        var k = Wa;
        s = po;
        var W = 32 - li(k) - 1;
        k &= ~(1 << W), _ += 1;
        var ie = 32 - li(l) + W;
        if (30 < ie) {
            var be = W - W % 5;
            ie = (k & (1 << be) - 1).toString(32), k >>= be, W -= be, Wa = 1 << 32 - li(l) + W | _ << W | k, po = ie + s
        } else Wa = 1 << ie | _ << W | k, po = s
    }

    function Bn(s) {
        s.return !== null && (Ka(s, 1), rd(s, 1, 0))
    }

    function Ws(s) {
        for (; s === Yu;) Yu = _a[--Ma], _a[Ma] = null, Zc = _a[--Ma], _a[Ma] = null;
        for (; s === Bs;) Bs = Po[--Oo], Po[Oo] = null, po = Po[--Oo], Po[Oo] = null, Wa = Po[--Oo], Po[Oo] = null
    }

    var qo = null, Dr = null, gr = !1, Ls = null;

    function bm(s, l) {
        var _ = ra(5, null, null, 0);
        _.elementType = "DELETED", _.stateNode = l, _.return = s, l = s.deletions, l === null ? (s.deletions = [_], s.flags |= 16) : l.push(_)
    }

    function Mo(s, l) {
        switch (s.tag) {
            case 5:
                var _ = s.type;
                return l = l.nodeType !== 1 || _.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (s.stateNode = l, qo = s, Dr = Ko(l.firstChild), !0) : !1;
            case 6:
                return l = s.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (s.stateNode = l, qo = s, Dr = null, !0) : !1;
            case 13:
                return l = l.nodeType !== 8 ? null : l, l !== null ? (_ = Bs !== null ? {
                    id: Wa,
                    overflow: po
                } : null, s.memoizedState = {
                    dehydrated: l,
                    treeContext: _,
                    retryLane: 1073741824
                }, _ = ra(18, null, null, 0), _.stateNode = l, _.return = s, s.child = _, qo = s, Dr = null, !0) : !1;
            default:
                return !1
        }
    }

    function pc(s) {
        return (s.mode & 1) !== 0 && (s.flags & 128) === 0
    }

    function Ff(s) {
        if (gr) {
            var l = Dr;
            if (l) {
                var _ = l;
                if (!Mo(s, l)) {
                    if (pc(s)) throw Error(i(418));
                    l = Ko(_.nextSibling);
                    var k = qo;
                    l && Mo(s, l) ? bm(k, _) : (s.flags = s.flags & -4097 | 2, gr = !1, qo = s)
                }
            } else {
                if (pc(s)) throw Error(i(418));
                s.flags = s.flags & -4097 | 2, gr = !1, qo = s
            }
        }
    }

    function ls(s) {
        for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13;) s = s.return;
        qo = s
    }

    function mc(s) {
        if (s !== qo) return !1;
        if (!gr) return ls(s), gr = !0, !1;
        var l;
        if ((l = s.tag !== 3) && !(l = s.tag !== 5) && (l = s.type, l = l !== "head" && l !== "body" && !Il(s.type, s.memoizedProps)), l && (l = Dr)) {
            if (pc(s)) throw Er(), Error(i(418));
            for (; l;) bm(s, l), l = Ko(l.nextSibling)
        }
        if (ls(s), s.tag === 13) {
            if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(i(317));
            e:{
                for (s = s.nextSibling, l = 0; s;) {
                    if (s.nodeType === 8) {
                        var _ = s.data;
                        if (_ === "/$") {
                            if (l === 0) {
                                Dr = Ko(s.nextSibling);
                                break e
                            }
                            l--
                        } else _ !== "$" && _ !== "$!" && _ !== "$?" || l++
                    }
                    s = s.nextSibling
                }
                Dr = null
            }
        } else Dr = qo ? Ko(s.stateNode.nextSibling) : null;
        return !0
    }

    function Er() {
        for (var s = Dr; s;) s = Ko(s.nextSibling)
    }

    function $c() {
        Dr = qo = null, gr = !1
    }

    function Nf(s) {
        Ls === null ? Ls = [s] : Ls.push(s)
    }

    var z0 = I.ReactCurrentBatchConfig;

    function qu(s, l, _) {
        if (s = _.ref, s !== null && typeof s != "function" && typeof s != "object") {
            if (_._owner) {
                if (_ = _._owner, _) {
                    if (_.tag !== 1) throw Error(i(309));
                    var k = _.stateNode
                }
                if (!k) throw Error(i(147, s));
                var W = k, ie = "" + s;
                return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === ie ? l.ref : (l = function (be) {
                    var Xe = W.refs;
                    be === null ? delete Xe[ie] : Xe[ie] = be
                }, l._stringRef = ie, l)
            }
            if (typeof s != "string") throw Error(i(284));
            if (!_._owner) throw Error(i(290, s))
        }
        return s
    }

    function eu(s, l) {
        throw s = Object.prototype.toString.call(l), Error(i(31, s === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : s))
    }

    function _m(s) {
        var l = s._init;
        return l(s._payload)
    }

    function sd(s) {
        function l(vt, ct) {
            if (s) {
                var yt = vt.deletions;
                yt === null ? (vt.deletions = [ct], vt.flags |= 16) : yt.push(ct)
            }
        }

        function _(vt, ct) {
            if (!s) return null;
            for (; ct !== null;) l(vt, ct), ct = ct.sibling;
            return null
        }

        function k(vt, ct) {
            for (vt = new Map; ct !== null;) ct.key !== null ? vt.set(ct.key, ct) : vt.set(ct.index, ct), ct = ct.sibling;
            return vt
        }

        function W(vt, ct) {
            return vt = Vl(vt, ct), vt.index = 0, vt.sibling = null, vt
        }

        function ie(vt, ct, yt) {
            return vt.index = yt, s ? (yt = vt.alternate, yt !== null ? (yt = yt.index, yt < ct ? (vt.flags |= 2, ct) : yt) : (vt.flags |= 2, ct)) : (vt.flags |= 1048576, ct)
        }

        function be(vt) {
            return s && vt.alternate === null && (vt.flags |= 2), vt
        }

        function Xe(vt, ct, yt, hn) {
            return ct === null || ct.tag !== 6 ? (ct = vp(yt, vt.mode, hn), ct.return = vt, ct) : (ct = W(ct, yt), ct.return = vt, ct)
        }

        function nt(vt, ct, yt, hn) {
            var Zn = yt.type;
            return Zn === N ? Zt(vt, ct, yt.props.children, hn, yt.key) : ct !== null && (ct.elementType === Zn || typeof Zn == "object" && Zn !== null && Zn.$$typeof === ue && _m(Zn) === ct.type) ? (hn = W(ct, yt.props), hn.ref = qu(vt, ct, yt), hn.return = vt, hn) : (hn = _d(yt.type, yt.key, yt.props, null, vt.mode, hn), hn.ref = qu(vt, ct, yt), hn.return = vt, hn)
        }

        function Et(vt, ct, yt, hn) {
            return ct === null || ct.tag !== 4 || ct.stateNode.containerInfo !== yt.containerInfo || ct.stateNode.implementation !== yt.implementation ? (ct = yp(yt, vt.mode, hn), ct.return = vt, ct) : (ct = W(ct, yt.children || []), ct.return = vt, ct)
        }

        function Zt(vt, ct, yt, hn, Zn) {
            return ct === null || ct.tag !== 7 ? (ct = Ic(yt, vt.mode, hn, Zn), ct.return = vt, ct) : (ct = W(ct, yt), ct.return = vt, ct)
        }

        function rn(vt, ct, yt) {
            if (typeof ct == "string" && ct !== "" || typeof ct == "number") return ct = vp("" + ct, vt.mode, yt), ct.return = vt, ct;
            if (typeof ct == "object" && ct !== null) {
                switch (ct.$$typeof) {
                    case L:
                        return yt = _d(ct.type, ct.key, ct.props, null, vt.mode, yt), yt.ref = qu(vt, null, ct), yt.return = vt, yt;
                    case O:
                        return ct = yp(ct, vt.mode, yt), ct.return = vt, ct;
                    case ue:
                        var hn = ct._init;
                        return rn(vt, hn(ct._payload), yt)
                }
                if (Oi(ct) || H(ct)) return ct = Ic(ct, vt.mode, yt, null), ct.return = vt, ct;
                eu(vt, ct)
            }
            return null
        }

        function qt(vt, ct, yt, hn) {
            var Zn = ct !== null ? ct.key : null;
            if (typeof yt == "string" && yt !== "" || typeof yt == "number") return Zn !== null ? null : Xe(vt, ct, "" + yt, hn);
            if (typeof yt == "object" && yt !== null) {
                switch (yt.$$typeof) {
                    case L:
                        return yt.key === Zn ? nt(vt, ct, yt, hn) : null;
                    case O:
                        return yt.key === Zn ? Et(vt, ct, yt, hn) : null;
                    case ue:
                        return Zn = yt._init, qt(vt, ct, Zn(yt._payload), hn)
                }
                if (Oi(yt) || H(yt)) return Zn !== null ? null : Zt(vt, ct, yt, hn, null);
                eu(vt, yt)
            }
            return null
        }

        function Ln(vt, ct, yt, hn, Zn) {
            if (typeof hn == "string" && hn !== "" || typeof hn == "number") return vt = vt.get(yt) || null, Xe(ct, vt, "" + hn, Zn);
            if (typeof hn == "object" && hn !== null) {
                switch (hn.$$typeof) {
                    case L:
                        return vt = vt.get(hn.key === null ? yt : hn.key) || null, nt(ct, vt, hn, Zn);
                    case O:
                        return vt = vt.get(hn.key === null ? yt : hn.key) || null, Et(ct, vt, hn, Zn);
                    case ue:
                        var di = hn._init;
                        return Ln(vt, ct, yt, di(hn._payload), Zn)
                }
                if (Oi(hn) || H(hn)) return vt = vt.get(yt) || null, Zt(ct, vt, hn, Zn, null);
                eu(ct, hn)
            }
            return null
        }

        function Qn(vt, ct, yt, hn) {
            for (var Zn = null, di = null, fi = ct, xi = ct = 0, Xs = null; fi !== null && xi < yt.length; xi++) {
                fi.index > xi ? (Xs = fi, fi = null) : Xs = fi.sibling;
                var dr = qt(vt, fi, yt[xi], hn);
                if (dr === null) {
                    fi === null && (fi = Xs);
                    break
                }
                s && fi && dr.alternate === null && l(vt, fi), ct = ie(dr, ct, xi), di === null ? Zn = dr : di.sibling = dr, di = dr, fi = Xs
            }
            if (xi === yt.length) return _(vt, fi), gr && Ka(vt, xi), Zn;
            if (fi === null) {
                for (; xi < yt.length; xi++) fi = rn(vt, yt[xi], hn), fi !== null && (ct = ie(fi, ct, xi), di === null ? Zn = fi : di.sibling = fi, di = fi);
                return gr && Ka(vt, xi), Zn
            }
            for (fi = k(vt, fi); xi < yt.length; xi++) Xs = Ln(fi, vt, xi, yt[xi], hn), Xs !== null && (s && Xs.alternate !== null && fi.delete(Xs.key === null ? xi : Xs.key), ct = ie(Xs, ct, xi), di === null ? Zn = Xs : di.sibling = Xs, di = Xs);
            return s && fi.forEach(function (Hl) {
                return l(vt, Hl)
            }), gr && Ka(vt, xi), Zn
        }

        function Yn(vt, ct, yt, hn) {
            var Zn = H(yt);
            if (typeof Zn != "function") throw Error(i(150));
            if (yt = Zn.call(yt), yt == null) throw Error(i(151));
            for (var di = Zn = null, fi = ct, xi = ct = 0, Xs = null, dr = yt.next(); fi !== null && !dr.done; xi++, dr = yt.next()) {
                fi.index > xi ? (Xs = fi, fi = null) : Xs = fi.sibling;
                var Hl = qt(vt, fi, dr.value, hn);
                if (Hl === null) {
                    fi === null && (fi = Xs);
                    break
                }
                s && fi && Hl.alternate === null && l(vt, fi), ct = ie(Hl, ct, xi), di === null ? Zn = Hl : di.sibling = Hl, di = Hl, fi = Xs
            }
            if (dr.done) return _(vt, fi), gr && Ka(vt, xi), Zn;
            if (fi === null) {
                for (; !dr.done; xi++, dr = yt.next()) dr = rn(vt, dr.value, hn), dr !== null && (ct = ie(dr, ct, xi), di === null ? Zn = dr : di.sibling = dr, di = dr);
                return gr && Ka(vt, xi), Zn
            }
            for (fi = k(vt, fi); !dr.done; xi++, dr = yt.next()) dr = Ln(fi, vt, xi, dr.value, hn), dr !== null && (s && dr.alternate !== null && fi.delete(dr.key === null ? xi : dr.key), ct = ie(dr, ct, xi), di === null ? Zn = dr : di.sibling = dr, di = dr);
            return s && fi.forEach(function (cv) {
                return l(vt, cv)
            }), gr && Ka(vt, xi), Zn
        }

        function us(vt, ct, yt, hn) {
            if (typeof yt == "object" && yt !== null && yt.type === N && yt.key === null && (yt = yt.props.children), typeof yt == "object" && yt !== null) {
                switch (yt.$$typeof) {
                    case L:
                        e:{
                            for (var Zn = yt.key, di = ct; di !== null;) {
                                if (di.key === Zn) {
                                    if (Zn = yt.type, Zn === N) {
                                        if (di.tag === 7) {
                                            _(vt, di.sibling), ct = W(di, yt.props.children), ct.return = vt, vt = ct;
                                            break e
                                        }
                                    } else if (di.elementType === Zn || typeof Zn == "object" && Zn !== null && Zn.$$typeof === ue && _m(Zn) === di.type) {
                                        _(vt, di.sibling), ct = W(di, yt.props), ct.ref = qu(vt, di, yt), ct.return = vt, vt = ct;
                                        break e
                                    }
                                    _(vt, di);
                                    break
                                } else l(vt, di);
                                di = di.sibling
                            }
                            yt.type === N ? (ct = Ic(yt.props.children, vt.mode, hn, yt.key), ct.return = vt, vt = ct) : (hn = _d(yt.type, yt.key, yt.props, null, vt.mode, hn), hn.ref = qu(vt, ct, yt), hn.return = vt, vt = hn)
                        }
                        return be(vt);
                    case O:
                        e:{
                            for (di = yt.key; ct !== null;) {
                                if (ct.key === di) if (ct.tag === 4 && ct.stateNode.containerInfo === yt.containerInfo && ct.stateNode.implementation === yt.implementation) {
                                    _(vt, ct.sibling), ct = W(ct, yt.children || []), ct.return = vt, vt = ct;
                                    break e
                                } else {
                                    _(vt, ct);
                                    break
                                } else l(vt, ct);
                                ct = ct.sibling
                            }
                            ct = yp(yt, vt.mode, hn), ct.return = vt, vt = ct
                        }
                        return be(vt);
                    case ue:
                        return di = yt._init, us(vt, ct, di(yt._payload), hn)
                }
                if (Oi(yt)) return Qn(vt, ct, yt, hn);
                if (H(yt)) return Yn(vt, ct, yt, hn);
                eu(vt, yt)
            }
            return typeof yt == "string" && yt !== "" || typeof yt == "number" ? (yt = "" + yt, ct !== null && ct.tag === 6 ? (_(vt, ct.sibling), ct = W(ct, yt), ct.return = vt, vt = ct) : (_(vt, ct), ct = vp(yt, vt.mode, hn), ct.return = vt, vt = ct), be(vt)) : _(vt, ct)
        }

        return us
    }

    var tu = sd(!0), Xn = sd(!1), od = Bl(null), So = null, Ll = null, Dl = null;

    function To() {
        Dl = Ll = So = null
    }

    function Ac(s) {
        var l = od.current;
        Gr(od), s._currentValue = l
    }

    function gs(s, l, _) {
        for (; s !== null;) {
            var k = s.alternate;
            if ((s.childLanes & l) !== l ? (s.childLanes |= l, k !== null && (k.childLanes |= l)) : k !== null && (k.childLanes & l) !== l && (k.childLanes |= l), s === _) break;
            s = s.return
        }
    }

    function Ti(s, l) {
        So = s, Dl = Ll = null, s = s.dependencies, s !== null && s.firstContext !== null && (s.lanes & l && (Fo = !0), s.firstContext = null)
    }

    function Jo(s) {
        var l = s._currentValue;
        if (Dl !== s) if (s = {context: s, memoizedValue: l, next: null}, Ll === null) {
            if (So === null) throw Error(i(308));
            Ll = s, So.dependencies = {lanes: 0, firstContext: s}
        } else Ll = Ll.next = s;
        return l
    }

    var Zo = null;

    function nu(s) {
        Zo === null ? Zo = [s] : Zo.push(s)
    }

    function Uf(s, l, _, k) {
        var W = l.interleaved;
        return W === null ? (_.next = _, nu(l)) : (_.next = W.next, W.next = _), l.interleaved = _, ko(s, k)
    }

    function ko(s, l) {
        s.lanes |= l;
        var _ = s.alternate;
        for (_ !== null && (_.lanes |= l), _ = s, s = s.return; s !== null;) s.childLanes |= l, _ = s.alternate, _ !== null && (_.childLanes |= l), _ = s, s = s.return;
        return _.tag === 3 ? _.stateNode : null
    }

    var $o = !1;

    function Pl(s) {
        s.updateQueue = {
            baseState: s.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {pending: null, interleaved: null, lanes: 0},
            effects: null
        }
    }

    function ad(s, l) {
        s = s.updateQueue, l.updateQueue === s && (l.updateQueue = {
            baseState: s.baseState,
            firstBaseUpdate: s.firstBaseUpdate,
            lastBaseUpdate: s.lastBaseUpdate,
            shared: s.shared,
            effects: s.effects
        })
    }

    function pa(s, l) {
        return {eventTime: s, lane: l, tag: 0, payload: null, callback: null, next: null}
    }

    function Sa(s, l, _) {
        var k = s.updateQueue;
        if (k === null) return null;
        if (k = k.shared, hr & 2) {
            var W = k.pending;
            return W === null ? l.next = l : (l.next = W.next, W.next = l), k.pending = l, ko(s, _)
        }
        return W = k.interleaved, W === null ? (l.next = l, nu(k)) : (l.next = W.next, W.next = l), k.interleaved = l, ko(s, _)
    }

    function gc(s, l, _) {
        if (l = l.updateQueue, l !== null && (l = l.shared, (_ & 4194240) !== 0)) {
            var k = l.lanes;
            k &= s.pendingLanes, _ |= k, l.lanes = _, at(s, _)
        }
    }

    function Ju(s, l) {
        var _ = s.updateQueue, k = s.alternate;
        if (k !== null && (k = k.updateQueue, _ === k)) {
            var W = null, ie = null;
            if (_ = _.firstBaseUpdate, _ !== null) {
                do {
                    var be = {
                        eventTime: _.eventTime,
                        lane: _.lane,
                        tag: _.tag,
                        payload: _.payload,
                        callback: _.callback,
                        next: null
                    };
                    ie === null ? W = ie = be : ie = ie.next = be, _ = _.next
                } while (_ !== null);
                ie === null ? W = ie = l : ie = ie.next = l
            } else W = ie = l;
            _ = {
                baseState: k.baseState,
                firstBaseUpdate: W,
                lastBaseUpdate: ie,
                shared: k.shared,
                effects: k.effects
            }, s.updateQueue = _;
            return
        }
        s = _.lastBaseUpdate, s === null ? _.firstBaseUpdate = l : s.next = l, _.lastBaseUpdate = l
    }

    function Zu(s, l, _, k) {
        var W = s.updateQueue;
        $o = !1;
        var ie = W.firstBaseUpdate, be = W.lastBaseUpdate, Xe = W.shared.pending;
        if (Xe !== null) {
            W.shared.pending = null;
            var nt = Xe, Et = nt.next;
            nt.next = null, be === null ? ie = Et : be.next = Et, be = nt;
            var Zt = s.alternate;
            Zt !== null && (Zt = Zt.updateQueue, Xe = Zt.lastBaseUpdate, Xe !== be && (Xe === null ? Zt.firstBaseUpdate = Et : Xe.next = Et, Zt.lastBaseUpdate = nt))
        }
        if (ie !== null) {
            var rn = W.baseState;
            be = 0, Zt = Et = nt = null, Xe = ie;
            do {
                var qt = Xe.lane, Ln = Xe.eventTime;
                if ((k & qt) === qt) {
                    Zt !== null && (Zt = Zt.next = {
                        eventTime: Ln,
                        lane: 0,
                        tag: Xe.tag,
                        payload: Xe.payload,
                        callback: Xe.callback,
                        next: null
                    });
                    e:{
                        var Qn = s, Yn = Xe;
                        switch (qt = l, Ln = _, Yn.tag) {
                            case 1:
                                if (Qn = Yn.payload, typeof Qn == "function") {
                                    rn = Qn.call(Ln, rn, qt);
                                    break e
                                }
                                rn = Qn;
                                break e;
                            case 3:
                                Qn.flags = Qn.flags & -65537 | 128;
                            case 0:
                                if (Qn = Yn.payload, qt = typeof Qn == "function" ? Qn.call(Ln, rn, qt) : Qn, qt == null) break e;
                                rn = ae({}, rn, qt);
                                break e;
                            case 2:
                                $o = !0
                        }
                    }
                    Xe.callback !== null && Xe.lane !== 0 && (s.flags |= 64, qt = W.effects, qt === null ? W.effects = [Xe] : qt.push(Xe))
                } else Ln = {
                    eventTime: Ln,
                    lane: qt,
                    tag: Xe.tag,
                    payload: Xe.payload,
                    callback: Xe.callback,
                    next: null
                }, Zt === null ? (Et = Zt = Ln, nt = rn) : Zt = Zt.next = Ln, be |= qt;
                if (Xe = Xe.next, Xe === null) {
                    if (Xe = W.shared.pending, Xe === null) break;
                    qt = Xe, Xe = qt.next, qt.next = null, W.lastBaseUpdate = qt, W.shared.pending = null
                }
            } while (!0);
            if (Zt === null && (nt = rn), W.baseState = nt, W.firstBaseUpdate = Et, W.lastBaseUpdate = Zt, l = W.shared.interleaved, l !== null) {
                W = l;
                do be |= W.lane, W = W.next; while (W !== l)
            } else ie === null && (W.shared.lanes = 0);
            lu |= be, s.lanes = be, s.memoizedState = rn
        }
    }

    function zf(s, l, _) {
        if (s = l.effects, l.effects = null, s !== null) for (l = 0; l < s.length; l++) {
            var k = s[l], W = k.callback;
            if (W !== null) {
                if (k.callback = null, k = _, typeof W != "function") throw Error(i(191, W));
                W.call(k)
            }
        }
    }

    var iu = {}, ea = Bl(iu), Ol = Bl(iu), Wr = Bl(iu);

    function vc(s) {
        if (s === iu) throw Error(i(174));
        return s
    }

    function ru(s, l) {
        switch (Ar(Wr, l), Ar(Ol, s), Ar(ea, iu), s = l.nodeType, s) {
            case 9:
            case 11:
                l = (l = l.documentElement) ? l.namespaceURI : Nr(null, "");
                break;
            default:
                s = s === 8 ? l.parentNode : l, l = s.namespaceURI || null, s = s.tagName, l = Nr(l, s)
        }
        Gr(ea), Ar(ea, l)
    }

    function ma() {
        Gr(ea), Gr(Ol), Gr(Wr)
    }

    function yc(s) {
        vc(Wr.current);
        var l = vc(ea.current), _ = Nr(l, s.type);
        l !== _ && (Ar(Ol, s), Ar(ea, _))
    }

    function no(s) {
        Ol.current === s && (Gr(ea), Gr(Ol))
    }

    var Jr = Bl(0);

    function $u(s) {
        for (var l = s; l !== null;) {
            if (l.tag === 13) {
                var _ = l.memoizedState;
                if (_ !== null && (_ = _.dehydrated, _ === null || _.data === "$?" || _.data === "$!")) return l
            } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
                if (l.flags & 128) return l
            } else if (l.child !== null) {
                l.child.return = l, l = l.child;
                continue
            }
            if (l === s) break;
            for (; l.sibling === null;) {
                if (l.return === null || l.return === s) return null;
                l = l.return
            }
            l.sibling.return = l.return, l = l.sibling
        }
        return null
    }

    var ld = [];

    function Gf() {
        for (var s = 0; s < ld.length; s++) ld[s]._workInProgressVersionPrimary = null;
        ld.length = 0
    }

    var cd = I.ReactCurrentDispatcher, ta = I.ReactCurrentBatchConfig, Xa = 0, xr = null, vs = null, Ds = null, ns = !1,
        Ya = !1, qa = 0, Mm = 0;

    function ys() {
        throw Error(i(321))
    }

    function ud(s, l) {
        if (l === null) return !1;
        for (var _ = 0; _ < l.length && _ < s.length; _++) if (!ai(s[_], l[_])) return !1;
        return !0
    }

    function eh(s, l, _, k, W, ie) {
        if (Xa = ie, xr = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, cd.current = s === null || s.memoizedState === null ? Q0 : j0, s = _(k, W), Ya) {
            ie = 0;
            do {
                if (Ya = !1, qa = 0, 25 <= ie) throw Error(i(301));
                ie += 1, Ds = vs = null, l.updateQueue = null, cd.current = W0, s = _(k, W)
            } while (Ya)
        }
        if (cd.current = pd, l = vs !== null && vs.next !== null, Xa = 0, Ds = vs = xr = null, ns = !1, l) throw Error(i(300));
        return s
    }

    function Vf() {
        var s = qa !== 0;
        return qa = 0, s
    }

    function Ja() {
        var s = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
        return Ds === null ? xr.memoizedState = Ds = s : Ds = Ds.next = s, Ds
    }

    function Ps() {
        if (vs === null) {
            var s = xr.alternate;
            s = s !== null ? s.memoizedState : null
        } else s = vs.next;
        var l = Ds === null ? xr.memoizedState : Ds.next;
        if (l !== null) Ds = l, vs = s; else {
            if (s === null) throw Error(i(310));
            vs = s, s = {
                memoizedState: vs.memoizedState,
                baseState: vs.baseState,
                baseQueue: vs.baseQueue,
                queue: vs.queue,
                next: null
            }, Ds === null ? xr.memoizedState = Ds = s : Ds = Ds.next = s
        }
        return Ds
    }

    function Ta(s, l) {
        return typeof l == "function" ? l(s) : l
    }

    function su(s) {
        var l = Ps(), _ = l.queue;
        if (_ === null) throw Error(i(311));
        _.lastRenderedReducer = s;
        var k = vs, W = k.baseQueue, ie = _.pending;
        if (ie !== null) {
            if (W !== null) {
                var be = W.next;
                W.next = ie.next, ie.next = be
            }
            k.baseQueue = W = ie, _.pending = null
        }
        if (W !== null) {
            ie = W.next, k = k.baseState;
            var Xe = be = null, nt = null, Et = ie;
            do {
                var Zt = Et.lane;
                if ((Xa & Zt) === Zt) nt !== null && (nt = nt.next = {
                    lane: 0,
                    action: Et.action,
                    hasEagerState: Et.hasEagerState,
                    eagerState: Et.eagerState,
                    next: null
                }), k = Et.hasEagerState ? Et.eagerState : s(k, Et.action); else {
                    var rn = {
                        lane: Zt,
                        action: Et.action,
                        hasEagerState: Et.hasEagerState,
                        eagerState: Et.eagerState,
                        next: null
                    };
                    nt === null ? (Xe = nt = rn, be = k) : nt = nt.next = rn, xr.lanes |= Zt, lu |= Zt
                }
                Et = Et.next
            } while (Et !== null && Et !== ie);
            nt === null ? be = k : nt.next = Xe, ai(k, l.memoizedState) || (Fo = !0), l.memoizedState = k, l.baseState = be, l.baseQueue = nt, _.lastRenderedState = k
        }
        if (s = _.interleaved, s !== null) {
            W = s;
            do ie = W.lane, xr.lanes |= ie, lu |= ie, W = W.next; while (W !== s)
        } else W === null && (_.lanes = 0);
        return [l.memoizedState, _.dispatch]
    }

    function Ec(s) {
        var l = Ps(), _ = l.queue;
        if (_ === null) throw Error(i(311));
        _.lastRenderedReducer = s;
        var k = _.dispatch, W = _.pending, ie = l.memoizedState;
        if (W !== null) {
            _.pending = null;
            var be = W = W.next;
            do ie = s(ie, be.action), be = be.next; while (be !== W);
            ai(ie, l.memoizedState) || (Fo = !0), l.memoizedState = ie, l.baseQueue === null && (l.baseState = ie), _.lastRenderedState = ie
        }
        return [ie, k]
    }

    function hd() {
    }

    function Sm(s, l) {
        var _ = xr, k = Ps(), W = l(), ie = !ai(k.memoizedState, W);
        if (ie && (k.memoizedState = W, Fo = !0), k = k.queue, Hf(Im.bind(null, _, k, s), [s]), k.getSnapshot !== l || ie || Ds !== null && Ds.memoizedState.tag & 1) {
            if (_.flags |= 2048, th(9, Tm.bind(null, _, k, W, l), void 0, null), ro === null) throw Error(i(349));
            Xa & 30 || xc(_, l, W)
        }
        return W
    }

    function xc(s, l, _) {
        s.flags |= 16384, s = {getSnapshot: l, value: _}, l = xr.updateQueue, l === null ? (l = {
            lastEffect: null,
            stores: null
        }, xr.updateQueue = l, l.stores = [s]) : (_ = l.stores, _ === null ? l.stores = [s] : _.push(s))
    }

    function Tm(s, l, _, k) {
        l.value = _, l.getSnapshot = k, Rm(l) && Bm(s)
    }

    function Im(s, l, _) {
        return _(function () {
            Rm(l) && Bm(s)
        })
    }

    function Rm(s) {
        var l = s.getSnapshot;
        s = s.value;
        try {
            var _ = l();
            return !ai(s, _)
        } catch {
            return !0
        }
    }

    function Bm(s) {
        var l = ko(s, 1);
        l !== null && $a(l, s, 1, -1)
    }

    function Lm(s) {
        var l = Ja();
        return typeof s == "function" && (s = s()), l.memoizedState = l.baseState = s, s = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ta,
            lastRenderedState: s
        }, l.queue = s, s = s.dispatch = H0.bind(null, xr, s), [l.memoizedState, s]
    }

    function th(s, l, _, k) {
        return s = {
            tag: s,
            create: l,
            destroy: _,
            deps: k,
            next: null
        }, l = xr.updateQueue, l === null ? (l = {
            lastEffect: null,
            stores: null
        }, xr.updateQueue = l, l.lastEffect = s.next = s) : (_ = l.lastEffect, _ === null ? l.lastEffect = s.next = s : (k = _.next, _.next = s, s.next = k, l.lastEffect = s)), s
    }

    function Dm() {
        return Ps().memoizedState
    }

    function dd(s, l, _, k) {
        var W = Ja();
        xr.flags |= s, W.memoizedState = th(1 | l, _, void 0, k === void 0 ? null : k)
    }

    function fd(s, l, _, k) {
        var W = Ps();
        k = k === void 0 ? null : k;
        var ie = void 0;
        if (vs !== null) {
            var be = vs.memoizedState;
            if (ie = be.destroy, k !== null && ud(k, be.deps)) {
                W.memoizedState = th(l, _, ie, k);
                return
            }
        }
        xr.flags |= s, W.memoizedState = th(1 | l, _, ie, k)
    }

    function Pm(s, l) {
        return dd(8390656, 8, s, l)
    }

    function Hf(s, l) {
        return fd(2048, 8, s, l)
    }

    function Om(s, l) {
        return fd(4, 2, s, l)
    }

    function km(s, l) {
        return fd(4, 4, s, l)
    }

    function Fm(s, l) {
        if (typeof l == "function") return s = s(), l(s), function () {
            l(null)
        };
        if (l != null) return s = s(), l.current = s, function () {
            l.current = null
        }
    }

    function Nm(s, l, _) {
        return _ = _ != null ? _.concat([s]) : null, fd(4, 4, Fm.bind(null, l, s), _)
    }

    function Qf() {
    }

    function Um(s, l) {
        var _ = Ps();
        l = l === void 0 ? null : l;
        var k = _.memoizedState;
        return k !== null && l !== null && ud(l, k[1]) ? k[0] : (_.memoizedState = [s, l], s)
    }

    function zm(s, l) {
        var _ = Ps();
        l = l === void 0 ? null : l;
        var k = _.memoizedState;
        return k !== null && l !== null && ud(l, k[1]) ? k[0] : (s = s(), _.memoizedState = [s, l], s)
    }

    function Gm(s, l, _) {
        return Xa & 21 ? (ai(_, l) || (_ = Ae(), xr.lanes |= _, lu |= _, s.baseState = !0), l) : (s.baseState && (s.baseState = !1, Fo = !0), s.memoizedState = _)
    }

    function G0(s, l) {
        var _ = wt;
        wt = _ !== 0 && 4 > _ ? _ : 4, s(!0);
        var k = ta.transition;
        ta.transition = {};
        try {
            s(!1), l()
        } finally {
            wt = _, ta.transition = k
        }
    }

    function Vm() {
        return Ps().memoizedState
    }

    function V0(s, l, _) {
        var k = bc(s);
        if (_ = {
            lane: k,
            action: _,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, Hm(s)) Qm(l, _); else if (_ = Uf(s, l, _, k), _ !== null) {
            var W = No();
            $a(_, s, k, W), jm(_, l, k)
        }
    }

    function H0(s, l, _) {
        var k = bc(s), W = {lane: k, action: _, hasEagerState: !1, eagerState: null, next: null};
        if (Hm(s)) Qm(l, W); else {
            var ie = s.alternate;
            if (s.lanes === 0 && (ie === null || ie.lanes === 0) && (ie = l.lastRenderedReducer, ie !== null)) try {
                var be = l.lastRenderedState, Xe = ie(be, _);
                if (W.hasEagerState = !0, W.eagerState = Xe, ai(Xe, be)) {
                    var nt = l.interleaved;
                    nt === null ? (W.next = W, nu(l)) : (W.next = nt.next, nt.next = W), l.interleaved = W;
                    return
                }
            } catch {
            } finally {
            }
            _ = Uf(s, l, W, k), _ !== null && (W = No(), $a(_, s, k, W), jm(_, l, k))
        }
    }

    function Hm(s) {
        var l = s.alternate;
        return s === xr || l !== null && l === xr
    }

    function Qm(s, l) {
        Ya = ns = !0;
        var _ = s.pending;
        _ === null ? l.next = l : (l.next = _.next, _.next = l), s.pending = l
    }

    function jm(s, l, _) {
        if (_ & 4194240) {
            var k = l.lanes;
            k &= s.pendingLanes, _ |= k, l.lanes = _, at(s, _)
        }
    }

    var pd = {
        readContext: Jo,
        useCallback: ys,
        useContext: ys,
        useEffect: ys,
        useImperativeHandle: ys,
        useInsertionEffect: ys,
        useLayoutEffect: ys,
        useMemo: ys,
        useReducer: ys,
        useRef: ys,
        useState: ys,
        useDebugValue: ys,
        useDeferredValue: ys,
        useTransition: ys,
        useMutableSource: ys,
        useSyncExternalStore: ys,
        useId: ys,
        unstable_isNewReconciler: !1
    }, Q0 = {
        readContext: Jo, useCallback: function (s, l) {
            return Ja().memoizedState = [s, l === void 0 ? null : l], s
        }, useContext: Jo, useEffect: Pm, useImperativeHandle: function (s, l, _) {
            return _ = _ != null ? _.concat([s]) : null, dd(4194308, 4, Fm.bind(null, l, s), _)
        }, useLayoutEffect: function (s, l) {
            return dd(4194308, 4, s, l)
        }, useInsertionEffect: function (s, l) {
            return dd(4, 2, s, l)
        }, useMemo: function (s, l) {
            var _ = Ja();
            return l = l === void 0 ? null : l, s = s(), _.memoizedState = [s, l], s
        }, useReducer: function (s, l, _) {
            var k = Ja();
            return l = _ !== void 0 ? _(l) : l, k.memoizedState = k.baseState = l, s = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: s,
                lastRenderedState: l
            }, k.queue = s, s = s.dispatch = V0.bind(null, xr, s), [k.memoizedState, s]
        }, useRef: function (s) {
            var l = Ja();
            return s = {current: s}, l.memoizedState = s
        }, useState: Lm, useDebugValue: Qf, useDeferredValue: function (s) {
            return Ja().memoizedState = s
        }, useTransition: function () {
            var s = Lm(!1), l = s[0];
            return s = G0.bind(null, s[1]), Ja().memoizedState = s, [l, s]
        }, useMutableSource: function () {
        }, useSyncExternalStore: function (s, l, _) {
            var k = xr, W = Ja();
            if (gr) {
                if (_ === void 0) throw Error(i(407));
                _ = _()
            } else {
                if (_ = l(), ro === null) throw Error(i(349));
                Xa & 30 || xc(k, l, _)
            }
            W.memoizedState = _;
            var ie = {value: _, getSnapshot: l};
            return W.queue = ie, Pm(Im.bind(null, k, ie, s), [s]), k.flags |= 2048, th(9, Tm.bind(null, k, ie, _, l), void 0, null), _
        }, useId: function () {
            var s = Ja(), l = ro.identifierPrefix;
            if (gr) {
                var _ = po, k = Wa;
                _ = (k & ~(1 << 32 - li(k) - 1)).toString(32) + _, l = ":" + l + "R" + _, _ = qa++, 0 < _ && (l += "H" + _.toString(32)), l += ":"
            } else _ = Mm++, l = ":" + l + "r" + _.toString(32) + ":";
            return s.memoizedState = l
        }, unstable_isNewReconciler: !1
    }, j0 = {
        readContext: Jo,
        useCallback: Um,
        useContext: Jo,
        useEffect: Hf,
        useImperativeHandle: Nm,
        useInsertionEffect: Om,
        useLayoutEffect: km,
        useMemo: zm,
        useReducer: su,
        useRef: Dm,
        useState: function () {
            return su(Ta)
        },
        useDebugValue: Qf,
        useDeferredValue: function (s) {
            var l = Ps();
            return Gm(l, vs.memoizedState, s)
        },
        useTransition: function () {
            var s = su(Ta)[0], l = Ps().memoizedState;
            return [s, l]
        },
        useMutableSource: hd,
        useSyncExternalStore: Sm,
        useId: Vm,
        unstable_isNewReconciler: !1
    }, W0 = {
        readContext: Jo,
        useCallback: Um,
        useContext: Jo,
        useEffect: Hf,
        useImperativeHandle: Nm,
        useInsertionEffect: Om,
        useLayoutEffect: km,
        useMemo: zm,
        useReducer: Ec,
        useRef: Dm,
        useState: function () {
            return Ec(Ta)
        },
        useDebugValue: Qf,
        useDeferredValue: function (s) {
            var l = Ps();
            return vs === null ? l.memoizedState = s : Gm(l, vs.memoizedState, s)
        },
        useTransition: function () {
            var s = Ec(Ta)[0], l = Ps().memoizedState;
            return [s, l]
        },
        useMutableSource: hd,
        useSyncExternalStore: Sm,
        useId: Vm,
        unstable_isNewReconciler: !1
    };

    function Ia(s, l) {
        if (s && s.defaultProps) {
            l = ae({}, l), s = s.defaultProps;
            for (var _ in s) l[_] === void 0 && (l[_] = s[_]);
            return l
        }
        return l
    }

    function jf(s, l, _, k) {
        l = s.memoizedState, _ = _(k, l), _ = _ == null ? l : ae({}, l, _), s.memoizedState = _, s.lanes === 0 && (s.updateQueue.baseState = _)
    }

    var md = {
        isMounted: function (s) {
            return (s = s._reactInternals) ? Hi(s) === s : !1
        }, enqueueSetState: function (s, l, _) {
            s = s._reactInternals;
            var k = No(), W = bc(s), ie = pa(k, W);
            ie.payload = l, _ != null && (ie.callback = _), l = Sa(s, ie, W), l !== null && ($a(l, s, W, k), gc(l, s, W))
        }, enqueueReplaceState: function (s, l, _) {
            s = s._reactInternals;
            var k = No(), W = bc(s), ie = pa(k, W);
            ie.tag = 1, ie.payload = l, _ != null && (ie.callback = _), l = Sa(s, ie, W), l !== null && ($a(l, s, W, k), gc(l, s, W))
        }, enqueueForceUpdate: function (s, l) {
            s = s._reactInternals;
            var _ = No(), k = bc(s), W = pa(_, k);
            W.tag = 2, l != null && (W.callback = l), l = Sa(s, W, k), l !== null && ($a(l, s, k, _), gc(l, s, k))
        }
    };

    function Wm(s, l, _, k, W, ie, be) {
        return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(k, ie, be) : l.prototype && l.prototype.isPureReactComponent ? !al(_, k) || !al(W, ie) : !0
    }

    function Km(s, l, _) {
        var k = !1, W = ho, ie = l.contextType;
        return typeof ie == "object" && ie !== null ? ie = Jo(ie) : (W = _o(l) ? dc : Rs.current, k = l.contextTypes, ie = (k = k != null) ? Jc(s, W) : ho), l = new l(_, ie), s.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = md, s.stateNode = l, l._reactInternals = s, k && (s = s.stateNode, s.__reactInternalMemoizedUnmaskedChildContext = W, s.__reactInternalMemoizedMaskedChildContext = ie), l
    }

    function Xm(s, l, _, k) {
        s = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(_, k), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(_, k), l.state !== s && md.enqueueReplaceState(l, l.state, null)
    }

    function Wf(s, l, _, k) {
        var W = s.stateNode;
        W.props = _, W.state = s.memoizedState, W.refs = {}, Pl(s);
        var ie = l.contextType;
        typeof ie == "object" && ie !== null ? W.context = Jo(ie) : (ie = _o(l) ? dc : Rs.current, W.context = Jc(s, ie)), W.state = s.memoizedState, ie = l.getDerivedStateFromProps, typeof ie == "function" && (jf(s, l, ie, _), W.state = s.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof W.getSnapshotBeforeUpdate == "function" || typeof W.UNSAFE_componentWillMount != "function" && typeof W.componentWillMount != "function" || (l = W.state, typeof W.componentWillMount == "function" && W.componentWillMount(), typeof W.UNSAFE_componentWillMount == "function" && W.UNSAFE_componentWillMount(), l !== W.state && md.enqueueReplaceState(W, W.state, null), Zu(s, _, W, k), W.state = s.memoizedState), typeof W.componentDidMount == "function" && (s.flags |= 4194308)
    }

    function ou(s, l) {
        try {
            var _ = "", k = l;
            do _ += Ve(k), k = k.return; while (k);
            var W = _
        } catch (ie) {
            W = `
Error generating stack: ` + ie.message + `
` + ie.stack
        }
        return {value: s, source: l, stack: W, digest: null}
    }

    function Kf(s, l, _) {
        return {value: s, source: null, stack: _ ?? null, digest: l ?? null}
    }

    function Xf(s, l) {
        try {
            console.error(l.value)
        } catch (_) {
            setTimeout(function () {
                throw _
            })
        }
    }

    var K0 = typeof WeakMap == "function" ? WeakMap : Map;

    function Ym(s, l, _) {
        _ = pa(-1, _), _.tag = 3, _.payload = {element: null};
        var k = l.value;
        return _.callback = function () {
            lp || (lp = !0, SA = k), Xf(s, l)
        }, _
    }

    function qm(s, l, _) {
        _ = pa(-1, _), _.tag = 3;
        var k = s.type.getDerivedStateFromError;
        if (typeof k == "function") {
            var W = l.value;
            _.payload = function () {
                return k(W)
            }, _.callback = function () {
                Xf(s, l)
            }
        }
        var ie = s.stateNode;
        return ie !== null && typeof ie.componentDidCatch == "function" && (_.callback = function () {
            Xf(s, l), typeof k != "function" && (Cc === null ? Cc = new Set([this]) : Cc.add(this));
            var be = l.stack;
            this.componentDidCatch(l.value, {componentStack: be !== null ? be : ""})
        }), _
    }

    function Jm(s, l, _) {
        var k = s.pingCache;
        if (k === null) {
            k = s.pingCache = new K0;
            var W = new Set;
            k.set(l, W)
        } else W = k.get(l), W === void 0 && (W = new Set, k.set(l, W));
        W.has(_) || (W.add(_), s = BA.bind(null, s, l, _), l.then(s, s))
    }

    function Zm(s) {
        do {
            var l;
            if ((l = s.tag === 13) && (l = s.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l) return s;
            s = s.return
        } while (s !== null);
        return null
    }

    function $m(s, l, _, k, W) {
        return s.mode & 1 ? (s.flags |= 65536, s.lanes = W, s) : (s === l ? s.flags |= 65536 : (s.flags |= 128, _.flags |= 131072, _.flags &= -52805, _.tag === 1 && (_.alternate === null ? _.tag = 17 : (l = pa(-1, 1), l.tag = 2, Sa(_, l, 1))), _.lanes |= 1), s)
    }

    var X0 = I.ReactCurrentOwner, Fo = !1;

    function Io(s, l, _, k) {
        l.child = s === null ? Xn(l, null, _, k) : tu(l, s.child, _, k)
    }

    function eA(s, l, _, k, W) {
        _ = _.render;
        var ie = l.ref;
        return Ti(l, W), k = eh(s, l, _, k, ie, W), _ = Vf(), s !== null && !Fo ? (l.updateQueue = s.updateQueue, l.flags &= -2053, s.lanes &= ~W, dl(s, l, W)) : (gr && _ && Bn(l), l.flags |= 1, Io(s, l, k, W), l.child)
    }

    function tA(s, l, _, k, W) {
        if (s === null) {
            var ie = _.type;
            return typeof ie == "function" && !ch(ie) && ie.defaultProps === void 0 && _.compare === null && _.defaultProps === void 0 ? (l.tag = 15, l.type = ie, nA(s, l, ie, k, W)) : (s = _d(_.type, null, k, l, l.mode, W), s.ref = l.ref, s.return = l, l.child = s)
        }
        if (ie = s.child, !(s.lanes & W)) {
            var be = ie.memoizedProps;
            if (_ = _.compare, _ = _ !== null ? _ : al, _(be, k) && s.ref === l.ref) return dl(s, l, W)
        }
        return l.flags |= 1, s = Vl(ie, k), s.ref = l.ref, s.return = l, l.child = s
    }

    function nA(s, l, _, k, W) {
        if (s !== null) {
            var ie = s.memoizedProps;
            if (al(ie, k) && s.ref === l.ref) if (Fo = !1, l.pendingProps = k = ie, (s.lanes & W) !== 0) s.flags & 131072 && (Fo = !0); else return l.lanes = s.lanes, dl(s, l, W)
        }
        return Yf(s, l, _, k, W)
    }

    function iA(s, l, _) {
        var k = l.pendingProps, W = k.children, ie = s !== null ? s.memoizedState : null;
        if (k.mode === "hidden") if (!(l.mode & 1)) l.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, Ar(rh, Aa), Aa |= _; else {
            if (!(_ & 1073741824)) return s = ie !== null ? ie.baseLanes | _ : _, l.lanes = l.childLanes = 1073741824, l.memoizedState = {
                baseLanes: s,
                cachePool: null,
                transitions: null
            }, l.updateQueue = null, Ar(rh, Aa), Aa |= s, null;
            l.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, k = ie !== null ? ie.baseLanes : _, Ar(rh, Aa), Aa |= k
        } else ie !== null ? (k = ie.baseLanes | _, l.memoizedState = null) : k = _, Ar(rh, Aa), Aa |= k;
        return Io(s, l, W, _), l.child
    }

    function rA(s, l) {
        var _ = l.ref;
        (s === null && _ !== null || s !== null && s.ref !== _) && (l.flags |= 512, l.flags |= 2097152)
    }

    function Yf(s, l, _, k, W) {
        var ie = _o(_) ? dc : Rs.current;
        return ie = Jc(l, ie), Ti(l, W), _ = eh(s, l, _, k, ie, W), k = Vf(), s !== null && !Fo ? (l.updateQueue = s.updateQueue, l.flags &= -2053, s.lanes &= ~W, dl(s, l, W)) : (gr && k && Bn(l), l.flags |= 1, Io(s, l, _, W), l.child)
    }

    function sA(s, l, _, k, W) {
        if (_o(_)) {
            var ie = !0;
            id(l)
        } else ie = !1;
        if (Ti(l, W), l.stateNode === null) gd(s, l), Km(l, _, k), Wf(l, _, k, W), k = !0; else if (s === null) {
            var be = l.stateNode, Xe = l.memoizedProps;
            be.props = Xe;
            var nt = be.context, Et = _.contextType;
            typeof Et == "object" && Et !== null ? Et = Jo(Et) : (Et = _o(_) ? dc : Rs.current, Et = Jc(l, Et));
            var Zt = _.getDerivedStateFromProps,
                rn = typeof Zt == "function" || typeof be.getSnapshotBeforeUpdate == "function";
            rn || typeof be.UNSAFE_componentWillReceiveProps != "function" && typeof be.componentWillReceiveProps != "function" || (Xe !== k || nt !== Et) && Xm(l, be, k, Et), $o = !1;
            var qt = l.memoizedState;
            be.state = qt, Zu(l, k, be, W), nt = l.memoizedState, Xe !== k || qt !== nt || js.current || $o ? (typeof Zt == "function" && (jf(l, _, Zt, k), nt = l.memoizedState), (Xe = $o || Wm(l, _, Xe, k, qt, nt, Et)) ? (rn || typeof be.UNSAFE_componentWillMount != "function" && typeof be.componentWillMount != "function" || (typeof be.componentWillMount == "function" && be.componentWillMount(), typeof be.UNSAFE_componentWillMount == "function" && be.UNSAFE_componentWillMount()), typeof be.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof be.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = k, l.memoizedState = nt), be.props = k, be.state = nt, be.context = Et, k = Xe) : (typeof be.componentDidMount == "function" && (l.flags |= 4194308), k = !1)
        } else {
            be = l.stateNode, ad(s, l), Xe = l.memoizedProps, Et = l.type === l.elementType ? Xe : Ia(l.type, Xe), be.props = Et, rn = l.pendingProps, qt = be.context, nt = _.contextType, typeof nt == "object" && nt !== null ? nt = Jo(nt) : (nt = _o(_) ? dc : Rs.current, nt = Jc(l, nt));
            var Ln = _.getDerivedStateFromProps;
            (Zt = typeof Ln == "function" || typeof be.getSnapshotBeforeUpdate == "function") || typeof be.UNSAFE_componentWillReceiveProps != "function" && typeof be.componentWillReceiveProps != "function" || (Xe !== rn || qt !== nt) && Xm(l, be, k, nt), $o = !1, qt = l.memoizedState, be.state = qt, Zu(l, k, be, W);
            var Qn = l.memoizedState;
            Xe !== rn || qt !== Qn || js.current || $o ? (typeof Ln == "function" && (jf(l, _, Ln, k), Qn = l.memoizedState), (Et = $o || Wm(l, _, Et, k, qt, Qn, nt) || !1) ? (Zt || typeof be.UNSAFE_componentWillUpdate != "function" && typeof be.componentWillUpdate != "function" || (typeof be.componentWillUpdate == "function" && be.componentWillUpdate(k, Qn, nt), typeof be.UNSAFE_componentWillUpdate == "function" && be.UNSAFE_componentWillUpdate(k, Qn, nt)), typeof be.componentDidUpdate == "function" && (l.flags |= 4), typeof be.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof be.componentDidUpdate != "function" || Xe === s.memoizedProps && qt === s.memoizedState || (l.flags |= 4), typeof be.getSnapshotBeforeUpdate != "function" || Xe === s.memoizedProps && qt === s.memoizedState || (l.flags |= 1024), l.memoizedProps = k, l.memoizedState = Qn), be.props = k, be.state = Qn, be.context = nt, k = Et) : (typeof be.componentDidUpdate != "function" || Xe === s.memoizedProps && qt === s.memoizedState || (l.flags |= 4), typeof be.getSnapshotBeforeUpdate != "function" || Xe === s.memoizedProps && qt === s.memoizedState || (l.flags |= 1024), k = !1)
        }
        return qf(s, l, _, k, ie, W)
    }

    function qf(s, l, _, k, W, ie) {
        rA(s, l);
        var be = (l.flags & 128) !== 0;
        if (!k && !be) return W && fc(l, _, !1), dl(s, l, ie);
        k = l.stateNode, X0.current = l;
        var Xe = be && typeof _.getDerivedStateFromError != "function" ? null : k.render();
        return l.flags |= 1, s !== null && be ? (l.child = tu(l, s.child, null, ie), l.child = tu(l, null, Xe, ie)) : Io(s, l, Xe, ie), l.memoizedState = k.state, W && fc(l, _, !0), l.child
    }

    function oA(s) {
        var l = s.stateNode;
        l.pendingContext ? Pf(s, l.pendingContext, l.pendingContext !== l.context) : l.context && Pf(s, l.context, !1), ru(s, l.containerInfo)
    }

    function aA(s, l, _, k, W) {
        return $c(), Nf(W), l.flags |= 256, Io(s, l, _, k), l.child
    }

    var Jf = {dehydrated: null, treeContext: null, retryLane: 0};

    function Zf(s) {
        return {baseLanes: s, cachePool: null, transitions: null}
    }

    function lA(s, l, _) {
        var k = l.pendingProps, W = Jr.current, ie = !1, be = (l.flags & 128) !== 0, Xe;
        if ((Xe = be) || (Xe = s !== null && s.memoizedState === null ? !1 : (W & 2) !== 0), Xe ? (ie = !0, l.flags &= -129) : (s === null || s.memoizedState !== null) && (W |= 1), Ar(Jr, W & 1), s === null) return Ff(l), s = l.memoizedState, s !== null && (s = s.dehydrated, s !== null) ? (l.mode & 1 ? s.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (be = k.children, s = k.fallback, ie ? (k = l.mode, ie = l.child, be = {
            mode: "hidden",
            children: be
        }, !(k & 1) && ie !== null ? (ie.childLanes = 0, ie.pendingProps = be) : ie = Md(be, k, 0, null), s = Ic(s, k, _, null), ie.return = l, s.return = l, ie.sibling = s, l.child = ie, l.child.memoizedState = Zf(_), l.memoizedState = Jf, s) : $f(l, be));
        if (W = s.memoizedState, W !== null && (Xe = W.dehydrated, Xe !== null)) return Y0(s, l, be, k, Xe, W, _);
        if (ie) {
            ie = k.fallback, be = l.mode, W = s.child, Xe = W.sibling;
            var nt = {mode: "hidden", children: k.children};
            return !(be & 1) && l.child !== W ? (k = l.child, k.childLanes = 0, k.pendingProps = nt, l.deletions = null) : (k = Vl(W, nt), k.subtreeFlags = W.subtreeFlags & 14680064), Xe !== null ? ie = Vl(Xe, ie) : (ie = Ic(ie, be, _, null), ie.flags |= 2), ie.return = l, k.return = l, k.sibling = ie, l.child = k, k = ie, ie = l.child, be = s.child.memoizedState, be = be === null ? Zf(_) : {
                baseLanes: be.baseLanes | _,
                cachePool: null,
                transitions: be.transitions
            }, ie.memoizedState = be, ie.childLanes = s.childLanes & ~_, l.memoizedState = Jf, k
        }
        return ie = s.child, s = ie.sibling, k = Vl(ie, {
            mode: "visible",
            children: k.children
        }), !(l.mode & 1) && (k.lanes = _), k.return = l, k.sibling = null, s !== null && (_ = l.deletions, _ === null ? (l.deletions = [s], l.flags |= 16) : _.push(s)), l.child = k, l.memoizedState = null, k
    }

    function $f(s, l) {
        return l = Md({mode: "visible", children: l}, s.mode, 0, null), l.return = s, s.child = l
    }

    function Ad(s, l, _, k) {
        return k !== null && Nf(k), tu(l, s.child, null, _), s = $f(l, l.pendingProps.children), s.flags |= 2, l.memoizedState = null, s
    }

    function Y0(s, l, _, k, W, ie, be) {
        if (_) return l.flags & 256 ? (l.flags &= -257, k = Kf(Error(i(422))), Ad(s, l, be, k)) : l.memoizedState !== null ? (l.child = s.child, l.flags |= 128, null) : (ie = k.fallback, W = l.mode, k = Md({
            mode: "visible",
            children: k.children
        }, W, 0, null), ie = Ic(ie, W, be, null), ie.flags |= 2, k.return = l, ie.return = l, k.sibling = ie, l.child = k, l.mode & 1 && tu(l, s.child, null, be), l.child.memoizedState = Zf(be), l.memoizedState = Jf, ie);
        if (!(l.mode & 1)) return Ad(s, l, be, null);
        if (W.data === "$!") {
            if (k = W.nextSibling && W.nextSibling.dataset, k) var Xe = k.dgst;
            return k = Xe, ie = Error(i(419)), k = Kf(ie, k, void 0), Ad(s, l, be, k)
        }
        if (Xe = (be & s.childLanes) !== 0, Fo || Xe) {
            if (k = ro, k !== null) {
                switch (be & -be) {
                    case 4:
                        W = 2;
                        break;
                    case 16:
                        W = 8;
                        break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        W = 32;
                        break;
                    case 536870912:
                        W = 268435456;
                        break;
                    default:
                        W = 0
                }
                W = W & (k.suspendedLanes | be) ? 0 : W, W !== 0 && W !== ie.retryLane && (ie.retryLane = W, ko(s, W), $a(k, s, W, -1))
            }
            return Ul(), k = Kf(Error(i(421))), Ad(s, l, be, k)
        }
        return W.data === "$?" ? (l.flags |= 128, l.child = s.child, l = iv.bind(null, s), W._reactRetry = l, null) : (s = ie.treeContext, Dr = Ko(W.nextSibling), qo = l, gr = !0, Ls = null, s !== null && (Po[Oo++] = Wa, Po[Oo++] = po, Po[Oo++] = Bs, Wa = s.id, po = s.overflow, Bs = l), l = $f(l, k.children), l.flags |= 4096, l)
    }

    function cA(s, l, _) {
        s.lanes |= l;
        var k = s.alternate;
        k !== null && (k.lanes |= l), gs(s.return, l, _)
    }

    function ep(s, l, _, k, W) {
        var ie = s.memoizedState;
        ie === null ? s.memoizedState = {
            isBackwards: l,
            rendering: null,
            renderingStartTime: 0,
            last: k,
            tail: _,
            tailMode: W
        } : (ie.isBackwards = l, ie.rendering = null, ie.renderingStartTime = 0, ie.last = k, ie.tail = _, ie.tailMode = W)
    }

    function uA(s, l, _) {
        var k = l.pendingProps, W = k.revealOrder, ie = k.tail;
        if (Io(s, l, k.children, _), k = Jr.current, k & 2) k = k & 1 | 2, l.flags |= 128; else {
            if (s !== null && s.flags & 128) e:for (s = l.child; s !== null;) {
                if (s.tag === 13) s.memoizedState !== null && cA(s, _, l); else if (s.tag === 19) cA(s, _, l); else if (s.child !== null) {
                    s.child.return = s, s = s.child;
                    continue
                }
                if (s === l) break e;
                for (; s.sibling === null;) {
                    if (s.return === null || s.return === l) break e;
                    s = s.return
                }
                s.sibling.return = s.return, s = s.sibling
            }
            k &= 1
        }
        if (Ar(Jr, k), !(l.mode & 1)) l.memoizedState = null; else switch (W) {
            case"forwards":
                for (_ = l.child, W = null; _ !== null;) s = _.alternate, s !== null && $u(s) === null && (W = _), _ = _.sibling;
                _ = W, _ === null ? (W = l.child, l.child = null) : (W = _.sibling, _.sibling = null), ep(l, !1, W, _, ie);
                break;
            case"backwards":
                for (_ = null, W = l.child, l.child = null; W !== null;) {
                    if (s = W.alternate, s !== null && $u(s) === null) {
                        l.child = W;
                        break
                    }
                    s = W.sibling, W.sibling = _, _ = W, W = s
                }
                ep(l, !0, _, null, ie);
                break;
            case"together":
                ep(l, !1, null, null, void 0);
                break;
            default:
                l.memoizedState = null
        }
        return l.child
    }

    function gd(s, l) {
        !(l.mode & 1) && s !== null && (s.alternate = null, l.alternate = null, l.flags |= 2)
    }

    function dl(s, l, _) {
        if (s !== null && (l.dependencies = s.dependencies), lu |= l.lanes, !(_ & l.childLanes)) return null;
        if (s !== null && l.child !== s.child) throw Error(i(153));
        if (l.child !== null) {
            for (s = l.child, _ = Vl(s, s.pendingProps), l.child = _, _.return = l; s.sibling !== null;) s = s.sibling, _ = _.sibling = Vl(s, s.pendingProps), _.return = l;
            _.sibling = null
        }
        return l.child
    }

    function q0(s, l, _) {
        switch (l.tag) {
            case 3:
                oA(l), $c();
                break;
            case 5:
                yc(l);
                break;
            case 1:
                _o(l.type) && id(l);
                break;
            case 4:
                ru(l, l.stateNode.containerInfo);
                break;
            case 10:
                var k = l.type._context, W = l.memoizedProps.value;
                Ar(od, k._currentValue), k._currentValue = W;
                break;
            case 13:
                if (k = l.memoizedState, k !== null) return k.dehydrated !== null ? (Ar(Jr, Jr.current & 1), l.flags |= 128, null) : _ & l.child.childLanes ? lA(s, l, _) : (Ar(Jr, Jr.current & 1), s = dl(s, l, _), s !== null ? s.sibling : null);
                Ar(Jr, Jr.current & 1);
                break;
            case 19:
                if (k = (_ & l.childLanes) !== 0, s.flags & 128) {
                    if (k) return uA(s, l, _);
                    l.flags |= 128
                }
                if (W = l.memoizedState, W !== null && (W.rendering = null, W.tail = null, W.lastEffect = null), Ar(Jr, Jr.current), k) break;
                return null;
            case 22:
            case 23:
                return l.lanes = 0, iA(s, l, _)
        }
        return dl(s, l, _)
    }

    var hA, tp, dA, fA;
    hA = function (s, l) {
        for (var _ = l.child; _ !== null;) {
            if (_.tag === 5 || _.tag === 6) s.appendChild(_.stateNode); else if (_.tag !== 4 && _.child !== null) {
                _.child.return = _, _ = _.child;
                continue
            }
            if (_ === l) break;
            for (; _.sibling === null;) {
                if (_.return === null || _.return === l) return;
                _ = _.return
            }
            _.sibling.return = _.return, _ = _.sibling
        }
    }, tp = function () {
    }, dA = function (s, l, _, k) {
        var W = s.memoizedProps;
        if (W !== k) {
            s = l.stateNode, vc(ea.current);
            var ie = null;
            switch (_) {
                case"input":
                    W = oi(s, W), k = oi(s, k), ie = [];
                    break;
                case"select":
                    W = ae({}, W, {value: void 0}), k = ae({}, k, {value: void 0}), ie = [];
                    break;
                case"textarea":
                    W = Ji(s, W), k = Ji(s, k), ie = [];
                    break;
                default:
                    typeof W.onClick != "function" && typeof k.onClick == "function" && (s.onclick = Qs)
            }
            oe(_, k);
            var be;
            _ = null;
            for (Et in W) if (!k.hasOwnProperty(Et) && W.hasOwnProperty(Et) && W[Et] != null) if (Et === "style") {
                var Xe = W[Et];
                for (be in Xe) Xe.hasOwnProperty(be) && (_ || (_ = {}), _[be] = "")
            } else Et !== "dangerouslySetInnerHTML" && Et !== "children" && Et !== "suppressContentEditableWarning" && Et !== "suppressHydrationWarning" && Et !== "autoFocus" && (c.hasOwnProperty(Et) ? ie || (ie = []) : (ie = ie || []).push(Et, null));
            for (Et in k) {
                var nt = k[Et];
                if (Xe = W != null ? W[Et] : void 0, k.hasOwnProperty(Et) && nt !== Xe && (nt != null || Xe != null)) if (Et === "style") if (Xe) {
                    for (be in Xe) !Xe.hasOwnProperty(be) || nt && nt.hasOwnProperty(be) || (_ || (_ = {}), _[be] = "");
                    for (be in nt) nt.hasOwnProperty(be) && Xe[be] !== nt[be] && (_ || (_ = {}), _[be] = nt[be])
                } else _ || (ie || (ie = []), ie.push(Et, _)), _ = nt; else Et === "dangerouslySetInnerHTML" ? (nt = nt ? nt.__html : void 0, Xe = Xe ? Xe.__html : void 0, nt != null && Xe !== nt && (ie = ie || []).push(Et, nt)) : Et === "children" ? typeof nt != "string" && typeof nt != "number" || (ie = ie || []).push(Et, "" + nt) : Et !== "suppressContentEditableWarning" && Et !== "suppressHydrationWarning" && (c.hasOwnProperty(Et) ? (nt != null && Et === "onScroll" && Ei("scroll", s), ie || Xe === nt || (ie = [])) : (ie = ie || []).push(Et, nt))
            }
            _ && (ie = ie || []).push("style", _);
            var Et = ie;
            (l.updateQueue = Et) && (l.flags |= 4)
        }
    }, fA = function (s, l, _, k) {
        _ !== k && (l.flags |= 4)
    };

    function nh(s, l) {
        if (!gr) switch (s.tailMode) {
            case"hidden":
                l = s.tail;
                for (var _ = null; l !== null;) l.alternate !== null && (_ = l), l = l.sibling;
                _ === null ? s.tail = null : _.sibling = null;
                break;
            case"collapsed":
                _ = s.tail;
                for (var k = null; _ !== null;) _.alternate !== null && (k = _), _ = _.sibling;
                k === null ? l || s.tail === null ? s.tail = null : s.tail.sibling = null : k.sibling = null
        }
    }

    function mo(s) {
        var l = s.alternate !== null && s.alternate.child === s.child, _ = 0, k = 0;
        if (l) for (var W = s.child; W !== null;) _ |= W.lanes | W.childLanes, k |= W.subtreeFlags & 14680064, k |= W.flags & 14680064, W.return = s, W = W.sibling; else for (W = s.child; W !== null;) _ |= W.lanes | W.childLanes, k |= W.subtreeFlags, k |= W.flags, W.return = s, W = W.sibling;
        return s.subtreeFlags |= k, s.childLanes = _, l
    }

    function J0(s, l, _) {
        var k = l.pendingProps;
        switch (Ws(l), l.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return mo(l), null;
            case 1:
                return _o(l.type) && Xu(), mo(l), null;
            case 3:
                return k = l.stateNode, ma(), Gr(js), Gr(Rs), Gf(), k.pendingContext && (k.context = k.pendingContext, k.pendingContext = null), (s === null || s.child === null) && (mc(l) ? l.flags |= 4 : s === null || s.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, Ls !== null && (cu(Ls), Ls = null))), tp(s, l), mo(l), null;
            case 5:
                no(l);
                var W = vc(Wr.current);
                if (_ = l.type, s !== null && l.stateNode != null) dA(s, l, _, k, W), s.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152); else {
                    if (!k) {
                        if (l.stateNode === null) throw Error(i(166));
                        return mo(l), null
                    }
                    if (s = vc(ea.current), mc(l)) {
                        k = l.stateNode, _ = l.type;
                        var ie = l.memoizedProps;
                        switch (k[Mn] = l, k[Xo] = ie, s = (l.mode & 1) !== 0, _) {
                            case"dialog":
                                Ei("cancel", k), Ei("close", k);
                                break;
                            case"iframe":
                            case"object":
                            case"embed":
                                Ei("load", k);
                                break;
                            case"video":
                            case"audio":
                                for (W = 0; W < $i.length; W++) Ei($i[W], k);
                                break;
                            case"source":
                                Ei("error", k);
                                break;
                            case"img":
                            case"image":
                            case"link":
                                Ei("error", k), Ei("load", k);
                                break;
                            case"details":
                                Ei("toggle", k);
                                break;
                            case"input":
                                pi(k, ie), Ei("invalid", k);
                                break;
                            case"select":
                                k._wrapperState = {wasMultiple: !!ie.multiple}, Ei("invalid", k);
                                break;
                            case"textarea":
                                Pi(k, ie), Ei("invalid", k)
                        }
                        oe(_, ie), W = null;
                        for (var be in ie) if (ie.hasOwnProperty(be)) {
                            var Xe = ie[be];
                            be === "children" ? typeof Xe == "string" ? k.textContent !== Xe && (ie.suppressHydrationWarning !== !0 && Ki(k.textContent, Xe, s), W = ["children", Xe]) : typeof Xe == "number" && k.textContent !== "" + Xe && (ie.suppressHydrationWarning !== !0 && Ki(k.textContent, Xe, s), W = ["children", "" + Xe]) : c.hasOwnProperty(be) && Xe != null && be === "onScroll" && Ei("scroll", k)
                        }
                        switch (_) {
                            case"input":
                                an(k), yi(k, ie, !0);
                                break;
                            case"textarea":
                                an(k), cr(k);
                                break;
                            case"select":
                            case"option":
                                break;
                            default:
                                typeof ie.onClick == "function" && (k.onclick = Qs)
                        }
                        k = W, l.updateQueue = k, k !== null && (l.flags |= 4)
                    } else {
                        be = W.nodeType === 9 ? W : W.ownerDocument, s === "http://www.w3.org/1999/xhtml" && (s = ss(_)), s === "http://www.w3.org/1999/xhtml" ? _ === "script" ? (s = be.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild)) : typeof k.is == "string" ? s = be.createElement(_, {is: k.is}) : (s = be.createElement(_), _ === "select" && (be = s, k.multiple ? be.multiple = !0 : k.size && (be.size = k.size))) : s = be.createElementNS(s, _), s[Mn] = l, s[Xo] = k, hA(s, l, !1, !1), l.stateNode = s;
                        e:{
                            switch (be = G(_, k), _) {
                                case"dialog":
                                    Ei("cancel", s), Ei("close", s), W = k;
                                    break;
                                case"iframe":
                                case"object":
                                case"embed":
                                    Ei("load", s), W = k;
                                    break;
                                case"video":
                                case"audio":
                                    for (W = 0; W < $i.length; W++) Ei($i[W], s);
                                    W = k;
                                    break;
                                case"source":
                                    Ei("error", s), W = k;
                                    break;
                                case"img":
                                case"image":
                                case"link":
                                    Ei("error", s), Ei("load", s), W = k;
                                    break;
                                case"details":
                                    Ei("toggle", s), W = k;
                                    break;
                                case"input":
                                    pi(s, k), W = oi(s, k), Ei("invalid", s);
                                    break;
                                case"option":
                                    W = k;
                                    break;
                                case"select":
                                    s._wrapperState = {wasMultiple: !!k.multiple}, W = ae({}, k, {value: void 0}), Ei("invalid", s);
                                    break;
                                case"textarea":
                                    Pi(s, k), W = Ji(s, k), Ei("invalid", s);
                                    break;
                                default:
                                    W = k
                            }
                            oe(_, W), Xe = W;
                            for (ie in Xe) if (Xe.hasOwnProperty(ie)) {
                                var nt = Xe[ie];
                                ie === "style" ? Ue(s, nt) : ie === "dangerouslySetInnerHTML" ? (nt = nt ? nt.__html : void 0, nt != null && jt(s, nt)) : ie === "children" ? typeof nt == "string" ? (_ !== "textarea" || nt !== "") && Se(s, nt) : typeof nt == "number" && Se(s, "" + nt) : ie !== "suppressContentEditableWarning" && ie !== "suppressHydrationWarning" && ie !== "autoFocus" && (c.hasOwnProperty(ie) ? nt != null && ie === "onScroll" && Ei("scroll", s) : nt != null && R(s, ie, nt, be))
                            }
                            switch (_) {
                                case"input":
                                    an(s), yi(s, k, !1);
                                    break;
                                case"textarea":
                                    an(s), cr(s);
                                    break;
                                case"option":
                                    k.value != null && s.setAttribute("value", "" + gt(k.value));
                                    break;
                                case"select":
                                    s.multiple = !!k.multiple, ie = k.value, ie != null ? Rr(s, !!k.multiple, ie, !1) : k.defaultValue != null && Rr(s, !!k.multiple, k.defaultValue, !0);
                                    break;
                                default:
                                    typeof W.onClick == "function" && (s.onclick = Qs)
                            }
                            switch (_) {
                                case"button":
                                case"input":
                                case"select":
                                case"textarea":
                                    k = !!k.autoFocus;
                                    break e;
                                case"img":
                                    k = !0;
                                    break e;
                                default:
                                    k = !1
                            }
                        }
                        k && (l.flags |= 4)
                    }
                    l.ref !== null && (l.flags |= 512, l.flags |= 2097152)
                }
                return mo(l), null;
            case 6:
                if (s && l.stateNode != null) fA(s, l, s.memoizedProps, k); else {
                    if (typeof k != "string" && l.stateNode === null) throw Error(i(166));
                    if (_ = vc(Wr.current), vc(ea.current), mc(l)) {
                        if (k = l.stateNode, _ = l.memoizedProps, k[Mn] = l, (ie = k.nodeValue !== _) && (s = qo, s !== null)) switch (s.tag) {
                            case 3:
                                Ki(k.nodeValue, _, (s.mode & 1) !== 0);
                                break;
                            case 5:
                                s.memoizedProps.suppressHydrationWarning !== !0 && Ki(k.nodeValue, _, (s.mode & 1) !== 0)
                        }
                        ie && (l.flags |= 4)
                    } else k = (_.nodeType === 9 ? _ : _.ownerDocument).createTextNode(k), k[Mn] = l, l.stateNode = k
                }
                return mo(l), null;
            case 13:
                if (Gr(Jr), k = l.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
                    if (gr && Dr !== null && l.mode & 1 && !(l.flags & 128)) Er(), $c(), l.flags |= 98560, ie = !1; else if (ie = mc(l), k !== null && k.dehydrated !== null) {
                        if (s === null) {
                            if (!ie) throw Error(i(318));
                            if (ie = l.memoizedState, ie = ie !== null ? ie.dehydrated : null, !ie) throw Error(i(317));
                            ie[Mn] = l
                        } else $c(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
                        mo(l), ie = !1
                    } else Ls !== null && (cu(Ls), Ls = null), ie = !0;
                    if (!ie) return l.flags & 65536 ? l : null
                }
                return l.flags & 128 ? (l.lanes = _, l) : (k = k !== null, k !== (s !== null && s.memoizedState !== null) && k && (l.child.flags |= 8192, l.mode & 1 && (s === null || Jr.current & 1 ? Ks === 0 && (Ks = 3) : Ul())), l.updateQueue !== null && (l.flags |= 4), mo(l), null);
            case 4:
                return ma(), tp(s, l), s === null && Do(l.stateNode.containerInfo), mo(l), null;
            case 10:
                return Ac(l.type._context), mo(l), null;
            case 17:
                return _o(l.type) && Xu(), mo(l), null;
            case 19:
                if (Gr(Jr), ie = l.memoizedState, ie === null) return mo(l), null;
                if (k = (l.flags & 128) !== 0, be = ie.rendering, be === null) if (k) nh(ie, !1); else {
                    if (Ks !== 0 || s !== null && s.flags & 128) for (s = l.child; s !== null;) {
                        if (be = $u(s), be !== null) {
                            for (l.flags |= 128, nh(ie, !1), k = be.updateQueue, k !== null && (l.updateQueue = k, l.flags |= 4), l.subtreeFlags = 0, k = _, _ = l.child; _ !== null;) ie = _, s = k, ie.flags &= 14680066, be = ie.alternate, be === null ? (ie.childLanes = 0, ie.lanes = s, ie.child = null, ie.subtreeFlags = 0, ie.memoizedProps = null, ie.memoizedState = null, ie.updateQueue = null, ie.dependencies = null, ie.stateNode = null) : (ie.childLanes = be.childLanes, ie.lanes = be.lanes, ie.child = be.child, ie.subtreeFlags = 0, ie.deletions = null, ie.memoizedProps = be.memoizedProps, ie.memoizedState = be.memoizedState, ie.updateQueue = be.updateQueue, ie.type = be.type, s = be.dependencies, ie.dependencies = s === null ? null : {
                                lanes: s.lanes,
                                firstContext: s.firstContext
                            }), _ = _.sibling;
                            return Ar(Jr, Jr.current & 1 | 2), l.child
                        }
                        s = s.sibling
                    }
                    ie.tail !== null && dt() > sh && (l.flags |= 128, k = !0, nh(ie, !1), l.lanes = 4194304)
                } else {
                    if (!k) if (s = $u(be), s !== null) {
                        if (l.flags |= 128, k = !0, _ = s.updateQueue, _ !== null && (l.updateQueue = _, l.flags |= 4), nh(ie, !0), ie.tail === null && ie.tailMode === "hidden" && !be.alternate && !gr) return mo(l), null
                    } else 2 * dt() - ie.renderingStartTime > sh && _ !== 1073741824 && (l.flags |= 128, k = !0, nh(ie, !1), l.lanes = 4194304);
                    ie.isBackwards ? (be.sibling = l.child, l.child = be) : (_ = ie.last, _ !== null ? _.sibling = be : l.child = be, ie.last = be)
                }
                return ie.tail !== null ? (l = ie.tail, ie.rendering = l, ie.tail = l.sibling, ie.renderingStartTime = dt(), l.sibling = null, _ = Jr.current, Ar(Jr, k ? _ & 1 | 2 : _ & 1), l) : (mo(l), null);
            case 22:
            case 23:
                return pp(), k = l.memoizedState !== null, s !== null && s.memoizedState !== null !== k && (l.flags |= 8192), k && l.mode & 1 ? Aa & 1073741824 && (mo(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : mo(l), null;
            case 24:
                return null;
            case 25:
                return null
        }
        throw Error(i(156, l.tag))
    }

    function Z0(s, l) {
        switch (Ws(l), l.tag) {
            case 1:
                return _o(l.type) && Xu(), s = l.flags, s & 65536 ? (l.flags = s & -65537 | 128, l) : null;
            case 3:
                return ma(), Gr(js), Gr(Rs), Gf(), s = l.flags, s & 65536 && !(s & 128) ? (l.flags = s & -65537 | 128, l) : null;
            case 5:
                return no(l), null;
            case 13:
                if (Gr(Jr), s = l.memoizedState, s !== null && s.dehydrated !== null) {
                    if (l.alternate === null) throw Error(i(340));
                    $c()
                }
                return s = l.flags, s & 65536 ? (l.flags = s & -65537 | 128, l) : null;
            case 19:
                return Gr(Jr), null;
            case 4:
                return ma(), null;
            case 10:
                return Ac(l.type._context), null;
            case 22:
            case 23:
                return pp(), null;
            case 24:
                return null;
            default:
                return null
        }
    }

    var vd = !1, Ao = !1, $0 = typeof WeakSet == "function" ? WeakSet : Set, Un = null;

    function au(s, l) {
        var _ = s.ref;
        if (_ !== null) if (typeof _ == "function") try {
            _(null)
        } catch (k) {
            Fr(s, l, k)
        } else _.current = null
    }

    function np(s, l, _) {
        try {
            _()
        } catch (k) {
            Fr(s, l, k)
        }
    }

    var pA = !1;

    function ev(s, l) {
        if (Va = _s, s = Sl(), Kc(s)) {
            if ("selectionStart" in s) var _ = {start: s.selectionStart, end: s.selectionEnd}; else e:{
                _ = (_ = s.ownerDocument) && _.defaultView || window;
                var k = _.getSelection && _.getSelection();
                if (k && k.rangeCount !== 0) {
                    _ = k.anchorNode;
                    var W = k.anchorOffset, ie = k.focusNode;
                    k = k.focusOffset;
                    try {
                        _.nodeType, ie.nodeType
                    } catch {
                        _ = null;
                        break e
                    }
                    var be = 0, Xe = -1, nt = -1, Et = 0, Zt = 0, rn = s, qt = null;
                    t:for (; ;) {
                        for (var Ln; rn !== _ || W !== 0 && rn.nodeType !== 3 || (Xe = be + W), rn !== ie || k !== 0 && rn.nodeType !== 3 || (nt = be + k), rn.nodeType === 3 && (be += rn.nodeValue.length), (Ln = rn.firstChild) !== null;) qt = rn, rn = Ln;
                        for (; ;) {
                            if (rn === s) break t;
                            if (qt === _ && ++Et === W && (Xe = be), qt === ie && ++Zt === k && (nt = be), (Ln = rn.nextSibling) !== null) break;
                            rn = qt, qt = rn.parentNode
                        }
                        rn = Ln
                    }
                    _ = Xe === -1 || nt === -1 ? null : {start: Xe, end: nt}
                } else _ = null
            }
            _ = _ || {start: 0, end: 0}
        } else _ = null;
        for (wa = {
            focusedElem: s,
            selectionRange: _
        }, _s = !1, Un = l; Un !== null;) if (l = Un, s = l.child, (l.subtreeFlags & 1028) !== 0 && s !== null) s.return = l, Un = s; else for (; Un !== null;) {
            l = Un;
            try {
                var Qn = l.alternate;
                if (l.flags & 1024) switch (l.tag) {
                    case 0:
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if (Qn !== null) {
                            var Yn = Qn.memoizedProps, us = Qn.memoizedState, vt = l.stateNode,
                                ct = vt.getSnapshotBeforeUpdate(l.elementType === l.type ? Yn : Ia(l.type, Yn), us);
                            vt.__reactInternalSnapshotBeforeUpdate = ct
                        }
                        break;
                    case 3:
                        var yt = l.stateNode.containerInfo;
                        yt.nodeType === 1 ? yt.textContent = "" : yt.nodeType === 9 && yt.documentElement && yt.removeChild(yt.documentElement);
                        break;
                    case 5:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        throw Error(i(163))
                }
            } catch (hn) {
                Fr(l, l.return, hn)
            }
            if (s = l.sibling, s !== null) {
                s.return = l.return, Un = s;
                break
            }
            Un = l.return
        }
        return Qn = pA, pA = !1, Qn
    }

    function ih(s, l, _) {
        var k = l.updateQueue;
        if (k = k !== null ? k.lastEffect : null, k !== null) {
            var W = k = k.next;
            do {
                if ((W.tag & s) === s) {
                    var ie = W.destroy;
                    W.destroy = void 0, ie !== void 0 && np(l, _, ie)
                }
                W = W.next
            } while (W !== k)
        }
    }

    function yd(s, l) {
        if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
            var _ = l = l.next;
            do {
                if ((_.tag & s) === s) {
                    var k = _.create;
                    _.destroy = k()
                }
                _ = _.next
            } while (_ !== l)
        }
    }

    function ip(s) {
        var l = s.ref;
        if (l !== null) {
            var _ = s.stateNode;
            switch (s.tag) {
                case 5:
                    s = _;
                    break;
                default:
                    s = _
            }
            typeof l == "function" ? l(s) : l.current = s
        }
    }

    function mA(s) {
        var l = s.alternate;
        l !== null && (s.alternate = null, mA(l)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (l = s.stateNode, l !== null && (delete l[Mn], delete l[Xo], delete l[Df], delete l[U0], delete l[Rl])), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null
    }

    function AA(s) {
        return s.tag === 5 || s.tag === 3 || s.tag === 4
    }

    function gA(s) {
        e:for (; ;) {
            for (; s.sibling === null;) {
                if (s.return === null || AA(s.return)) return null;
                s = s.return
            }
            for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18;) {
                if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
                s.child.return = s, s = s.child
            }
            if (!(s.flags & 2)) return s.stateNode
        }
    }

    function rp(s, l, _) {
        var k = s.tag;
        if (k === 5 || k === 6) s = s.stateNode, l ? _.nodeType === 8 ? _.parentNode.insertBefore(s, l) : _.insertBefore(s, l) : (_.nodeType === 8 ? (l = _.parentNode, l.insertBefore(s, _)) : (l = _, l.appendChild(s)), _ = _._reactRootContainer, _ != null || l.onclick !== null || (l.onclick = Qs)); else if (k !== 4 && (s = s.child, s !== null)) for (rp(s, l, _), s = s.sibling; s !== null;) rp(s, l, _), s = s.sibling
    }

    function sp(s, l, _) {
        var k = s.tag;
        if (k === 5 || k === 6) s = s.stateNode, l ? _.insertBefore(s, l) : _.appendChild(s); else if (k !== 4 && (s = s.child, s !== null)) for (sp(s, l, _), s = s.sibling; s !== null;) sp(s, l, _), s = s.sibling
    }

    var io = null, Ra = !1;

    function kl(s, l, _) {
        for (_ = _.child; _ !== null;) vA(s, l, _), _ = _.sibling
    }

    function vA(s, l, _) {
        if (Wn && typeof Wn.onCommitFiberUnmount == "function") try {
            Wn.onCommitFiberUnmount(jn, _)
        } catch {
        }
        switch (_.tag) {
            case 5:
                Ao || au(_, l);
            case 6:
                var k = io, W = Ra;
                io = null, kl(s, l, _), io = k, Ra = W, io !== null && (Ra ? (s = io, _ = _.stateNode, s.nodeType === 8 ? s.parentNode.removeChild(_) : s.removeChild(_)) : io.removeChild(_.stateNode));
                break;
            case 18:
                io !== null && (Ra ? (s = io, _ = _.stateNode, s.nodeType === 8 ? uc(s.parentNode, _) : s.nodeType === 1 && uc(s, _), Yr(s)) : uc(io, _.stateNode));
                break;
            case 4:
                k = io, W = Ra, io = _.stateNode.containerInfo, Ra = !0, kl(s, l, _), io = k, Ra = W;
                break;
            case 0:
            case 11:
            case 14:
            case 15:
                if (!Ao && (k = _.updateQueue, k !== null && (k = k.lastEffect, k !== null))) {
                    W = k = k.next;
                    do {
                        var ie = W, be = ie.destroy;
                        ie = ie.tag, be !== void 0 && (ie & 2 || ie & 4) && np(_, l, be), W = W.next
                    } while (W !== k)
                }
                kl(s, l, _);
                break;
            case 1:
                if (!Ao && (au(_, l), k = _.stateNode, typeof k.componentWillUnmount == "function")) try {
                    k.props = _.memoizedProps, k.state = _.memoizedState, k.componentWillUnmount()
                } catch (Xe) {
                    Fr(_, l, Xe)
                }
                kl(s, l, _);
                break;
            case 21:
                kl(s, l, _);
                break;
            case 22:
                _.mode & 1 ? (Ao = (k = Ao) || _.memoizedState !== null, kl(s, l, _), Ao = k) : kl(s, l, _);
                break;
            default:
                kl(s, l, _)
        }
    }

    function yA(s) {
        var l = s.updateQueue;
        if (l !== null) {
            s.updateQueue = null;
            var _ = s.stateNode;
            _ === null && (_ = s.stateNode = new $0), l.forEach(function (k) {
                var W = LA.bind(null, s, k);
                _.has(k) || (_.add(k), k.then(W, W))
            })
        }
    }

    function Ba(s, l) {
        var _ = l.deletions;
        if (_ !== null) for (var k = 0; k < _.length; k++) {
            var W = _[k];
            try {
                var ie = s, be = l, Xe = be;
                e:for (; Xe !== null;) {
                    switch (Xe.tag) {
                        case 5:
                            io = Xe.stateNode, Ra = !1;
                            break e;
                        case 3:
                            io = Xe.stateNode.containerInfo, Ra = !0;
                            break e;
                        case 4:
                            io = Xe.stateNode.containerInfo, Ra = !0;
                            break e
                    }
                    Xe = Xe.return
                }
                if (io === null) throw Error(i(160));
                vA(ie, be, W), io = null, Ra = !1;
                var nt = W.alternate;
                nt !== null && (nt.return = null), W.return = null
            } catch (Et) {
                Fr(W, l, Et)
            }
        }
        if (l.subtreeFlags & 12854) for (l = l.child; l !== null;) EA(l, s), l = l.sibling
    }

    function EA(s, l) {
        var _ = s.alternate, k = s.flags;
        switch (s.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if (Ba(l, s), Za(s), k & 4) {
                    try {
                        ih(3, s, s.return), yd(3, s)
                    } catch (Yn) {
                        Fr(s, s.return, Yn)
                    }
                    try {
                        ih(5, s, s.return)
                    } catch (Yn) {
                        Fr(s, s.return, Yn)
                    }
                }
                break;
            case 1:
                Ba(l, s), Za(s), k & 512 && _ !== null && au(_, _.return);
                break;
            case 5:
                if (Ba(l, s), Za(s), k & 512 && _ !== null && au(_, _.return), s.flags & 32) {
                    var W = s.stateNode;
                    try {
                        Se(W, "")
                    } catch (Yn) {
                        Fr(s, s.return, Yn)
                    }
                }
                if (k & 4 && (W = s.stateNode, W != null)) {
                    var ie = s.memoizedProps, be = _ !== null ? _.memoizedProps : ie, Xe = s.type, nt = s.updateQueue;
                    if (s.updateQueue = null, nt !== null) try {
                        Xe === "input" && ie.type === "radio" && ie.name != null && hi(W, ie), G(Xe, be);
                        var Et = G(Xe, ie);
                        for (be = 0; be < nt.length; be += 2) {
                            var Zt = nt[be], rn = nt[be + 1];
                            Zt === "style" ? Ue(W, rn) : Zt === "dangerouslySetInnerHTML" ? jt(W, rn) : Zt === "children" ? Se(W, rn) : R(W, Zt, rn, Et)
                        }
                        switch (Xe) {
                            case"input":
                                Vn(W, ie);
                                break;
                            case"textarea":
                                Br(W, ie);
                                break;
                            case"select":
                                var qt = W._wrapperState.wasMultiple;
                                W._wrapperState.wasMultiple = !!ie.multiple;
                                var Ln = ie.value;
                                Ln != null ? Rr(W, !!ie.multiple, Ln, !1) : qt !== !!ie.multiple && (ie.defaultValue != null ? Rr(W, !!ie.multiple, ie.defaultValue, !0) : Rr(W, !!ie.multiple, ie.multiple ? [] : "", !1))
                        }
                        W[Xo] = ie
                    } catch (Yn) {
                        Fr(s, s.return, Yn)
                    }
                }
                break;
            case 6:
                if (Ba(l, s), Za(s), k & 4) {
                    if (s.stateNode === null) throw Error(i(162));
                    W = s.stateNode, ie = s.memoizedProps;
                    try {
                        W.nodeValue = ie
                    } catch (Yn) {
                        Fr(s, s.return, Yn)
                    }
                }
                break;
            case 3:
                if (Ba(l, s), Za(s), k & 4 && _ !== null && _.memoizedState.isDehydrated) try {
                    Yr(l.containerInfo)
                } catch (Yn) {
                    Fr(s, s.return, Yn)
                }
                break;
            case 4:
                Ba(l, s), Za(s);
                break;
            case 13:
                Ba(l, s), Za(s), W = s.child, W.flags & 8192 && (ie = W.memoizedState !== null, W.stateNode.isHidden = ie, !ie || W.alternate !== null && W.alternate.memoizedState !== null || (MA = dt())), k & 4 && yA(s);
                break;
            case 22:
                if (Zt = _ !== null && _.memoizedState !== null, s.mode & 1 ? (Ao = (Et = Ao) || Zt, Ba(l, s), Ao = Et) : Ba(l, s), Za(s), k & 8192) {
                    if (Et = s.memoizedState !== null, (s.stateNode.isHidden = Et) && !Zt && s.mode & 1) for (Un = s, Zt = s.child; Zt !== null;) {
                        for (rn = Un = Zt; Un !== null;) {
                            switch (qt = Un, Ln = qt.child, qt.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    ih(4, qt, qt.return);
                                    break;
                                case 1:
                                    au(qt, qt.return);
                                    var Qn = qt.stateNode;
                                    if (typeof Qn.componentWillUnmount == "function") {
                                        k = qt, _ = qt.return;
                                        try {
                                            l = k, Qn.props = l.memoizedProps, Qn.state = l.memoizedState, Qn.componentWillUnmount()
                                        } catch (Yn) {
                                            Fr(k, _, Yn)
                                        }
                                    }
                                    break;
                                case 5:
                                    au(qt, qt.return);
                                    break;
                                case 22:
                                    if (qt.memoizedState !== null) {
                                        wA(rn);
                                        continue
                                    }
                            }
                            Ln !== null ? (Ln.return = qt, Un = Ln) : wA(rn)
                        }
                        Zt = Zt.sibling
                    }
                    e:for (Zt = null, rn = s; ;) {
                        if (rn.tag === 5) {
                            if (Zt === null) {
                                Zt = rn;
                                try {
                                    W = rn.stateNode, Et ? (ie = W.style, typeof ie.setProperty == "function" ? ie.setProperty("display", "none", "important") : ie.display = "none") : (Xe = rn.stateNode, nt = rn.memoizedProps.style, be = nt != null && nt.hasOwnProperty("display") ? nt.display : null, Xe.style.display = Le("display", be))
                                } catch (Yn) {
                                    Fr(s, s.return, Yn)
                                }
                            }
                        } else if (rn.tag === 6) {
                            if (Zt === null) try {
                                rn.stateNode.nodeValue = Et ? "" : rn.memoizedProps
                            } catch (Yn) {
                                Fr(s, s.return, Yn)
                            }
                        } else if ((rn.tag !== 22 && rn.tag !== 23 || rn.memoizedState === null || rn === s) && rn.child !== null) {
                            rn.child.return = rn, rn = rn.child;
                            continue
                        }
                        if (rn === s) break e;
                        for (; rn.sibling === null;) {
                            if (rn.return === null || rn.return === s) break e;
                            Zt === rn && (Zt = null), rn = rn.return
                        }
                        Zt === rn && (Zt = null), rn.sibling.return = rn.return, rn = rn.sibling
                    }
                }
                break;
            case 19:
                Ba(l, s), Za(s), k & 4 && yA(s);
                break;
            case 21:
                break;
            default:
                Ba(l, s), Za(s)
        }
    }

    function Za(s) {
        var l = s.flags;
        if (l & 2) {
            try {
                e:{
                    for (var _ = s.return; _ !== null;) {
                        if (AA(_)) {
                            var k = _;
                            break e
                        }
                        _ = _.return
                    }
                    throw Error(i(160))
                }
                switch (k.tag) {
                    case 5:
                        var W = k.stateNode;
                        k.flags & 32 && (Se(W, ""), k.flags &= -33);
                        var ie = gA(s);
                        sp(s, ie, W);
                        break;
                    case 3:
                    case 4:
                        var be = k.stateNode.containerInfo, Xe = gA(s);
                        rp(s, Xe, be);
                        break;
                    default:
                        throw Error(i(161))
                }
            } catch (nt) {
                Fr(s, s.return, nt)
            }
            s.flags &= -3
        }
        l & 4096 && (s.flags &= -4097)
    }

    function tv(s, l, _) {
        Un = s, xA(s)
    }

    function xA(s, l, _) {
        for (var k = (s.mode & 1) !== 0; Un !== null;) {
            var W = Un, ie = W.child;
            if (W.tag === 22 && k) {
                var be = W.memoizedState !== null || vd;
                if (!be) {
                    var Xe = W.alternate, nt = Xe !== null && Xe.memoizedState !== null || Ao;
                    Xe = vd;
                    var Et = Ao;
                    if (vd = be, (Ao = nt) && !Et) for (Un = W; Un !== null;) be = Un, nt = be.child, be.tag === 22 && be.memoizedState !== null ? nv(W) : nt !== null ? (nt.return = be, Un = nt) : nv(W);
                    for (; ie !== null;) Un = ie, xA(ie), ie = ie.sibling;
                    Un = W, vd = Xe, Ao = Et
                }
                CA(s)
            } else W.subtreeFlags & 8772 && ie !== null ? (ie.return = W, Un = ie) : CA(s)
        }
    }

    function CA(s) {
        for (; Un !== null;) {
            var l = Un;
            if (l.flags & 8772) {
                var _ = l.alternate;
                try {
                    if (l.flags & 8772) switch (l.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Ao || yd(5, l);
                            break;
                        case 1:
                            var k = l.stateNode;
                            if (l.flags & 4 && !Ao) if (_ === null) k.componentDidMount(); else {
                                var W = l.elementType === l.type ? _.memoizedProps : Ia(l.type, _.memoizedProps);
                                k.componentDidUpdate(W, _.memoizedState, k.__reactInternalSnapshotBeforeUpdate)
                            }
                            var ie = l.updateQueue;
                            ie !== null && zf(l, ie, k);
                            break;
                        case 3:
                            var be = l.updateQueue;
                            if (be !== null) {
                                if (_ = null, l.child !== null) switch (l.child.tag) {
                                    case 5:
                                        _ = l.child.stateNode;
                                        break;
                                    case 1:
                                        _ = l.child.stateNode
                                }
                                zf(l, be, _)
                            }
                            break;
                        case 5:
                            var Xe = l.stateNode;
                            if (_ === null && l.flags & 4) {
                                _ = Xe;
                                var nt = l.memoizedProps;
                                switch (l.type) {
                                    case"button":
                                    case"input":
                                    case"select":
                                    case"textarea":
                                        nt.autoFocus && _.focus();
                                        break;
                                    case"img":
                                        nt.src && (_.src = nt.src)
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (l.memoizedState === null) {
                                var Et = l.alternate;
                                if (Et !== null) {
                                    var Zt = Et.memoizedState;
                                    if (Zt !== null) {
                                        var rn = Zt.dehydrated;
                                        rn !== null && Yr(rn)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(i(163))
                    }
                    Ao || l.flags & 512 && ip(l)
                } catch (qt) {
                    Fr(l, l.return, qt)
                }
            }
            if (l === s) {
                Un = null;
                break
            }
            if (_ = l.sibling, _ !== null) {
                _.return = l.return, Un = _;
                break
            }
            Un = l.return
        }
    }

    function wA(s) {
        for (; Un !== null;) {
            var l = Un;
            if (l === s) {
                Un = null;
                break
            }
            var _ = l.sibling;
            if (_ !== null) {
                _.return = l.return, Un = _;
                break
            }
            Un = l.return
        }
    }

    function nv(s) {
        for (; Un !== null;) {
            var l = Un;
            try {
                switch (l.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var _ = l.return;
                        try {
                            yd(4, l)
                        } catch (nt) {
                            Fr(l, _, nt)
                        }
                        break;
                    case 1:
                        var k = l.stateNode;
                        if (typeof k.componentDidMount == "function") {
                            var W = l.return;
                            try {
                                k.componentDidMount()
                            } catch (nt) {
                                Fr(l, W, nt)
                            }
                        }
                        var ie = l.return;
                        try {
                            ip(l)
                        } catch (nt) {
                            Fr(l, ie, nt)
                        }
                        break;
                    case 5:
                        var be = l.return;
                        try {
                            ip(l)
                        } catch (nt) {
                            Fr(l, be, nt)
                        }
                }
            } catch (nt) {
                Fr(l, l.return, nt)
            }
            if (l === s) {
                Un = null;
                break
            }
            var Xe = l.sibling;
            if (Xe !== null) {
                Xe.return = l.return, Un = Xe;
                break
            }
            Un = l.return
        }
    }

    var V1 = Math.ceil, op = I.ReactCurrentDispatcher, bA = I.ReactCurrentOwner, La = I.ReactCurrentBatchConfig, hr = 0,
        ro = null, Os = null, go = 0, Aa = 0, rh = Bl(0), Ks = 0, Ed = null, lu = 0, ap = 0, _A = 0, xd = null,
        na = null, MA = 0, sh = 1 / 0, Fl = null, lp = !1, SA = null, Cc = null, cp = !1, wc = null, up = 0, Cd = 0,
        TA = null, hp = -1, dp = 0;

    function No() {
        return hr & 6 ? dt() : hp !== -1 ? hp : hp = dt()
    }

    function bc(s) {
        return s.mode & 1 ? hr & 2 && go !== 0 ? go & -go : z0.transition !== null ? (dp === 0 && (dp = Ae()), dp) : (s = wt, s !== 0 || (s = window.event, s = s === void 0 ? 16 : rr(s.type)), s) : 1
    }

    function $a(s, l, _, k) {
        if (50 < Cd) throw Cd = 0, TA = null, Error(i(185));
        Oe(s, _, k), (!(hr & 2) || s !== ro) && (s === ro && (!(hr & 2) && (ap |= _), Ks === 4 && Nl(s, go)), ci(s, k), _ === 1 && hr === 0 && !(l.mode & 1) && (sh = dt() + 500, or && fo()))
    }

    function ci(s, l) {
        var _ = s.callbackNode;
        $(s, l);
        var k = _r(s, s === ro ? go : 0);
        if (k === 0) _ !== null && Ke(_), s.callbackNode = null, s.callbackPriority = 0; else if (l = k & -k, s.callbackPriority !== l) {
            if (_ != null && Ke(_), l === 1) s.tag === 0 ? kf(IA.bind(null, s)) : ja(IA.bind(null, s)), Yc(function () {
                !(hr & 6) && fo()
            }), _ = null; else {
                switch (kt(k)) {
                    case 1:
                        _ = Kt;
                        break;
                    case 4:
                        _ = Rn;
                        break;
                    case 16:
                        _ = xn;
                        break;
                    case 536870912:
                        _ = Hn;
                        break;
                    default:
                        _ = xn
                }
                _ = DA(_, wn.bind(null, s))
            }
            s.callbackPriority = l, s.callbackNode = _
        }
    }

    function wn(s, l) {
        if (hp = -1, dp = 0, hr & 6) throw Error(i(327));
        var _ = s.callbackNode;
        if (zl() && s.callbackNode !== _) return null;
        var k = _r(s, s === ro ? go : 0);
        if (k === 0) return null;
        if (k & 30 || k & s.expiredLanes || l) l = ah(s, k); else {
            l = k;
            var W = hr;
            hr |= 2;
            var ie = oh();
            (ro !== s || go !== l) && (Fl = null, sh = dt() + 500, Sc(s, l));
            do try {
                mp();
                break
            } catch (Xe) {
                RA(s, Xe)
            } while (!0);
            To(), op.current = ie, hr = W, Os !== null ? l = 0 : (ro = null, go = 0, l = Ks)
        }
        if (l !== 0) {
            if (l === 2 && (W = re(s), W !== 0 && (k = W, l = ia(s, W))), l === 1) throw _ = Ed, Sc(s, 0), Nl(s, k), ci(s, dt()), _;
            if (l === 6) Nl(s, k); else {
                if (W = s.current.alternate, !(k & 30) && !_c(W) && (l = ah(s, k), l === 2 && (ie = re(s), ie !== 0 && (k = ie, l = ia(s, ie))), l === 1)) throw _ = Ed, Sc(s, 0), Nl(s, k), ci(s, dt()), _;
                switch (s.finishedWork = W, s.finishedLanes = k, l) {
                    case 0:
                    case 1:
                        throw Error(i(345));
                    case 2:
                        fl(s, na, Fl);
                        break;
                    case 3:
                        if (Nl(s, k), (k & 130023424) === k && (l = MA + 500 - dt(), 10 < l)) {
                            if (_r(s, 0) !== 0) break;
                            if (W = s.suspendedLanes, (W & k) !== k) {
                                No(), s.pingedLanes |= s.suspendedLanes & W;
                                break
                            }
                            s.timeoutHandle = as(fl.bind(null, s, na, Fl), l);
                            break
                        }
                        fl(s, na, Fl);
                        break;
                    case 4:
                        if (Nl(s, k), (k & 4194240) === k) break;
                        for (l = s.eventTimes, W = -1; 0 < k;) {
                            var be = 31 - li(k);
                            ie = 1 << be, be = l[be], be > W && (W = be), k &= ~ie
                        }
                        if (k = W, k = dt() - k, k = (120 > k ? 120 : 480 > k ? 480 : 1080 > k ? 1080 : 1920 > k ? 1920 : 3e3 > k ? 3e3 : 4320 > k ? 4320 : 1960 * V1(k / 1960)) - k, 10 < k) {
                            s.timeoutHandle = as(fl.bind(null, s, na, Fl), k);
                            break
                        }
                        fl(s, na, Fl);
                        break;
                    case 5:
                        fl(s, na, Fl);
                        break;
                    default:
                        throw Error(i(329))
                }
            }
        }
        return ci(s, dt()), s.callbackNode === _ ? wn.bind(null, s) : null
    }

    function ia(s, l) {
        var _ = xd;
        return s.current.memoizedState.isDehydrated && (Sc(s, l).flags |= 256), s = ah(s, l), s !== 2 && (l = na, na = _, l !== null && cu(l)), s
    }

    function cu(s) {
        na === null ? na = s : na.push.apply(na, s)
    }

    function _c(s) {
        for (var l = s; ;) {
            if (l.flags & 16384) {
                var _ = l.updateQueue;
                if (_ !== null && (_ = _.stores, _ !== null)) for (var k = 0; k < _.length; k++) {
                    var W = _[k], ie = W.getSnapshot;
                    W = W.value;
                    try {
                        if (!ai(ie(), W)) return !1
                    } catch {
                        return !1
                    }
                }
            }
            if (_ = l.child, l.subtreeFlags & 16384 && _ !== null) _.return = l, l = _; else {
                if (l === s) break;
                for (; l.sibling === null;) {
                    if (l.return === null || l.return === s) return !0;
                    l = l.return
                }
                l.sibling.return = l.return, l = l.sibling
            }
        }
        return !0
    }

    function Nl(s, l) {
        for (l &= ~_A, l &= ~ap, s.suspendedLanes |= l, s.pingedLanes &= ~l, s = s.expirationTimes; 0 < l;) {
            var _ = 31 - li(l), k = 1 << _;
            s[_] = -1, l &= ~k
        }
    }

    function IA(s) {
        if (hr & 6) throw Error(i(327));
        zl();
        var l = _r(s, 0);
        if (!(l & 1)) return ci(s, dt()), null;
        var _ = ah(s, l);
        if (s.tag !== 0 && _ === 2) {
            var k = re(s);
            k !== 0 && (l = k, _ = ia(s, k))
        }
        if (_ === 1) throw _ = Ed, Sc(s, 0), Nl(s, l), ci(s, dt()), _;
        if (_ === 6) throw Error(i(345));
        return s.finishedWork = s.current.alternate, s.finishedLanes = l, fl(s, na, Fl), ci(s, dt()), null
    }

    function fp(s, l) {
        var _ = hr;
        hr |= 1;
        try {
            return s(l)
        } finally {
            hr = _, hr === 0 && (sh = dt() + 500, or && fo())
        }
    }

    function Mc(s) {
        wc !== null && wc.tag === 0 && !(hr & 6) && zl();
        var l = hr;
        hr |= 1;
        var _ = La.transition, k = wt;
        try {
            if (La.transition = null, wt = 1, s) return s()
        } finally {
            wt = k, La.transition = _, hr = l, !(hr & 6) && fo()
        }
    }

    function pp() {
        Aa = rh.current, Gr(rh)
    }

    function Sc(s, l) {
        s.finishedWork = null, s.finishedLanes = 0;
        var _ = s.timeoutHandle;
        if (_ !== -1 && (s.timeoutHandle = -1, fa(_)), Os !== null) for (_ = Os.return; _ !== null;) {
            var k = _;
            switch (Ws(k), k.tag) {
                case 1:
                    k = k.type.childContextTypes, k != null && Xu();
                    break;
                case 3:
                    ma(), Gr(js), Gr(Rs), Gf();
                    break;
                case 5:
                    no(k);
                    break;
                case 4:
                    ma();
                    break;
                case 13:
                    Gr(Jr);
                    break;
                case 19:
                    Gr(Jr);
                    break;
                case 10:
                    Ac(k.type._context);
                    break;
                case 22:
                case 23:
                    pp()
            }
            _ = _.return
        }
        if (ro = s, Os = s = Vl(s.current, null), go = Aa = l, Ks = 0, Ed = null, _A = ap = lu = 0, na = xd = null, Zo !== null) {
            for (l = 0; l < Zo.length; l++) if (_ = Zo[l], k = _.interleaved, k !== null) {
                _.interleaved = null;
                var W = k.next, ie = _.pending;
                if (ie !== null) {
                    var be = ie.next;
                    ie.next = W, k.next = be
                }
                _.pending = k
            }
            Zo = null
        }
        return s
    }

    function RA(s, l) {
        do {
            var _ = Os;
            try {
                if (To(), cd.current = pd, ns) {
                    for (var k = xr.memoizedState; k !== null;) {
                        var W = k.queue;
                        W !== null && (W.pending = null), k = k.next
                    }
                    ns = !1
                }
                if (Xa = 0, Ds = vs = xr = null, Ya = !1, qa = 0, bA.current = null, _ === null || _.return === null) {
                    Ks = 1, Ed = l, Os = null;
                    break
                }
                e:{
                    var ie = s, be = _.return, Xe = _, nt = l;
                    if (l = go, Xe.flags |= 32768, nt !== null && typeof nt == "object" && typeof nt.then == "function") {
                        var Et = nt, Zt = Xe, rn = Zt.tag;
                        if (!(Zt.mode & 1) && (rn === 0 || rn === 11 || rn === 15)) {
                            var qt = Zt.alternate;
                            qt ? (Zt.updateQueue = qt.updateQueue, Zt.memoizedState = qt.memoizedState, Zt.lanes = qt.lanes) : (Zt.updateQueue = null, Zt.memoizedState = null)
                        }
                        var Ln = Zm(be);
                        if (Ln !== null) {
                            Ln.flags &= -257, $m(Ln, be, Xe, ie, l), Ln.mode & 1 && Jm(ie, Et, l), l = Ln, nt = Et;
                            var Qn = l.updateQueue;
                            if (Qn === null) {
                                var Yn = new Set;
                                Yn.add(nt), l.updateQueue = Yn
                            } else Qn.add(nt);
                            break e
                        } else {
                            if (!(l & 1)) {
                                Jm(ie, Et, l), Ul();
                                break e
                            }
                            nt = Error(i(426))
                        }
                    } else if (gr && Xe.mode & 1) {
                        var us = Zm(be);
                        if (us !== null) {
                            !(us.flags & 65536) && (us.flags |= 256), $m(us, be, Xe, ie, l), Nf(ou(nt, Xe));
                            break e
                        }
                    }
                    ie = nt = ou(nt, Xe), Ks !== 4 && (Ks = 2), xd === null ? xd = [ie] : xd.push(ie), ie = be;
                    do {
                        switch (ie.tag) {
                            case 3:
                                ie.flags |= 65536, l &= -l, ie.lanes |= l;
                                var vt = Ym(ie, nt, l);
                                Ju(ie, vt);
                                break e;
                            case 1:
                                Xe = nt;
                                var ct = ie.type, yt = ie.stateNode;
                                if (!(ie.flags & 128) && (typeof ct.getDerivedStateFromError == "function" || yt !== null && typeof yt.componentDidCatch == "function" && (Cc === null || !Cc.has(yt)))) {
                                    ie.flags |= 65536, l &= -l, ie.lanes |= l;
                                    var hn = qm(ie, Xe, l);
                                    Ju(ie, hn);
                                    break e
                                }
                        }
                        ie = ie.return
                    } while (ie !== null)
                }
                wd(_)
            } catch (Zn) {
                l = Zn, Os === _ && _ !== null && (Os = _ = _.return);
                continue
            }
            break
        } while (!0)
    }

    function oh() {
        var s = op.current;
        return op.current = pd, s === null ? pd : s
    }

    function Ul() {
        (Ks === 0 || Ks === 3 || Ks === 2) && (Ks = 4), ro === null || !(lu & 268435455) && !(ap & 268435455) || Nl(ro, go)
    }

    function ah(s, l) {
        var _ = hr;
        hr |= 2;
        var k = oh();
        (ro !== s || go !== l) && (Fl = null, Sc(s, l));
        do try {
            Tc();
            break
        } catch (W) {
            RA(s, W)
        } while (!0);
        if (To(), hr = _, op.current = k, Os !== null) throw Error(i(261));
        return ro = null, go = 0, Ks
    }

    function Tc() {
        for (; Os !== null;) Ap(Os)
    }

    function mp() {
        for (; Os !== null && !rt();) Ap(Os)
    }

    function Ap(s) {
        var l = lh(s.alternate, s, Aa);
        s.memoizedProps = s.pendingProps, l === null ? wd(s) : Os = l, bA.current = null
    }

    function wd(s) {
        var l = s;
        do {
            var _ = l.alternate;
            if (s = l.return, l.flags & 32768) {
                if (_ = Z0(_, l), _ !== null) {
                    _.flags &= 32767, Os = _;
                    return
                }
                if (s !== null) s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null; else {
                    Ks = 6, Os = null;
                    return
                }
            } else if (_ = J0(_, l, Aa), _ !== null) {
                Os = _;
                return
            }
            if (l = l.sibling, l !== null) {
                Os = l;
                return
            }
            Os = l = s
        } while (l !== null);
        Ks === 0 && (Ks = 5)
    }

    function fl(s, l, _) {
        var k = wt, W = La.transition;
        try {
            La.transition = null, wt = 1, gp(s, l, _, k)
        } finally {
            La.transition = W, wt = k
        }
        return null
    }

    function gp(s, l, _, k) {
        do zl(); while (wc !== null);
        if (hr & 6) throw Error(i(327));
        _ = s.finishedWork;
        var W = s.finishedLanes;
        if (_ === null) return null;
        if (s.finishedWork = null, s.finishedLanes = 0, _ === s.current) throw Error(i(177));
        s.callbackNode = null, s.callbackPriority = 0;
        var ie = _.lanes | _.childLanes;
        if (Ze(s, ie), s === ro && (Os = ro = null, go = 0), !(_.subtreeFlags & 2064) && !(_.flags & 2064) || cp || (cp = !0, DA(xn, function () {
            return zl(), null
        })), ie = (_.flags & 15990) !== 0, _.subtreeFlags & 15990 || ie) {
            ie = La.transition, La.transition = null;
            var be = wt;
            wt = 1;
            var Xe = hr;
            hr |= 4, bA.current = null, ev(s, _), EA(_, s), td(wa), _s = !!Va, wa = Va = null, s.current = _, tv(_), Ct(), hr = Xe, wt = be, La.transition = ie
        } else s.current = _;
        if (cp && (cp = !1, wc = s, up = W), ie = s.pendingLanes, ie === 0 && (Cc = null), Wi(_.stateNode), ci(s, dt()), l !== null) for (k = s.onRecoverableError, _ = 0; _ < l.length; _++) W = l[_], k(W.value, {
            componentStack: W.stack,
            digest: W.digest
        });
        if (lp) throw lp = !1, s = SA, SA = null, s;
        return up & 1 && s.tag !== 0 && zl(), ie = s.pendingLanes, ie & 1 ? s === TA ? Cd++ : (Cd = 0, TA = s) : Cd = 0, fo(), null
    }

    function zl() {
        if (wc !== null) {
            var s = kt(up), l = La.transition, _ = wt;
            try {
                if (La.transition = null, wt = 16 > s ? 16 : s, wc === null) var k = !1; else {
                    if (s = wc, wc = null, up = 0, hr & 6) throw Error(i(331));
                    var W = hr;
                    for (hr |= 4, Un = s.current; Un !== null;) {
                        var ie = Un, be = ie.child;
                        if (Un.flags & 16) {
                            var Xe = ie.deletions;
                            if (Xe !== null) {
                                for (var nt = 0; nt < Xe.length; nt++) {
                                    var Et = Xe[nt];
                                    for (Un = Et; Un !== null;) {
                                        var Zt = Un;
                                        switch (Zt.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                ih(8, Zt, ie)
                                        }
                                        var rn = Zt.child;
                                        if (rn !== null) rn.return = Zt, Un = rn; else for (; Un !== null;) {
                                            Zt = Un;
                                            var qt = Zt.sibling, Ln = Zt.return;
                                            if (mA(Zt), Zt === Et) {
                                                Un = null;
                                                break
                                            }
                                            if (qt !== null) {
                                                qt.return = Ln, Un = qt;
                                                break
                                            }
                                            Un = Ln
                                        }
                                    }
                                }
                                var Qn = ie.alternate;
                                if (Qn !== null) {
                                    var Yn = Qn.child;
                                    if (Yn !== null) {
                                        Qn.child = null;
                                        do {
                                            var us = Yn.sibling;
                                            Yn.sibling = null, Yn = us
                                        } while (Yn !== null)
                                    }
                                }
                                Un = ie
                            }
                        }
                        if (ie.subtreeFlags & 2064 && be !== null) be.return = ie, Un = be; else e:for (; Un !== null;) {
                            if (ie = Un, ie.flags & 2048) switch (ie.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    ih(9, ie, ie.return)
                            }
                            var vt = ie.sibling;
                            if (vt !== null) {
                                vt.return = ie.return, Un = vt;
                                break e
                            }
                            Un = ie.return
                        }
                    }
                    var ct = s.current;
                    for (Un = ct; Un !== null;) {
                        be = Un;
                        var yt = be.child;
                        if (be.subtreeFlags & 2064 && yt !== null) yt.return = be, Un = yt; else e:for (be = ct; Un !== null;) {
                            if (Xe = Un, Xe.flags & 2048) try {
                                switch (Xe.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        yd(9, Xe)
                                }
                            } catch (Zn) {
                                Fr(Xe, Xe.return, Zn)
                            }
                            if (Xe === be) {
                                Un = null;
                                break e
                            }
                            var hn = Xe.sibling;
                            if (hn !== null) {
                                hn.return = Xe.return, Un = hn;
                                break e
                            }
                            Un = Xe.return
                        }
                    }
                    if (hr = W, fo(), Wn && typeof Wn.onPostCommitFiberRoot == "function") try {
                        Wn.onPostCommitFiberRoot(jn, s)
                    } catch {
                    }
                    k = !0
                }
                return k
            } finally {
                wt = _, La.transition = l
            }
        }
        return !1
    }

    function Gl(s, l, _) {
        l = ou(_, l), l = Ym(s, l, 1), s = Sa(s, l, 1), l = No(), s !== null && (Oe(s, 1, l), ci(s, l))
    }

    function Fr(s, l, _) {
        if (s.tag === 3) Gl(s, s, _); else for (; l !== null;) {
            if (l.tag === 3) {
                Gl(l, s, _);
                break
            } else if (l.tag === 1) {
                var k = l.stateNode;
                if (typeof l.type.getDerivedStateFromError == "function" || typeof k.componentDidCatch == "function" && (Cc === null || !Cc.has(k))) {
                    s = ou(_, s), s = qm(l, s, 1), l = Sa(l, s, 1), s = No(), l !== null && (Oe(l, 1, s), ci(l, s));
                    break
                }
            }
            l = l.return
        }
    }

    function BA(s, l, _) {
        var k = s.pingCache;
        k !== null && k.delete(l), l = No(), s.pingedLanes |= s.suspendedLanes & _, ro === s && (go & _) === _ && (Ks === 4 || Ks === 3 && (go & 130023424) === go && 500 > dt() - MA ? Sc(s, 0) : _A |= _), ci(s, l)
    }

    function bd(s, l) {
        l === 0 && (s.mode & 1 ? (l = Cn, Cn <<= 1, !(Cn & 130023424) && (Cn = 4194304)) : l = 1);
        var _ = No();
        s = ko(s, l), s !== null && (Oe(s, l, _), ci(s, _))
    }

    function iv(s) {
        var l = s.memoizedState, _ = 0;
        l !== null && (_ = l.retryLane), bd(s, _)
    }

    function LA(s, l) {
        var _ = 0;
        switch (s.tag) {
            case 13:
                var k = s.stateNode, W = s.memoizedState;
                W !== null && (_ = W.retryLane);
                break;
            case 19:
                k = s.stateNode;
                break;
            default:
                throw Error(i(314))
        }
        k !== null && k.delete(l), bd(s, _)
    }

    var lh;
    lh = function (s, l, _) {
        if (s !== null) if (s.memoizedProps !== l.pendingProps || js.current) Fo = !0; else {
            if (!(s.lanes & _) && !(l.flags & 128)) return Fo = !1, q0(s, l, _);
            Fo = !!(s.flags & 131072)
        } else Fo = !1, gr && l.flags & 1048576 && rd(l, Zc, l.index);
        switch (l.lanes = 0, l.tag) {
            case 2:
                var k = l.type;
                gd(s, l), s = l.pendingProps;
                var W = Jc(l, Rs.current);
                Ti(l, _), W = eh(null, l, k, s, W, _);
                var ie = Vf();
                return l.flags |= 1, typeof W == "object" && W !== null && typeof W.render == "function" && W.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, _o(k) ? (ie = !0, id(l)) : ie = !1, l.memoizedState = W.state !== null && W.state !== void 0 ? W.state : null, Pl(l), W.updater = md, l.stateNode = W, W._reactInternals = l, Wf(l, k, s, _), l = qf(null, l, k, !0, ie, _)) : (l.tag = 0, gr && ie && Bn(l), Io(null, l, W, _), l = l.child), l;
            case 16:
                k = l.elementType;
                e:{
                    switch (gd(s, l), s = l.pendingProps, W = k._init, k = W(k._payload), l.type = k, W = l.tag = rv(k), s = Ia(k, s), W) {
                        case 0:
                            l = Yf(null, l, k, s, _);
                            break e;
                        case 1:
                            l = sA(null, l, k, s, _);
                            break e;
                        case 11:
                            l = eA(null, l, k, s, _);
                            break e;
                        case 14:
                            l = tA(null, l, k, Ia(k.type, s), _);
                            break e
                    }
                    throw Error(i(306, k, ""))
                }
                return l;
            case 0:
                return k = l.type, W = l.pendingProps, W = l.elementType === k ? W : Ia(k, W), Yf(s, l, k, W, _);
            case 1:
                return k = l.type, W = l.pendingProps, W = l.elementType === k ? W : Ia(k, W), sA(s, l, k, W, _);
            case 3:
                e:{
                    if (oA(l), s === null) throw Error(i(387));
                    k = l.pendingProps, ie = l.memoizedState, W = ie.element, ad(s, l), Zu(l, k, null, _);
                    var be = l.memoizedState;
                    if (k = be.element, ie.isDehydrated) if (ie = {
                        element: k,
                        isDehydrated: !1,
                        cache: be.cache,
                        pendingSuspenseBoundaries: be.pendingSuspenseBoundaries,
                        transitions: be.transitions
                    }, l.updateQueue.baseState = ie, l.memoizedState = ie, l.flags & 256) {
                        W = ou(Error(i(423)), l), l = aA(s, l, k, _, W);
                        break e
                    } else if (k !== W) {
                        W = ou(Error(i(424)), l), l = aA(s, l, k, _, W);
                        break e
                    } else for (Dr = Ko(l.stateNode.containerInfo.firstChild), qo = l, gr = !0, Ls = null, _ = Xn(l, null, k, _), l.child = _; _;) _.flags = _.flags & -3 | 4096, _ = _.sibling; else {
                        if ($c(), k === W) {
                            l = dl(s, l, _);
                            break e
                        }
                        Io(s, l, k, _)
                    }
                    l = l.child
                }
                return l;
            case 5:
                return yc(l), s === null && Ff(l), k = l.type, W = l.pendingProps, ie = s !== null ? s.memoizedProps : null, be = W.children, Il(k, W) ? be = null : ie !== null && Il(k, ie) && (l.flags |= 32), rA(s, l), Io(s, l, be, _), l.child;
            case 6:
                return s === null && Ff(l), null;
            case 13:
                return lA(s, l, _);
            case 4:
                return ru(l, l.stateNode.containerInfo), k = l.pendingProps, s === null ? l.child = tu(l, null, k, _) : Io(s, l, k, _), l.child;
            case 11:
                return k = l.type, W = l.pendingProps, W = l.elementType === k ? W : Ia(k, W), eA(s, l, k, W, _);
            case 7:
                return Io(s, l, l.pendingProps, _), l.child;
            case 8:
                return Io(s, l, l.pendingProps.children, _), l.child;
            case 12:
                return Io(s, l, l.pendingProps.children, _), l.child;
            case 10:
                e:{
                    if (k = l.type._context, W = l.pendingProps, ie = l.memoizedProps, be = W.value, Ar(od, k._currentValue), k._currentValue = be, ie !== null) if (ai(ie.value, be)) {
                        if (ie.children === W.children && !js.current) {
                            l = dl(s, l, _);
                            break e
                        }
                    } else for (ie = l.child, ie !== null && (ie.return = l); ie !== null;) {
                        var Xe = ie.dependencies;
                        if (Xe !== null) {
                            be = ie.child;
                            for (var nt = Xe.firstContext; nt !== null;) {
                                if (nt.context === k) {
                                    if (ie.tag === 1) {
                                        nt = pa(-1, _ & -_), nt.tag = 2;
                                        var Et = ie.updateQueue;
                                        if (Et !== null) {
                                            Et = Et.shared;
                                            var Zt = Et.pending;
                                            Zt === null ? nt.next = nt : (nt.next = Zt.next, Zt.next = nt), Et.pending = nt
                                        }
                                    }
                                    ie.lanes |= _, nt = ie.alternate, nt !== null && (nt.lanes |= _), gs(ie.return, _, l), Xe.lanes |= _;
                                    break
                                }
                                nt = nt.next
                            }
                        } else if (ie.tag === 10) be = ie.type === l.type ? null : ie.child; else if (ie.tag === 18) {
                            if (be = ie.return, be === null) throw Error(i(341));
                            be.lanes |= _, Xe = be.alternate, Xe !== null && (Xe.lanes |= _), gs(be, _, l), be = ie.sibling
                        } else be = ie.child;
                        if (be !== null) be.return = ie; else for (be = ie; be !== null;) {
                            if (be === l) {
                                be = null;
                                break
                            }
                            if (ie = be.sibling, ie !== null) {
                                ie.return = be.return, be = ie;
                                break
                            }
                            be = be.return
                        }
                        ie = be
                    }
                    Io(s, l, W.children, _), l = l.child
                }
                return l;
            case 9:
                return W = l.type, k = l.pendingProps.children, Ti(l, _), W = Jo(W), k = k(W), l.flags |= 1, Io(s, l, k, _), l.child;
            case 14:
                return k = l.type, W = Ia(k, l.pendingProps), W = Ia(k.type, W), tA(s, l, k, W, _);
            case 15:
                return nA(s, l, l.type, l.pendingProps, _);
            case 17:
                return k = l.type, W = l.pendingProps, W = l.elementType === k ? W : Ia(k, W), gd(s, l), l.tag = 1, _o(k) ? (s = !0, id(l)) : s = !1, Ti(l, _), Km(l, k, W), Wf(l, k, W, _), qf(null, l, k, !0, s, _);
            case 19:
                return uA(s, l, _);
            case 22:
                return iA(s, l, _)
        }
        throw Error(i(156, l.tag))
    };

    function DA(s, l) {
        return De(s, l)
    }

    function PA(s, l, _, k) {
        this.tag = s, this.key = _, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = k, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
    }

    function ra(s, l, _, k) {
        return new PA(s, l, _, k)
    }

    function ch(s) {
        return s = s.prototype, !(!s || !s.isReactComponent)
    }

    function rv(s) {
        if (typeof s == "function") return ch(s) ? 1 : 0;
        if (s != null) {
            if (s = s.$$typeof, s === Y) return 11;
            if (s === pe) return 14
        }
        return 2
    }

    function Vl(s, l) {
        var _ = s.alternate;
        return _ === null ? (_ = ra(s.tag, l, s.key, s.mode), _.elementType = s.elementType, _.type = s.type, _.stateNode = s.stateNode, _.alternate = s, s.alternate = _) : (_.pendingProps = l, _.type = s.type, _.flags = 0, _.subtreeFlags = 0, _.deletions = null), _.flags = s.flags & 14680064, _.childLanes = s.childLanes, _.lanes = s.lanes, _.child = s.child, _.memoizedProps = s.memoizedProps, _.memoizedState = s.memoizedState, _.updateQueue = s.updateQueue, l = s.dependencies, _.dependencies = l === null ? null : {
            lanes: l.lanes,
            firstContext: l.firstContext
        }, _.sibling = s.sibling, _.index = s.index, _.ref = s.ref, _
    }

    function _d(s, l, _, k, W, ie) {
        var be = 2;
        if (k = s, typeof s == "function") ch(s) && (be = 1); else if (typeof s == "string") be = 5; else e:switch (s) {
            case N:
                return Ic(_.children, W, ie, l);
            case F:
                be = 8, W |= 8;
                break;
            case V:
                return s = ra(12, _, l, W | 2), s.elementType = V, s.lanes = ie, s;
            case fe:
                return s = ra(13, _, l, W), s.elementType = fe, s.lanes = ie, s;
            case se:
                return s = ra(19, _, l, W), s.elementType = se, s.lanes = ie, s;
            case he:
                return Md(_, W, ie, l);
            default:
                if (typeof s == "object" && s !== null) switch (s.$$typeof) {
                    case U:
                        be = 10;
                        break e;
                    case j:
                        be = 9;
                        break e;
                    case Y:
                        be = 11;
                        break e;
                    case pe:
                        be = 14;
                        break e;
                    case ue:
                        be = 16, k = null;
                        break e
                }
                throw Error(i(130, s == null ? s : typeof s, ""))
        }
        return l = ra(be, _, l, W), l.elementType = s, l.type = k, l.lanes = ie, l
    }

    function Ic(s, l, _, k) {
        return s = ra(7, s, k, l), s.lanes = _, s
    }

    function Md(s, l, _, k) {
        return s = ra(22, s, k, l), s.elementType = he, s.lanes = _, s.stateNode = {isHidden: !1}, s
    }

    function vp(s, l, _) {
        return s = ra(6, s, null, l), s.lanes = _, s
    }

    function yp(s, l, _) {
        return l = ra(4, s.children !== null ? s.children : [], s.key, l), l.lanes = _, l.stateNode = {
            containerInfo: s.containerInfo,
            pendingChildren: null,
            implementation: s.implementation
        }, l
    }

    function sv(s, l, _, k, W) {
        this.tag = l, this.containerInfo = s, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = xe(0), this.expirationTimes = xe(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = xe(0), this.identifierPrefix = k, this.onRecoverableError = W, this.mutableSourceEagerHydrationData = null
    }

    function uh(s, l, _, k, W, ie, be, Xe, nt) {
        return s = new sv(s, l, _, Xe, nt), l === 1 ? (l = 1, ie === !0 && (l |= 8)) : l = 0, ie = ra(3, null, null, l), s.current = ie, ie.stateNode = s, ie.memoizedState = {
            element: k,
            isDehydrated: _,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        }, Pl(ie), s
    }

    function OA(s, l, _) {
        var k = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {$$typeof: O, key: k == null ? null : "" + k, children: s, containerInfo: l, implementation: _}
    }

    function Ep(s) {
        if (!s) return ho;
        s = s._reactInternals;
        e:{
            if (Hi(s) !== s || s.tag !== 1) throw Error(i(170));
            var l = s;
            do {
                switch (l.tag) {
                    case 3:
                        l = l.stateNode.context;
                        break e;
                    case 1:
                        if (_o(l.type)) {
                            l = l.stateNode.__reactInternalMemoizedMergedChildContext;
                            break e
                        }
                }
                l = l.return
            } while (l !== null);
            throw Error(i(171))
        }
        if (s.tag === 1) {
            var _ = s.type;
            if (_o(_)) return Of(s, _, l)
        }
        return l
    }

    function xp(s, l, _, k, W, ie, be, Xe, nt) {
        return s = uh(_, k, !0, s, W, ie, be, Xe, nt), s.context = Ep(null), _ = s.current, k = No(), W = bc(_), ie = pa(k, W), ie.callback = l ?? null, Sa(_, ie, W), s.current.lanes = W, Oe(s, W, k), ci(s, k), s
    }

    function hh(s, l, _, k) {
        var W = l.current, ie = No(), be = bc(W);
        return _ = Ep(_), l.context === null ? l.context = _ : l.pendingContext = _, l = pa(ie, be), l.payload = {element: s}, k = k === void 0 ? null : k, k !== null && (l.callback = k), s = Sa(W, l, be), s !== null && ($a(s, W, be, ie), gc(s, W, be)), be
    }

    function dh(s) {
        if (s = s.current, !s.child) return null;
        switch (s.child.tag) {
            case 5:
                return s.child.stateNode;
            default:
                return s.child.stateNode
        }
    }

    function Cp(s, l) {
        if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
            var _ = s.retryLane;
            s.retryLane = _ !== 0 && _ < l ? _ : l
        }
    }

    function Sd(s, l) {
        Cp(s, l), (s = s.alternate) && Cp(s, l)
    }

    function kA() {
        return null
    }

    var wp = typeof reportError == "function" ? reportError : function (s) {
        console.error(s)
    };

    function Td(s) {
        this._internalRoot = s
    }

    pl.prototype.render = Td.prototype.render = function (s) {
        var l = this._internalRoot;
        if (l === null) throw Error(i(409));
        hh(s, l, null, null)
    }, pl.prototype.unmount = Td.prototype.unmount = function () {
        var s = this._internalRoot;
        if (s !== null) {
            this._internalRoot = null;
            var l = s.containerInfo;
            Mc(function () {
                hh(null, s, null, null)
            }), l[ts] = null
        }
    };

    function pl(s) {
        this._internalRoot = s
    }

    pl.prototype.unstable_scheduleHydration = function (s) {
        if (s) {
            var l = de();
            s = {blockedOn: null, target: s, priority: l};
            for (var _ = 0; _ < sn.length && l !== 0 && l < sn[_].priority; _++) ;
            sn.splice(_, 0, s), _ === 0 && yn(s)
        }
    };

    function cs(s) {
        return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11)
    }

    function is(s) {
        return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11 && (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "))
    }

    function fh() {
    }

    function ov(s, l, _, k, W) {
        if (W) {
            if (typeof k == "function") {
                var ie = k;
                k = function () {
                    var Et = dh(be);
                    ie.call(Et)
                }
            }
            var be = xp(l, k, s, 0, null, !1, !1, "", fh);
            return s._reactRootContainer = be, s[ts] = be.current, Do(s.nodeType === 8 ? s.parentNode : s), Mc(), be
        }
        for (; W = s.lastChild;) s.removeChild(W);
        if (typeof k == "function") {
            var Xe = k;
            k = function () {
                var Et = dh(nt);
                Xe.call(Et)
            }
        }
        var nt = uh(s, 0, !1, null, null, !1, !1, "", fh);
        return s._reactRootContainer = nt, s[ts] = nt.current, Do(s.nodeType === 8 ? s.parentNode : s), Mc(function () {
            hh(l, nt, _, k)
        }), nt
    }

    function Id(s, l, _, k, W) {
        var ie = _._reactRootContainer;
        if (ie) {
            var be = ie;
            if (typeof W == "function") {
                var Xe = W;
                W = function () {
                    var nt = dh(be);
                    Xe.call(nt)
                }
            }
            hh(l, be, s, W)
        } else be = ov(_, l, s, W, k);
        return dh(be)
    }

    et = function (s) {
        switch (s.tag) {
            case 3:
                var l = s.stateNode;
                if (l.current.memoizedState.isDehydrated) {
                    var _ = Ai(l.pendingLanes);
                    _ !== 0 && (at(l, _ | 1), ci(l, dt()), !(hr & 6) && (sh = dt() + 500, fo()))
                }
                break;
            case 13:
                Mc(function () {
                    var k = ko(s, 1);
                    if (k !== null) {
                        var W = No();
                        $a(k, s, 1, W)
                    }
                }), Sd(s, 1)
        }
    }, _t = function (s) {
        if (s.tag === 13) {
            var l = ko(s, 134217728);
            if (l !== null) {
                var _ = No();
                $a(l, s, 134217728, _)
            }
            Sd(s, 134217728)
        }
    }, ce = function (s) {
        if (s.tag === 13) {
            var l = bc(s), _ = ko(s, l);
            if (_ !== null) {
                var k = No();
                $a(_, s, l, k)
            }
            Sd(s, l)
        }
    }, de = function () {
        return wt
    }, we = function (s, l) {
        var _ = wt;
        try {
            return wt = s, l()
        } finally {
            wt = _
        }
    }, Be = function (s, l, _) {
        switch (l) {
            case"input":
                if (Vn(s, _), l = _.name, _.type === "radio" && l != null) {
                    for (_ = s; _.parentNode;) _ = _.parentNode;
                    for (_ = _.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < _.length; l++) {
                        var k = _[l];
                        if (k !== s && k.form === s.form) {
                            var W = Ku(k);
                            if (!W) throw Error(i(90));
                            En(k), Vn(k, W)
                        }
                    }
                }
                break;
            case"textarea":
                Br(s, _);
                break;
            case"select":
                l = _.value, l != null && Rr(s, !!_.multiple, l, !1)
        }
    }, en = fp, Sn = Mc;
    var av = {usingClientEntryPoint: !1, Events: [to, hc, Ku, cn, $t, fp]},
        ph = {findFiberByHostInstance: Qa, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom"}, lv = {
            bundleType: ph.bundleType,
            version: ph.version,
            rendererPackageName: ph.rendererPackageName,
            rendererConfig: ph.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: I.ReactCurrentDispatcher,
            findHostInstanceByFiber: function (s) {
                return s = Ea(s), s === null ? null : s.stateNode
            },
            findFiberByHostInstance: ph.findFiberByHostInstance || kA,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
        };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var Rd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Rd.isDisabled && Rd.supportsFiber) try {
            jn = Rd.inject(lv), Wn = Rd
        } catch {
        }
    }
    return va.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = av, va.createPortal = function (s, l) {
        var _ = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!cs(l)) throw Error(i(200));
        return OA(s, l, null, _)
    }, va.createRoot = function (s, l) {
        if (!cs(s)) throw Error(i(299));
        var _ = !1, k = "", W = wp;
        return l != null && (l.unstable_strictMode === !0 && (_ = !0), l.identifierPrefix !== void 0 && (k = l.identifierPrefix), l.onRecoverableError !== void 0 && (W = l.onRecoverableError)), l = uh(s, 1, !1, null, null, _, !1, k, W), s[ts] = l.current, Do(s.nodeType === 8 ? s.parentNode : s), new Td(l)
    }, va.findDOMNode = function (s) {
        if (s == null) return null;
        if (s.nodeType === 1) return s;
        var l = s._reactInternals;
        if (l === void 0) throw typeof s.render == "function" ? Error(i(188)) : (s = Object.keys(s).join(","), Error(i(268, s)));
        return s = Ea(l), s = s === null ? null : s.stateNode, s
    }, va.flushSync = function (s) {
        return Mc(s)
    }, va.hydrate = function (s, l, _) {
        if (!is(l)) throw Error(i(200));
        return Id(null, s, l, !0, _)
    }, va.hydrateRoot = function (s, l, _) {
        if (!cs(s)) throw Error(i(405));
        var k = _ != null && _.hydratedSources || null, W = !1, ie = "", be = wp;
        if (_ != null && (_.unstable_strictMode === !0 && (W = !0), _.identifierPrefix !== void 0 && (ie = _.identifierPrefix), _.onRecoverableError !== void 0 && (be = _.onRecoverableError)), l = xp(l, null, s, 1, _ ?? null, W, !1, ie, be), s[ts] = l.current, Do(s), k) for (s = 0; s < k.length; s++) _ = k[s], W = _._getVersion, W = W(_._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [_, W] : l.mutableSourceEagerHydrationData.push(_, W);
        return new pl(l)
    }, va.render = function (s, l, _) {
        if (!is(l)) throw Error(i(200));
        return Id(null, s, l, !1, _)
    }, va.unmountComponentAtNode = function (s) {
        if (!is(s)) throw Error(i(40));
        return s._reactRootContainer ? (Mc(function () {
            Id(null, null, s, !1, function () {
                s._reactRootContainer = null, s[ts] = null
            })
        }), !0) : !1
    }, va.unstable_batchedUpdates = fp, va.unstable_renderSubtreeIntoContainer = function (s, l, _, k) {
        if (!is(_)) throw Error(i(200));
        if (s == null || s._reactInternals === void 0) throw Error(i(38));
        return Id(s, l, _, !1, k)
    }, va.version = "18.3.1-next-f1338f8080-20240426", va
}

var nw;

function JI() {
    if (nw) return s1.exports;
    nw = 1;

    function A() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(A)
        } catch (t) {
            console.error(t)
        }
    }

    return A(), s1.exports = qI(), s1.exports
}

var iw;

function ZI() {
    if (iw) return l0;
    iw = 1;
    var A = JI();
    return l0.createRoot = A.createRoot, l0.hydrateRoot = A.hydrateRoot, l0
}

var $I = ZI();
const eR = dw($I), M0 = {CAMERA_RIG: "cameraRig", HEAD: "head"}, gm = {
        SKY: {ID: "sky", SRC: "../images/blue-sky.jpg"},
        YOSEMITE: {ID: "yosemite", SRC: "./images/yosemite.jpg"},
        SPACE: {ID: "space", SRC: "../images/space.jpg"},
        WAVE: {ID: "wave", SRC: "../images/bg-1.png"},
        ARCH: {ID: "arch", SRC: "../images/bg-3.png"}
    }, tR = Object.keys(gm).map(A => gm[A]), S0 = {
        BRICK: {ID: "brick", SRC: "./textures/TCom_Wall_Stone3_2x2_1K_albedo.jpeg"},
        GRASS: {ID: "grass", SRC: "./textures/TCom_Ground_Grass03_header.jpg"}
    }, nR = Object.keys(S0).map(A => S0[A]), T0 = {
        BRICK: {ID: "brick-normal", SRC: "./textures/TCom_Wall_Stone3_2x2_1K_albedo_NormalMap.png"},
        GRASS: {ID: "grass-normal", SRC: "./textures/TCom_Ground_Grass03_header_NormalMap.png"}
    }, iR = Object.keys(T0).map(A => T0[A]), Kl = {PRODUCT: "product", STAGE: "stage", ENVIRONMENT: "environment"}, vm = {
        STORE: {ID: "apple-store", SRC: "./models/apple-store2.glb", TYPE: Kl.STAGE},
        VISION_PRO: {ID: "apple-vision-pro", SRC: "./models/apple-vision-pro.glb", TYPE: Kl.PRODUCT},
        PENCIL_PRO: {ID: "apple-pencil-pro", SRC: "./models/apple-pencil-pro.glb", TYPE: Kl.PRODUCT},
        WATCH: {ID: "apple-watch", SRC: "./models/apple-watch.glb", TYPE: Kl.PRODUCT},
        IMAC_GREEN: {ID: "imac-green", SRC: "./models/imac-green.glb", TYPE: Kl.PRODUCT},
        IMAC_YELLOW: {ID: "imac-yellow", SRC: "./models/imac-yellow.glb", TYPE: Kl.PRODUCT},
        IPHONE_16_PRO: {ID: "iphone-16-pro", SRC: "./models/iphone-16-pro.glb", TYPE: Kl.PRODUCT},
        MBP_BLACK: {ID: "macbook-pro-black", SRC: "./models/macbook-pro-black.glb", TYPE: Kl.PRODUCT},
        MBP_SILVER: {ID: "macbook-pro-silver", SRC: "./models/macbook-pro-silver.glb", TYPE: Kl.PRODUCT}
    }, rR = Object.keys(vm).map(A => vm[A]), _u = (A => (Object.keys(vm).forEach(t => {
        const i = vm[t];
        i.TYPE === Kl.PRODUCT && (A[t] = i.ID)
    }), A))({}), Jw = {
        [_u.VISION_PRO]: {SCALE: {x: .03, y: .03, z: .03}, POSITION: {y: 1.6, z: -1}},
        [_u.PENCIL_PRO]: {SCALE: {x: 4, y: 4, z: 4}, POSITION: {y: 1.5, z: -1}},
        [_u.WATCH]: {SCALE: {x: .001, y: .001, z: .001}, POSITION: {y: 1.6, z: -1}, ROTATION: {x: 70}},
        [_u.IMAC_GREEN]: {SCALE: {x: 1e-4, y: 1e-4, z: 1e-4}, POSITION: {y: 1.5, z: -.5}},
        [_u.IMAC_YELLOW]: {SCALE: {x: .15, y: .15, z: .15}, POSITION: {y: 1.2, z: -1}, ROTATION: {y: 180}},
        [_u.IPHONE_16_PRO]: {SCALE: {x: 4, y: 4, z: 4}, POSITION: {y: 1.4, z: -.7}},
        [_u.MBP_BLACK]: {SCALE: {x: .2, y: .2, z: .2}, POSITION: {x: 1.1, y: 1.3, z: -1}, ROTATION: {x: 30}},
        [_u.MBP_SILVER]: {SCALE: {x: .2, y: .2, z: .2}, POSITION: {x: -.2, y: 1.3, z: -1}, ROTATION: {x: 30}}
    }, rw = {
        SPACE_BLACK: {LABEL_CODE: "#FFFFFF", NAME: "Space Black", CODE: "#2e2c2f", ID: "space-black"},
        SILVER: {LABEL_CODE: "#000000", NAME: "Silver", CODE: "#e3e4e6", ID: "silver"}
    }, sR = Object.keys(rw).map(A => rw[A]), sw = {
        GB_128: {ID: "GB_128", NAME: "128 GB"},
        GB_256: {ID: "GB_256", NAME: "256 GB"},
        GB_512: {ID: "GB_512", NAME: "512 GB"},
        TB_1: {ID: "TB_1", NAME: "1 TB"},
        TB_2: {ID: "TB_2", NAME: "2 TB"}
    }, oR = Object.keys(sw).map(A => sw[A]), aR = (({document: A}) => {
        const t = {};
        return ({src: i, attributes: o}) => new Promise((c, f) => {
            const T = t[i];
            if (T) c(T); else {
                const m = A.createElement("script");
                m.type = "text/javascript", m.src = i, o && Object.keys(o).forEach(h => {
                    m[h] = o[h]
                }), m.onload = h => {
                    t[i] = h, c(h)
                }, m.onerror = f;
                const [x] = A.getElementsByTagName("head");
                x.appendChild(m)
            }
        })
    })(window), lR = "https://cdn.jsdelivr.net/npm/handy-work@3.1.11/build/handy-controls.min.js",
    cR = ({children: A}) => (Nt.useLayoutEffect(() => {
        aR({src: lR, attributes: {defer: !0}})
    }, []), ii.createElement("a-entity", {
        id: "cameraRig", "simple-navmesh-constraint": `navmesh: .navmesh;
                                                fall: 0.5;
                                                height: 0;
                                                exclude: .navmesh-hole;
                                      `, "movement-controls": `speed: 0.15;
                                camera: #${M0.HEAD};
                                `, position: "1 0 -1", rotation: "0 0 0"
    }, ii.createElement("a-entity", {
        id: M0.HEAD,
        camera: "near:0.01;",
        "look-controls": "pointerLockEnabled: false",
        position: "0 1.65 0"
    }), ii.createElement("a-entity", {"handy-controls": !0}, ii.createElement("a-entity", {
        "data-right": "index-finger-tip", mixin: "blink", "blink-controls": `snapTurn: false;
                                          startEvents: pose_point_fuseShort;
                                          endEvents: pose_point_fuseLong;
                                          cancelEvents: pose_cancel_point;`
    }), ii.createElement("a-entity", {
        "data-left": "index-finger-tip", mixin: "blink", "blink-controls": `snapTurn: false;
                                          startEvents: pose_point_fuseShort;
                                          endEvents: pose_point_fuseLong;
                                          cancelEvents: pose_cancel_point;`
    })))), uR = () => ii.createElement("div", {className: "new__bg"}, ii.createElement("div", {
        className: "hello__div", dangerouslySetInnerHTML: {
            __html: `
                <svg class="hello__svg" viewBox="0 0 1230.94 414.57">
                    <path
                        d="M-293.58-104.62S-103.61-205.49-60-366.25c9.13-32.45,9-58.31,0-74-10.72-18.82-49.69-33.21-75.55,31.94-27.82,70.11-52.22,377.24-44.11,322.48s34-176.24,99.89-183.19c37.66-4,49.55,23.58,52.83,47.92a117.06,117.06,0,0,1-3,45.32c-7.17,27.28-20.47,97.67,33.51,96.86,66.93-1,131.91-53.89,159.55-84.49,31.1-36.17,31.1-70.64,19.27-90.25-16.74-29.92-69.47-33-92.79,16.73C62.78-179.86,98.7-93.8,159-81.63S302.7-99.55,393.3-269.92c29.86-58.16,52.85-114.71,46.14-150.08-7.44-39.21-59.74-54.5-92.87-8.7-47,65-61.78,266.62-34.74,308.53S416.62-58,481.52-130.31s133.2-188.56,146.54-256.23c14-71.15-56.94-94.64-88.4-47.32C500.53-375,467.58-229.49,503.3-127a73.73,73.73,0,0,0,23.43,33.67c25.49,20.23,55.1,16,77.46,6.32a111.25,111.25,0,0,0,30.44-19.87c37.73-34.23,29-36.71,64.58-127.53C724-284.3,785-298.63,821-259.13a71,71,0,0,1,13.69,22.56c17.68,46,6.81,80-6.81,107.89-12,24.62-34.56,42.72-61.45,47.91-23.06,4.45-48.37-.35-66.48-24.27a78.88,78.88,0,0,1-12.66-25.8c-14.75-51,4.14-88.76,11-101.41,6.18-11.39,37.26-69.61,103.42-42.24,55.71,23.05,100.66-23.31,100.66-23.31"
                        transform="translate(311.08 476.02)"
                        style="fill:none;stroke:#f3f3f3;stroke-linecap:round;stroke-miterlimit:10;stroke-width:30px"/>
                </svg>
            `
        }
    })), hR = [...nR, ...iR, ...tR],
    dR = () => ii.createElement("a-assets", null, rR.map(({ID: A, SRC: t}) => ii.createElement("a-asset-item", {
        key: A,
        id: A,
        src: t
    })), hR.map(({ID: A, SRC: t}) => ii.createElement("img", {key: A, id: A, src: t})), ii.createElement("a-mixin", {
        id: "blink", "blink-controls": `
                        rotateOnTeleport: false;
                        cameraRig: #${M0.CAMERA_RIG};
                        teleportOrigin: #${M0.HEAD};
                        collisionEntities: .navmesh;
                     `
    })), fR = {BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1}, {MODE: JB, DEV: ZB, PROD: pR} = fR,
    d0 = {isLoading: !0, loadingTimeout: pR ? 6e3 : 0, enableDefaultLoadingScreen: !1},
    mR = ii.createContext({APPLICATION_STATE: d0}), AR = ({children: A}) => {
        const [t, i] = Nt.useState(d0.isLoading);
        Nt.useEffect(() => {
            window.setTimeout(i, d0.loadingTimeout, !1)
        }, []);
        const o = {isLoading: t};
        return ii.createElement(mR.Provider, {value: o}, ii.createElement("a-scene", {"loading-screen": `enabled: ${d0.enableDefaultLoadingScreen};`}, ii.createElement(dR, null), t ? ii.createElement(uR, null) : ii.createElement(ii.Fragment, null, ii.createElement(cR, null), A)))
    };
var tm = {}, ow;

function gR() {
    if (ow) return tm;
    ow = 1, Object.defineProperty(tm, "__esModule", {value: !0}), tm.parse = T, tm.serialize = h;
    const A = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/,
        i = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        o = /^[\u0020-\u003A\u003D-\u007E]*$/, c = Object.prototype.toString, f = (() => {
            const v = function () {
            };
            return v.prototype = Object.create(null), v
        })();

    function T(v, E) {
        const p = new f, C = v.length;
        if (C < 2) return p;
        const M = (E == null ? void 0 : E.decode) || g;
        let b = 0;
        do {
            const B = v.indexOf("=", b);
            if (B === -1) break;
            const R = v.indexOf(";", b), I = R === -1 ? C : R;
            if (B > I) {
                b = v.lastIndexOf(";", B - 1) + 1;
                continue
            }
            const L = m(v, b, B), O = x(v, B, L), N = v.slice(L, O);
            if (p[N] === void 0) {
                let F = m(v, B + 1, I), V = x(v, I, F);
                const U = M(v.slice(F, V));
                p[N] = U
            }
            b = I + 1
        } while (b < C);
        return p
    }

    function m(v, E, p) {
        do {
            const C = v.charCodeAt(E);
            if (C !== 32 && C !== 9) return E
        } while (++E < p);
        return p
    }

    function x(v, E, p) {
        for (; E > p;) {
            const C = v.charCodeAt(--E);
            if (C !== 32 && C !== 9) return E + 1
        }
        return p
    }

    function h(v, E, p) {
        const C = (p == null ? void 0 : p.encode) || encodeURIComponent;
        if (!A.test(v)) throw new TypeError(`argument name is invalid: ${v}`);
        const M = C(E);
        if (!t.test(M)) throw new TypeError(`argument val is invalid: ${E}`);
        let b = v + "=" + M;
        if (!p) return b;
        if (p.maxAge !== void 0) {
            if (!Number.isInteger(p.maxAge)) throw new TypeError(`option maxAge is invalid: ${p.maxAge}`);
            b += "; Max-Age=" + p.maxAge
        }
        if (p.domain) {
            if (!i.test(p.domain)) throw new TypeError(`option domain is invalid: ${p.domain}`);
            b += "; Domain=" + p.domain
        }
        if (p.path) {
            if (!o.test(p.path)) throw new TypeError(`option path is invalid: ${p.path}`);
            b += "; Path=" + p.path
        }
        if (p.expires) {
            if (!w(p.expires) || !Number.isFinite(p.expires.valueOf())) throw new TypeError(`option expires is invalid: ${p.expires}`);
            b += "; Expires=" + p.expires.toUTCString()
        }
        if (p.httpOnly && (b += "; HttpOnly"), p.secure && (b += "; Secure"), p.partitioned && (b += "; Partitioned"), p.priority) switch (typeof p.priority == "string" ? p.priority.toLowerCase() : void 0) {
            case"low":
                b += "; Priority=Low";
                break;
            case"medium":
                b += "; Priority=Medium";
                break;
            case"high":
                b += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${p.priority}`)
        }
        if (p.sameSite) switch (typeof p.sameSite == "string" ? p.sameSite.toLowerCase() : p.sameSite) {
            case!0:
            case"strict":
                b += "; SameSite=Strict";
                break;
            case"lax":
                b += "; SameSite=Lax";
                break;
            case"none":
                b += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${p.sameSite}`)
        }
        return b
    }

    function g(v) {
        if (v.indexOf("%") === -1) return v;
        try {
            return decodeURIComponent(v)
        } catch {
            return v
        }
    }

    function w(v) {
        return c.call(v) === "[object Date]"
    }

    return tm
}

gR();
/**
 * react-router v7.1.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var aw = "popstate";

function vR(A = {}) {
    function t(o, c) {
        let {pathname: f, search: T, hash: m} = o.location;
        return C1("", {
            pathname: f,
            search: T,
            hash: m
        }, c.state && c.state.usr || null, c.state && c.state.key || "default")
    }

    function i(o, c) {
        return typeof c == "string" ? c : ym(c)
    }

    return ER(t, i, null, A)
}

function ps(A, t) {
    if (A === !1 || A === null || typeof A > "u") throw new Error(t)
}

function ql(A, t) {
    if (!A) {
        typeof console < "u" && console.warn(t);
        try {
            throw new Error(t)
        } catch {
        }
    }
}

function yR() {
    return Math.random().toString(36).substring(2, 10)
}

function lw(A, t) {
    return {usr: A.state, key: A.key, idx: t}
}

function C1(A, t, i = null, o) {
    return {
        pathname: typeof A == "string" ? A : A.pathname,
        search: "",
        hash: "", ...typeof t == "string" ? df(t) : t,
        state: i,
        key: t && t.key || o || yR()
    }
}

function ym({pathname: A = "/", search: t = "", hash: i = ""}) {
    return t && t !== "?" && (A += t.charAt(0) === "?" ? t : "?" + t), i && i !== "#" && (A += i.charAt(0) === "#" ? i : "#" + i), A
}

function df(A) {
    let t = {};
    if (A) {
        let i = A.indexOf("#");
        i >= 0 && (t.hash = A.substring(i), A = A.substring(0, i));
        let o = A.indexOf("?");
        o >= 0 && (t.search = A.substring(o), A = A.substring(0, o)), A && (t.pathname = A)
    }
    return t
}

function ER(A, t, i, o = {}) {
    let {window: c = document.defaultView, v5Compat: f = !1} = o, T = c.history, m = "POP", x = null, h = g();
    h == null && (h = 0, T.replaceState({...T.state, idx: h}, ""));

    function g() {
        return (T.state || {idx: null}).idx
    }

    function w() {
        m = "POP";
        let M = g(), b = M == null ? null : M - h;
        h = M, x && x({action: m, location: C.location, delta: b})
    }

    function v(M, b) {
        m = "PUSH";
        let B = C1(C.location, M, b);
        h = g() + 1;
        let R = lw(B, h), I = C.createHref(B);
        try {
            T.pushState(R, "", I)
        } catch (L) {
            if (L instanceof DOMException && L.name === "DataCloneError") throw L;
            c.location.assign(I)
        }
        f && x && x({action: m, location: C.location, delta: 1})
    }

    function E(M, b) {
        m = "REPLACE";
        let B = C1(C.location, M, b);
        h = g();
        let R = lw(B, h), I = C.createHref(B);
        T.replaceState(R, "", I), f && x && x({action: m, location: C.location, delta: 0})
    }

    function p(M) {
        let b = c.location.origin !== "null" ? c.location.origin : c.location.href,
            B = typeof M == "string" ? M : ym(M);
        return B = B.replace(/ $/, "%20"), ps(b, `No window.location.(origin|href) available to create URL for href: ${B}`), new URL(B, b)
    }

    let C = {
        get action() {
            return m
        }, get location() {
            return A(c, T)
        }, listen(M) {
            if (x) throw new Error("A history only accepts one active listener");
            return c.addEventListener(aw, w), x = M, () => {
                c.removeEventListener(aw, w), x = null
            }
        }, createHref(M) {
            return t(c, M)
        }, createURL: p, encodeLocation(M) {
            let b = p(M);
            return {pathname: b.pathname, search: b.search, hash: b.hash}
        }, push: v, replace: E, go(M) {
            return T.go(M)
        }
    };
    return C
}

function Zw(A, t, i = "/") {
    return xR(A, t, i, !1)
}

function xR(A, t, i, o) {
    let c = typeof t == "string" ? df(t) : t, f = Du(c.pathname || "/", i);
    if (f == null) return null;
    let T = $w(A);
    CR(T);
    let m = null;
    for (let x = 0; m == null && x < T.length; ++x) {
        let h = DR(f);
        m = BR(T[x], h, o)
    }
    return m
}

function $w(A, t = [], i = [], o = "") {
    let c = (f, T, m) => {
        let x = {
            relativePath: m === void 0 ? f.path || "" : m,
            caseSensitive: f.caseSensitive === !0,
            childrenIndex: T,
            route: f
        };
        x.relativePath.startsWith("/") && (ps(x.relativePath.startsWith(o), `Absolute route path "${x.relativePath}" nested under path "${o}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), x.relativePath = x.relativePath.slice(o.length));
        let h = Vc([o, x.relativePath]), g = i.concat(x);
        f.children && f.children.length > 0 && (ps(f.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${h}".`), $w(f.children, t, g, h)), !(f.path == null && !f.index) && t.push({
            path: h,
            score: IR(h, f.index),
            routesMeta: g
        })
    };
    return A.forEach((f, T) => {
        var m;
        if (f.path === "" || !((m = f.path) != null && m.includes("?"))) c(f, T); else for (let x of eb(f.path)) c(f, T, x)
    }), t
}

function eb(A) {
    let t = A.split("/");
    if (t.length === 0) return [];
    let [i, ...o] = t, c = i.endsWith("?"), f = i.replace(/\?$/, "");
    if (o.length === 0) return c ? [f, ""] : [f];
    let T = eb(o.join("/")), m = [];
    return m.push(...T.map(x => x === "" ? f : [f, x].join("/"))), c && m.push(...T), m.map(x => A.startsWith("/") && x === "" ? "/" : x)
}

function CR(A) {
    A.sort((t, i) => t.score !== i.score ? i.score - t.score : RR(t.routesMeta.map(o => o.childrenIndex), i.routesMeta.map(o => o.childrenIndex)))
}

var wR = /^:[\w-]+$/, bR = 3, _R = 2, MR = 1, SR = 10, TR = -2, cw = A => A === "*";

function IR(A, t) {
    let i = A.split("/"), o = i.length;
    return i.some(cw) && (o += TR), t && (o += _R), i.filter(c => !cw(c)).reduce((c, f) => c + (wR.test(f) ? bR : f === "" ? MR : SR), o)
}

function RR(A, t) {
    return A.length === t.length && A.slice(0, -1).every((o, c) => o === t[c]) ? A[A.length - 1] - t[t.length - 1] : 0
}

function BR(A, t, i = !1) {
    let {routesMeta: o} = A, c = {}, f = "/", T = [];
    for (let m = 0; m < o.length; ++m) {
        let x = o[m], h = m === o.length - 1, g = f === "/" ? t : t.slice(f.length) || "/",
            w = I0({path: x.relativePath, caseSensitive: x.caseSensitive, end: h}, g), v = x.route;
        if (!w && h && i && !o[o.length - 1].route.index && (w = I0({
            path: x.relativePath,
            caseSensitive: x.caseSensitive,
            end: !1
        }, g)), !w) return null;
        Object.assign(c, w.params), T.push({
            params: c,
            pathname: Vc([f, w.pathname]),
            pathnameBase: FR(Vc([f, w.pathnameBase])),
            route: v
        }), w.pathnameBase !== "/" && (f = Vc([f, w.pathnameBase]))
    }
    return T
}

function I0(A, t) {
    typeof A == "string" && (A = {path: A, caseSensitive: !1, end: !0});
    let [i, o] = LR(A.path, A.caseSensitive, A.end), c = t.match(i);
    if (!c) return null;
    let f = c[0], T = f.replace(/(.)\/+$/, "$1"), m = c.slice(1);
    return {
        params: o.reduce((h, {paramName: g, isOptional: w}, v) => {
            if (g === "*") {
                let p = m[v] || "";
                T = f.slice(0, f.length - p.length).replace(/(.)\/+$/, "$1")
            }
            const E = m[v];
            return w && !E ? h[g] = void 0 : h[g] = (E || "").replace(/%2F/g, "/"), h
        }, {}), pathname: f, pathnameBase: T, pattern: A
    }
}

function LR(A, t = !1, i = !0) {
    ql(A === "*" || !A.endsWith("*") || A.endsWith("/*"), `Route path "${A}" will be treated as if it were "${A.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${A.replace(/\*$/, "/*")}".`);
    let o = [],
        c = "^" + A.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (T, m, x) => (o.push({
            paramName: m,
            isOptional: x != null
        }), x ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return A.endsWith("*") ? (o.push({paramName: "*"}), c += A === "*" || A === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : i ? c += "\\/*$" : A !== "" && A !== "/" && (c += "(?:(?=\\/|$))"), [new RegExp(c, t ? void 0 : "i"), o]
}

function DR(A) {
    try {
        return A.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/")
    } catch (t) {
        return ql(!1, `The URL path "${A}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`), A
    }
}

function Du(A, t) {
    if (t === "/") return A;
    if (!A.toLowerCase().startsWith(t.toLowerCase())) return null;
    let i = t.endsWith("/") ? t.length - 1 : t.length, o = A.charAt(i);
    return o && o !== "/" ? null : A.slice(i) || "/"
}

function PR(A, t = "/") {
    let {pathname: i, search: o = "", hash: c = ""} = typeof A == "string" ? df(A) : A;
    return {pathname: i ? i.startsWith("/") ? i : OR(i, t) : t, search: NR(o), hash: UR(c)}
}

function OR(A, t) {
    let i = t.replace(/\/+$/, "").split("/");
    return A.split("/").forEach(c => {
        c === ".." ? i.length > 1 && i.pop() : c !== "." && i.push(c)
    }), i.length > 1 ? i.join("/") : "/"
}

function l1(A, t, i, o) {
    return `Cannot include a '${A}' character in a manually specified \`to.${t}\` field [${JSON.stringify(o)}].  Please separate it out to the \`to.${i}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}

function kR(A) {
    return A.filter((t, i) => i === 0 || t.route.path && t.route.path.length > 0)
}

function tb(A) {
    let t = kR(A);
    return t.map((i, o) => o === t.length - 1 ? i.pathname : i.pathnameBase)
}

function nb(A, t, i, o = !1) {
    let c;
    typeof A == "string" ? c = df(A) : (c = {...A}, ps(!c.pathname || !c.pathname.includes("?"), l1("?", "pathname", "search", c)), ps(!c.pathname || !c.pathname.includes("#"), l1("#", "pathname", "hash", c)), ps(!c.search || !c.search.includes("#"), l1("#", "search", "hash", c)));
    let f = A === "" || c.pathname === "", T = f ? "/" : c.pathname, m;
    if (T == null) m = i; else {
        let w = t.length - 1;
        if (!o && T.startsWith("..")) {
            let v = T.split("/");
            for (; v[0] === "..";) v.shift(), w -= 1;
            c.pathname = v.join("/")
        }
        m = w >= 0 ? t[w] : "/"
    }
    let x = PR(c, m), h = T && T !== "/" && T.endsWith("/"), g = (f || T === ".") && i.endsWith("/");
    return !x.pathname.endsWith("/") && (h || g) && (x.pathname += "/"), x
}

var Vc = A => A.join("/").replace(/\/\/+/g, "/"), FR = A => A.replace(/\/+$/, "").replace(/^\/*/, "/"),
    NR = A => !A || A === "?" ? "" : A.startsWith("?") ? A : "?" + A,
    UR = A => !A || A === "#" ? "" : A.startsWith("#") ? A : "#" + A;

function zR(A) {
    return A != null && typeof A.status == "number" && typeof A.statusText == "string" && typeof A.internal == "boolean" && "data" in A
}

var ib = ["POST", "PUT", "PATCH", "DELETE"];
new Set(ib);
var GR = ["GET", ...ib];
new Set(GR);
var ff = Nt.createContext(null);
ff.displayName = "DataRouter";
var k0 = Nt.createContext(null);
k0.displayName = "DataRouterState";
var rb = Nt.createContext({isTransitioning: !1});
rb.displayName = "ViewTransition";
var VR = Nt.createContext(new Map);
VR.displayName = "Fetchers";
var HR = Nt.createContext(null);
HR.displayName = "Await";
var $l = Nt.createContext(null);
$l.displayName = "Navigation";
var xm = Nt.createContext(null);
xm.displayName = "Location";
var ec = Nt.createContext({outlet: null, matches: [], isDataRoute: !1});
ec.displayName = "Route";
var F1 = Nt.createContext(null);
F1.displayName = "RouteError";

function QR(A, {relative: t} = {}) {
    ps(Cm(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: i, navigator: o} = Nt.useContext($l), {hash: c, pathname: f, search: T} = wm(A, {relative: t}),
        m = f;
    return i !== "/" && (m = f === "/" ? i : Vc([i, f])), o.createHref({pathname: m, search: T, hash: c})
}

function Cm() {
    return Nt.useContext(xm) != null
}

function Nh() {
    return ps(Cm(), "useLocation() may be used only in the context of a <Router> component."), Nt.useContext(xm).location
}

var sb = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";

function ob(A) {
    Nt.useContext($l).static || Nt.useLayoutEffect(A)
}

function F0() {
    let {isDataRoute: A} = Nt.useContext(ec);
    return A ? iB() : jR()
}

function jR() {
    ps(Cm(), "useNavigate() may be used only in the context of a <Router> component.");
    let A = Nt.useContext(ff), {
            basename: t,
            navigator: i
        } = Nt.useContext($l), {matches: o} = Nt.useContext(ec), {pathname: c} = Nh(), f = JSON.stringify(tb(o)),
        T = Nt.useRef(!1);
    return ob(() => {
        T.current = !0
    }), Nt.useCallback((x, h = {}) => {
        if (ql(T.current, sb), !T.current) return;
        if (typeof x == "number") {
            i.go(x);
            return
        }
        let g = nb(x, JSON.parse(f), c, h.relative === "path");
        A == null && t !== "/" && (g.pathname = g.pathname === "/" ? t : Vc([t, g.pathname])), (h.replace ? i.replace : i.push)(g, h.state, h)
    }, [t, i, f, c, A])
}

Nt.createContext(null);

function ab() {
    let {matches: A} = Nt.useContext(ec), t = A[A.length - 1];
    return t ? t.params : {}
}

function wm(A, {relative: t} = {}) {
    let {matches: i} = Nt.useContext(ec), {pathname: o} = Nh(), c = JSON.stringify(tb(i));
    return Nt.useMemo(() => nb(A, JSON.parse(c), o, t === "path"), [A, c, o, t])
}

function WR(A, t) {
    return lb(A, t)
}

function lb(A, t, i, o) {
    var b;
    ps(Cm(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: c} = Nt.useContext($l), {matches: f} = Nt.useContext(ec), T = f[f.length - 1],
        m = T ? T.params : {}, x = T ? T.pathname : "/", h = T ? T.pathnameBase : "/", g = T && T.route;
    {
        let B = g && g.path || "";
        cb(x, !g || B.endsWith("*") || B.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${x}" (under <Route path="${B}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${B}"> to <Route path="${B === "/" ? "*" : `${B}/*`}">.`)
    }
    let w = Nh(), v;
    if (t) {
        let B = typeof t == "string" ? df(t) : t;
        ps(h === "/" || ((b = B.pathname) == null ? void 0 : b.startsWith(h)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${h}" but pathname "${B.pathname}" was given in the \`location\` prop.`), v = B
    } else v = w;
    let E = v.pathname || "/", p = E;
    if (h !== "/") {
        let B = h.replace(/^\//, "").split("/");
        p = "/" + E.replace(/^\//, "").split("/").slice(B.length).join("/")
    }
    let C = Zw(A, {pathname: p});
    ql(g || C != null, `No routes matched location "${v.pathname}${v.search}${v.hash}" `), ql(C == null || C[C.length - 1].route.element !== void 0 || C[C.length - 1].route.Component !== void 0 || C[C.length - 1].route.lazy !== void 0, `Matched leaf route at location "${v.pathname}${v.search}${v.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let M = JR(C && C.map(B => Object.assign({}, B, {
        params: Object.assign({}, m, B.params),
        pathname: Vc([h, c.encodeLocation ? c.encodeLocation(B.pathname).pathname : B.pathname]),
        pathnameBase: B.pathnameBase === "/" ? h : Vc([h, c.encodeLocation ? c.encodeLocation(B.pathnameBase).pathname : B.pathnameBase])
    })), f, i, o);
    return t && M ? Nt.createElement(xm.Provider, {
        value: {
            location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default", ...v
            }, navigationType: "POP"
        }
    }, M) : M
}

function KR() {
    let A = nB(), t = zR(A) ? `${A.status} ${A.statusText}` : A instanceof Error ? A.message : JSON.stringify(A),
        i = A instanceof Error ? A.stack : null, o = "rgba(200,200,200, 0.5)",
        c = {padding: "0.5rem", backgroundColor: o}, f = {padding: "2px 4px", backgroundColor: o}, T = null;
    return console.error("Error handled by React Router default ErrorBoundary:", A), T = Nt.createElement(Nt.Fragment, null, Nt.createElement("p", null, "💿 Hey developer 👋"), Nt.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", Nt.createElement("code", {style: f}, "ErrorBoundary"), " or", " ", Nt.createElement("code", {style: f}, "errorElement"), " prop on your route.")), Nt.createElement(Nt.Fragment, null, Nt.createElement("h2", null, "Unexpected Application Error!"), Nt.createElement("h3", {style: {fontStyle: "italic"}}, t), i ? Nt.createElement("pre", {style: c}, i) : null, T)
}

var XR = Nt.createElement(KR, null), YR = class extends Nt.Component {
    constructor(A) {
        super(A), this.state = {location: A.location, revalidation: A.revalidation, error: A.error}
    }

    static getDerivedStateFromError(A) {
        return {error: A}
    }

    static getDerivedStateFromProps(A, t) {
        return t.location !== A.location || t.revalidation !== "idle" && A.revalidation === "idle" ? {
            error: A.error,
            location: A.location,
            revalidation: A.revalidation
        } : {
            error: A.error !== void 0 ? A.error : t.error,
            location: t.location,
            revalidation: A.revalidation || t.revalidation
        }
    }

    componentDidCatch(A, t) {
        console.error("React Router caught the following error during render", A, t)
    }

    render() {
        return this.state.error !== void 0 ? Nt.createElement(ec.Provider, {value: this.props.routeContext}, Nt.createElement(F1.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
};

function qR({routeContext: A, match: t, children: i}) {
    let o = Nt.useContext(ff);
    return o && o.static && o.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = t.route.id), Nt.createElement(ec.Provider, {value: A}, i)
}

function JR(A, t = [], i = null, o = null) {
    if (A == null) {
        if (!i) return null;
        if (i.errors) A = i.matches; else if (t.length === 0 && !i.initialized && i.matches.length > 0) A = i.matches; else return null
    }
    let c = A, f = i == null ? void 0 : i.errors;
    if (f != null) {
        let x = c.findIndex(h => h.route.id && (f == null ? void 0 : f[h.route.id]) !== void 0);
        ps(x >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(f).join(",")}`), c = c.slice(0, Math.min(c.length, x + 1))
    }
    let T = !1, m = -1;
    if (i) for (let x = 0; x < c.length; x++) {
        let h = c[x];
        if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (m = x), h.route.id) {
            let {loaderData: g, errors: w} = i,
                v = h.route.loader && !g.hasOwnProperty(h.route.id) && (!w || w[h.route.id] === void 0);
            if (h.route.lazy || v) {
                T = !0, m >= 0 ? c = c.slice(0, m + 1) : c = [c[0]];
                break
            }
        }
    }
    return c.reduceRight((x, h, g) => {
        let w, v = !1, E = null, p = null;
        i && (w = f && h.route.id ? f[h.route.id] : void 0, E = h.route.errorElement || XR, T && (m < 0 && g === 0 ? (cb("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), v = !0, p = null) : m === g && (v = !0, p = h.route.hydrateFallbackElement || null)));
        let C = t.concat(c.slice(0, g + 1)), M = () => {
            let b;
            return w ? b = E : v ? b = p : h.route.Component ? b = Nt.createElement(h.route.Component, null) : h.route.element ? b = h.route.element : b = x, Nt.createElement(qR, {
                match: h,
                routeContext: {outlet: x, matches: C, isDataRoute: i != null},
                children: b
            })
        };
        return i && (h.route.ErrorBoundary || h.route.errorElement || g === 0) ? Nt.createElement(YR, {
            location: i.location,
            revalidation: i.revalidation,
            component: E,
            error: w,
            children: M(),
            routeContext: {outlet: null, matches: C, isDataRoute: !0}
        }) : M()
    }, null)
}

function N1(A) {
    return `${A} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}

function ZR(A) {
    let t = Nt.useContext(ff);
    return ps(t, N1(A)), t
}

function $R(A) {
    let t = Nt.useContext(k0);
    return ps(t, N1(A)), t
}

function eB(A) {
    let t = Nt.useContext(ec);
    return ps(t, N1(A)), t
}

function U1(A) {
    let t = eB(A), i = t.matches[t.matches.length - 1];
    return ps(i.route.id, `${A} can only be used on routes that contain a unique "id"`), i.route.id
}

function tB() {
    return U1("useRouteId")
}

function nB() {
    var o;
    let A = Nt.useContext(F1), t = $R("useRouteError"), i = U1("useRouteError");
    return A !== void 0 ? A : (o = t.errors) == null ? void 0 : o[i]
}

function iB() {
    let {router: A} = ZR("useNavigate"), t = U1("useNavigate"), i = Nt.useRef(!1);
    return ob(() => {
        i.current = !0
    }), Nt.useCallback(async (c, f = {}) => {
        ql(i.current, sb), i.current && (typeof c == "number" ? A.navigate(c) : await A.navigate(c, {fromRouteId: t, ...f}))
    }, [A, t])
}

var uw = {};

function cb(A, t, i) {
    !t && !uw[A] && (uw[A] = !0, ql(!1, i))
}

Nt.memo(rB);

function rB({routes: A, future: t, state: i}) {
    return lb(A, void 0, i, t)
}

function f0(A) {
    ps(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}

function sB({
                basename: A = "/",
                children: t = null,
                location: i,
                navigationType: o = "POP",
                navigator: c,
                static: f = !1
            }) {
    ps(!Cm(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let T = A.replace(/^\/*/, "/"),
        m = Nt.useMemo(() => ({basename: T, navigator: c, static: f, future: {}}), [T, c, f]);
    typeof i == "string" && (i = df(i));
    let {pathname: x = "/", search: h = "", hash: g = "", state: w = null, key: v = "default"} = i,
        E = Nt.useMemo(() => {
            let p = Du(x, T);
            return p == null ? null : {location: {pathname: p, search: h, hash: g, state: w, key: v}, navigationType: o}
        }, [T, x, h, g, w, v, o]);
    return ql(E != null, `<Router basename="${T}"> is not able to match the URL "${x}${h}${g}" because it does not start with the basename, so the <Router> won't render anything.`), E == null ? null : Nt.createElement($l.Provider, {value: m}, Nt.createElement(xm.Provider, {
        children: t,
        value: E
    }))
}

function oB({children: A, location: t}) {
    return WR(w1(A), t)
}

function w1(A, t = []) {
    let i = [];
    return Nt.Children.forEach(A, (o, c) => {
        if (!Nt.isValidElement(o)) return;
        let f = [...t, c];
        if (o.type === Nt.Fragment) {
            i.push.apply(i, w1(o.props.children, f));
            return
        }
        ps(o.type === f0, `[${typeof o.type == "string" ? o.type : o.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), ps(!o.props.index || !o.props.children, "An index route cannot have child routes.");
        let T = {
            id: o.props.id || f.join("-"),
            caseSensitive: o.props.caseSensitive,
            element: o.props.element,
            Component: o.props.Component,
            index: o.props.index,
            path: o.props.path,
            loader: o.props.loader,
            action: o.props.action,
            hydrateFallbackElement: o.props.hydrateFallbackElement,
            HydrateFallback: o.props.HydrateFallback,
            errorElement: o.props.errorElement,
            ErrorBoundary: o.props.ErrorBoundary,
            hasErrorBoundary: o.props.hasErrorBoundary === !0 || o.props.ErrorBoundary != null || o.props.errorElement != null,
            shouldRevalidate: o.props.shouldRevalidate,
            handle: o.props.handle,
            lazy: o.props.lazy
        };
        o.props.children && (T.children = w1(o.props.children, f)), i.push(T)
    }), i
}

var p0 = "get", m0 = "application/x-www-form-urlencoded";

function N0(A) {
    return A != null && typeof A.tagName == "string"
}

function aB(A) {
    return N0(A) && A.tagName.toLowerCase() === "button"
}

function lB(A) {
    return N0(A) && A.tagName.toLowerCase() === "form"
}

function cB(A) {
    return N0(A) && A.tagName.toLowerCase() === "input"
}

function uB(A) {
    return !!(A.metaKey || A.altKey || A.ctrlKey || A.shiftKey)
}

function hB(A, t) {
    return A.button === 0 && (!t || t === "_self") && !uB(A)
}

var c0 = null;

function dB() {
    if (c0 === null) try {
        new FormData(document.createElement("form"), 0), c0 = !1
    } catch {
        c0 = !0
    }
    return c0
}

var fB = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);

function c1(A) {
    return A != null && !fB.has(A) ? (ql(!1, `"${A}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${m0}"`), null) : A
}

function pB(A, t) {
    let i, o, c, f, T;
    if (lB(A)) {
        let m = A.getAttribute("action");
        o = m ? Du(m, t) : null, i = A.getAttribute("method") || p0, c = c1(A.getAttribute("enctype")) || m0, f = new FormData(A)
    } else if (aB(A) || cB(A) && (A.type === "submit" || A.type === "image")) {
        let m = A.form;
        if (m == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let x = A.getAttribute("formaction") || m.getAttribute("action");
        if (o = x ? Du(x, t) : null, i = A.getAttribute("formmethod") || m.getAttribute("method") || p0, c = c1(A.getAttribute("formenctype")) || c1(m.getAttribute("enctype")) || m0, f = new FormData(m, A), !dB()) {
            let {name: h, type: g, value: w} = A;
            if (g === "image") {
                let v = h ? `${h}.` : "";
                f.append(`${v}x`, "0"), f.append(`${v}y`, "0")
            } else h && f.append(h, w)
        }
    } else {
        if (N0(A)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        i = p0, o = null, c = m0, T = A
    }
    return f && c === "text/plain" && (T = f, f = void 0), {
        action: o,
        method: i.toLowerCase(),
        encType: c,
        formData: f,
        body: T
    }
}

function z1(A, t) {
    if (A === !1 || A === null || typeof A > "u") throw new Error(t)
}

async function mB(A, t) {
    if (A.id in t) return t[A.id];
    try {
        let i = await import(A.module);
        return t[A.id] = i, i
    } catch (i) {
        return console.error(`Error loading route module \`${A.module}\`, reloading page...`), console.error(i), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
        })
    }
}

function AB(A) {
    return A == null ? !1 : A.href == null ? A.rel === "preload" && typeof A.imageSrcSet == "string" && typeof A.imageSizes == "string" : typeof A.rel == "string" && typeof A.href == "string"
}

async function gB(A, t, i) {
    let o = await Promise.all(A.map(async c => {
        let f = t.routes[c.route.id];
        if (f) {
            let T = await mB(f, i);
            return T.links ? T.links() : []
        }
        return []
    }));
    return xB(o.flat(1).filter(AB).filter(c => c.rel === "stylesheet" || c.rel === "preload").map(c => c.rel === "stylesheet" ? {
        ...c,
        rel: "prefetch",
        as: "style"
    } : {...c, rel: "prefetch"}))
}

function hw(A, t, i, o, c, f) {
    let T = (x, h) => i[h] ? x.route.id !== i[h].route.id : !0, m = (x, h) => {
        var g;
        return i[h].pathname !== x.pathname || ((g = i[h].route.path) == null ? void 0 : g.endsWith("*")) && i[h].params["*"] !== x.params["*"]
    };
    return f === "assets" ? t.filter((x, h) => T(x, h) || m(x, h)) : f === "data" ? t.filter((x, h) => {
        var w;
        let g = o.routes[x.route.id];
        if (!g || !g.hasLoader) return !1;
        if (T(x, h) || m(x, h)) return !0;
        if (x.route.shouldRevalidate) {
            let v = x.route.shouldRevalidate({
                currentUrl: new URL(c.pathname + c.search + c.hash, window.origin),
                currentParams: ((w = i[0]) == null ? void 0 : w.params) || {},
                nextUrl: new URL(A, window.origin),
                nextParams: x.params,
                defaultShouldRevalidate: !0
            });
            if (typeof v == "boolean") return v
        }
        return !0
    }) : []
}

function vB(A, t) {
    return yB(A.map(i => {
        let o = t.routes[i.route.id];
        if (!o) return [];
        let c = [o.module];
        return o.imports && (c = c.concat(o.imports)), c
    }).flat(1))
}

function yB(A) {
    return [...new Set(A)]
}

function EB(A) {
    let t = {}, i = Object.keys(A).sort();
    for (let o of i) t[o] = A[o];
    return t
}

function xB(A, t) {
    let i = new Set;
    return new Set(t), A.reduce((o, c) => {
        let f = JSON.stringify(EB(c));
        return i.has(f) || (i.add(f), o.push({key: f, link: c})), o
    }, [])
}

function CB(A) {
    let t = typeof A == "string" ? new URL(A, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : A;
    return t.pathname === "/" ? t.pathname = "_root.data" : t.pathname = `${t.pathname.replace(/\/$/, "")}.data`, t
}

function wB() {
    let A = Nt.useContext(ff);
    return z1(A, "You must render this element inside a <DataRouterContext.Provider> element"), A
}

function bB() {
    let A = Nt.useContext(k0);
    return z1(A, "You must render this element inside a <DataRouterStateContext.Provider> element"), A
}

var G1 = Nt.createContext(void 0);
G1.displayName = "FrameworkContext";

function ub() {
    let A = Nt.useContext(G1);
    return z1(A, "You must render this element inside a <HydratedRouter> element"), A
}

function _B(A, t) {
    let i = Nt.useContext(G1), [o, c] = Nt.useState(!1), [f, T] = Nt.useState(!1), {
        onFocus: m,
        onBlur: x,
        onMouseEnter: h,
        onMouseLeave: g,
        onTouchStart: w
    } = t, v = Nt.useRef(null);
    Nt.useEffect(() => {
        if (A === "render" && T(!0), A === "viewport") {
            let C = b => {
                b.forEach(B => {
                    T(B.isIntersecting)
                })
            }, M = new IntersectionObserver(C, {threshold: .5});
            return v.current && M.observe(v.current), () => {
                M.disconnect()
            }
        }
    }, [A]), Nt.useEffect(() => {
        if (o) {
            let C = setTimeout(() => {
                T(!0)
            }, 100);
            return () => {
                clearTimeout(C)
            }
        }
    }, [o]);
    let E = () => {
        c(!0)
    }, p = () => {
        c(!1), T(!1)
    };
    return i ? A !== "intent" ? [f, v, {}] : [f, v, {
        onFocus: nm(m, E),
        onBlur: nm(x, p),
        onMouseEnter: nm(h, E),
        onMouseLeave: nm(g, p),
        onTouchStart: nm(w, E)
    }] : [!1, v, {}]
}

function nm(A, t) {
    return i => {
        A && A(i), i.defaultPrevented || t(i)
    }
}

function MB({page: A, ...t}) {
    let {router: i} = wB(), o = Nt.useMemo(() => Zw(i.routes, A, i.basename), [i.routes, A, i.basename]);
    return o ? Nt.createElement(TB, {page: A, matches: o, ...t}) : null
}

function SB(A) {
    let {manifest: t, routeModules: i} = ub(), [o, c] = Nt.useState([]);
    return Nt.useEffect(() => {
        let f = !1;
        return gB(A, t, i).then(T => {
            f || c(T)
        }), () => {
            f = !0
        }
    }, [A, t, i]), o
}

function TB({page: A, matches: t, ...i}) {
    let o = Nh(), {manifest: c, routeModules: f} = ub(), {loaderData: T, matches: m} = bB(),
        x = Nt.useMemo(() => hw(A, t, m, c, o, "data"), [A, t, m, c, o]),
        h = Nt.useMemo(() => hw(A, t, m, c, o, "assets"), [A, t, m, c, o]), g = Nt.useMemo(() => {
            if (A === o.pathname + o.search + o.hash) return [];
            let E = new Set, p = !1;
            if (t.forEach(M => {
                var B;
                let b = c.routes[M.route.id];
                !b || !b.hasLoader || (!x.some(R => R.route.id === M.route.id) && M.route.id in T && ((B = f[M.route.id]) != null && B.shouldRevalidate) || b.hasClientLoader ? p = !0 : E.add(M.route.id))
            }), E.size === 0) return [];
            let C = CB(A);
            return p && E.size > 0 && C.searchParams.set("_routes", t.filter(M => E.has(M.route.id)).map(M => M.route.id).join(",")), [C.pathname + C.search]
        }, [T, o, c, x, t, A, f]), w = Nt.useMemo(() => vB(h, c), [h, c]), v = SB(h);
    return Nt.createElement(Nt.Fragment, null, g.map(E => Nt.createElement("link", {
        key: E,
        rel: "prefetch",
        as: "fetch",
        href: E, ...i
    })), w.map(E => Nt.createElement("link", {key: E, rel: "modulepreload", href: E, ...i})), v.map(({
                                                                                                         key: E,
                                                                                                         link: p
                                                                                                     }) => Nt.createElement("link", {key: E, ...p})))
}

function IB(...A) {
    return t => {
        A.forEach(i => {
            typeof i == "function" ? i(t) : i != null && (i.current = t)
        })
    }
}

var hb = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    hb && (window.__reactRouterVersion = "7.1.3")
} catch {
}

function RB({basename: A, children: t, window: i}) {
    let o = Nt.useRef();
    o.current == null && (o.current = vR({window: i, v5Compat: !0}));
    let c = o.current, [f, T] = Nt.useState({action: c.action, location: c.location}), m = Nt.useCallback(x => {
        Nt.startTransition(() => T(x))
    }, [T]);
    return Nt.useLayoutEffect(() => c.listen(m), [c, m]), Nt.createElement(sB, {
        basename: A,
        children: t,
        location: f.location,
        navigationType: f.action,
        navigator: c
    })
}

var db = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, fb = Nt.forwardRef(function ({
                                                                           onClick: t,
                                                                           discover: i = "render",
                                                                           prefetch: o = "none",
                                                                           relative: c,
                                                                           reloadDocument: f,
                                                                           replace: T,
                                                                           state: m,
                                                                           target: x,
                                                                           to: h,
                                                                           preventScrollReset: g,
                                                                           viewTransition: w,
                                                                           ...v
                                                                       }, E) {
    let {basename: p} = Nt.useContext($l), C = typeof h == "string" && db.test(h), M, b = !1;
    if (typeof h == "string" && C && (M = h, hb)) try {
        let V = new URL(window.location.href), U = h.startsWith("//") ? new URL(V.protocol + h) : new URL(h),
            j = Du(U.pathname, p);
        U.origin === V.origin && j != null ? h = j + U.search + U.hash : b = !0
    } catch {
        ql(!1, `<Link to="${h}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
    }
    let B = QR(h, {relative: c}), [R, I, L] = _B(o, v),
        O = PB(h, {replace: T, state: m, target: x, preventScrollReset: g, relative: c, viewTransition: w});

    function N(V) {
        t && t(V), V.defaultPrevented || O(V)
    }

    let F = Nt.createElement("a", {
        ...v, ...L,
        href: M || B,
        onClick: b || f ? t : N,
        ref: IB(E, I),
        target: x,
        "data-discover": !C && i === "render" ? "true" : void 0
    });
    return R && !C ? Nt.createElement(Nt.Fragment, null, F, Nt.createElement(MB, {page: B})) : F
});
fb.displayName = "Link";
var BB = Nt.forwardRef(function ({
                                     "aria-current": t = "page",
                                     caseSensitive: i = !1,
                                     className: o = "",
                                     end: c = !1,
                                     style: f,
                                     to: T,
                                     viewTransition: m,
                                     children: x,
                                     ...h
                                 }, g) {
    let w = wm(T, {relative: h.relative}), v = Nh(), E = Nt.useContext(k0), {
            navigator: p,
            basename: C
        } = Nt.useContext($l), M = E != null && UB(w) && m === !0,
        b = p.encodeLocation ? p.encodeLocation(w).pathname : w.pathname, B = v.pathname,
        R = E && E.navigation && E.navigation.location ? E.navigation.location.pathname : null;
    i || (B = B.toLowerCase(), R = R ? R.toLowerCase() : null, b = b.toLowerCase()), R && C && (R = Du(R, C) || R);
    const I = b !== "/" && b.endsWith("/") ? b.length - 1 : b.length;
    let L = B === b || !c && B.startsWith(b) && B.charAt(I) === "/",
        O = R != null && (R === b || !c && R.startsWith(b) && R.charAt(b.length) === "/"),
        N = {isActive: L, isPending: O, isTransitioning: M}, F = L ? t : void 0, V;
    typeof o == "function" ? V = o(N) : V = [o, L ? "active" : null, O ? "pending" : null, M ? "transitioning" : null].filter(Boolean).join(" ");
    let U = typeof f == "function" ? f(N) : f;
    return Nt.createElement(fb, {
        ...h,
        "aria-current": F,
        className: V,
        ref: g,
        style: U,
        to: T,
        viewTransition: m
    }, typeof x == "function" ? x(N) : x)
});
BB.displayName = "NavLink";
var LB = Nt.forwardRef(({
                            discover: A = "render",
                            fetcherKey: t,
                            navigate: i,
                            reloadDocument: o,
                            replace: c,
                            state: f,
                            method: T = p0,
                            action: m,
                            onSubmit: x,
                            relative: h,
                            preventScrollReset: g,
                            viewTransition: w,
                            ...v
                        }, E) => {
    let p = FB(), C = NB(m, {relative: h}), M = T.toLowerCase() === "get" ? "get" : "post",
        b = typeof m == "string" && db.test(m), B = R => {
            if (x && x(R), R.defaultPrevented) return;
            R.preventDefault();
            let I = R.nativeEvent.submitter, L = (I == null ? void 0 : I.getAttribute("formmethod")) || T;
            p(I || R.currentTarget, {
                fetcherKey: t,
                method: L,
                navigate: i,
                replace: c,
                state: f,
                relative: h,
                preventScrollReset: g,
                viewTransition: w
            })
        };
    return Nt.createElement("form", {
        ref: E,
        method: M,
        action: C,
        onSubmit: o ? x : B, ...v,
        "data-discover": !b && A === "render" ? "true" : void 0
    })
});
LB.displayName = "Form";

function DB(A) {
    return `${A} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}

function pb(A) {
    let t = Nt.useContext(ff);
    return ps(t, DB(A)), t
}

function PB(A, {target: t, replace: i, state: o, preventScrollReset: c, relative: f, viewTransition: T} = {}) {
    let m = F0(), x = Nh(), h = wm(A, {relative: f});
    return Nt.useCallback(g => {
        if (hB(g, t)) {
            g.preventDefault();
            let w = i !== void 0 ? i : ym(x) === ym(h);
            m(A, {replace: w, state: o, preventScrollReset: c, relative: f, viewTransition: T})
        }
    }, [x, m, h, i, o, t, A, c, f, T])
}

var OB = 0, kB = () => `__${String(++OB)}__`;

function FB() {
    let {router: A} = pb("useSubmit"), {basename: t} = Nt.useContext($l), i = tB();
    return Nt.useCallback(async (o, c = {}) => {
        let {action: f, method: T, encType: m, formData: x, body: h} = pB(o, t);
        if (c.navigate === !1) {
            let g = c.fetcherKey || kB();
            await A.fetch(g, i, c.action || f, {
                preventScrollReset: c.preventScrollReset,
                formData: x,
                body: h,
                formMethod: c.method || T,
                formEncType: c.encType || m,
                flushSync: c.flushSync
            })
        } else await A.navigate(c.action || f, {
            preventScrollReset: c.preventScrollReset,
            formData: x,
            body: h,
            formMethod: c.method || T,
            formEncType: c.encType || m,
            replace: c.replace,
            state: c.state,
            fromRouteId: i,
            flushSync: c.flushSync,
            viewTransition: c.viewTransition
        })
    }, [A, t, i])
}

function NB(A, {relative: t} = {}) {
    let {basename: i} = Nt.useContext($l), o = Nt.useContext(ec);
    ps(o, "useFormAction must be used inside a RouteContext");
    let [c] = o.matches.slice(-1), f = {...wm(A || ".", {relative: t})}, T = Nh();
    if (A == null) {
        f.search = T.search;
        let m = new URLSearchParams(f.search), x = m.getAll("index");
        if (x.some(g => g === "")) {
            m.delete("index"), x.filter(w => w).forEach(w => m.append("index", w));
            let g = m.toString();
            f.search = g ? `?${g}` : ""
        }
    }
    return (!A || A === ".") && c.route.index && (f.search = f.search ? f.search.replace(/^\?/, "?index&") : "?index"), i !== "/" && (f.pathname = f.pathname === "/" ? i : Vc([i, f.pathname])), ym(f)
}

function UB(A, t = {}) {
    let i = Nt.useContext(rb);
    ps(i != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: o} = pb("useViewTransitionState"), c = wm(A, {relative: t.relative});
    if (!i.isTransitioning) return !1;
    let f = Du(i.currentLocation.pathname, o) || i.currentLocation.pathname,
        T = Du(i.nextLocation.pathname, o) || i.nextLocation.pathname;
    return I0(c.pathname, T) != null || I0(c.pathname, f) != null
}

new TextEncoder;
const zB = () => {
        const A = F0(), t = Nt.useCallback(o => {
            o && A(`${Oh.PRODUCT.PATH}/${o}`)
        }, [A]), i = Nt.useCallback(o => {
            o && A(`${Oh.CONFIGURATION.PATH}/${o}`)
        }, [A]);
        return window.goToProduct = t, window.goToConfiguration = i, ii.createElement(ii.Fragment, null, ii.createElement("a-entity", {
            scale: "1 1 1",
            position: "3 0 -4.5",
            rotation: "0 -17 0",
            "gltf-model": `#${vm.STORE.ID}`
        }), ii.createElement("a-plane", {
            src: `#${S0.BRICK.ID}`,
            "normal-map": `#${T0.BRICK.ID}`,
            "normal-texture-repeat": "20 20",
            "normal-scale": "1 -1",
            roughness: "0.9",
            repeat: "20 20",
            height: "20",
            width: "21",
            position: "-3.5 .1 -14",
            rotation: "-90 -17 0"
        }), ii.createElement("a-plane", {
            src: `#${S0.GRASS.ID}`,
            "normal-map": `#${T0.GRASS.ID}`,
            "normal-texture-repeat": "30 30",
            "normal-scale": "1 -1",
            roughness: "0.4",
            repeat: "30 30",
            height: "100",
            width: "100",
            rotation: "-90 0 0",
            position: "0 0 -1"
        }), ii.createElement("a-sky", {
            src: `#${gm.YOSEMITE.ID}`,
            radius: "1000",
            position: "0 900 0",
            rotation: "0 -60 0"
        }))
    }, b1 = {x: 0, y: 0, z: 0}, GB = {POSITION: b1, ROTATION: b1, SCALE: {x: 1, y: 1, z: 1}},
    u1 = ({x: A, y: t, z: i} = b1) => `${A} ${t} ${i}`, {POSITION: VB, ROTATION: HB, SCALE: QB} = GB,
    mb = ({modelId: A, position: t, rotation: i, scale: o}) => {
        const c = `#${A}`, f = u1({...VB, ...t}), T = u1({...HB, ...i}), m = u1({...QB, ...o});
        return ii.createElement(ii.Fragment, null, ii.createElement("a-entity", {
            id: A,
            scale: m,
            position: f,
            rotation: T,
            "gltf-model": c
        }))
    }, Ab = ({text: A = "Error"}) => ii.createElement("a-entity", {
        position: "3 0 -10",
        scale: "10 10 10",
        text: `value: ${A}; color: black;`
    }), jB = () => {
        const A = F0(), {productId: t} = ab(), i = Nt.useCallback(() => {
            A(Oh.STORE.PATH)
        }, [A]);
        window.goToStore = i;
        const o = Jw[t];
        return o ? ii.createElement(ii.Fragment, null, ii.createElement("a-sky", {
            src: `#${gm.WAVE.ID}`,
            radius: "500",
            position: "0 0 0",
            rotation: "0 -90 -30"
        }), ii.createElement(mb, {
            modelId: t,
            scale: o.SCALE,
            position: o.POSITION,
            rotation: o.ROTATION
        })) : ii.createElement(Ab, {text: `Incorrect product id: ${t}`})
    }, WB = ({colors: A}) => ii.createElement("a-box", {
        color: "#F3F3F3",
        width: "0.5",
        height: "0.2",
        depth: "0.01",
        position: "0.5 1.9 -0.7",
        rotation: "0 0 0",
        scale: "1 1 1",
        opacity: "0"
    }, A.map(({ID: t, targetId: i, CODE: o, NAME: c, LABEL_CODE: f}, T) => {
        const m = T * -.15;
        return ii.createElement("a-circle", {
            id: t,
            color: o,
            position: `${m} 0 0.01`,
            opacity: "0.7",
            side: "double",
            scale: "0.05 0.05 0.05",
            key: o,
            "event-set__enter": `_event: mouseenter; _target: #${t}; material.opacity: 1;`,
            "event-set__update_text": `_event: click; _target: #${t}-text; color: blue;`
        }, ii.createElement("a-text", {
            id: `${t}-text`,
            scale: "1.5 1.5 1.5",
            value: c,
            text: `align: center; color: ${f}`
        }))
    })), KB = ({options: A}) => ii.createElement("a-box", {
        color: "#F3F3F3",
        width: "0.5",
        height: "0.2",
        depth: "0.01",
        position: "0.5 1.6 -0.7",
        rotation: "0 0 0",
        scale: "1 1 1",
        opacity: "0"
    }, A.map(({ID: t, NAME: i}, o) => {
        const c = o * -.15;
        return ii.createElement("a-box", {
            id: t,
            color: "#F3F3F3",
            width: "4.5",
            height: "2",
            depth: "0.01",
            position: `-0.1 ${c} 0`,
            side: "double",
            scale: "0.05 0.05 0.05",
            key: i,
            "event-set__select": `_event: click; _target: #${t}; color: blue;`,
            "event-set__update": `_event: click; _target: #${t}-text; color: white;`
        }, ii.createElement("a-text", {
            id: `${t}-text`,
            scale: "3 3 3",
            position: "0.1 0 0.1",
            value: i,
            text: "align: center; color: #000000;"
        }))
    })), XB = () => {
        const A = F0(), {productId: t} = ab(), i = Nt.useCallback(() => {
            A(Oh.STORE.PATH)
        }, [A]);
        window.goToStore = i;
        const o = Jw[t];
        return o ? ii.createElement(ii.Fragment, null, ii.createElement("a-sky", {
            src: `#${gm.ARCH.ID}`,
            radius: "500",
            position: "0 0 0",
            rotation: "0 -90 -30"
        }), ii.createElement(mb, {
            modelId: t,
            scale: o.SCALE,
            position: o.POSITION,
            rotation: o.ROTATION
        }), ii.createElement(WB, {colors: sR}), ii.createElement(KB, {options: oR})) : ii.createElement(Ab, {text: `Incorrect product id: ${t}`})
    }, Oh = {
        STORE: {URL: "/", PATH: "/"},
        PRODUCT: {URL: "/product/:productId", PATH: "/product", PARAMS: {PRODUCT_ID: "productId"}},
        CONFIGURATION: {URL: "/configuration/:productId", PATH: "/configuration", PARAMS: {PRODUCT_ID: "productId"}}
    }, YB = () => ii.createElement(RB, null, ii.createElement(oB, null, ii.createElement(f0, {
        path: Oh.STORE.URL,
        element: ii.createElement(zB, null)
    }), ii.createElement(f0, {
        path: Oh.PRODUCT.URL,
        element: ii.createElement(jB, null)
    }), ii.createElement(f0, {path: Oh.CONFIGURATION.URL, element: ii.createElement(XB, null)})));
eR.createRoot(document.getElementById("app")).render(ii.createElement(ii.StrictMode, null, ii.createElement(AR, null, ii.createElement(YB, null))));
